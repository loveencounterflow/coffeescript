// Generated by CoffeeScript 2.7.0
(function() {
  // The **Scope** class regulates lexical scoping within CoffeeScript. As you
  // generate code, you create a tree of scopes in the same shape as the nested
  // function bodies. Each scope knows about the variables declared within it,
  // and has a reference to its parent enclosing scope. In this way, we know which
  // variables are new and need to be declared with `var`, and which are shared
  // with external scopes.
  var Scope,
    indexOf = [].indexOf;

  exports.Scope = Scope = class Scope {
    // Initialize a scope with its parent, for lookups up the chain,
    // as well as a reference to the **Block** node it belongs to, which is
    // where it should declare its variables, a reference to the function that
    // it belongs to, and a list of variables referenced in the source code
    // and therefore should be avoided when generating variables. Also track comments
    // that should be output as part of variable declarations.
    constructor(parent, expressions, method, referencedVars) {
      var ref, ref1;
      this.parent = parent;
      this.expressions = expressions;
      this.method = method;
      this.referencedVars = referencedVars;
      this.variables = [
        {
          name: 'arguments',
          type: 'arguments'
        }
      ];
      this.comments = {};
      this.positions = {};
      if (!this.parent) {
        this.utilities = {};
      }
      // The `@root` is the top-level **Scope** object for a given file.
      this.root = (ref = (ref1 = this.parent) != null ? ref1.root : void 0) != null ? ref : this;
    }

    // Adds a new variable or overrides an existing one.
    add(name, type, immediate) {
      if (this.shared && !immediate) {
        return this.parent.add(name, type, immediate);
      }
      if (Object.prototype.hasOwnProperty.call(this.positions, name)) {
        return this.variables[this.positions[name]].type = type;
      } else {
        return this.positions[name] = this.variables.push({name, type}) - 1;
      }
    }

    // When `super` is called, we need to find the name of the current method we're
    // in, so that we know how to invoke the same method of the parent class. This
    // can get complicated if super is being called from an inner function.
    // `namedMethod` will walk up the scope tree until it either finds the first
    // function object that has a name filled in, or bottoms out.
    namedMethod() {
      var ref;
      if (((ref = this.method) != null ? ref.name : void 0) || !this.parent) {
        return this.method;
      }
      return this.parent.namedMethod();
    }

    // Look up a variable name in lexical scope, and declare it if it does not
    // already exist.
    find(name, type = 'var') {
      if (this.check(name)) {
        return true;
      }
      this.add(name, type);
      return false;
    }

    // Reserve a variable name as originating from a function parameter for this
    // scope. No `var` required for internal references.
    parameter(name) {
      if (this.shared && this.parent.check(name, true)) {
        return;
      }
      return this.add(name, 'param');
    }

    // Just check to see if a variable has already been declared, without reserving,
    // walks up to the root scope.
    check(name) {
      var ref;
      return !!(this.type(name) || ((ref = this.parent) != null ? ref.check(name) : void 0));
    }

    // Generate a temporary variable name at the given index.
    temporary(name, index, single = false) {
      var diff, endCode, letter, newCode, num, startCode;
      if (single) {
        startCode = name.charCodeAt(0);
        endCode = 'z'.charCodeAt(0);
        diff = endCode - startCode;
        newCode = startCode + index % (diff + 1);
        letter = String.fromCharCode(newCode);
        num = Math.floor(index / (diff + 1));
        return `${letter}${num || ''}`;
      } else {
        return `${name}${index || ''}`;
      }
    }

    // Gets the type of a variable.
    type(name) {
      var i, len, ref, v;
      ref = this.variables;
      for (i = 0, len = ref.length; i < len; i++) {
        v = ref[i];
        if (v.name === name) {
          return v.type;
        }
      }
      return null;
    }

    // If we need to store an intermediate result, find an available name for a
    // compiler-generated variable. `_var`, `_var2`, and so on...
    freeVariable(name, options = {}) {
      var index, ref, temp;
      index = 0;
      while (true) {
        temp = this.temporary(name, index, options.single);
        if (!(this.check(temp) || indexOf.call(this.root.referencedVars, temp) >= 0)) {
          break;
        }
        index++;
      }
      if ((ref = options.reserve) != null ? ref : true) {
        this.add(temp, 'var', true);
      }
      return temp;
    }

    // Ensure that an assignment is made at the top of this scope
    // (or at the top-level scope, if requested).
    assign(name, value) {
      this.add(name, {
        value,
        assigned: true
      }, true);
      return this.hasAssignments = true;
    }

    // Does this scope have any declared variables?
    hasDeclarations() {
      return !!this.declaredVariables().length;
    }

    // Return the list of variables first declared in this scope.
    declaredVariables() {
      var v;
      return ((function() {
        var i, len, ref, results;
        ref = this.variables;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          v = ref[i];
          if (v.type === 'var') {
            results.push(v.name);
          }
        }
        return results;
      }).call(this)).sort();
    }

    // Return the list of assignments that are supposed to be made at the top
    // of this scope.
    assignedVariables() {
      var i, len, ref, results, v;
      ref = this.variables;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        v = ref[i];
        if (v.type.assigned) {
          results.push(`${v.name} = ${v.type.value}`);
        }
      }
      return results;
    }

  };

}).call(this);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NvcGUuanMiLCJzb3VyY2VSb290IjoiLi4vLi4vIiwic291cmNlcyI6WyJzcmMvc2NvcGUubGl0Y29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFLdUI7RUFBQTs7Ozs7O0FBQUEsTUFBQSxLQUFBO0lBQUE7O0VBRW5CLE9BQU8sQ0FBQyxLQUFSLEdBQXNCLFFBQU4sTUFBQSxNQUFBLENBQUE7Ozs7Ozs7SUFTZCxXQUFhLE9BQUEsYUFBQSxRQUFBLGdCQUFBLENBQUE7QUFDbkIsVUFBQSxHQUFBLEVBQUE7TUFEb0IsSUFBQyxDQUFBO01BQVEsSUFBQyxDQUFBO01BQWEsSUFBQyxDQUFBO01BQVEsSUFBQyxDQUFBO01BQzdDLElBQUMsQ0FBQSxTQUFELEdBQWE7UUFBQztVQUFDLElBQUEsRUFBTSxXQUFQO1VBQW9CLElBQUEsRUFBTTtRQUExQixDQUFEOztNQUNiLElBQUMsQ0FBQSxRQUFELEdBQWEsQ0FBQTtNQUNiLElBQUMsQ0FBQSxTQUFELEdBQWEsQ0FBQTtNQUNiLEtBQXVCLElBQUMsQ0FBQSxNQUF4QjtRQUFBLElBQUMsQ0FBQSxTQUFELEdBQWEsQ0FBQSxFQUFiO09BSFI7O01BT1EsSUFBQyxDQUFBLElBQUQsNkVBQXdCO0lBUmIsQ0FBbkI7OztJQVlNLEdBQUssQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLFNBQWIsQ0FBQTtNQUNILElBQTRDLElBQUMsQ0FBQSxNQUFELElBQVksQ0FBSSxTQUE1RDtBQUFBLGVBQU8sSUFBQyxDQUFBLE1BQU0sQ0FBQyxHQUFSLENBQVksSUFBWixFQUFrQixJQUFsQixFQUF3QixTQUF4QixFQUFQOztNQUNBLElBQUcsTUFBTSxDQUFBLFNBQUUsQ0FBQSxjQUFjLENBQUMsSUFBdkIsQ0FBNEIsSUFBQyxDQUFBLFNBQTdCLEVBQXdDLElBQXhDLENBQUg7ZUFDRSxJQUFDLENBQUEsU0FBUyxDQUFDLElBQUMsQ0FBQSxTQUFTLENBQUMsSUFBRCxDQUFYLENBQWtCLENBQUMsSUFBN0IsR0FBb0MsS0FEdEM7T0FB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QUFBOzthQUNBO0lBUFksQ0F6RXBCOzs7O0lBcUZNLE1BQVEsQ0FBQyxJQUFELEVBQU8sS0FBUCxDQUFBO01BQ04sSUFBQyxDQUFBLEdBQUQsQ0FBSyxJQUFMLEVBQVc7UUFBQyxLQUFEO1FBQVEsUUFBQSxFQUFVO01BQWxCLENBQVgsRUFBbUMsSUFBbkM7YUFDQSxJQUFDLENBQUEsY0FBRCxHQUFrQjtJQUZaLENBckZkOzs7SUEyRk0sZUFBaUIsQ0FBQSxDQUFBO2FBQ2YsQ0FBQyxDQUFDLElBQUMsQ0FBQSxpQkFBRCxDQUFBLENBQW9CLENBQUM7SUFEUixDQTNGdkI7OztJQWdHTSxpQkFBbUIsQ0FBQSxDQUFBO0FBQ3pCLFVBQUE7YUFBUTs7QUFBQztBQUFBO1FBQUEsS0FBQSxxQ0FBQTs7Y0FBZ0MsQ0FBQyxDQUFDLElBQUYsS0FBVTt5QkFBMUMsQ0FBQyxDQUFDOztRQUFGLENBQUE7O21CQUFELENBQWlELENBQUMsSUFBbEQsQ0FBQTtJQURpQixDQWhHekI7Ozs7SUFzR00saUJBQW1CLENBQUEsQ0FBQTtBQUN6QixVQUFBLENBQUEsRUFBQSxHQUFBLEVBQUEsR0FBQSxFQUFBLE9BQUEsRUFBQTtBQUFRO0FBQUE7TUFBQSxLQUFBLHFDQUFBOztZQUF1RCxDQUFDLENBQUMsSUFBSSxDQUFDO3VCQUE5RCxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUMsSUFBTCxDQUFBLEdBQUEsQ0FBQSxDQUFlLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBdEIsQ0FBQTs7TUFBQSxDQUFBOztJQURpQjs7RUEvR0w7QUFGRyIsInNvdXJjZXNDb250ZW50IjpbIlRoZSAqKlNjb3BlKiogY2xhc3MgcmVndWxhdGVzIGxleGljYWwgc2NvcGluZyB3aXRoaW4gQ29mZmVlU2NyaXB0LiBBcyB5b3VcbmdlbmVyYXRlIGNvZGUsIHlvdSBjcmVhdGUgYSB0cmVlIG9mIHNjb3BlcyBpbiB0aGUgc2FtZSBzaGFwZSBhcyB0aGUgbmVzdGVkXG5mdW5jdGlvbiBib2RpZXMuIEVhY2ggc2NvcGUga25vd3MgYWJvdXQgdGhlIHZhcmlhYmxlcyBkZWNsYXJlZCB3aXRoaW4gaXQsXG5hbmQgaGFzIGEgcmVmZXJlbmNlIHRvIGl0cyBwYXJlbnQgZW5jbG9zaW5nIHNjb3BlLiBJbiB0aGlzIHdheSwgd2Uga25vdyB3aGljaFxudmFyaWFibGVzIGFyZSBuZXcgYW5kIG5lZWQgdG8gYmUgZGVjbGFyZWQgd2l0aCBgdmFyYCwgYW5kIHdoaWNoIGFyZSBzaGFyZWRcbndpdGggZXh0ZXJuYWwgc2NvcGVzLlxuXG4gICAgZXhwb3J0cy5TY29wZSA9IGNsYXNzIFNjb3BlXG5cbkluaXRpYWxpemUgYSBzY29wZSB3aXRoIGl0cyBwYXJlbnQsIGZvciBsb29rdXBzIHVwIHRoZSBjaGFpbixcbmFzIHdlbGwgYXMgYSByZWZlcmVuY2UgdG8gdGhlICoqQmxvY2sqKiBub2RlIGl0IGJlbG9uZ3MgdG8sIHdoaWNoIGlzXG53aGVyZSBpdCBzaG91bGQgZGVjbGFyZSBpdHMgdmFyaWFibGVzLCBhIHJlZmVyZW5jZSB0byB0aGUgZnVuY3Rpb24gdGhhdFxuaXQgYmVsb25ncyB0bywgYW5kIGEgbGlzdCBvZiB2YXJpYWJsZXMgcmVmZXJlbmNlZCBpbiB0aGUgc291cmNlIGNvZGVcbmFuZCB0aGVyZWZvcmUgc2hvdWxkIGJlIGF2b2lkZWQgd2hlbiBnZW5lcmF0aW5nIHZhcmlhYmxlcy4gQWxzbyB0cmFjayBjb21tZW50c1xudGhhdCBzaG91bGQgYmUgb3V0cHV0IGFzIHBhcnQgb2YgdmFyaWFibGUgZGVjbGFyYXRpb25zLlxuXG4gICAgICBjb25zdHJ1Y3RvcjogKEBwYXJlbnQsIEBleHByZXNzaW9ucywgQG1ldGhvZCwgQHJlZmVyZW5jZWRWYXJzKSAtPlxuICAgICAgICBAdmFyaWFibGVzID0gW3tuYW1lOiAnYXJndW1lbnRzJywgdHlwZTogJ2FyZ3VtZW50cyd9XVxuICAgICAgICBAY29tbWVudHMgID0ge31cbiAgICAgICAgQHBvc2l0aW9ucyA9IHt9XG4gICAgICAgIEB1dGlsaXRpZXMgPSB7fSB1bmxlc3MgQHBhcmVudFxuXG5UaGUgYEByb290YCBpcyB0aGUgdG9wLWxldmVsICoqU2NvcGUqKiBvYmplY3QgZm9yIGEgZ2l2ZW4gZmlsZS5cblxuICAgICAgICBAcm9vdCA9IEBwYXJlbnQ/LnJvb3QgPyB0aGlzXG5cbkFkZHMgYSBuZXcgdmFyaWFibGUgb3Igb3ZlcnJpZGVzIGFuIGV4aXN0aW5nIG9uZS5cblxuICAgICAgYWRkOiAobmFtZSwgdHlwZSwgaW1tZWRpYXRlKSAtPlxuICAgICAgICByZXR1cm4gQHBhcmVudC5hZGQgbmFtZSwgdHlwZSwgaW1tZWRpYXRlIGlmIEBzaGFyZWQgYW5kIG5vdCBpbW1lZGlhdGVcbiAgICAgICAgaWYgT2JqZWN0OjpoYXNPd25Qcm9wZXJ0eS5jYWxsIEBwb3NpdGlvbnMsIG5hbWVcbiAgICAgICAgICBAdmFyaWFibGVzW0Bwb3NpdGlvbnNbbmFtZV1dLnR5cGUgPSB0eXBlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBAcG9zaXRpb25zW25hbWVdID0gQHZhcmlhYmxlcy5wdXNoKHtuYW1lLCB0eXBlfSkgLSAxXG5cbldoZW4gYHN1cGVyYCBpcyBjYWxsZWQsIHdlIG5lZWQgdG8gZmluZCB0aGUgbmFtZSBvZiB0aGUgY3VycmVudCBtZXRob2Qgd2UncmVcbmluLCBzbyB0aGF0IHdlIGtub3cgaG93IHRvIGludm9rZSB0aGUgc2FtZSBtZXRob2Qgb2YgdGhlIHBhcmVudCBjbGFzcy4gVGhpc1xuY2FuIGdldCBjb21wbGljYXRlZCBpZiBzdXBlciBpcyBiZWluZyBjYWxsZWQgZnJvbSBhbiBpbm5lciBmdW5jdGlvbi5cbmBuYW1lZE1ldGhvZGAgd2lsbCB3YWxrIHVwIHRoZSBzY29wZSB0cmVlIHVudGlsIGl0IGVpdGhlciBmaW5kcyB0aGUgZmlyc3RcbmZ1bmN0aW9uIG9iamVjdCB0aGF0IGhhcyBhIG5hbWUgZmlsbGVkIGluLCBvciBib3R0b21zIG91dC5cblxuICAgICAgbmFtZWRNZXRob2Q6IC0+XG4gICAgICAgIHJldHVybiBAbWV0aG9kIGlmIEBtZXRob2Q/Lm5hbWUgb3IgIUBwYXJlbnRcbiAgICAgICAgQHBhcmVudC5uYW1lZE1ldGhvZCgpXG5cbkxvb2sgdXAgYSB2YXJpYWJsZSBuYW1lIGluIGxleGljYWwgc2NvcGUsIGFuZCBkZWNsYXJlIGl0IGlmIGl0IGRvZXMgbm90XG5hbHJlYWR5IGV4aXN0LlxuXG4gICAgICBmaW5kOiAobmFtZSwgdHlwZSA9ICd2YXInKSAtPlxuICAgICAgICByZXR1cm4geWVzIGlmIEBjaGVjayBuYW1lXG4gICAgICAgIEBhZGQgbmFtZSwgdHlwZVxuICAgICAgICBub1xuXG5SZXNlcnZlIGEgdmFyaWFibGUgbmFtZSBhcyBvcmlnaW5hdGluZyBmcm9tIGEgZnVuY3Rpb24gcGFyYW1ldGVyIGZvciB0aGlzXG5zY29wZS4gTm8gYHZhcmAgcmVxdWlyZWQgZm9yIGludGVybmFsIHJlZmVyZW5jZXMuXG5cbiAgICAgIHBhcmFtZXRlcjogKG5hbWUpIC0+XG4gICAgICAgIHJldHVybiBpZiBAc2hhcmVkIGFuZCBAcGFyZW50LmNoZWNrIG5hbWUsIHllc1xuICAgICAgICBAYWRkIG5hbWUsICdwYXJhbSdcblxuSnVzdCBjaGVjayB0byBzZWUgaWYgYSB2YXJpYWJsZSBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkLCB3aXRob3V0IHJlc2VydmluZyxcbndhbGtzIHVwIHRvIHRoZSByb290IHNjb3BlLlxuXG4gICAgICBjaGVjazogKG5hbWUpIC0+XG4gICAgICAgICEhKEB0eXBlKG5hbWUpIG9yIEBwYXJlbnQ/LmNoZWNrKG5hbWUpKVxuXG5HZW5lcmF0ZSBhIHRlbXBvcmFyeSB2YXJpYWJsZSBuYW1lIGF0IHRoZSBnaXZlbiBpbmRleC5cblxuICAgICAgdGVtcG9yYXJ5OiAobmFtZSwgaW5kZXgsIHNpbmdsZT1mYWxzZSkgLT5cbiAgICAgICAgaWYgc2luZ2xlXG4gICAgICAgICAgc3RhcnRDb2RlID0gbmFtZS5jaGFyQ29kZUF0KDApXG4gICAgICAgICAgZW5kQ29kZSA9ICd6Jy5jaGFyQ29kZUF0KDApXG4gICAgICAgICAgZGlmZiA9IGVuZENvZGUgLSBzdGFydENvZGVcbiAgICAgICAgICBuZXdDb2RlID0gc3RhcnRDb2RlICsgaW5kZXggJSAoZGlmZiArIDEpXG4gICAgICAgICAgbGV0dGVyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXdDb2RlKVxuICAgICAgICAgIG51bSA9IGluZGV4IC8vIChkaWZmICsgMSlcbiAgICAgICAgICBcIiN7bGV0dGVyfSN7bnVtIG9yICcnfVwiXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBcIiN7bmFtZX0je2luZGV4IG9yICcnfVwiXG5cbkdldHMgdGhlIHR5cGUgb2YgYSB2YXJpYWJsZS5cblxuICAgICAgdHlwZTogKG5hbWUpIC0+XG4gICAgICAgIHJldHVybiB2LnR5cGUgZm9yIHYgaW4gQHZhcmlhYmxlcyB3aGVuIHYubmFtZSBpcyBuYW1lXG4gICAgICAgIG51bGxcblxuSWYgd2UgbmVlZCB0byBzdG9yZSBhbiBpbnRlcm1lZGlhdGUgcmVzdWx0LCBmaW5kIGFuIGF2YWlsYWJsZSBuYW1lIGZvciBhXG5jb21waWxlci1nZW5lcmF0ZWQgdmFyaWFibGUuIGBfdmFyYCwgYF92YXIyYCwgYW5kIHNvIG9uLi4uXG5cbiAgICAgIGZyZWVWYXJpYWJsZTogKG5hbWUsIG9wdGlvbnM9e30pIC0+XG4gICAgICAgIGluZGV4ID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgdGVtcCA9IEB0ZW1wb3JhcnkgbmFtZSwgaW5kZXgsIG9wdGlvbnMuc2luZ2xlXG4gICAgICAgICAgYnJlYWsgdW5sZXNzIEBjaGVjayh0ZW1wKSBvciB0ZW1wIGluIEByb290LnJlZmVyZW5jZWRWYXJzXG4gICAgICAgICAgaW5kZXgrK1xuICAgICAgICBAYWRkIHRlbXAsICd2YXInLCB5ZXMgaWYgb3B0aW9ucy5yZXNlcnZlID8gdHJ1ZVxuICAgICAgICB0ZW1wXG5cbkVuc3VyZSB0aGF0IGFuIGFzc2lnbm1lbnQgaXMgbWFkZSBhdCB0aGUgdG9wIG9mIHRoaXMgc2NvcGVcbihvciBhdCB0aGUgdG9wLWxldmVsIHNjb3BlLCBpZiByZXF1ZXN0ZWQpLlxuXG4gICAgICBhc3NpZ246IChuYW1lLCB2YWx1ZSkgLT5cbiAgICAgICAgQGFkZCBuYW1lLCB7dmFsdWUsIGFzc2lnbmVkOiB5ZXN9LCB5ZXNcbiAgICAgICAgQGhhc0Fzc2lnbm1lbnRzID0geWVzXG5cbkRvZXMgdGhpcyBzY29wZSBoYXZlIGFueSBkZWNsYXJlZCB2YXJpYWJsZXM/XG5cbiAgICAgIGhhc0RlY2xhcmF0aW9uczogLT5cbiAgICAgICAgISFAZGVjbGFyZWRWYXJpYWJsZXMoKS5sZW5ndGhcblxuUmV0dXJuIHRoZSBsaXN0IG9mIHZhcmlhYmxlcyBmaXJzdCBkZWNsYXJlZCBpbiB0aGlzIHNjb3BlLlxuXG4gICAgICBkZWNsYXJlZFZhcmlhYmxlczogLT5cbiAgICAgICAgKHYubmFtZSBmb3IgdiBpbiBAdmFyaWFibGVzIHdoZW4gdi50eXBlIGlzICd2YXInKS5zb3J0KClcblxuUmV0dXJuIHRoZSBsaXN0IG9mIGFzc2lnbm1lbnRzIHRoYXQgYXJlIHN1cHBvc2VkIHRvIGJlIG1hZGUgYXQgdGhlIHRvcFxub2YgdGhpcyBzY29wZS5cblxuICAgICAgYXNzaWduZWRWYXJpYWJsZXM6IC0+XG4gICAgICAgIFwiI3t2Lm5hbWV9ID0gI3t2LnR5cGUudmFsdWV9XCIgZm9yIHYgaW4gQHZhcmlhYmxlcyB3aGVuIHYudHlwZS5hc3NpZ25lZFxuIl19
//# sourceURL=/home/flow/jzr/coffeescript/src/scope.litcoffee