// Generated by CoffeeScript 2.7.0
(function() {
  // The CoffeeScript Lexer. Uses a series of token-matching regexes to attempt
  // matches against the beginning of the source code. When a match is found,
  // a token is produced, we consume the match, and start again. Tokens are in the
  // form:

  //     [tag, value, locationData]

  // where locationData is {first_line, first_column, last_line, last_column, last_line_exclusive, last_column_exclusive}, which is a
  // format that can be fed directly into [Jison](https://github.com/zaach/jison).  These
  // are read by jison in the `parser.lexer` function defined in coffeescript.coffee.
  var BOM, BOOL, CALLABLE, CODE, COFFEE_ALIASES, COFFEE_ALIAS_MAP, COFFEE_KEYWORDS, COMMENT, COMPARABLE_LEFT_SIDE, COMPARE, COMPOUND_ASSIGN, HERECOMMENT_ILLEGAL, HEREDOC_DOUBLE, HEREDOC_INDENT, HEREDOC_SINGLE, HEREGEX, HEREGEX_COMMENT, HERE_JSTOKEN, IDENTIFIER, INDENTABLE_CLOSERS, INDEXABLE, INSIDE_JSX, INVERSES, JSTOKEN, JSX_ATTRIBUTE, JSX_FRAGMENT_IDENTIFIER, JSX_IDENTIFIER, JSX_IDENTIFIER_PART, JSX_INTERPOLATION, JS_KEYWORDS, LINE_BREAK, LINE_CONTINUER, Lexer, MATH, MULTI_DENT, NOT_REGEX, NUMBER, OPERATOR, POSSIBLY_DIVISION, REGEX, REGEX_FLAGS, REGEX_ILLEGAL, REGEX_INVALID_ESCAPE, RELATION, RESERVED, Rewriter, SHIFT, STRICT_PROSCRIBED, STRING_DOUBLE, STRING_INVALID_ESCAPE, STRING_SINGLE, STRING_START, TRAILING_SPACES, UNARY, UNARY_MATH, UNFINISHED, VALID_FLAGS, WHITESPACE, addTokenData, attachCommentsToNode, compact, count, flatten, invertLiterate, isForFrom, isUnassignable, key, locationDataToString, merge, parseNumber, repeat, replaceUnicodeCodePointEscapes, starts, throwSyntaxError,
    indexOf = [].indexOf,
    slice = [].slice;

  ({Rewriter, INVERSES, UNFINISHED} = require('./rewriter'));

  // Import the helpers we need.
  ({count, starts, compact, repeat, invertLiterate, merge, attachCommentsToNode, locationDataToString, throwSyntaxError, replaceUnicodeCodePointEscapes, flatten, parseNumber} = require('./helpers'));

  // The Lexer Class
  // ---------------

  // The Lexer class reads a stream of CoffeeScript and divvies it up into tagged
  // tokens. Some potential ambiguity in the grammar has been avoided by
  // pushing some extra smarts into the Lexer.
  exports.Lexer = Lexer = class Lexer {
    constructor() {
      // Throws an error at either a given offset from the current chunk or at the
      // location of a token (`token[2]`).
      this.error = this.error.bind(this);
    }

    // **tokenize** is the Lexer's main method. Scan by attempting to match tokens
    // one at a time, using a regular expression anchored at the start of the
    // remaining code, or a custom recursive token-matching method
    // (for interpolations). When the next token has been recorded, we move forward
    // within the code past the token, and begin again.

    // Each tokenizing method is responsible for returning the number of characters
    // it has consumed.

    // Before returning the token stream, run it through the [Rewriter](rewriter.html).
    tokenize(code, opts = {}) {
      var consumed, end, i, ref;
      this.literate = opts.literate; // Are we lexing literate CoffeeScript?
      this.indent = 0; // The current indentation level.
      this.baseIndent = 0; // The overall minimum indentation level.
      this.continuationLineAdditionalIndent = 0; // The over-indentation at the current level.
      this.outdebt = 0; // The under-outdentation at the current level.
      this.indents = []; // The stack of all current indentation levels.
      this.indentLiteral = ''; // The indentation.
      this.ends = []; // The stack for pairing up tokens.
      this.tokens = []; // Stream of parsed tokens in the form `['TYPE', value, location data]`.
      this.seenFor = false; // Used to recognize `FORIN`, `FOROF` and `FORFROM` tokens.
      this.seenImport = false; // Used to recognize `IMPORT FROM? AS?` tokens.
      this.seenExport = false; // Used to recognize `EXPORT FROM? AS?` tokens.
      this.importSpecifierList = false; // Used to identify when in an `IMPORT {...} FROM? ...`.
      this.exportSpecifierList = false; // Used to identify when in an `EXPORT {...} FROM? ...`.
      this.jsxDepth = 0; // Used to optimize JSX checks, how deep in JSX we are.
      this.jsxObjAttribute = {}; // Used to detect if JSX attributes is wrapped in {} (<div {props...} />).
      this.chunkLine = opts.line || 0; // The start line for the current @chunk.
      this.chunkColumn = opts.column || 0; // The start column of the current @chunk.
      this.chunkOffset = opts.offset || 0; // The start offset for the current @chunk.
      this.locationDataCompensations = opts.locationDataCompensations || {};
      code = this.clean(code); // The stripped, cleaned original source code.
      
      // At every position, run through this list of attempted matches,
      // short-circuiting if any of them succeed. Their order determines precedence:
      // `@literalToken` is the fallback catch-all.
      i = 0;
      while (this.chunk = code.slice(i)) {
        consumed = this.identifierToken() || this.commentToken() || this.whitespaceToken() || this.lineToken() || this.stringToken() || this.numberToken() || this.jsxToken() || this.regexToken() || this.jsToken() || this.literalToken();
        // Update position.
        [this.chunkLine, this.chunkColumn, this.chunkOffset] = this.getLineAndColumnFromChunk(consumed);
        i += consumed;
        if (opts.untilBalanced && this.ends.length === 0) {
          return {
            tokens: this.tokens,
            index: i
          };
        }
      }
      this.closeIndentation();
      if (end = this.ends.pop()) {
        this.error(`missing ${end.tag}`, ((ref = end.origin) != null ? ref : end)[2]);
      }
      if (opts.rewrite === false) {
        return this.tokens;
      }
      return (new Rewriter()).rewrite(this.tokens);
    }

    // Preprocess the code to remove leading and trailing whitespace, carriage
    // returns, etc. If we’re lexing literate CoffeeScript, strip external Markdown
    // by removing all lines that aren’t indented by at least four spaces or a tab.
    clean(code) {
      var base, thusFar;
      thusFar = 0;
      if (code.charCodeAt(0) === BOM) {
        code = code.slice(1);
        this.locationDataCompensations[0] = 1;
        thusFar += 1;
      }
      if (WHITESPACE.test(code)) {
        code = `\n${code}`;
        this.chunkLine--;
        if ((base = this.locationDataCompensations)[0] == null) {
          base[0] = 0;
        }
        this.locationDataCompensations[0] -= 1;
      }
      code = code.replace(/\r/g, (match, offset) => {
        this.locationDataCompensations[thusFar + offset] = 1;
        return '';
      }).replace(TRAILING_SPACES, '');
      if (this.literate) {
        code = invertLiterate(code);
      }
      return code;
    }

    // Tokenizers
    // ----------

      // Matches identifying literals: variables, keywords, method names, etc.
    // Check to ensure that JavaScript reserved words aren’t being used as
    // identifiers. Because CoffeeScript reserves a handful of keywords that are
    // allowed in JavaScript, we’re careful not to tag them as keywords when
    // referenced as property names here, so you can still do `jQuery.is()` even
    // though `is` means `===` otherwise.
    identifierToken() {
      var alias, colon, colonOffset, colonToken, id, idLength, inJSXTag, input, match, poppedToken, prev, prevprev, ref, ref1, ref10, ref11, ref12, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, regExSuper, regex, sup, tag, tagToken, tokenData;
      inJSXTag = this.atJSXTag();
      regex = inJSXTag ? JSX_ATTRIBUTE : IDENTIFIER;
      if (!(match = regex.exec(this.chunk))) {
        return 0;
      }
      [input, id, colon] = match;
      // Preserve length of id for location data
      idLength = id.length;
      poppedToken = void 0;
      if (id === 'own' && this.tag() === 'FOR') {
        this.token('OWN', id);
        return id.length;
      }
      if (id === 'from' && this.tag() === 'YIELD') {
        this.token('FROM', id);
        return id.length;
      }
      if (id === 'as' && this.seenImport) {
        if (this.value() === '*') {
          this.tokens[this.tokens.length - 1][0] = 'IMPORT_ALL';
        } else if (ref = this.value(true), indexOf.call(COFFEE_KEYWORDS, ref) >= 0) {
          prev = this.prev();
          [prev[0], prev[1]] = ['IDENTIFIER', this.value(true)];
        }
        if ((ref1 = this.tag()) === 'DEFAULT' || ref1 === 'IMPORT_ALL' || ref1 === 'IDENTIFIER') {
          this.token('AS', id);
          return id.length;
        }
      }
      if (id === 'as' && this.seenExport) {
        if ((ref2 = this.tag()) === 'IDENTIFIER' || ref2 === 'DEFAULT') {
          this.token('AS', id);
          return id.length;
        }
        if (ref3 = this.value(true), indexOf.call(COFFEE_KEYWORDS, ref3) >= 0) {
          prev = this.prev();
          [prev[0], prev[1]] = ['IDENTIFIER', this.value(true)];
          this.token('AS', id);
          return id.length;
        }
      }
      if (id === 'default' && this.seenExport && ((ref4 = this.tag()) === 'EXPORT' || ref4 === 'AS')) {
        this.token('DEFAULT', id);
        return id.length;
      }
      if (id === 'assert' && (this.seenImport || this.seenExport) && this.tag() === 'STRING') {
        this.token('ASSERT', id);
        return id.length;
      }
      if (id === 'do' && (regExSuper = /^(\s*super)(?!\(\))/.exec(this.chunk.slice(3)))) {
        this.token('SUPER', 'super');
        this.token('CALL_START', '(');
        this.token('CALL_END', ')');
        [input, sup] = regExSuper;
        return sup.length + 3;
      }
      prev = this.prev();
      tag = colon || (prev != null) && (((ref5 = prev[0]) === '.' || ref5 === '?.' || ref5 === '::' || ref5 === '?::') || !prev.spaced && prev[0] === '@') ? 'PROPERTY' : 'IDENTIFIER';
      tokenData = {};
      if (tag === 'IDENTIFIER' && (indexOf.call(JS_KEYWORDS, id) >= 0 || indexOf.call(COFFEE_KEYWORDS, id) >= 0) && !(this.exportSpecifierList && indexOf.call(COFFEE_KEYWORDS, id) >= 0)) {
        tag = id.toUpperCase();
        if (tag === 'WHEN' && (ref6 = this.tag(), indexOf.call(LINE_BREAK, ref6) >= 0)) {
          tag = 'LEADING_WHEN';
        } else if (tag === 'FOR') {
          this.seenFor = {
            endsLength: this.ends.length
          };
        } else if (tag === 'UNLESS') {
          tag = 'IF';
        } else if (tag === 'IMPORT') {
          this.seenImport = true;
        } else if (tag === 'EXPORT') {
          this.seenExport = true;
        } else if (indexOf.call(UNARY, tag) >= 0) {
          tag = 'UNARY';
        } else if (indexOf.call(RELATION, tag) >= 0) {
          if (tag !== 'INSTANCEOF' && this.seenFor) {
            tag = 'FOR' + tag;
            this.seenFor = false;
          } else {
            tag = 'RELATION';
            if (this.value() === '!') {
              poppedToken = this.tokens.pop();
              tokenData.invert = (ref7 = (ref8 = poppedToken.data) != null ? ref8.original : void 0) != null ? ref7 : poppedToken[1];
            }
          }
        }
      } else if (tag === 'IDENTIFIER' && this.seenFor && id === 'from' && isForFrom(prev)) {
        tag = 'FORFROM';
        this.seenFor = false;
      // Throw an error on attempts to use `get` or `set` as keywords, or
      // what CoffeeScript would normally interpret as calls to functions named
      // `get` or `set`, i.e. `get({foo: function () {}})`.
      } else if (tag === 'PROPERTY' && prev) {
        if (prev.spaced && (ref9 = prev[0], indexOf.call(CALLABLE, ref9) >= 0) && /^[gs]et$/.test(prev[1]) && this.tokens.length > 1 && ((ref10 = this.tokens[this.tokens.length - 2][0]) !== '.' && ref10 !== '?.' && ref10 !== '@')) {
          this.error(`'${prev[1]}' cannot be used as a keyword, or as a function call without parentheses`, prev[2]);
        } else if (prev[0] === '.' && this.tokens.length > 1 && (prevprev = this.tokens[this.tokens.length - 2])[0] === 'UNARY' && prevprev[1] === 'new') {
          prevprev[0] = 'NEW_TARGET';
        } else if (prev[0] === '.' && this.tokens.length > 1 && (prevprev = this.tokens[this.tokens.length - 2])[0] === 'IMPORT' && prevprev[1] === 'import') {
          this.seenImport = false;
          prevprev[0] = 'IMPORT_META';
        } else if (this.tokens.length > 2) {
          prevprev = this.tokens[this.tokens.length - 2];
          if (((ref11 = prev[0]) === '@' || ref11 === 'THIS') && prevprev && prevprev.spaced && /^[gs]et$/.test(prevprev[1]) && ((ref12 = this.tokens[this.tokens.length - 3][0]) !== '.' && ref12 !== '?.' && ref12 !== '@')) {
            this.error(`'${prevprev[1]}' cannot be used as a keyword, or as a function call without parentheses`, prevprev[2]);
          }
        }
      }
      if (tag === 'IDENTIFIER' && indexOf.call(RESERVED, id) >= 0 && !inJSXTag) {
        this.error(`reserved word '${id}'`, {
          length: id.length
        });
      }
      if (!(tag === 'PROPERTY' || this.exportSpecifierList || this.importSpecifierList)) {
        if (indexOf.call(COFFEE_ALIASES, id) >= 0) {
          alias = id;
          id = COFFEE_ALIAS_MAP[id];
          tokenData.original = alias;
        }
        tag = (function() {
          switch (id) {
            case '!':
              return 'UNARY';
            case '==':
            case '!=':
              return 'COMPARE';
            case 'true':
            case 'false':
              return 'BOOL';
            case 'break':
            case 'continue':
            case 'debugger':
              return 'STATEMENT';
            case '&&':
            case '||':
              return id;
            default:
              return tag;
          }
        })();
      }
      tagToken = this.token(tag, id, {
        length: idLength,
        data: tokenData
      });
      if (alias) {
        tagToken.origin = [tag, alias, tagToken[2]];
      }
      if (poppedToken) {
        [tagToken[2].first_line, tagToken[2].first_column, tagToken[2].range[0]] = [poppedToken[2].first_line, poppedToken[2].first_column, poppedToken[2].range[0]];
      }
      if (colon) {
        colonOffset = input.lastIndexOf(inJSXTag ? '=' : ':');
        colonToken = this.token(':', ':', {
          offset: colonOffset
        });
        if (inJSXTag) { // used by rewriter
          colonToken.jsxColon = true;
        }
      }
      if (inJSXTag && tag === 'IDENTIFIER' && prev[0] !== ':') {
        this.token(',', ',', {
          length: 0,
          origin: tagToken,
          generated: true
        });
      }
      return input.length;
    }

    // Matches numbers, including decimals, hex, and exponential notation.
    // Be careful not to interfere with ranges in progress.
    numberToken() {
      var lexedLength, match, number, parsedValue, tag, tokenData;
      if (!(match = NUMBER.exec(this.chunk))) {
        return 0;
      }
      number = match[0];
      lexedLength = number.length;
      switch (false) {
        case !/^0[BOX]/.test(number):
          this.error(`radix prefix in '${number}' must be lowercase`, {
            offset: 1
          });
          break;
        case !/^0\d*[89]/.test(number):
          this.error(`decimal literal '${number}' must not be prefixed with '0'`, {
            length: lexedLength
          });
          break;
        case !/^0\d+/.test(number):
          this.error(`octal literal '${number}' must be prefixed with '0o'`, {
            length: lexedLength
          });
      }
      parsedValue = parseNumber(number);
      tokenData = {parsedValue};
      tag = parsedValue === 2e308 ? 'INFINITY' : 'NUMBER';
      if (tag === 'INFINITY') {
        tokenData.original = number;
      }
      this.token(tag, number, {
        length: lexedLength,
        data: tokenData
      });
      return lexedLength;
    }

    // Matches strings, including multiline strings, as well as heredocs, with or without
    // interpolation.
    stringToken() {
      var attempt, delimiter, doc, end, heredoc, i, indent, match, prev, quote, ref, regex, token, tokens;
      [quote] = STRING_START.exec(this.chunk) || [];
      if (!quote) {
        return 0;
      }
      // If the preceding token is `from` and this is an import or export statement,
      // properly tag the `from`.
      prev = this.prev();
      if (prev && this.value() === 'from' && (this.seenImport || this.seenExport)) {
        prev[0] = 'FROM';
      }
      regex = (function() {
        switch (quote) {
          case "'":
            return STRING_SINGLE;
          case '"':
            return STRING_DOUBLE;
          case "'''":
            return HEREDOC_SINGLE;
          case '"""':
            return HEREDOC_DOUBLE;
        }
      })();
      ({
        tokens,
        index: end
      } = this.matchWithInterpolations(regex, quote));
      heredoc = quote.length === 3;
      if (heredoc) {
        // Find the smallest indentation. It will be removed from all lines later.
        indent = null;
        doc = ((function() {
          var j, len, results;
          results = [];
          for (i = j = 0, len = tokens.length; j < len; i = ++j) {
            token = tokens[i];
            if (token[0] === 'NEOSTRING') {
              results.push(token[1]);
            }
          }
          return results;
        })()).join('#{}');
        while (match = HEREDOC_INDENT.exec(doc)) {
          attempt = match[1];
          if (indent === null || (0 < (ref = attempt.length) && ref < indent.length)) {
            indent = attempt;
          }
        }
      }
      delimiter = quote.charAt(0);
      this.mergeInterpolationTokens(tokens, {
        quote,
        indent,
        endOffset: end
      }, (value) => {
        return this.validateUnicodeCodePointEscapes(value, {
          delimiter: quote
        });
      });
      if (this.atJSXTag()) {
        this.token(',', ',', {
          length: 0,
          origin: this.prev,
          generated: true
        });
      }
      return end;
    }

    // Matches and consumes comments. The comments are taken out of the token
    // stream and saved for later, to be reinserted into the output after
    // everything has been parsed and the JavaScript code generated.
    commentToken(chunk = this.chunk, {heregex, returnCommentTokens = false, offsetInChunk = 0} = {}) {
      var commentAttachment, commentAttachments, commentWithSurroundingWhitespace, content, contents, getIndentSize, hasSeenFirstCommentLine, hereComment, hereLeadingWhitespace, hereTrailingWhitespace, i, indentSize, leadingNewline, leadingNewlineOffset, leadingNewlines, leadingWhitespace, length, lineComment, match, matchIllegal, noIndent, nonInitial, placeholderToken, precededByBlankLine, precedingNonCommentLines, prev;
      if (!(match = chunk.match(COMMENT))) {
        return 0;
      }
      [commentWithSurroundingWhitespace, hereLeadingWhitespace, hereComment, hereTrailingWhitespace, lineComment] = match;
      contents = null;
      // Does this comment follow code on the same line?
      leadingNewline = /^\s*\n+\s*#/.test(commentWithSurroundingWhitespace);
      if (hereComment) {
        matchIllegal = HERECOMMENT_ILLEGAL.exec(hereComment);
        if (matchIllegal) {
          this.error(`block comments cannot contain ${matchIllegal[0]}`, {
            offset: '###'.length + matchIllegal.index,
            length: matchIllegal[0].length
          });
        }
        // Parse indentation or outdentation as if this block comment didn’t exist.
        chunk = chunk.replace(`###${hereComment}###`, '');
        // Remove leading newlines, like `Rewriter::removeLeadingNewlines`, to
        // avoid the creation of unwanted `TERMINATOR` tokens.
        chunk = chunk.replace(/^\n+/, '');
        this.lineToken({chunk});
        // Pull out the ###-style comment’s content, and format it.
        content = hereComment;
        contents = [
          {
            content,
            length: commentWithSurroundingWhitespace.length - hereLeadingWhitespace.length - hereTrailingWhitespace.length,
            leadingWhitespace: hereLeadingWhitespace
          }
        ];
      } else {
        // The `COMMENT` regex captures successive line comments as one token.
        // Remove any leading newlines before the first comment, but preserve
        // blank lines between line comments.
        leadingNewlines = '';
        content = lineComment.replace(/^(\n*)/, function(leading) {
          leadingNewlines = leading;
          return '';
        });
        precedingNonCommentLines = '';
        hasSeenFirstCommentLine = false;
        contents = content.split('\n').map(function(line, index) {
          var comment, leadingWhitespace;
          if (!(line.indexOf('#') > -1)) {
            precedingNonCommentLines += `\n${line}`;
            return;
          }
          leadingWhitespace = '';
          content = line.replace(/^([ |\t]*)#/, function(_, whitespace) {
            leadingWhitespace = whitespace;
            return '';
          });
          comment = {
            content,
            length: '#'.length + content.length,
            leadingWhitespace: `${!hasSeenFirstCommentLine ? leadingNewlines : ''}${precedingNonCommentLines}${leadingWhitespace}`,
            precededByBlankLine: !!precedingNonCommentLines
          };
          hasSeenFirstCommentLine = true;
          precedingNonCommentLines = '';
          return comment;
        }).filter(function(comment) {
          return comment;
        });
      }
      getIndentSize = function({leadingWhitespace, nonInitial}) {
        var lastNewlineIndex;
        lastNewlineIndex = leadingWhitespace.lastIndexOf('\n');
        if ((hereComment != null) || !nonInitial) {
          if (!(lastNewlineIndex > -1)) {
            return null;
          }
        } else {
          if (lastNewlineIndex == null) {
            lastNewlineIndex = -1;
          }
        }
        return leadingWhitespace.length - 1 - lastNewlineIndex;
      };
      commentAttachments = (function() {
        var j, len, results;
        results = [];
        for (i = j = 0, len = contents.length; j < len; i = ++j) {
          ({content, length, leadingWhitespace, precededByBlankLine} = contents[i]);
          nonInitial = i !== 0;
          leadingNewlineOffset = nonInitial ? 1 : 0;
          offsetInChunk += leadingNewlineOffset + leadingWhitespace.length;
          indentSize = getIndentSize({leadingWhitespace, nonInitial});
          noIndent = (indentSize == null) || indentSize === -1;
          commentAttachment = {
            content,
            here: hereComment != null,
            newLine: leadingNewline || nonInitial, // Line comments after the first one start new lines, by definition.
            locationData: this.makeLocationData({offsetInChunk, length}),
            precededByBlankLine,
            indentSize,
            indented: !noIndent && indentSize > this.indent,
            outdented: !noIndent && indentSize < this.indent
          };
          if (heregex) {
            commentAttachment.heregex = true;
          }
          offsetInChunk += length;
          results.push(commentAttachment);
        }
        return results;
      }).call(this);
      prev = this.prev();
      if (!prev) {
        // If there’s no previous token, create a placeholder token to attach
        // this comment to; and follow with a newline.
        commentAttachments[0].newLine = true;
        this.lineToken({
          chunk: this.chunk.slice(commentWithSurroundingWhitespace.length),
          offset: commentWithSurroundingWhitespace.length // Set the indent.
        });
        placeholderToken = this.makeToken('JS', '', {
          offset: commentWithSurroundingWhitespace.length,
          generated: true
        });
        placeholderToken.comments = commentAttachments;
        this.tokens.push(placeholderToken);
        this.newlineToken(commentWithSurroundingWhitespace.length);
      } else {
        attachCommentsToNode(commentAttachments, prev);
      }
      if (returnCommentTokens) {
        return commentAttachments;
      }
      return commentWithSurroundingWhitespace.length;
    }

    // Matches JavaScript interpolated directly into the source via backticks.
    jsToken() {
      var length, match, matchedHere, script;
      if (!(this.chunk.charAt(0) === '`' && (match = (matchedHere = HERE_JSTOKEN.exec(this.chunk)) || JSTOKEN.exec(this.chunk)))) {
        return 0;
      }
      // Convert escaped backticks to backticks, and escaped backslashes
      // just before escaped backticks to backslashes
      script = match[1];
      ({length} = match[0]);
      this.token('JS', script, {
        length,
        data: {
          here: !!matchedHere
        }
      });
      return length;
    }

    // Matches regular expression literals, as well as multiline extended ones.
    // Lexing regular expressions is difficult to distinguish from division, so we
    // borrow some basic heuristics from JavaScript and Ruby.
    regexToken() {
      var body, closed, comment, commentIndex, commentOpts, commentTokens, comments, delimiter, end, flags, fullMatch, index, leadingWhitespace, match, matchedComment, origin, prev, ref, ref1, regex, tokens;
      switch (false) {
        case !(match = REGEX_ILLEGAL.exec(this.chunk)):
          this.error(`regular expressions cannot begin with ${match[2]}`, {
            offset: match.index + match[1].length
          });
          break;
        case !(match = this.matchWithInterpolations(HEREGEX, '///')):
          ({tokens, index} = match);
          comments = [];
          while (matchedComment = HEREGEX_COMMENT.exec(this.chunk.slice(0, index))) {
            ({
              index: commentIndex
            } = matchedComment);
            [fullMatch, leadingWhitespace, comment] = matchedComment;
            comments.push({
              comment,
              offsetInChunk: commentIndex + leadingWhitespace.length
            });
          }
          commentTokens = flatten((function() {
            var j, len, results;
            results = [];
            for (j = 0, len = comments.length; j < len; j++) {
              commentOpts = comments[j];
              results.push(this.commentToken(commentOpts.comment, Object.assign(commentOpts, {
                heregex: true,
                returnCommentTokens: true
              })));
            }
            return results;
          }).call(this));
          break;
        case !(match = REGEX.exec(this.chunk)):
          [regex, body, closed] = match;
          this.validateEscapes(body, {
            isRegex: true,
            offsetInChunk: 1
          });
          index = regex.length;
          prev = this.prev();
          if (prev) {
            if (prev.spaced && (ref = prev[0], indexOf.call(CALLABLE, ref) >= 0)) {
              if (!closed || POSSIBLY_DIVISION.test(regex)) {
                return 0;
              }
            } else if (ref1 = prev[0], indexOf.call(NOT_REGEX, ref1) >= 0) {
              return 0;
            }
          }
          if (!closed) {
            this.error('missing / (unclosed regex)');
          }
          break;
        default:
          return 0;
      }
      [flags] = REGEX_FLAGS.exec(this.chunk.slice(index));
      end = index + flags.length;
      origin = this.makeToken('REGEX', null, {
        length: end
      });
      switch (false) {
        case !!VALID_FLAGS.test(flags):
          this.error(`invalid regular expression flags ${flags}`, {
            offset: index,
            length: flags.length
          });
          break;
        case !(regex || tokens.length === 1):
          delimiter = body ? '/' : '///';
          if (body == null) {
            body = tokens[0][1];
          }
          this.validateUnicodeCodePointEscapes(body, {delimiter});
          this.token('REGEX', `/${body}/${flags}`, {
            length: end,
            origin,
            data: {delimiter}
          });
          break;
        default:
          this.token('REGEX_START', '(', {
            length: 0,
            origin,
            generated: true
          });
          this.token('IDENTIFIER', 'RegExp', {
            length: 0,
            generated: true
          });
          this.token('CALL_START', '(', {
            length: 0,
            generated: true
          });
          this.mergeInterpolationTokens(tokens, {
            double: true,
            heregex: {flags},
            endOffset: end - flags.length,
            quote: '///'
          }, (str) => {
            return this.validateUnicodeCodePointEscapes(str, {delimiter});
          });
          if (flags) {
            this.token(',', ',', {
              offset: index - 1,
              length: 0,
              generated: true
            });
            this.token('STRING', '"' + flags + '"', {
              offset: index,
              length: flags.length
            });
          }
          this.token(')', ')', {
            offset: end,
            length: 0,
            generated: true
          });
          this.token('REGEX_END', ')', {
            offset: end,
            length: 0,
            generated: true
          });
      }
      // Explicitly attach any heregex comments to the REGEX/REGEX_END token.
      if (commentTokens != null ? commentTokens.length : void 0) {
        addTokenData(this.tokens[this.tokens.length - 1], {
          heregexCommentTokens: commentTokens
        });
      }
      return end;
    }

    // Matches newlines, indents, and outdents, and determines which is which.
    // If we can detect that the current line is continued onto the next line,
    // then the newline is suppressed:

    //     elements
    //       .each( ... )
    //       .map( ... )

    // Keeps track of the level of indentation, because a single outdent token
    // can close multiple indents, so we need to know how far in we happen to be.
    lineToken({chunk = this.chunk, offset = 0} = {}) {
      var backslash, diff, endsContinuationLineIndentation, indent, match, minLiteralLength, newIndentLiteral, noNewlines, prev, ref, size;
      if (!(match = MULTI_DENT.exec(chunk))) {
        return 0;
      }
      indent = match[0];
      prev = this.prev();
      backslash = (prev != null ? prev[0] : void 0) === '\\';
      if (!((backslash || ((ref = this.seenFor) != null ? ref.endsLength : void 0) < this.ends.length) && this.seenFor)) {
        this.seenFor = false;
      }
      if (!((backslash && this.seenImport) || this.importSpecifierList)) {
        this.seenImport = false;
      }
      if (!((backslash && this.seenExport) || this.exportSpecifierList)) {
        this.seenExport = false;
      }
      size = indent.length - 1 - indent.lastIndexOf('\n');
      noNewlines = this.unfinished();
      newIndentLiteral = size > 0 ? indent.slice(-size) : '';
      if (!/^(.?)\1*$/.exec(newIndentLiteral)) {
        this.error('mixed indentation', {
          offset: indent.length
        });
        return indent.length;
      }
      minLiteralLength = Math.min(newIndentLiteral.length, this.indentLiteral.length);
      if (newIndentLiteral.slice(0, minLiteralLength) !== this.indentLiteral.slice(0, minLiteralLength)) {
        this.error('indentation mismatch', {
          offset: indent.length
        });
        return indent.length;
      }
      if (size - this.continuationLineAdditionalIndent === this.indent) {
        if (noNewlines) {
          this.suppressNewlines();
        } else {
          this.newlineToken(offset);
        }
        return indent.length;
      }
      if (size > this.indent) {
        if (noNewlines) {
          if (!backslash) {
            this.continuationLineAdditionalIndent = size - this.indent;
          }
          if (this.continuationLineAdditionalIndent) {
            prev.continuationLineIndent = this.indent + this.continuationLineAdditionalIndent;
          }
          this.suppressNewlines();
          return indent.length;
        }
        if (!this.tokens.length) {
          this.baseIndent = this.indent = size;
          this.indentLiteral = newIndentLiteral;
          return indent.length;
        }
        diff = size - this.indent + this.outdebt;
        this.token('INDENT', diff, {
          offset: offset + indent.length - size,
          length: size
        });
        this.indents.push(diff);
        this.ends.push({
          tag: 'OUTDENT'
        });
        this.outdebt = this.continuationLineAdditionalIndent = 0;
        this.indent = size;
        this.indentLiteral = newIndentLiteral;
      } else if (size < this.baseIndent) {
        this.error('missing indentation', {
          offset: offset + indent.length
        });
      } else {
        endsContinuationLineIndentation = this.continuationLineAdditionalIndent > 0;
        this.continuationLineAdditionalIndent = 0;
        this.outdentToken({
          moveOut: this.indent - size,
          noNewlines,
          outdentLength: indent.length,
          offset,
          indentSize: size,
          endsContinuationLineIndentation
        });
      }
      return indent.length;
    }

    // Record an outdent token or multiple tokens, if we happen to be moving back
    // inwards past several recorded indents. Sets new @indent value.
    outdentToken({moveOut, noNewlines, outdentLength = 0, offset = 0, indentSize, endsContinuationLineIndentation}) {
      var decreasedIndent, dent, lastIndent, ref, terminatorToken;
      decreasedIndent = this.indent - moveOut;
      while (moveOut > 0) {
        lastIndent = this.indents[this.indents.length - 1];
        if (!lastIndent) {
          this.outdebt = moveOut = 0;
        } else if (this.outdebt && moveOut <= this.outdebt) {
          this.outdebt -= moveOut;
          moveOut = 0;
        } else {
          dent = this.indents.pop() + this.outdebt;
          if (outdentLength && (ref = this.chunk[outdentLength], indexOf.call(INDENTABLE_CLOSERS, ref) >= 0)) {
            decreasedIndent -= dent - moveOut;
            moveOut = dent;
          }
          this.outdebt = 0;
          // pair might call outdentToken, so preserve decreasedIndent
          this.pair('OUTDENT');
          this.token('OUTDENT', moveOut, {
            length: outdentLength,
            indentSize: indentSize + moveOut - dent
          });
          moveOut -= dent;
        }
      }
      if (dent) {
        this.outdebt -= moveOut;
      }
      this.suppressSemicolons();
      if (!(this.tag() === 'TERMINATOR' || noNewlines)) {
        terminatorToken = this.token('TERMINATOR', '\n', {
          offset: offset + outdentLength,
          length: 0
        });
        if (endsContinuationLineIndentation) {
          terminatorToken.endsContinuationLineIndentation = {
            preContinuationLineIndent: this.indent
          };
        }
      }
      this.indent = decreasedIndent;
      this.indentLiteral = this.indentLiteral.slice(0, decreasedIndent);
      return this;
    }

    // Matches and consumes non-meaningful whitespace. Tag the previous token
    // as being “spaced”, because there are some cases where it makes a difference.
    whitespaceToken() {
      var match, nline, prev;
      if (!((match = WHITESPACE.exec(this.chunk)) || (nline = this.chunk.charAt(0) === '\n'))) {
        return 0;
      }
      prev = this.prev();
      if (prev) {
        prev[match ? 'spaced' : 'newLine'] = true;
      }
      if (match) {
        return match[0].length;
      } else {
        return 0;
      }
    }

    // Generate a newline token. Consecutive newlines get merged together.
    newlineToken(offset) {
      this.suppressSemicolons();
      if (this.tag() !== 'TERMINATOR') {
        this.token('TERMINATOR', '\n', {
          offset,
          length: 0
        });
      }
      return this;
    }

    // Use a `\` at a line-ending to suppress the newline.
    // The slash is removed here once its job is done.
    suppressNewlines() {
      var prev;
      prev = this.prev();
      if (prev[1] === '\\') {
        if (prev.comments && this.tokens.length > 1) {
          // `@tokens.length` should be at least 2 (some code, then `\`).
          // If something puts a `\` after nothing, they deserve to lose any
          // comments that trail it.
          attachCommentsToNode(prev.comments, this.tokens[this.tokens.length - 2]);
        }
        this.tokens.pop();
      }
      return this;
    }

    jsxToken() {
      var afterTag, end, endToken, firstChar, fullId, fullTagName, id, input, j, jsxTag, len, match, offset, openingTagToken, prev, prevChar, properties, property, ref, tagToken, token, tokens;
      firstChar = this.chunk[0];
      // Check the previous token to detect if attribute is spread.
      prevChar = this.tokens.length > 0 ? this.tokens[this.tokens.length - 1][0] : '';
      if (firstChar === '<') {
        match = JSX_IDENTIFIER.exec(this.chunk.slice(1)) || JSX_FRAGMENT_IDENTIFIER.exec(this.chunk.slice(1));
        // Not the right hand side of an unspaced comparison (i.e. `a<b`).
        if (!(match && (this.jsxDepth > 0 || !(prev = this.prev()) || prev.spaced || (ref = prev[0], indexOf.call(COMPARABLE_LEFT_SIDE, ref) < 0)))) {
          return 0;
        }
        [input, id] = match;
        fullId = id;
        if (indexOf.call(id, '.') >= 0) {
          [id, ...properties] = id.split('.');
        } else {
          properties = [];
        }
        tagToken = this.token('JSX_TAG', id, {
          length: id.length + 1,
          data: {
            openingBracketToken: this.makeToken('<', '<'),
            tagNameToken: this.makeToken('IDENTIFIER', id, {
              offset: 1
            })
          }
        });
        offset = id.length + 1;
        for (j = 0, len = properties.length; j < len; j++) {
          property = properties[j];
          this.token('.', '.', {offset});
          offset += 1;
          this.token('PROPERTY', property, {offset});
          offset += property.length;
        }
        this.token('CALL_START', '(', {
          generated: true
        });
        this.token('[', '[', {
          generated: true
        });
        this.ends.push({
          tag: '/>',
          origin: tagToken,
          name: id,
          properties
        });
        this.jsxDepth++;
        return fullId.length + 1;
      } else if (jsxTag = this.atJSXTag()) {
        if (this.chunk.slice(0, 2) === '/>') { // Self-closing tag.
          this.pair('/>');
          this.token(']', ']', {
            length: 2,
            generated: true
          });
          this.token('CALL_END', ')', {
            length: 2,
            generated: true,
            data: {
              selfClosingSlashToken: this.makeToken('/', '/'),
              closingBracketToken: this.makeToken('>', '>', {
                offset: 1
              })
            }
          });
          this.jsxDepth--;
          return 2;
        } else if (firstChar === '{') {
          if (prevChar === ':') {
            // This token represents the start of a JSX attribute value
            // that’s an expression (e.g. the `{b}` in `<div a={b} />`).
            // Our grammar represents the beginnings of expressions as `(`
            // tokens, so make this into a `(` token that displays as `{`.
            token = this.token('(', '{');
            this.jsxObjAttribute[this.jsxDepth] = false;
            // tag attribute name as JSX
            addTokenData(this.tokens[this.tokens.length - 3], {
              jsx: true
            });
          } else {
            token = this.token('{', '{');
            this.jsxObjAttribute[this.jsxDepth] = true;
          }
          this.ends.push({
            tag: '}',
            origin: token
          });
          return 1;
        } else if (firstChar === '>') { // end of opening tag
          ({
            // Ignore terminators inside a tag.
            origin: openingTagToken
          } = this.pair('/>')); // As if the current tag was self-closing.
          this.token(']', ']', {
            generated: true,
            data: {
              closingBracketToken: this.makeToken('>', '>')
            }
          });
          this.token(',', 'JSX_COMMA', {
            generated: true
          });
          ({
            tokens,
            index: end
          } = this.matchWithInterpolations(INSIDE_JSX, '>', '</', JSX_INTERPOLATION));
          this.mergeInterpolationTokens(tokens, {
            endOffset: end,
            jsx: true
          }, (value) => {
            return this.validateUnicodeCodePointEscapes(value, {
              delimiter: '>'
            });
          });
          match = JSX_IDENTIFIER.exec(this.chunk.slice(end)) || JSX_FRAGMENT_IDENTIFIER.exec(this.chunk.slice(end));
          if (!match || match[1] !== `${jsxTag.name}${((function() {
            var k, len1, ref1, results;
            ref1 = jsxTag.properties;
            results = [];
            for (k = 0, len1 = ref1.length; k < len1; k++) {
              property = ref1[k];
              results.push(`.${property}`);
            }
            return results;
          })()).join('')}`) {
            this.error(`expected corresponding JSX closing tag for ${jsxTag.name}`, jsxTag.origin.data.tagNameToken[2]);
          }
          [, fullTagName] = match;
          afterTag = end + fullTagName.length;
          if (this.chunk[afterTag] !== '>') {
            this.error("missing closing > after tag name", {
              offset: afterTag,
              length: 1
            });
          }
          // -2/+2 for the opening `</` and +1 for the closing `>`.
          endToken = this.token('CALL_END', ')', {
            offset: end - 2,
            length: fullTagName.length + 3,
            generated: true,
            data: {
              closingTagOpeningBracketToken: this.makeToken('<', '<', {
                offset: end - 2
              }),
              closingTagSlashToken: this.makeToken('/', '/', {
                offset: end - 1
              }),
              // TODO: individual tokens for complex tag name? eg < / A . B >
              closingTagNameToken: this.makeToken('IDENTIFIER', fullTagName, {
                offset: end
              }),
              closingTagClosingBracketToken: this.makeToken('>', '>', {
                offset: end + fullTagName.length
              })
            }
          });
          // make the closing tag location data more easily accessible to the grammar
          addTokenData(openingTagToken, endToken.data);
          this.jsxDepth--;
          return afterTag + 1;
        } else {
          return 0;
        }
      } else if (this.atJSXTag(1)) {
        if (firstChar === '}') {
          this.pair(firstChar);
          if (this.jsxObjAttribute[this.jsxDepth]) {
            this.token('}', '}');
            this.jsxObjAttribute[this.jsxDepth] = false;
          } else {
            this.token(')', '}');
          }
          this.token(',', ',', {
            generated: true
          });
          return 1;
        } else {
          return 0;
        }
      } else {
        return 0;
      }
    }

    atJSXTag(depth = 0) {
      var i, last, ref;
      if (this.jsxDepth === 0) {
        return false;
      }
      i = this.ends.length - 1;
      while (((ref = this.ends[i]) != null ? ref.tag : void 0) === 'OUTDENT' || depth-- > 0) { // Ignore indents.
        i--;
      }
      last = this.ends[i];
      return (last != null ? last.tag : void 0) === '/>' && last;
    }

    // We treat all other single characters as a token. E.g.: `( ) , . !`
    // Multi-character operators are also literal tokens, so that Jison can assign
    // the proper order of operations. There are some symbols that we tag specially
    // here. `;` and newlines are both treated as a `TERMINATOR`, we distinguish
    // parentheses that indicate a method call from regular parentheses, and so on.
    literalToken() {
      var match, message, origin, prev, ref, ref1, ref2, ref3, ref4, ref5, skipToken, tag, token, value;
      if (match = OPERATOR.exec(this.chunk)) {
        [value] = match;
        if (CODE.test(value)) {
          this.tagParameters();
        }
      } else {
        value = this.chunk.charAt(0);
      }
      tag = value;
      prev = this.prev();
      if (prev && indexOf.call(['=', ...COMPOUND_ASSIGN], value) >= 0) {
        skipToken = false;
        if (value === '=' && ((ref = prev[1]) === '||' || ref === '&&') && !prev.spaced) {
          prev[0] = 'COMPOUND_ASSIGN';
          prev[1] += '=';
          if ((ref1 = prev.data) != null ? ref1.original : void 0) {
            prev.data.original += '=';
          }
          prev[2].range = [prev[2].range[0], prev[2].range[1] + 1];
          prev[2].last_column += 1;
          prev[2].last_column_exclusive += 1;
          prev = this.tokens[this.tokens.length - 2];
          skipToken = true;
        }
        if (prev && prev[0] !== 'PROPERTY') {
          origin = (ref2 = prev.origin) != null ? ref2 : prev;
          message = isUnassignable(prev[1], origin[1]);
          if (message) {
            this.error(message, origin[2]);
          }
        }
        if (skipToken) {
          return value.length;
        }
      }
      if (value === '(' && (prev != null ? prev[0] : void 0) === 'IMPORT') {
        prev[0] = 'DYNAMIC_IMPORT';
      }
      if (value === '{' && this.seenImport) {
        this.importSpecifierList = true;
      } else if (this.importSpecifierList && value === '}') {
        this.importSpecifierList = false;
      } else if (value === '{' && (prev != null ? prev[0] : void 0) === 'EXPORT') {
        this.exportSpecifierList = true;
      } else if (this.exportSpecifierList && value === '}') {
        this.exportSpecifierList = false;
      }
      if (value === ';') {
        if (ref3 = prev != null ? prev[0] : void 0, indexOf.call(['=', ...UNFINISHED], ref3) >= 0) {
          this.error('unexpected ;');
        }
        this.seenFor = this.seenImport = this.seenExport = false;
        tag = 'TERMINATOR';
      } else if (value === '*' && (prev != null ? prev[0] : void 0) === 'EXPORT') {
        tag = 'EXPORT_ALL';
      } else if (indexOf.call(MATH, value) >= 0) {
        tag = 'MATH';
      } else if (indexOf.call(COMPARE, value) >= 0) {
        tag = 'COMPARE';
      } else if (indexOf.call(COMPOUND_ASSIGN, value) >= 0) {
        tag = 'COMPOUND_ASSIGN';
      } else if (indexOf.call(UNARY, value) >= 0) {
        tag = 'UNARY';
      } else if (indexOf.call(UNARY_MATH, value) >= 0) {
        tag = 'UNARY_MATH';
      } else if (indexOf.call(SHIFT, value) >= 0) {
        tag = 'SHIFT';
      } else if (value === '?' && (prev != null ? prev.spaced : void 0)) {
        tag = 'BIN?';
      } else if (prev) {
        if (value === '(' && !prev.spaced && (ref4 = prev[0], indexOf.call(CALLABLE, ref4) >= 0)) {
          if (prev[0] === '?') {
            prev[0] = 'FUNC_EXIST';
          }
          tag = 'CALL_START';
        } else if (value === '[' && (((ref5 = prev[0], indexOf.call(INDEXABLE, ref5) >= 0) && !prev.spaced) || (prev[0] === '::'))) { // `.prototype` can’t be a method you can call.
          tag = 'INDEX_START';
          switch (prev[0]) {
            case '?':
              prev[0] = 'INDEX_SOAK';
          }
        }
      }
      token = this.makeToken(tag, value);
      switch (value) {
        case '(':
        case '{':
        case '[':
          this.ends.push({
            tag: INVERSES[value],
            origin: token
          });
          break;
        case ')':
        case '}':
        case ']':
          this.pair(value);
      }
      this.tokens.push(this.makeToken(tag, value));
      return value.length;
    }

    // Token Manipulators
    // ------------------

      // A source of ambiguity in our grammar used to be parameter lists in function
    // definitions versus argument lists in function calls. Walk backwards, tagging
    // parameters specially in order to make things easier for the parser.
    tagParameters() {
      var i, paramEndToken, stack, tok, tokens;
      if (this.tag() !== ')') {
        return this.tagDoIife();
      }
      stack = [];
      ({tokens} = this);
      i = tokens.length;
      paramEndToken = tokens[--i];
      paramEndToken[0] = 'PARAM_END';
      while (tok = tokens[--i]) {
        switch (tok[0]) {
          case ')':
            stack.push(tok);
            break;
          case '(':
          case 'CALL_START':
            if (stack.length) {
              stack.pop();
            } else if (tok[0] === '(') {
              tok[0] = 'PARAM_START';
              return this.tagDoIife(i - 1);
            } else {
              paramEndToken[0] = 'CALL_END';
              return this;
            }
        }
      }
      return this;
    }

    // Tag `do` followed by a function differently than `do` followed by eg an
    // identifier to allow for different grammar precedence
    tagDoIife(tokenIndex) {
      var tok;
      tok = this.tokens[tokenIndex != null ? tokenIndex : this.tokens.length - 1];
      if ((tok != null ? tok[0] : void 0) !== 'DO') {
        return this;
      }
      tok[0] = 'DO_IIFE';
      return this;
    }

    // Close up all remaining open blocks at the end of the file.
    closeIndentation() {
      return this.outdentToken({
        moveOut: this.indent,
        indentSize: 0
      });
    }

    // Match the contents of a delimited token and expand variables and expressions
    // inside it using Ruby-like notation for substitution of arbitrary
    // expressions.

    //     "Hello #{name.capitalize()}."

    // If it encounters an interpolation, this method will recursively create a new
    // Lexer and tokenize until the `{` of `#{` is balanced with a `}`.

    //  - `regex` matches the contents of a token (but not `delimiter`, and not
    //    `#{` if interpolations are desired).
    //  - `delimiter` is the delimiter of the token. Examples are `'`, `"`, `'''`,
    //    `"""` and `///`.
    //  - `closingDelimiter` is different from `delimiter` only in JSX
    //  - `interpolators` matches the start of an interpolation, for JSX it's both
    //    `{` and `<` (i.e. nested JSX tag)

    // This method allows us to have strings within interpolations within strings,
    // ad infinitum.
    matchWithInterpolations(regex, delimiter, closingDelimiter = delimiter, interpolators = /^#\{/) {
      var braceInterpolator, close, column, index, interpolationOffset, interpolator, line, match, nested, offset, offsetInChunk, open, ref, ref1, rest, str, strPart, tokens;
      tokens = [];
      offsetInChunk = delimiter.length;
      if (this.chunk.slice(0, offsetInChunk) !== delimiter) {
        return null;
      }
      str = this.chunk.slice(offsetInChunk);
      while (true) {
        [strPart] = regex.exec(str);
        this.validateEscapes(strPart, {
          isRegex: delimiter.charAt(0) === '/',
          offsetInChunk
        });
        // Push a fake `'NEOSTRING'` token, which will get turned into a real string later.
        tokens.push(this.makeToken('NEOSTRING', strPart, {
          offset: offsetInChunk
        }));
        str = str.slice(strPart.length);
        offsetInChunk += strPart.length;
        if (!(match = interpolators.exec(str))) {
          break;
        }
        [interpolator] = match;
        // To remove the `#` in `#{`.
        interpolationOffset = interpolator.length - 1;
        [line, column, offset] = this.getLineAndColumnFromChunk(offsetInChunk + interpolationOffset);
        rest = str.slice(interpolationOffset);
        ({
          tokens: nested,
          index
        } = new Lexer().tokenize(rest, {
          line,
          column,
          offset,
          untilBalanced: true,
          locationDataCompensations: this.locationDataCompensations
        }));
        // Account for the `#` in `#{`.
        index += interpolationOffset;
        braceInterpolator = str[index - 1] === '}';
        if (braceInterpolator) {
          // Turn the leading and trailing `{` and `}` into parentheses. Unnecessary
          // parentheses will be removed later.
          [open] = nested, [close] = slice.call(nested, -1);
          open[0] = 'INTERPOLATION_START';
          open[1] = '(';
          open[2].first_column -= interpolationOffset;
          open[2].range = [open[2].range[0] - interpolationOffset, open[2].range[1]];
          close[0] = 'INTERPOLATION_END';
          close[1] = ')';
          close.origin = ['', 'end of interpolation', close[2]];
        }
        if (((ref = nested[1]) != null ? ref[0] : void 0) === 'TERMINATOR') {
          // Remove leading `'TERMINATOR'` (if any).
          nested.splice(1, 1);
        }
        if (((ref1 = nested[nested.length - 3]) != null ? ref1[0] : void 0) === 'INDENT' && nested[nested.length - 2][0] === 'OUTDENT') {
          // Remove trailing `'INDENT'/'OUTDENT'` pair (if any).
          nested.splice(-3, 2);
        }
        if (!braceInterpolator) {
          // We are not using `{` and `}`, so wrap the interpolated tokens instead.
          open = this.makeToken('INTERPOLATION_START', '(', {
            offset: offsetInChunk,
            length: 0,
            generated: true
          });
          close = this.makeToken('INTERPOLATION_END', ')', {
            offset: offsetInChunk + index,
            length: 0,
            generated: true
          });
          nested = [open, ...nested, close];
        }
        // Push a fake `'TOKENS'` token, which will get turned into real tokens later.
        tokens.push(['TOKENS', nested]);
        str = str.slice(index);
        offsetInChunk += index;
      }
      if (str.slice(0, closingDelimiter.length) !== closingDelimiter) {
        this.error(`missing ${closingDelimiter}`, {
          length: delimiter.length
        });
      }
      return {
        tokens,
        index: offsetInChunk + closingDelimiter.length
      };
    }

    // Merge the array `tokens` of the fake token types `'TOKENS'` and `'NEOSTRING'`
    // (as returned by `matchWithInterpolations`) into the token stream. The value
    // of `'NEOSTRING'`s are converted using `fn` and turned into strings using
    // `options` first.
    mergeInterpolationTokens(tokens, options, fn) {
      var $, converted, double, endOffset, firstIndex, heregex, i, indent, j, jsx, k, lastToken, len, len1, locationToken, lparen, placeholderToken, quote, ref, ref1, rparen, tag, token, tokensToPush, val, value;
      ({quote, indent, double, heregex, endOffset, jsx} = options);
      if (tokens.length > 1) {
        lparen = this.token('STRING_START', '(', {
          length: (ref = quote != null ? quote.length : void 0) != null ? ref : 0,
          data: {quote},
          generated: !(quote != null ? quote.length : void 0)
        });
      }
      firstIndex = this.tokens.length;
      $ = tokens.length - 1;
      for (i = j = 0, len = tokens.length; j < len; i = ++j) {
        token = tokens[i];
        [tag, value] = token;
        switch (tag) {
          case 'TOKENS':
            // There are comments (and nothing else) in this interpolation.
            if (value.length === 2 && (value[0].comments || value[1].comments)) {
              placeholderToken = this.makeToken('JS', '', {
                generated: true
              });
              // Use the same location data as the first parenthesis.
              placeholderToken[2] = value[0][2];
              for (k = 0, len1 = value.length; k < len1; k++) {
                val = value[k];
                if (!val.comments) {
                  continue;
                }
                if (placeholderToken.comments == null) {
                  placeholderToken.comments = [];
                }
                placeholderToken.comments.push(...val.comments);
              }
              value.splice(1, 0, placeholderToken);
            }
            // Push all the tokens in the fake `'TOKENS'` token. These already have
            // sane location data.
            locationToken = value[0];
            tokensToPush = value;
            break;
          case 'NEOSTRING':
            // Convert `'NEOSTRING'` into `'STRING'`.
            converted = fn.call(this, token[1], i);
            if (i === 0) {
              addTokenData(token, {
                initialChunk: true
              });
            }
            if (i === $) {
              addTokenData(token, {
                finalChunk: true
              });
            }
            addTokenData(token, {indent, quote, double});
            if (heregex) {
              addTokenData(token, {heregex});
            }
            if (jsx) {
              addTokenData(token, {jsx});
            }
            token[0] = 'STRING';
            token[1] = '"' + converted + '"';
            if (tokens.length === 1 && (quote != null)) {
              token[2].first_column -= quote.length;
              if (token[1].substr(-2, 1) === '\n') {
                token[2].last_line += 1;
                token[2].last_column = quote.length - 1;
              } else {
                token[2].last_column += quote.length;
                if (token[1].length === 2) {
                  token[2].last_column -= 1;
                }
              }
              token[2].last_column_exclusive += quote.length;
              token[2].range = [token[2].range[0] - quote.length, token[2].range[1] + quote.length];
            }
            locationToken = token;
            tokensToPush = [token];
        }
        this.tokens.push(...tokensToPush);
      }
      if (lparen) {
        [lastToken] = slice.call(tokens, -1);
        lparen.origin = [
          'STRING',
          null,
          {
            first_line: lparen[2].first_line,
            first_column: lparen[2].first_column,
            last_line: lastToken[2].last_line,
            last_column: lastToken[2].last_column,
            last_line_exclusive: lastToken[2].last_line_exclusive,
            last_column_exclusive: lastToken[2].last_column_exclusive,
            range: [lparen[2].range[0],
          lastToken[2].range[1]]
          }
        ];
        if (!(quote != null ? quote.length : void 0)) {
          lparen[2] = lparen.origin[2];
        }
        return rparen = this.token('STRING_END', ')', {
          offset: endOffset - (quote != null ? quote : '').length,
          length: (ref1 = quote != null ? quote.length : void 0) != null ? ref1 : 0,
          generated: !(quote != null ? quote.length : void 0)
        });
      }
    }

    // Pairs up a closing token, ensuring that all listed pairs of tokens are
    // correctly balanced throughout the course of the token stream.
    pair(tag) {
      var lastIndent, prev, ref, ref1, wanted;
      ref = this.ends, [prev] = slice.call(ref, -1);
      if (tag !== (wanted = prev != null ? prev.tag : void 0)) {
        if ('OUTDENT' !== wanted) {
          this.error(`unmatched ${tag}`);
        }
        // Auto-close `INDENT` to support syntax like this:

        //     el.click((event) ->
        //       el.hide())

        ref1 = this.indents, [lastIndent] = slice.call(ref1, -1);
        this.outdentToken({
          moveOut: lastIndent,
          noNewlines: true
        });
        return this.pair(tag);
      }
      return this.ends.pop();
    }

    // Helpers
    // -------

      // Compensate for the things we strip out initially (e.g. carriage returns)
    // so that location data stays accurate with respect to the original source file.
    getLocationDataCompensation(start, end) {
      var compensation, current, initialEnd, totalCompensation;
      totalCompensation = 0;
      initialEnd = end;
      current = start;
      while (current <= end) {
        if (current === end && start !== initialEnd) {
          break;
        }
        compensation = this.locationDataCompensations[current];
        if (compensation != null) {
          totalCompensation += compensation;
          end += compensation;
        }
        current++;
      }
      return totalCompensation;
    }

    // Returns the line and column number from an offset into the current chunk.

    // `offset` is a number of characters into `@chunk`.
    getLineAndColumnFromChunk(offset) {
      var column, columnCompensation, compensation, lastLine, lineCount, previousLinesCompensation, ref, string;
      compensation = this.getLocationDataCompensation(this.chunkOffset, this.chunkOffset + offset);
      if (offset === 0) {
        return [this.chunkLine, this.chunkColumn + compensation, this.chunkOffset + compensation];
      }
      if (offset >= this.chunk.length) {
        string = this.chunk;
      } else {
        string = this.chunk.slice(0, +(offset - 1) + 1 || 9e9);
      }
      lineCount = count(string, '\n');
      column = this.chunkColumn;
      if (lineCount > 0) {
        ref = string.split('\n'), [lastLine] = slice.call(ref, -1);
        column = lastLine.length;
        previousLinesCompensation = this.getLocationDataCompensation(this.chunkOffset, this.chunkOffset + offset - column);
        if (previousLinesCompensation < 0) {
          // Don't recompensate for initially inserted newline.
          previousLinesCompensation = 0;
        }
        columnCompensation = this.getLocationDataCompensation(this.chunkOffset + offset + previousLinesCompensation - column, this.chunkOffset + offset + previousLinesCompensation);
      } else {
        column += string.length;
        columnCompensation = compensation;
      }
      return [this.chunkLine + lineCount, column + columnCompensation, this.chunkOffset + offset + compensation];
    }

    makeLocationData({offsetInChunk, length}) {
      var endOffset, lastCharacter, locationData;
      locationData = {
        range: []
      };
      [locationData.first_line, locationData.first_column, locationData.range[0]] = this.getLineAndColumnFromChunk(offsetInChunk);
      // Use length - 1 for the final offset - we’re supplying the last_line and the last_column,
      // so if last_column == first_column, then we’re looking at a character of length 1.
      lastCharacter = length > 0 ? length - 1 : 0;
      [locationData.last_line, locationData.last_column, endOffset] = this.getLineAndColumnFromChunk(offsetInChunk + lastCharacter);
      [locationData.last_line_exclusive, locationData.last_column_exclusive] = this.getLineAndColumnFromChunk(offsetInChunk + lastCharacter + (length > 0 ? 1 : 0));
      locationData.range[1] = length > 0 ? endOffset + 1 : endOffset;
      return locationData;
    }

    // Same as `token`, except this just returns the token without adding it
    // to the results.
    makeToken(tag, value, {
        offset: offsetInChunk = 0,
        length = value.length,
        origin,
        generated,
        indentSize
      } = {}) {
      var token;
      token = [tag, value, this.makeLocationData({offsetInChunk, length})];
      if (origin) {
        token.origin = origin;
      }
      if (generated) {
        token.generated = true;
      }
      if (indentSize != null) {
        token.indentSize = indentSize;
      }
      return token;
    }

    // Add a token to the results.
    // `offset` is the offset into the current `@chunk` where the token starts.
    // `length` is the length of the token in the `@chunk`, after the offset.  If
    // not specified, the length of `value` will be used.

    // Returns the new token.
    token(tag, value, {offset, length, origin, data, generated, indentSize} = {}) {
      var token;
      token = this.makeToken(tag, value, {offset, length, origin, generated, indentSize});
      if (data) {
        addTokenData(token, data);
      }
      this.tokens.push(token);
      return token;
    }

    // Peek at the last tag in the token stream.
    tag() {
      var ref, token;
      ref = this.tokens, [token] = slice.call(ref, -1);
      return token != null ? token[0] : void 0;
    }

    // Peek at the last value in the token stream.
    value(useOrigin = false) {
      var ref, token;
      ref = this.tokens, [token] = slice.call(ref, -1);
      if (useOrigin && ((token != null ? token.origin : void 0) != null)) {
        return token.origin[1];
      } else {
        return token != null ? token[1] : void 0;
      }
    }

    // Get the previous token in the token stream.
    prev() {
      return this.tokens[this.tokens.length - 1];
    }

    // Are we in the midst of an unfinished expression?
    unfinished() {
      var ref;
      return LINE_CONTINUER.test(this.chunk) || (ref = this.tag(), indexOf.call(UNFINISHED, ref) >= 0);
    }

    validateUnicodeCodePointEscapes(str, options) {
      return replaceUnicodeCodePointEscapes(str, merge(options, {error: this.error}));
    }

    // Validates escapes in strings and regexes.
    validateEscapes(str, options = {}) {
      var before, hex, invalidEscape, invalidEscapeRegex, match, message, octal, ref, unicode, unicodeCodePoint;
      invalidEscapeRegex = options.isRegex ? REGEX_INVALID_ESCAPE : STRING_INVALID_ESCAPE;
      match = invalidEscapeRegex.exec(str);
      if (!match) {
        return;
      }
      match[0], before = match[1], octal = match[2], hex = match[3], unicodeCodePoint = match[4], unicode = match[5];
      message = octal ? "octal escape sequences are not allowed" : "invalid escape sequence";
      invalidEscape = `\\${octal || hex || unicodeCodePoint || unicode}`;
      return this.error(`${message} ${invalidEscape}`, {
        offset: ((ref = options.offsetInChunk) != null ? ref : 0) + match.index + before.length,
        length: invalidEscape.length
      });
    }

    suppressSemicolons() {
      var ref, ref1, results;
      results = [];
      while (this.value() === ';') {
        this.tokens.pop();
        if (ref = (ref1 = this.prev()) != null ? ref1[0] : void 0, indexOf.call(['=', ...UNFINISHED], ref) >= 0) {
          results.push(this.error('unexpected ;'));
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    error(message, options = {}) {
      var first_column, first_line, location, ref, ref1;
      location = 'first_line' in options ? options : ([first_line, first_column] = this.getLineAndColumnFromChunk((ref = options.offset) != null ? ref : 0), {
        first_line,
        first_column,
        last_column: first_column + ((ref1 = options.length) != null ? ref1 : 1) - 1
      });
      return throwSyntaxError(message, location);
    }

  };

  // Helper functions
  // ----------------
  isUnassignable = function(name, displayName = name) {
    switch (false) {
      case indexOf.call([...JS_KEYWORDS, ...COFFEE_KEYWORDS], name) < 0:
        return `keyword '${displayName}' can't be assigned`;
      case indexOf.call(STRICT_PROSCRIBED, name) < 0:
        return `'${displayName}' can't be assigned`;
      case indexOf.call(RESERVED, name) < 0:
        return `reserved word '${displayName}' can't be assigned`;
      default:
        return false;
    }
  };

  exports.isUnassignable = isUnassignable;

  // `from` isn’t a CoffeeScript keyword, but it behaves like one in `import` and
  // `export` statements (handled above) and in the declaration line of a `for`
  // loop. Try to detect when `from` is a variable identifier and when it is this
  // “sometimes” keyword.
  isForFrom = function(prev) {
    var ref;
    // `for i from iterable`
    if (prev[0] === 'IDENTIFIER') {
      return true;
    // `for from…`
    } else if (prev[0] === 'FOR') {
      return false;
    // `for {from}…`, `for [from]…`, `for {a, from}…`, `for {a: from}…`
    } else if ((ref = prev[1]) === '{' || ref === '[' || ref === ',' || ref === ':') {
      return false;
    } else {
      return true;
    }
  };

  addTokenData = function(token, data) {
    return Object.assign((token.data != null ? token.data : token.data = {}), data);
  };

  // Constants
  // ---------

  // Keywords that CoffeeScript shares in common with JavaScript.
  JS_KEYWORDS = ['true', 'false', 'null', 'this', 'new', 'delete', 'typeof', 'in', 'instanceof', 'return', 'throw', 'break', 'continue', 'debugger', 'yield', 'await', 'if', 'else', 'switch', 'for', 'while', 'do', 'try', 'catch', 'finally', 'class', 'extends', 'super', 'import', 'export', 'default'];

  // CoffeeScript-only keywords.
  COFFEE_KEYWORDS = ['undefined', 'Infinity', 'NaN', 'then', 'unless', 'until', 'loop', 'of', 'by', 'when'];

  COFFEE_ALIAS_MAP = {
    and: '&&',
    or: '||',
    is: '==',
    isnt: '!=',
    not: '!',
    yes: 'true',
    no: 'false',
    on: 'true',
    off: 'false'
  };

  COFFEE_ALIASES = (function() {
    var results;
    results = [];
    for (key in COFFEE_ALIAS_MAP) {
      results.push(key);
    }
    return results;
  })();

  COFFEE_KEYWORDS = COFFEE_KEYWORDS.concat(COFFEE_ALIASES);

  // The list of keywords that are reserved by JavaScript, but not used, or are
  // used by CoffeeScript internally. We throw an error when these are encountered,
  // to avoid having a JavaScript error at runtime.
  RESERVED = ['case', 'function', 'var', 'void', 'with', 'const', 'let', 'enum', 'native', 'implements', 'interface', 'package', 'private', 'protected', 'public', 'static'];

  STRICT_PROSCRIBED = ['arguments', 'eval'];

  // The superset of both JavaScript keywords and reserved words, none of which may
  // be used as identifiers or properties.
  exports.JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED).concat(STRICT_PROSCRIBED);

  // The character code of the nasty Microsoft madness otherwise known as the BOM.
  BOM = 65279;

  // Token matching regexes.
  IDENTIFIER = /^(?!\d)((?:(?!\s)[$\w\x7f-\uffff])+)([^\n\S]*:(?!:))?/; // Is this a property name?

  // Like `IDENTIFIER`, but includes `-`s
  JSX_IDENTIFIER_PART = /(?:(?!\s)[\-$\w\x7f-\uffff])+/.source;

  // In https://facebook.github.io/jsx/ spec, JSXElementName can be
  // JSXIdentifier, JSXNamespacedName (JSXIdentifier : JSXIdentifier), or
  // JSXMemberExpression (two or more JSXIdentifier connected by `.`s).
  JSX_IDENTIFIER = RegExp(`^(?![\\d<])(${JSX_IDENTIFIER_PART // Must not start with `<`.
  // JSXNamespacedName
  // JSXMemberExpression
}(?:\\s*:\\s*${JSX_IDENTIFIER_PART}|(?:\\s*\\.\\s*${JSX_IDENTIFIER_PART})+)?)`);

  // Fragment: <></>
  JSX_FRAGMENT_IDENTIFIER = /^()>/; // Ends immediately with `>`.

  // In https://facebook.github.io/jsx/ spec, JSXAttributeName can be either
  // JSXIdentifier or JSXNamespacedName which is JSXIdentifier : JSXIdentifier
  JSX_ATTRIBUTE = RegExp(`^(?!\\d)(${JSX_IDENTIFIER_PART // JSXNamespacedName
  // Is this an attribute with a value?
}(?:\\s*:\\s*${JSX_IDENTIFIER_PART})?)([^\\S]*=(?!=))?`);

  NUMBER = /^0b[01](?:_?[01])*n?|^0o[0-7](?:_?[0-7])*n?|^0x[\da-f](?:_?[\da-f])*n?|^\d+(?:_\d+)*n|^(?:\d+(?:_\d+)*)?\.?\d+(?:_\d+)*(?:e[+-]?\d+(?:_\d+)*)?/i; // binary
  // octal
  // hex
  // decimal bigint
  // decimal
  // decimal without support for numeric literal separators for reference:
  // \d*\.?\d+ (?:e[+-]?\d+)?

  OPERATOR = /^(?:[-=]>|[-+*\/%<>&|^!?=]=|>>>=?|([-+:])\1|([&|<>*\/%])\2=?|\?(\.|::)|\.{2,3})/; // function
  // compound assign / compare
  // zero-fill right shift
  // doubles
  // logic / shift / power / floor division / modulo
  // soak access
  // range or splat

  WHITESPACE = /^[^\n\S]+/;

  COMMENT = /^(\s*)###([^#][\s\S]*?)(?:###([^\n\S]*)|###$)|^((?:\s*#(?!##[^#]).*)+)/;

  CODE = /^[-=]>/;

  MULTI_DENT = /^(?:\n[^\n\S]*)+/;

  JSTOKEN = /^`(?!``)((?:[^`\\]|\\[\s\S])*)`/;

  HERE_JSTOKEN = /^```((?:[^`\\]|\\[\s\S]|`(?!``))*)```/;

  // String-matching-regexes.
  STRING_START = /^(?:'''|"""|'|")/;

  STRING_SINGLE = /^(?:[^\\']|\\[\s\S])*/;

  STRING_DOUBLE = /^(?:[^\\"#]|\\[\s\S]|\#(?!\{))*/;

  HEREDOC_SINGLE = /^(?:[^\\']|\\[\s\S]|'(?!''))*/;

  HEREDOC_DOUBLE = /^(?:[^\\"#]|\\[\s\S]|"(?!"")|\#(?!\{))*/;

  INSIDE_JSX = /^(?:[^\{<])*/; // Start of CoffeeScript interpolation. // Similar to `HEREDOC_DOUBLE` but there is no escaping.
  // Maybe JSX tag (`<` not allowed even if bare).

  JSX_INTERPOLATION = /^(?:\{|<(?!\/))/; // CoffeeScript interpolation.
  // JSX opening tag.

  HEREDOC_INDENT = /\n+([^\n\S]*)(?=\S)/g;

  // Regex-matching-regexes.
  REGEX = /^\/(?!\/)((?:[^[\/\n\\]|\\[^\n]|\[(?:\\[^\n]|[^\]\n\\])*\])*)(\/)?/; // Every other thing.
  // Anything but newlines escaped.
  // Character class.

  REGEX_FLAGS = /^\w*/;

  VALID_FLAGS = /^(?!.*(.).*\1)[dgimsuvy]*$/;

  HEREGEX = /^(?:[^\\\/#\s]|\\[\s\S]|\/(?!\/\/)|\#(?!\{)|\s+(?:#(?!\{).*)?)*/; // Match any character, except those that need special handling below.
  // Match `\` followed by any character.
  // Match any `/` except `///`.
  // Match `#` which is not part of interpolation, e.g. `#{}`.
  // Comments consume everything until the end of the line, including `///`.

  HEREGEX_COMMENT = /(\s+)(#(?!{).*)/gm;

  REGEX_ILLEGAL = /^(\/|\/{3}\s*)(\*)/;

  POSSIBLY_DIVISION = /^\/=?\s/;

  // Other regexes.
  HERECOMMENT_ILLEGAL = /\*\//;

  LINE_CONTINUER = /^\s*(?:,|\??\.(?![.\d])|\??::)/;

  STRING_INVALID_ESCAPE = /((?:^|[^\\])(?:\\\\)*)\\(?:(0\d|[1-7])|(x(?![\da-fA-F]{2}).{0,2})|(u\{(?![\da-fA-F]{1,}\})[^}]*\}?)|(u(?!\{|[\da-fA-F]{4}).{0,4}))/; // Make sure the escape isn’t escaped.
  // octal escape
  // hex escape
  // unicode code point escape
  // unicode escape

  REGEX_INVALID_ESCAPE = /((?:^|[^\\])(?:\\\\)*)\\(?:(0\d)|(x(?![\da-fA-F]{2}).{0,2})|(u\{(?![\da-fA-F]{1,}\})[^}]*\}?)|(u(?!\{|[\da-fA-F]{4}).{0,4}))/; // Make sure the escape isn’t escaped.
  // octal escape
  // hex escape
  // unicode code point escape
  // unicode escape

  TRAILING_SPACES = /\s+$/;

  // Compound assignment tokens.
  COMPOUND_ASSIGN = ['-=', '+=', '/=', '*=', '%=', '||=', '&&=', '?=', '<<=', '>>=', '>>>=', '&=', '^=', '|=', '**=', '//=', '%%='];

  // Unary tokens.
  UNARY = ['NEW', 'TYPEOF', 'DELETE'];

  UNARY_MATH = ['!', '~'];

  // Bit-shifting tokens.
  SHIFT = ['<<', '>>', '>>>'];

  // Comparison tokens.
  COMPARE = ['==', '!=', '<', '>', '<=', '>='];

  // Mathematical tokens.
  MATH = ['*', '/', '%', '//', '%%'];

  // Relational tokens that are negatable with `not` prefix.
  RELATION = ['IN', 'OF', 'INSTANCEOF'];

  // Boolean tokens.
  BOOL = ['TRUE', 'FALSE'];

  // Tokens which could legitimately be invoked or indexed. An opening
  // parentheses or bracket following these tokens will be recorded as the start
  // of a function invocation or indexing operation.
  CALLABLE = ['IDENTIFIER', 'PROPERTY', ')', ']', '?', '@', 'THIS', 'SUPER', 'DYNAMIC_IMPORT'];

  INDEXABLE = CALLABLE.concat(['NUMBER', 'INFINITY', 'NAN', 'STRING', 'STRING_END', 'REGEX', 'REGEX_END', 'BOOL', 'NULL', 'UNDEFINED', '}', '::']);

  // Tokens which can be the left-hand side of a less-than comparison, i.e. `a<b`.
  COMPARABLE_LEFT_SIDE = ['IDENTIFIER', ')', ']', 'NUMBER'];

  // Tokens which a regular expression will never immediately follow (except spaced
  // CALLABLEs in some cases), but which a division operator can.

  // See: http://www-archive.mozilla.org/js/language/js20-2002-04/rationale/syntax.html#regular-expressions
  NOT_REGEX = INDEXABLE.concat(['++', '--']);

  // Tokens that, when immediately preceding a `WHEN`, indicate that the `WHEN`
  // occurs at the start of a line. We disambiguate these from trailing whens to
  // avoid an ambiguity in the grammar.
  LINE_BREAK = ['INDENT', 'OUTDENT', 'TERMINATOR'];

  // Additional indent in front of these is ignored.
  INDENTABLE_CLOSERS = [')', '}', ']'];

}).call(this);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGV4ZXIuanMiLCJzb3VyY2VSb290IjoiLi4vLi4vIiwic291cmNlcyI6WyJzcmMvbGV4ZXIuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFTa0Y7RUFBQTs7Ozs7Ozs7OztBQUFBLE1BQUEsR0FBQSxFQUFBLElBQUEsRUFBQSxRQUFBLEVBQUEsSUFBQSxFQUFBLGNBQUEsRUFBQSxnQkFBQSxFQUFBLGVBQUEsRUFBQSxPQUFBLEVBQUEsb0JBQUEsRUFBQSxPQUFBLEVBQUEsZUFBQSxFQUFBLG1CQUFBLEVBQUEsY0FBQSxFQUFBLGNBQUEsRUFBQSxjQUFBLEVBQUEsT0FBQSxFQUFBLGVBQUEsRUFBQSxZQUFBLEVBQUEsVUFBQSxFQUFBLGtCQUFBLEVBQUEsU0FBQSxFQUFBLFVBQUEsRUFBQSxRQUFBLEVBQUEsT0FBQSxFQUFBLGFBQUEsRUFBQSx1QkFBQSxFQUFBLGNBQUEsRUFBQSxtQkFBQSxFQUFBLGlCQUFBLEVBQUEsV0FBQSxFQUFBLFVBQUEsRUFBQSxjQUFBLEVBQUEsS0FBQSxFQUFBLElBQUEsRUFBQSxVQUFBLEVBQUEsU0FBQSxFQUFBLE1BQUEsRUFBQSxRQUFBLEVBQUEsaUJBQUEsRUFBQSxLQUFBLEVBQUEsV0FBQSxFQUFBLGFBQUEsRUFBQSxvQkFBQSxFQUFBLFFBQUEsRUFBQSxRQUFBLEVBQUEsUUFBQSxFQUFBLEtBQUEsRUFBQSxpQkFBQSxFQUFBLGFBQUEsRUFBQSxxQkFBQSxFQUFBLGFBQUEsRUFBQSxZQUFBLEVBQUEsZUFBQSxFQUFBLEtBQUEsRUFBQSxVQUFBLEVBQUEsVUFBQSxFQUFBLFdBQUEsRUFBQSxVQUFBLEVBQUEsWUFBQSxFQUFBLG9CQUFBLEVBQUEsT0FBQSxFQUFBLEtBQUEsRUFBQSxPQUFBLEVBQUEsY0FBQSxFQUFBLFNBQUEsRUFBQSxjQUFBLEVBQUEsR0FBQSxFQUFBLG9CQUFBLEVBQUEsS0FBQSxFQUFBLFdBQUEsRUFBQSxNQUFBLEVBQUEsOEJBQUEsRUFBQSxNQUFBLEVBQUEsZ0JBQUE7SUFBQTs7O0VBRWxG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ZXMgYSBzZXJpZXMgb2YgdG9rZW4tbWF0Y2hpbmcgcmVnZXhlcyB0byBhdHRlbXB0XG4jIG1hdGNoZXMgYWdhaW5zdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzb3VyY2UgY29kZS4gV2hlbiBhIG1hdGNoIGlzIGZvdW5kLFxuIyBhIHRva2VuIGlzIHByb2R1Y2VkLCB3ZSBjb25zdW1lIHRoZSBtYXRjaCwgYW5kIHN0YXJ0IGFnYWluLiBUb2tlbnMgYXJlIGluIHRoZVxuIyBmb3JtOlxuI1xuIyAgICAgW3RhZywgdmFsdWUsIGxvY2F0aW9uRGF0YV1cbiNcbiMgd2hlcmUgbG9jYXRpb25EYXRhIGlzIHtmaXJzdF9saW5lLCBmaXJzdF9jb2x1bW4sIGxhc3RfbGluZSwgbGFzdF9jb2x1bW4sIGxhc3RfbGluZV9leGNsdXNpdmUsIGxhc3RfY29sdW1uX2V4Y2x1c2l2ZX0sIHdoaWNoIGlzIGFcbiMgZm9ybWF0IHRoYXQgY2FuIGJlIGZlZCBkaXJlY3RseSBpbnRvIFtKaXNvbl0oaHR0cHM6Ly9naXRodWIuY29tL3phYWNoL2ppc29uKS4gIFRoZXNlXG4jIGFyZSByZWFkIGJ5IGppc29uIGluIHRoZSBgcGFyc2VyLmxleGVyYCBmdW5jdGlvbiBkZWZpbmVkIGluIGNvZmZlZXNjcmlwdC5jb2ZmZWUuXG5cbntSZXdyaXRlciwgSU5WRVJTRVMsIFVORklOSVNIRUR9ID0gcmVxdWlyZSAnLi9yZXdyaXRlcidcblxuIyBJbXBvcnQgdGhlIGhlbHBlcnMgd2UgbmVlZC5cbntjb3VudCwgc3RhcnRzLCBjb21wYWN0LCByZXBlYXQsIGludmVydExpdGVyYXRlLCBtZXJnZSxcbmF0dGFjaENvbW1lbnRzVG9Ob2RlLCBsb2NhdGlvbkRhdGFUb1N0cmluZywgdGhyb3dTeW50YXhFcnJvclxucmVwbGFjZVVuaWNvZGVDb2RlUG9pbnRFc2NhcGVzLCBmbGF0dGVuLCBwYXJzZU51bWJlcn0gPSByZXF1aXJlICcuL2hlbHBlcnMnXG5cbiMgVGhlIExleGVyIENsYXNzXG4jIC0tLS0tLS0tLS0tLS0tLVxuXG4jIFRoZSBMZXhlciBjbGFzcyByZWFkcyBhIHN0cmVhbSBvZiBDb2ZmZWVTY3JpcHQgYW5kIGRpdnZpZXMgaXQgdXAgaW50byB0YWdnZWRcbiMgdG9rZW5zLiBTb21lIHBvdGVudGlhbCBhbWJpZ3VpdHkgaW4gdGhlIGdyYW1tYXIgaGFzIGJlZW4gYXZvaWRlZCBieVxuIyBwdXNoaW5nIHNvbWUgZXh0cmEgc21hcnRzIGludG8gdGhlIExleGVyLlxuZXhwb3J0cy5MZXhlciA9IGNsYXNzIExleGVyXG5cbiAgIyAqKnRva2VuaXplKiogaXMgdGhlIExleGVyJ3MgbWFpbiBtZXRob2QuIFNjYW4gYnkgYXR0ZW1wdGluZyB0byBtYXRjaCB0b2tlbnNcbiAgIyBvbmUgYXQgYSB0aW1lLCB1c2luZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBhbmNob3JlZCBhdCB0aGUgc3RhcnQgb2YgdGhlXG4gICMgcmVtYWluaW5nIGNvZGUsIG9yIGEgY3VzdG9tIHJlY3Vyc2l2ZSB0b2tlbi1tYXRjaGluZyBtZXRob2RcbiAgIyAoZm9yIGludGVycG9sYXRpb25zKS4gV2hlbiB0aGUgbmV4dCB0b2tlbiBoYXMgYmVlbiByZWNvcmRlZCwgd2UgbW92ZSBmb3J3YXJkXG4gICMgd2l0aGluIHRoZSBjb2RlIHBhc3QgdGhlIHRva2VuLCBhbmQgYmVnaW4gYWdhaW4uXG4gICNcbiAgIyBFYWNoIHRva2VuaXppbmcgbWV0aG9kIGlzIHJlc3BvbnNpYmxlIGZvciByZXR1cm5pbmcgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICMgaXQgaGFzIGNvbnN1bWVkLlxuICAjXG4gICMgQmVmb3JlIHJldHVybmluZyB0aGUgdG9rZW4gc3RyZWFtLCBydW4gaXQgdGhyb3VnaCB0aGUgW1Jld3JpdGVyXShyZXdyaXRlci5odG1sKS5cbiAgdG9rZW5pemU6IChjb2RlLCBvcHRzID0ge30pIC0+XG4gICAgQGxpdGVyYXRlICAgPSBvcHRzLmxpdGVyYXRlICAjIEFyZSB3ZSBsZXhpbmcgbGl0ZXJhdGUgQ29mZmVlU2NyaXB0P1xuICAgIEBpbmRlbnQgICAgID0gMCAgICAgICAgICAgICAgIyBUaGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbC5cbiAgICBAYmFzZUluZGVudCA9IDAgICAgICAgICAgICAgICMgVGhlIG92ZXJhbGwgbWluaW11bSBpbmRlbnRhdGlvbiBsZXZlbC5cbiAgICBAY29udGludWF0aW9uTGluZUFkZGl0aW9uYWxJbmRlbnQgPSAwICMgVGhlIG92ZXItaW5kZW50YXRpb24gYXQgdGhlIGN1cnJlbnQgbGV2ZWwuXG4gICAgQG91dGRlYnQgICAgPSAwICAgICAgICAgICAgICAjIFRoZSB1bmRlci1vdXRkZW50YXRpb24gYXQgdGhlIGN1cnJlbnQgbGV2ZWwuXG4gICAgQGluZGVudHMgICAgPSBbXSAgICAgICAgICAgICAjIFRoZSBzdGFjayBvZiBhbGwgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbHMuXG4gICAgQGluZGVudExpdGVyYWwgPSAnJyAgICAgICAgICAjIFRoZSBpbmRlbnRhdGlvbi5cbiAgICBAZW5kcyAgICAgICA9IFtdICAgICAgICAgICAgICMgVGhlIHN0YWNrIGZvciBwYWlyaW5nIHVwIHRva2Vucy5cbiAgICBAdG9rZW5zICAgICA9IFtdICAgICAgICAgICAgICMgU3RyZWFtIG9mIHBhcnNlZCB0b2tlbnMgaW4gdGhlIGZvcm0gYFsnVFlQRScsIHZhbHVlLCBsb2NhdGlvbiBkYXRhXWAuXG4gICAgQHNlZW5Gb3IgICAgPSBubyAgICAgICAgICAgICAjIFVzZWQgdG8gcmVjb2duaXplIGBGT1JJTmAsIGBGT1JPRmAgYW5kIGBGT1JGUk9NYCB0b2tlbnMuXG4gICAgQHNlZW5JbXBvcnQgPSBubyAgICAgICAgICAgICAjIFVzZWQgdG8gcmVjb2duaXplIGBJTVBPUlQgRlJPTT8gQVM/YCB0b2tlbnMuXG4gICAgQHNlZW5FeHBvcnQgPSBubyAgICAgICAgICAgICAjIFVzZWQgdG8gcmVjb2duaXplIGBFWFBPUlQgRlJPTT8gQVM/YCB0b2tlbnMuXG4gICAgQGltcG9ydFNwZWNpZmllckxpc3QgPSBubyAgICAjIFVzZWQgdG8gaWRlbnRpZnkgd2hlbiBpbiBhbiBgSU1QT1JUIHsuLi59IEZST00/IC4uLmAuXG4gICAgQGV4cG9ydFNwZWNpZmllckxpc3QgPSBubyAgICAjIFVzZWQgdG8gaWRlbnRpZnkgd2hlbiBpbiBhbiBgRVhQT1JUIHsuLi59IEZST00/IC4uLmAuXG4gICAgQGpzeERlcHRoID0gMCAgICAgICAgICAgICAgICAjIFVzZWQgdG8gb3B0aW1pemUgSlNYIGNoZWNrcywgaG93IGRlZXAgaW4gSlNYIHdlIGFyZS5cbiAgICBAanN4T2JqQXR0cmlidXRlID0ge30gICAgICAgICMgVXNlZCB0byBkZXRlY3QgaWYgSlNYIGF0dHJpYnV0ZXMgaXMgd3JhcHBlZCBpbiB7fSAoPGRpdiB7cHJvcHMuLi59IC8+KS5cblxuICAgIEBjaHVua0xpbmUgPVxuICAgICAgb3B0cy5saW5lIG9yIDAgICAgICAgICAgICAgIyBUaGUgc3RhcnQgbGluZSBmb3IgdGhlIGN1cnJlbnQgQGNodW5rLlxuICAgIEBjaHVua0NvbHVtbiA9XG4gICAgICBvcHRzLmNvbHVtbiBvciAwICAgICAgICAgICAjIFRoZSBzdGFydCBjb2x1bW4gb2YgdGhlIGN1cnJlbnQgQGNodW5rLlxuICAgIEBjaHVua09mZnNldCA9XG4gICAgICBvcHRzLm9mZnNldCBvciAwICAgICAgICAgICAjIFRoZSBzdGFydCBvZmZzZXQgZm9yIHRoZSBjdXJyZW50IEBjaHVuay5cbiAgICBAbG9jYXRpb25EYXRhQ29tcGVuc2F0aW9ucyA9XG4gICAgICBvcHRzLmxvY2F0aW9uRGF0YUNvbXBlbnNhdGlvbnMgb3Ige30gIyBUaGUgbG9jYXRpb24gZGF0YSBjb21wZW5zYXRpb25zIGZvciB0aGUgY3VycmVudCBAY2h1bmsuXG4gICAgY29kZSA9IEBjbGVhbiBjb2RlICAgICAgICAgICAjIFRoZSBzdHJpcHBlZCwgY2xlYW5lZCBvcmlnaW5hbCBzb3VyY2UgY29kZS5cblxuICAgICMgQXQgZXZlcnkgcG9zaXRpb24sIHJ1biB0aHJvdWdoIHRoaXMgbGlzdCBvZiBhdHRlbXB0ZWQgbWF0Y2hlcyxcbiAgICAjIHNob3J0LWNpcmN1aXRpbmcgaWYgYW55IG9mIHRoZW0gc3VjY2VlZC4gVGhlaXIgb3JkZXIgZGV0ZXJtaW5lcyBwcmVjZWRlbmNlOlxuICAgICMgYEBsaXRlcmFsVG9rZW5gIGlzIHRoZSBmYWxsYmFjayBjYXRjaC1hbGwuXG4gICAgaSA9IDBcbiAgICB3aGlsZSBAY2h1bmsgPSBjb2RlW2kuLl1cbiAgICAgIGNvbnN1bWVkID0gXFxcbiAgICAgICAgICAgQGlkZW50aWZpZXJUb2tlbigpIG9yXG4gICAgICAgICAgIEBjb21tZW50VG9rZW4oKSAgICBvclxuICAgICAgICAgICBAd2hpdGVzcGFjZVRva2VuKCkgb3JcbiAgICAgICAgICAgQGxpbmVUb2tlbigpICAgICAgIG9yXG4gICAgICAgICAgIEBzdHJpbmdUb2tlbigpICAgICBvclxuICAgICAgICAgICBAbnVtYmVyVG9rZW4oKSAgICAgb3JcbiAgICAgICAgICAgQGpzeFRva2VuKCkgICAgICAgIG9yXG4gICAgICAgICAgIEByZWdleFRva2VuKCkgICAgICBvclxuICAgICAgICAgICBAanNUb2tlbigpICAgICAgICAgb3JcbiAgICAgICAgICAgQGxpdGVyYWxUb2tlbigpXG5cbiAgICAgICMgVXBkYXRlIHBvc2l0aW9uLlxuICAgICAgW0BjaHVua0xpbmUsIEBjaHVua0NvbHVtbiwgQGNodW5rT2Zmc2V0XSA9IEBnZXRMaW5lQW5kQ29sdW1uRnJvbUNodW5rIGNvbnN1bWVkXG5cbiAgICAgIGkgKz0gY29uc3VtZWRcblxuICAgICAgcmV0dXJuIHtAdG9rZW5zLCBpbmRleDogaX0gaWYgb3B0cy51bnRpbEJhbGFuY2VkIGFuZCBAZW5kcy5sZW5ndGggaXMgMFxuXG4gICAgQGNsb3NlSW5kZW50YXRpb24oKVxuICAgIEBlcnJvciBcIm1pc3NpbmcgI3tlbmQudGFnfVwiLCAoZW5kLm9yaWdpbiA/IGVuZClbMl0gaWYgZW5kID0gQGVuZHMucG9wKClcbiAgICByZXR1cm4gQHRva2VucyBpZiBvcHRzLnJld3JpdGUgaXMgb2ZmXG4gICAgKG5ldyBSZXdyaXRlcikucmV3cml0ZSBAdG9rZW5zXG5cbiAgIyBQcmVwcm9jZXNzIHRoZSBjb2RlIHRvIHJlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXJyaWFnZVxuICAjIHJldHVybnMsIGV0Yy4gSWYgd2XigJlyZSBsZXhpbmcgbGl0ZXJhdGUgQ29mZmVlU2NyaXB0LCBzdHJpcCBleHRlcm5hbCBNYXJrZG93blxuICAjIGJ5IHJlbW92aW5nIGFsbCBsaW5lcyB0aGF0IGFyZW7igJl0IGluZGVudGVkIGJ5IGF0IGxlYXN0IGZvdXIgc3BhY2VzIG9yIGEgdGFiLlxuICBjbGVhbjogKGNvZGUpIC0+XG4gICAgdGh1c0ZhciA9IDBcbiAgICBpZiBjb2RlLmNoYXJDb2RlQXQoMCkgaXMgQk9NXG4gICAgICBjb2RlID0gY29kZS5zbGljZSAxXG4gICAgICBAbG9jYXRpb25EYXRhQ29tcGVuc2F0aW9uc1swXSA9IDFcbiAgICAgIHRodXNGYXIgKz0gMVxuICAgIGlmIFdISVRFU1BBQ0UudGVzdCBjb2RlXG4gICAgICBjb2RlID0gXCJcXG4je2NvZGV9XCJcbiAgICAgIEBjaHVua0xpbmUtLVxuICAgICAgQGxvY2F0aW9uRGF0YUNvbXBlbnNhdGlvbnNbMF0gPz0gMFxuICAgICAgQGxvY2F0aW9uRGF0YUNvbXBlbnNhdGlvbnNbMF0gLT0gMVxuICAgIGNvZGUgPSBjb2RlXG4gICAgICAucmVwbGFjZSAvXFxyL2csIChtYXRjaCwgb2Zmc2V0KSA9PlxuICAgICAgICBAbG9jYXRpb25EYXRhQ29tcGVuc2F0aW9uc1t0aHVzRmFyICsgb2Zmc2V0XSA9IDFcbiAgICAgICAgJydcbiAgICAgIC5yZXBsYWNlIFRSQUlMSU5HX1NQQUNFUywgJydcbiAgICBjb2RlID0gaW52ZXJ0TGl0ZXJhdGUgY29kZSBpZiBAbGl0ZXJhdGVcbiAgICBjb2RlXG5cbiAgIyBUb2tlbml6ZXJzXG4gICMgLS0tLS0tLS0tLVxuXG4gICMgTWF0Y2hlcyBpZGVudGlmeWluZyBsaXRlcmFsczogdmFyaWFibGVzLCBrZXl3b3JkcywgbWV0aG9kIG5hbWVzLCBldGMuXG4gICMgQ2hlY2sgdG8gZW5zdXJlIHRoYXQgSmF2YVNjcmlwdCByZXNlcnZlZCB3b3JkcyBhcmVu4oCZdCBiZWluZyB1c2VkIGFzXG4gICMgaWRlbnRpZmllcnMuIEJlY2F1c2UgQ29mZmVlU2NyaXB0IHJlc2VydmVzIGEgaGFuZGZ1bCBvZiBrZXl3b3JkcyB0aGF0IGFyZVxuICAjIGFsbG93ZWQgaW4gSmF2YVNjcmlwdCwgd2XigJlyZSBjYXJlZnVsIG5vdCB0byB0YWcgdGhlbSBhcyBrZXl3b3JkcyB3aGVuXG4gICMgcmVmZXJlbmNlZCBhcyBwcm9wZXJ0eSBuYW1lcyBoZXJlLCBzbyB5b3UgY2FuIHN0aWxsIGRvIGBqUXVlcnkuaXMoKWAgZXZlblxuICAjIHRob3VnaCBgaXNgIG1lYW5zIGA9PT1gIG90aGVyd2lzZS5cbiAgaWRlbnRpZmllclRva2VuOiAtPlxuICAgIGluSlNYVGFnID0gQGF0SlNYVGFnKClcbiAgICByZWdleCA9IGlmIGluSlNYVGFnIHRoZW4gSlNYX0FUVFJJQlVURSBlbHNlIElERU5USUZJRVJcbiAgICByZXR1cm4gMCB1bmxlc3MgbWF0Y2ggPSByZWdleC5leGVjIEBjaHVua1xuICAgIFtpbnB1dCwgaWQsIGNvbG9uXSA9IG1hdGNoXG5cbiAgICAjIFByZXNlcnZlIGxlbmd0aCBvZiBpZCBmb3IgbG9jYXRpb24gZGF0YVxuICAgIGlkTGVuZ3RoID0gaWQubGVuZ3RoXG4gICAgcG9wcGVkVG9rZW4gPSB1bmRlZmluZWRcbiAgICBpZiBpZCBpcyAnb3duJyBhbmQgQHRhZygpIGlzICdGT1InXG4gICAgICBAdG9rZW4gJ09XTicsIGlkXG4gICAgICByZXR1cm4gaWQubGVuZ3RoXG4gICAgaWYgaWQgaXMgJ2Zyb20nIGFuZCBAdGFnKCkgaXMgJ1lJRUxEJ1xuICAgICAgQHRva2VuICdGUk9NJywgaWRcbiAgICAgIHJldHVybiBpZC5sZW5ndGhcbiAgICBpZiBpZCBpcyAnYXMnIGFuZCBAc2VlbkltcG9ydFxuICAgICAgaWYgQHZhbHVlKCkgaXMgJyonXG4gICAgICAgIEB0b2tlbnNbQHRva2Vucy5sZW5ndGggLSAxXVswXSA9ICdJTVBPUlRfQUxMJ1xuICAgICAgZWxzZSBpZiBAdmFsdWUoeWVzKSBpbiBDT0ZGRUVfS0VZV09SRFNcbiAgICAgICAgcHJldiA9IEBwcmV2KClcbiAgICAgICAgW3ByZXZbMF0sIHByZXZbMV1dID0gWydJREVOVElGSUVSJywgQHZhbHVlKHllcyldXG4gICAgICBpZiBAdGFnKCkgaW4gWydERUZBVUxUJywgJ0lNUE9SVF9BTEwnLCAnSURFTlRJRklFUiddXG4gICAgICAgIEB0b2tlbiAnQVMnLCBpZFxuICAgICAgICByZXR1cm4gaWQubGVuZ3RoXG4gICAgaWYgaWQgaXMgJ2FzJyBhbmQgQHNlZW5FeHBvcnRcbiAgICAgIGlmIEB0YWcoKSBpbiBbJ0lERU5USUZJRVInLCAnREVGQVVMVCddXG4gICAgICAgIEB0b2tlbiAnQVMnLCBpZFxuICAgICAgICByZXR1cm4gaWQubGVuZ3RoXG4gICAgICBpZiBAdmFsdWUoeWVzKSBpbiBDT0ZGRUVfS0VZV09SRFNcbiAgICAgICAgcHJldiA9IEBwcmV2KClcbiAgICAgICAgW3ByZXZbMF0sIHByZXZbMV1dID0gWydJREVOVElGSUVSJywgQHZhbHVlKHllcyldXG4gICAgICAgIEB0b2tlbiAnQVMnLCBpZFxuICAgICAgICByZXR1cm4gaWQubGVuZ3RoXG4gICAgaWYgaWQgaXMgJ2RlZmF1bHQnIGFuZCBAc2VlbkV4cG9ydCBhbmQgQHRhZygpIGluIFsnRVhQT1JUJywgJ0FTJ11cbiAgICAgIEB0b2tlbiAnREVGQVVMVCcsIGlkXG4gICAgICByZXR1cm4gaWQubGVuZ3RoXG4gICAgaWYgaWQgaXMgJ2Fzc2VydCcgYW5kIChAc2VlbkltcG9ydCBvciBAc2VlbkV4cG9ydCkgYW5kIEB0YWcoKSBpcyAnU1RSSU5HJ1xuICAgICAgQHRva2VuICdBU1NFUlQnLCBpZFxuICAgICAgcmV0dXJuIGlkLmxlbmd0aFxuICAgIGlmIGlkIGlzICdkbycgYW5kIHJlZ0V4U3VwZXIgPSAvXihcXHMqc3VwZXIpKD8hXFwoXFwpKS8uZXhlYyBAY2h1bmtbMy4uLl1cbiAgICAgIEB0b2tlbiAnU1VQRVInLCAnc3VwZXInXG4gICAgICBAdG9rZW4gJ0NBTExfU1RBUlQnLCAnKCdcbiAgICAgIEB0b2tlbiAnQ0FMTF9FTkQnLCAnKSdcbiAgICAgIFtpbnB1dCwgc3VwXSA9IHJlZ0V4U3VwZXJcbiAgICAgIHJldHVybiBzdXAubGVuZ3RoICsgM1xuXG4gICAgcHJldiA9IEBwcmV2KClcblxuICAgIHRhZyA9XG4gICAgICBpZiBjb2xvbiBvciBwcmV2PyBhbmRcbiAgICAgICAgIChwcmV2WzBdIGluIFsnLicsICc/LicsICc6OicsICc/OjonXSBvclxuICAgICAgICAgbm90IHByZXYuc3BhY2VkIGFuZCBwcmV2WzBdIGlzICdAJylcbiAgICAgICAgJ1BST1BFUlRZJ1xuICAgICAgZWxzZVxuICAgICAgICAnSURFTlRJRklFUidcblxuICAgIHRva2VuRGF0YSA9IHt9XG4gICAgaWYgdGFnIGlzICdJREVOVElGSUVSJyBhbmQgKGlkIGluIEpTX0tFWVdPUkRTIG9yIGlkIGluIENPRkZFRV9LRVlXT1JEUykgYW5kXG4gICAgICAgbm90IChAZXhwb3J0U3BlY2lmaWVyTGlzdCBhbmQgaWQgaW4gQ09GRkVFX0tFWVdPUkRTKVxuICAgICAgdGFnID0gaWQudG9VcHBlckNhc2UoKVxuICAgICAgaWYgdGFnIGlzICdXSEVOJyBhbmQgQHRhZygpIGluIExJTkVfQlJFQUtcbiAgICAgICAgdGFnID0gJ0xFQURJTkdfV0hFTidcbiAgICAgIGVsc2UgaWYgdGFnIGlzICdGT1InXG4gICAgICAgIEBzZWVuRm9yID0ge2VuZHNMZW5ndGg6IEBlbmRzLmxlbmd0aH1cbiAgICAgIGVsc2UgaWYgdGFnIGlzICdVTkxFU1MnXG4gICAgICAgIHRhZyA9ICdJRidcbiAgICAgIGVsc2UgaWYgdGFnIGlzICdJTVBPUlQnXG4gICAgICAgIEBzZWVuSW1wb3J0ID0geWVzXG4gICAgICBlbHNlIGlmIHRhZyBpcyAnRVhQT1JUJ1xuICAgICAgICBAc2VlbkV4cG9ydCA9IHllc1xuICAgICAgZWxzZSBpZiB0YWcgaW4gVU5BUllcbiAgICAgICAgdGFnID0gJ1VOQVJZJ1xuICAgICAgZWxzZSBpZiB0YWcgaW4gUkVMQVRJT05cbiAgICAgICAgaWYgdGFnIGlzbnQgJ0lOU1RBTkNFT0YnIGFuZCBAc2VlbkZvclxuICAgICAgICAgIHRhZyA9ICdGT1InICsgdGFnXG4gICAgICAgICAgQHNlZW5Gb3IgPSBub1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGFnID0gJ1JFTEFUSU9OJ1xuICAgICAgICAgIGlmIEB2YWx1ZSgpIGlzICchJ1xuICAgICAgICAgICAgcG9wcGVkVG9rZW4gPSBAdG9rZW5zLnBvcCgpXG4gICAgICAgICAgICB0b2tlbkRhdGEuaW52ZXJ0ID0gcG9wcGVkVG9rZW4uZGF0YT8ub3JpZ2luYWwgPyBwb3BwZWRUb2tlblsxXVxuICAgIGVsc2UgaWYgdGFnIGlzICdJREVOVElGSUVSJyBhbmQgQHNlZW5Gb3IgYW5kIGlkIGlzICdmcm9tJyBhbmRcbiAgICAgICBpc0ZvckZyb20ocHJldilcbiAgICAgIHRhZyA9ICdGT1JGUk9NJ1xuICAgICAgQHNlZW5Gb3IgPSBub1xuICAgICMgVGhyb3cgYW4gZXJyb3Igb24gYXR0ZW1wdHMgdG8gdXNlIGBnZXRgIG9yIGBzZXRgIGFzIGtleXdvcmRzLCBvclxuICAgICMgd2hhdCBDb2ZmZWVTY3JpcHQgd291bGQgbm9ybWFsbHkgaW50ZXJwcmV0IGFzIGNhbGxzIHRvIGZ1bmN0aW9ucyBuYW1lZFxuICAgICMgYGdldGAgb3IgYHNldGAsIGkuZS4gYGdldCh7Zm9vOiBmdW5jdGlvbiAoKSB7fX0pYC5cbiAgICBlbHNlIGlmIHRhZyBpcyAnUFJPUEVSVFknIGFuZCBwcmV2XG4gICAgICBpZiBwcmV2LnNwYWNlZCBhbmQgcHJldlswXSBpbiBDQUxMQUJMRSBhbmQgL15bZ3NdZXQkLy50ZXN0KHByZXZbMV0pIGFuZFxuICAgICAgICAgQHRva2Vucy5sZW5ndGggPiAxIGFuZCBAdG9rZW5zW0B0b2tlbnMubGVuZ3RoIC0gMl1bMF0gbm90IGluIFsnLicsICc/LicsICdAJ11cbiAgICAgICAgQGVycm9yIFwiJyN7cHJldlsxXX0nIGNhbm5vdCBiZSB1c2VkIGFzIGEga2V5d29yZCwgb3IgYXMgYSBmdW5jdGlvbiBjYWxsXG4gICAgICAgIHdpdGhvdXQgcGFyZW50aGVzZXNcIiwgcHJldlsyXVxuICAgICAgZWxzZSBpZiBwcmV2WzBdIGlzICcuJyBhbmQgQHRva2Vucy5sZW5ndGggPiAxIGFuZCAocHJldnByZXYgPSBAdG9rZW5zW0B0b2tlbnMubGVuZ3RoIC0gMl0pWzBdIGlzICdVTkFSWScgYW5kIHByZXZwcmV2WzFdIGlzICduZXcnXG4gICAgICAgIHByZXZwcmV2WzBdID0gJ05FV19UQVJHRVQnXG4gICAgICBlbHNlIGlmIHByZXZbMF0gaXMgJy4nIGFuZCBAdG9rZW5zLmxlbmd0aCA+IDEgYW5kIChwcmV2cHJldiA9IEB0b2tlbnNbQHRva2Vucy5sZW5ndGggLSAyXSlbMF0gaXMgJ0lNUE9SVCcgYW5kIHByZXZwcmV2WzFdIGlzICdpbXBvcnQnXG4gICAgICAgIEBzZWVuSW1wb3J0ID0gbm9cbiAgICAgICAgcHJldnByZXZbMF0gPSAnSU1QT1JUX01FVEEnXG4gICAgICBlbHNlIGlmIEB0b2tlbnMubGVuZ3RoID4gMlxuICAgICAgICBwcmV2cHJldiA9IEB0b2tlbnNbQHRva2Vucy5sZW5ndGggLSAyXVxuICAgICAgICBpZiBwcmV2WzBdIGluIFsnQCcsICdUSElTJ10gYW5kIHByZXZwcmV2IGFuZCBwcmV2cHJldi5zcGFjZWQgYW5kXG4gICAgICAgICAgIC9eW2dzXWV0JC8udGVzdChwcmV2cHJldlsxXSkgYW5kXG4gICAgICAgICAgIEB0b2tlbnNbQHRva2Vucy5sZW5ndGggLSAzXVswXSBub3QgaW4gWycuJywgJz8uJywgJ0AnXVxuICAgICAgICAgIEBlcnJvciBcIicje3ByZXZwcmV2WzFdfScgY2Fubm90IGJlIHVzZWQgYXMgYSBrZXl3b3JkLCBvciBhcyBhXG4gICAgICAgICAgZnVuY3Rpb24gY2FsbCB3aXRob3V0IHBhcmVudGhlc2VzXCIsIHByZXZwcmV2WzJdXG5cbiAgICBpZiB0YWcgaXMgJ0lERU5USUZJRVInIGFuZCBpZCBpbiBSRVNFUlZFRCBhbmQgbm90IGluSlNYVGFnXG4gICAgICBAZXJyb3IgXCJyZXNlcnZlZCB3b3JkICcje2lkfSdcIiwgbGVuZ3RoOiBpZC5sZW5ndGhcblxuICAgIHVubGVzcyB0YWcgaXMgJ1BST1BFUlRZJyBvciBAZXhwb3J0U3BlY2lmaWVyTGlzdCBvciBAaW1wb3J0U3BlY2lmaWVyTGlzdFxuICAgICAgaWYgaWQgaW4gQ09GRkVFX0FMSUFTRVNcbiAgICAgICAgYWxpYXMgPSBpZFxuICAgICAgICBpZCA9IENPRkZFRV9BTElBU19NQVBbaWRdXG4gICAgICAgIHRva2VuRGF0YS5vcmlnaW5hbCA9IGFsaWFzXG4gICAgICB0YWcgPSBzd2l0Y2ggaWRcbiAgICAgICAgd2hlbiAnIScgICAgICAgICAgICAgICAgIHRoZW4gJ1VOQVJZJ1xuICAgICAgICB3aGVuICc9PScsICchPScgICAgICAgICAgdGhlbiAnQ09NUEFSRSdcbiAgICAgICAgd2hlbiAndHJ1ZScsICdmYWxzZScgICAgIHRoZW4gJ0JPT0wnXG4gICAgICAgIHdoZW4gJ2JyZWFrJywgJ2NvbnRpbnVlJywgXFxcbiAgICAgICAgICAgICAnZGVidWdnZXInICAgICAgICAgIHRoZW4gJ1NUQVRFTUVOVCdcbiAgICAgICAgd2hlbiAnJiYnLCAnfHwnICAgICAgICAgIHRoZW4gaWRcbiAgICAgICAgZWxzZSAgdGFnXG5cbiAgICB0YWdUb2tlbiA9IEB0b2tlbiB0YWcsIGlkLCBsZW5ndGg6IGlkTGVuZ3RoLCBkYXRhOiB0b2tlbkRhdGFcbiAgICB0YWdUb2tlbi5vcmlnaW4gPSBbdGFnLCBhbGlhcywgdGFnVG9rZW5bMl1dIGlmIGFsaWFzXG4gICAgaWYgcG9wcGVkVG9rZW5cbiAgICAgIFt0YWdUb2tlblsyXS5maXJzdF9saW5lLCB0YWdUb2tlblsyXS5maXJzdF9jb2x1bW4sIHRhZ1Rva2VuWzJdLnJhbmdlWzBdXSA9XG4gICAgICAgIFtwb3BwZWRUb2tlblsyXS5maXJzdF9saW5lLCBwb3BwZWRUb2tlblsyXS5maXJzdF9jb2x1bW4sIHBvcHBlZFRva2VuWzJdLnJhbmdlWzBdXVxuICAgIGlmIGNvbG9uXG4gICAgICBjb2xvbk9mZnNldCA9IGlucHV0Lmxhc3RJbmRleE9mIGlmIGluSlNYVGFnIHRoZW4gJz0nIGVsc2UgJzonXG4gICAgICBjb2xvblRva2VuID0gQHRva2VuICc6JywgJzonLCBvZmZzZXQ6IGNvbG9uT2Zmc2V0XG4gICAgICBjb2xvblRva2VuLmpzeENvbG9uID0geWVzIGlmIGluSlNYVGFnICMgdXNlZCBieSByZXdyaXRlclxuICAgIGlmIGluSlNYVGFnIGFuZCB0YWcgaXMgJ0lERU5USUZJRVInIGFuZCBwcmV2WzBdIGlzbnQgJzonXG4gICAgICBAdG9rZW4gJywnLCAnLCcsIGxlbmd0aDogMCwgb3JpZ2luOiB0YWdUb2tlbiwgZ2VuZXJhdGVkOiB5ZXNcblxuICAgIGlucHV0Lmxlbmd0aFxuXG4gICMgTWF0Y2hlcyBudW1iZXJzLCBpbmNsdWRpbmcgZGVjaW1hbHMsIGhleCwgYW5kIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxuICAjIEJlIGNhcmVmdWwgbm90IHRvIGludGVyZmVyZSB3aXRoIHJhbmdlcyBpbiBwcm9ncmVzcy5cbiAgbnVtYmVyVG9rZW46IC0+XG4gICAgcmV0dXJuIDAgdW5sZXNzIG1hdGNoID0gTlVNQkVSLmV4ZWMgQGNodW5rXG5cbiAgICBudW1iZXIgPSBtYXRjaFswXVxuICAgIGxleGVkTGVuZ3RoID0gbnVtYmVyLmxlbmd0aFxuXG4gICAgc3dpdGNoXG4gICAgICB3aGVuIC9eMFtCT1hdLy50ZXN0IG51bWJlclxuICAgICAgICBAZXJyb3IgXCJyYWRpeCBwcmVmaXggaW4gJyN7bnVtYmVyfScgbXVzdCBiZSBsb3dlcmNhc2VcIiwgb2Zmc2V0OiAxXG4gICAgICB3aGVuIC9eMFxcZCpbODldLy50ZXN0IG51bWJlclxuICAgICAgICBAZXJyb3IgXCJkZWNpbWFsIGxpdGVyYWwgJyN7bnVtYmVyfScgbXVzdCBub3QgYmUgcHJlZml4ZWQgd2l0aCAnMCdcIiwgbGVuZ3RoOiBsZXhlZExlbmd0aFxuICAgICAgd2hlbiAvXjBcXGQrLy50ZXN0IG51bWJlclxuICAgICAgICBAZXJyb3IgXCJvY3RhbCBsaXRlcmFsICcje251bWJlcn0nIG11c3QgYmUgcHJlZml4ZWQgd2l0aCAnMG8nXCIsIGxlbmd0aDogbGV4ZWRMZW5ndGhcblxuICAgIHBhcnNlZFZhbHVlID0gcGFyc2VOdW1iZXIgbnVtYmVyXG4gICAgdG9rZW5EYXRhID0ge3BhcnNlZFZhbHVlfVxuXG4gICAgdGFnID0gaWYgcGFyc2VkVmFsdWUgaXMgSW5maW5pdHkgdGhlbiAnSU5GSU5JVFknIGVsc2UgJ05VTUJFUidcbiAgICBpZiB0YWcgaXMgJ0lORklOSVRZJ1xuICAgICAgdG9rZW5EYXRhLm9yaWdpbmFsID0gbnVtYmVyXG4gICAgQHRva2VuIHRhZywgbnVtYmVyLFxuICAgICAgbGVuZ3RoOiBsZXhlZExlbmd0aFxuICAgICAgZGF0YTogdG9rZW5EYXRhXG4gICAgbGV4ZWRMZW5ndGhcblxuICAjIE1hdGNoZXMgc3RyaW5ncywgaW5jbHVkaW5nIG11bHRpbGluZSBzdHJpbmdzLCBhcyB3ZWxsIGFzIGhlcmVkb2NzLCB3aXRoIG9yIHdpdGhvdXRcbiAgIyBpbnRlcnBvbGF0aW9uLlxuICBzdHJpbmdUb2tlbjogLT5cbiAgICBbcXVvdGVdID0gU1RSSU5HX1NUQVJULmV4ZWMoQGNodW5rKSB8fCBbXVxuICAgIHJldHVybiAwIHVubGVzcyBxdW90ZVxuXG4gICAgIyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIGlzIGBmcm9tYCBhbmQgdGhpcyBpcyBhbiBpbXBvcnQgb3IgZXhwb3J0IHN0YXRlbWVudCxcbiAgICAjIHByb3Blcmx5IHRhZyB0aGUgYGZyb21gLlxuICAgIHByZXYgPSBAcHJldigpXG4gICAgaWYgcHJldiBhbmQgQHZhbHVlKCkgaXMgJ2Zyb20nIGFuZCAoQHNlZW5JbXBvcnQgb3IgQHNlZW5FeHBvcnQpXG4gICAgICBwcmV2WzBdID0gJ0ZST00nXG5cbiAgICByZWdleCA9IHN3aXRjaCBxdW90ZVxuICAgICAgd2hlbiBcIidcIiAgIHRoZW4gU1RSSU5HX1NJTkdMRVxuICAgICAgd2hlbiAnXCInICAgdGhlbiBTVFJJTkdfRE9VQkxFXG4gICAgICB3aGVuIFwiJycnXCIgdGhlbiBIRVJFRE9DX1NJTkdMRVxuICAgICAgd2hlbiAnXCJcIlwiJyB0aGVuIEhFUkVET0NfRE9VQkxFXG5cbiAgICB7dG9rZW5zLCBpbmRleDogZW5kfSA9IEBtYXRjaFdpdGhJbnRlcnBvbGF0aW9ucyByZWdleCwgcXVvdGVcblxuICAgIGhlcmVkb2MgPSBxdW90ZS5sZW5ndGggaXMgM1xuICAgIGlmIGhlcmVkb2NcbiAgICAgICMgRmluZCB0aGUgc21hbGxlc3QgaW5kZW50YXRpb24uIEl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIGFsbCBsaW5lcyBsYXRlci5cbiAgICAgIGluZGVudCA9IG51bGxcbiAgICAgIGRvYyA9ICh0b2tlblsxXSBmb3IgdG9rZW4sIGkgaW4gdG9rZW5zIHdoZW4gdG9rZW5bMF0gaXMgJ05FT1NUUklORycpLmpvaW4gJyN7fSdcbiAgICAgIHdoaWxlIG1hdGNoID0gSEVSRURPQ19JTkRFTlQuZXhlYyBkb2NcbiAgICAgICAgYXR0ZW1wdCA9IG1hdGNoWzFdXG4gICAgICAgIGluZGVudCA9IGF0dGVtcHQgaWYgaW5kZW50IGlzIG51bGwgb3IgMCA8IGF0dGVtcHQubGVuZ3RoIDwgaW5kZW50Lmxlbmd0aFxuXG4gICAgZGVsaW1pdGVyID0gcXVvdGUuY2hhckF0KDApXG4gICAgQG1lcmdlSW50ZXJwb2xhdGlvblRva2VucyB0b2tlbnMsIHtxdW90ZSwgaW5kZW50LCBlbmRPZmZzZXQ6IGVuZH0sICh2YWx1ZSkgPT5cbiAgICAgIEB2YWxpZGF0ZVVuaWNvZGVDb2RlUG9pbnRFc2NhcGVzIHZhbHVlLCBkZWxpbWl0ZXI6IHF1b3RlXG5cbiAgICBpZiBAYXRKU1hUYWcoKVxuICAgICAgQHRva2VuICcsJywgJywnLCBsZW5ndGg6IDAsIG9yaWdpbjogQHByZXYsIGdlbmVyYXRlZDogeWVzXG5cbiAgICBlbmRcblxuICAjIE1hdGNoZXMgYW5kIGNvbnN1bWVzIGNvbW1lbnRzLiBUaGUgY29tbWVudHMgYXJlIHRha2VuIG91dCBvZiB0aGUgdG9rZW5cbiAgIyBzdHJlYW0gYW5kIHNhdmVkIGZvciBsYXRlciwgdG8gYmUgcmVpbnNlcnRlZCBpbnRvIHRoZSBvdXRwdXQgYWZ0ZXJcbiAgIyBldmVyeXRoaW5nIGhhcyBiZWVuIHBhcnNlZCBhbmQgdGhlIEphdmFTY3JpcHQgY29kZSBnZW5lcmF0ZWQuXG4gIGNvbW1lbnRUb2tlbjogKGNodW5rID0gQGNodW5rLCB7aGVyZWdleCwgcmV0dXJuQ29tbWVudFRva2VucyA9IG5vLCBvZmZzZXRJbkNodW5rID0gMH0gPSB7fSkgLT5cbiAgICByZXR1cm4gMCB1bmxlc3MgbWF0Y2ggPSBjaHVuay5tYXRjaCBDT01NRU5UXG4gICAgW2NvbW1lbnRXaXRoU3Vycm91bmRpbmdXaGl0ZXNwYWNlLCBoZXJlTGVhZGluZ1doaXRlc3BhY2UsIGhlcmVDb21tZW50LCBoZXJlVHJhaWxpbmdXaGl0ZXNwYWNlLCBsaW5lQ29tbWVudF0gPSBtYXRjaFxuICAgIGNvbnRlbnRzID0gbnVsbFxuICAgICMgRG9lcyB0aGlzIGNvbW1lbnQgZm9sbG93IGNvZGUgb24gdGhlIHNhbWUgbGluZT9cbiAgICBsZWFkaW5nTmV3bGluZSA9IC9eXFxzKlxcbitcXHMqIy8udGVzdCBjb21tZW50V2l0aFN1cnJvdW5kaW5nV2hpdGVzcGFjZVxuICAgIGlmIGhlcmVDb21tZW50XG4gICAgICBtYXRjaElsbGVnYWwgPSBIRVJFQ09NTUVOVF9JTExFR0FMLmV4ZWMgaGVyZUNvbW1lbnRcbiAgICAgIGlmIG1hdGNoSWxsZWdhbFxuICAgICAgICBAZXJyb3IgXCJibG9jayBjb21tZW50cyBjYW5ub3QgY29udGFpbiAje21hdGNoSWxsZWdhbFswXX1cIixcbiAgICAgICAgICBvZmZzZXQ6ICcjIyMnLmxlbmd0aCArIG1hdGNoSWxsZWdhbC5pbmRleCwgbGVuZ3RoOiBtYXRjaElsbGVnYWxbMF0ubGVuZ3RoXG5cbiAgICAgICMgUGFyc2UgaW5kZW50YXRpb24gb3Igb3V0ZGVudGF0aW9uIGFzIGlmIHRoaXMgYmxvY2sgY29tbWVudCBkaWRu4oCZdCBleGlzdC5cbiAgICAgIGNodW5rID0gY2h1bmsucmVwbGFjZSBcIiMjIyN7aGVyZUNvbW1lbnR9IyMjXCIsICcnXG4gICAgICAjIFJlbW92ZSBsZWFkaW5nIG5ld2xpbmVzLCBsaWtlIGBSZXdyaXRlcjo6cmVtb3ZlTGVhZGluZ05ld2xpbmVzYCwgdG9cbiAgICAgICMgYXZvaWQgdGhlIGNyZWF0aW9uIG9mIHVud2FudGVkIGBURVJNSU5BVE9SYCB0b2tlbnMuXG4gICAgICBjaHVuayA9IGNodW5rLnJlcGxhY2UgL15cXG4rLywgJydcbiAgICAgIEBsaW5lVG9rZW4ge2NodW5rfVxuXG4gICAgICAjIFB1bGwgb3V0IHRoZSAjIyMtc3R5bGUgY29tbWVudOKAmXMgY29udGVudCwgYW5kIGZvcm1hdCBpdC5cbiAgICAgIGNvbnRlbnQgPSBoZXJlQ29tbWVudFxuICAgICAgY29udGVudHMgPSBbe1xuICAgICAgICBjb250ZW50XG4gICAgICAgIGxlbmd0aDogY29tbWVudFdpdGhTdXJyb3VuZGluZ1doaXRlc3BhY2UubGVuZ3RoIC0gaGVyZUxlYWRpbmdXaGl0ZXNwYWNlLmxlbmd0aCAtIGhlcmVUcmFpbGluZ1doaXRlc3BhY2UubGVuZ3RoXG4gICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlOiBoZXJlTGVhZGluZ1doaXRlc3BhY2VcbiAgICAgIH1dXG4gICAgZWxzZVxuICAgICAgIyBUaGUgYENPTU1FTlRgIHJlZ2V4IGNhcHR1cmVzIHN1Y2Nlc3NpdmUgbGluZSBjb21tZW50cyBhcyBvbmUgdG9rZW4uXG4gICAgICAjIFJlbW92ZSBhbnkgbGVhZGluZyBuZXdsaW5lcyBiZWZvcmUgdGhlIGZpcnN0IGNvbW1lbnQsIGJ1dCBwcmVzZXJ2ZVxuICAgICAgIyBibGFuayBsaW5lcyBiZXR3ZWVuIGxpbmUgY29tbWVudHMuXG4gICAgICBsZWFkaW5nTmV3bGluZXMgPSAnJ1xuICAgICAgY29udGVudCA9IGxpbmVDb21tZW50LnJlcGxhY2UgL14oXFxuKikvLCAobGVhZGluZykgLT5cbiAgICAgICAgbGVhZGluZ05ld2xpbmVzID0gbGVhZGluZ1xuICAgICAgICAnJ1xuICAgICAgcHJlY2VkaW5nTm9uQ29tbWVudExpbmVzID0gJydcbiAgICAgIGhhc1NlZW5GaXJzdENvbW1lbnRMaW5lID0gbm9cbiAgICAgIGNvbnRlbnRzID1cbiAgICAgICAgY29udGVudC5zcGxpdCAnXFxuJ1xuICAgICAgICAubWFwIChsaW5lLCBpbmRleCkgLT5cbiAgICAgICAgICB1bmxlc3MgbGluZS5pbmRleE9mKCcjJykgPiAtMVxuICAgICAgICAgICAgcHJlY2VkaW5nTm9uQ29tbWVudExpbmVzICs9IFwiXFxuI3tsaW5lfVwiXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZSA9ICcnXG4gICAgICAgICAgY29udGVudCA9IGxpbmUucmVwbGFjZSAvXihbIHxcXHRdKikjLywgKF8sIHdoaXRlc3BhY2UpIC0+XG4gICAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZSA9IHdoaXRlc3BhY2VcbiAgICAgICAgICAgICcnXG4gICAgICAgICAgY29tbWVudCA9IHtcbiAgICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgICAgIGxlbmd0aDogJyMnLmxlbmd0aCArIGNvbnRlbnQubGVuZ3RoXG4gICAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZTogXCIje3VubGVzcyBoYXNTZWVuRmlyc3RDb21tZW50TGluZSB0aGVuIGxlYWRpbmdOZXdsaW5lcyBlbHNlICcnfSN7cHJlY2VkaW5nTm9uQ29tbWVudExpbmVzfSN7bGVhZGluZ1doaXRlc3BhY2V9XCJcbiAgICAgICAgICAgIHByZWNlZGVkQnlCbGFua0xpbmU6ICEhcHJlY2VkaW5nTm9uQ29tbWVudExpbmVzXG4gICAgICAgICAgfVxuICAgICAgICAgIGhhc1NlZW5GaXJzdENvbW1lbnRMaW5lID0geWVzXG4gICAgICAgICAgcHJlY2VkaW5nTm9uQ29tbWVudExpbmVzID0gJydcbiAgICAgICAgICBjb21tZW50XG4gICAgICAgIC5maWx0ZXIgKGNvbW1lbnQpIC0+IGNvbW1lbnRcblxuICAgIGdldEluZGVudFNpemUgPSAoe2xlYWRpbmdXaGl0ZXNwYWNlLCBub25Jbml0aWFsfSkgLT5cbiAgICAgIGxhc3ROZXdsaW5lSW5kZXggPSBsZWFkaW5nV2hpdGVzcGFjZS5sYXN0SW5kZXhPZiAnXFxuJ1xuICAgICAgaWYgaGVyZUNvbW1lbnQ/IG9yIG5vdCBub25Jbml0aWFsXG4gICAgICAgIHJldHVybiBudWxsIHVubGVzcyBsYXN0TmV3bGluZUluZGV4ID4gLTFcbiAgICAgIGVsc2VcbiAgICAgICAgbGFzdE5ld2xpbmVJbmRleCA/PSAtMVxuICAgICAgbGVhZGluZ1doaXRlc3BhY2UubGVuZ3RoIC0gMSAtIGxhc3ROZXdsaW5lSW5kZXhcbiAgICBjb21tZW50QXR0YWNobWVudHMgPSBmb3Ige2NvbnRlbnQsIGxlbmd0aCwgbGVhZGluZ1doaXRlc3BhY2UsIHByZWNlZGVkQnlCbGFua0xpbmV9LCBpIGluIGNvbnRlbnRzXG4gICAgICBub25Jbml0aWFsID0gaSBpc250IDBcbiAgICAgIGxlYWRpbmdOZXdsaW5lT2Zmc2V0ID0gaWYgbm9uSW5pdGlhbCB0aGVuIDEgZWxzZSAwXG4gICAgICBvZmZzZXRJbkNodW5rICs9IGxlYWRpbmdOZXdsaW5lT2Zmc2V0ICsgbGVhZGluZ1doaXRlc3BhY2UubGVuZ3RoXG4gICAgICBpbmRlbnRTaXplID0gZ2V0SW5kZW50U2l6ZSB7bGVhZGluZ1doaXRlc3BhY2UsIG5vbkluaXRpYWx9XG4gICAgICBub0luZGVudCA9IG5vdCBpbmRlbnRTaXplPyBvciBpbmRlbnRTaXplIGlzIC0xXG4gICAgICBjb21tZW50QXR0YWNobWVudCA9IHtcbiAgICAgICAgY29udGVudFxuICAgICAgICBoZXJlOiBoZXJlQ29tbWVudD9cbiAgICAgICAgbmV3TGluZTogbGVhZGluZ05ld2xpbmUgb3Igbm9uSW5pdGlhbCAjIExpbmUgY29tbWVudHMgYWZ0ZXIgdGhlIGZpcnN0IG9uZSBzdGFydCBuZXcgbGluZXMsIGJ5IGRlZmluaXRpb24uXG4gICAgICAgIGxvY2F0aW9uRGF0YTogQG1ha2VMb2NhdGlvbkRhdGEge29mZnNldEluQ2h1bmssIGxlbmd0aH1cbiAgICAgICAgcHJlY2VkZWRCeUJsYW5rTGluZVxuICAgICAgICBpbmRlbnRTaXplXG4gICAgICAgIGluZGVudGVkOiAgbm90IG5vSW5kZW50IGFuZCBpbmRlbnRTaXplID4gQGluZGVudFxuICAgICAgICBvdXRkZW50ZWQ6IG5vdCBub0luZGVudCBhbmQgaW5kZW50U2l6ZSA8IEBpbmRlbnRcbiAgICAgIH1cbiAgICAgIGNvbW1lbnRBdHRhY2htZW50LmhlcmVnZXggPSB5ZXMgaWYgaGVyZWdleFxuICAgICAgb2Zmc2V0SW5DaHVuayArPSBsZW5ndGhcbiAgICAgIGNvbW1lbnRBdHRhY2htZW50XG5cbiAgICBwcmV2ID0gQHByZXYoKVxuICAgIHVubGVzcyBwcmV2XG4gICAgICAjIElmIHRoZXJl4oCZcyBubyBwcmV2aW91cyB0b2tlbiwgY3JlYXRlIGEgcGxhY2Vob2xkZXIgdG9rZW4gdG8gYXR0YWNoXG4gICAgICAjIHRoaXMgY29tbWVudCB0bzsgYW5kIGZvbGxvdyB3aXRoIGEgbmV3bGluZS5cbiAgICAgIGNvbW1lbnRBdHRhY2htZW50c1swXS5uZXdMaW5lID0geWVzXG4gICAgICBAbGluZVRva2VuIGNodW5rOiBAY2h1bmtbY29tbWVudFdpdGhTdXJyb3VuZGluZ1doaXRlc3BhY2UubGVuZ3RoLi5dLCBvZmZzZXQ6IGNvbW1lbnRXaXRoU3Vycm91bmRpbmdXaGl0ZXNwYWNlLmxlbmd0aCAjIFNldCB0aGUgaW5kZW50LlxuICAgICAgcGxhY2Vob2xkZXJUb2tlbiA9IEBtYWtlVG9rZW4gJ0pTJywgJycsIG9mZnNldDogY29tbWVudFdpdGhTdXJyb3VuZGluZ1doaXRlc3BhY2UubGVuZ3RoLCBnZW5lcmF0ZWQ6IHllc1xuICAgICAgcGxhY2Vob2xkZXJUb2tlbi5jb21tZW50cyA9IGNvbW1lbnRBdHRhY2htZW50c1xuICAgICAgQHRva2Vucy5wdXNoIHBsYWNlaG9sZGVyVG9rZW5cbiAgICAgIEBuZXdsaW5lVG9rZW4gY29tbWVudFdpdGhTdXJyb3VuZGluZ1doaXRlc3BhY2UubGVuZ3RoXG4gICAgZWxzZVxuICAgICAgYXR0YWNoQ29tbWVudHNUb05vZGUgY29tbWVudEF0dGFjaG1lbnRzLCBwcmV2XG5cbiAgICByZXR1cm4gY29tbWVudEF0dGFjaG1lbnRzIGlmIHJldHVybkNvbW1lbnRUb2tlbnNcbiAgICBjb21tZW50V2l0aFN1cnJvdW5kaW5nV2hpdGVzcGFjZS5sZW5ndGhcblxuICAjIE1hdGNoZXMgSmF2YVNjcmlwdCBpbnRlcnBvbGF0ZWQgZGlyZWN0bHkgaW50byB0aGUgc291cmNlIHZpYSBiYWNrdGlja3MuXG4gIGpzVG9rZW46IC0+XG4gICAgcmV0dXJuIDAgdW5sZXNzIEBjaHVuay5jaGFyQXQoMCkgaXMgJ2AnIGFuZFxuICAgICAgKG1hdGNoID0gKG1hdGNoZWRIZXJlID0gSEVSRV9KU1RPS0VOLmV4ZWMoQGNodW5rKSkgb3IgSlNUT0tFTi5leGVjKEBjaHVuaykpXG4gICAgIyBDb252ZXJ0IGVzY2FwZWQgYmFja3RpY2tzIHRvIGJhY2t0aWNrcywgYW5kIGVzY2FwZWQgYmFja3NsYXNoZXNcbiAgICAjIGp1c3QgYmVmb3JlIGVzY2FwZWQgYmFja3RpY2tzIHRvIGJhY2tzbGFzaGVzXG4gICAgc2NyaXB0ID0gbWF0Y2hbMV1cbiAgICB7bGVuZ3RofSA9IG1hdGNoWzBdXG4gICAgQHRva2VuICdKUycsIHNjcmlwdCwge2xlbmd0aCwgZGF0YToge2hlcmU6ICEhbWF0Y2hlZEhlcmV9fVxuICAgIGxlbmd0aFxuXG4gICMgTWF0Y2hlcyByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbHMsIGFzIHdlbGwgYXMgbXVsdGlsaW5lIGV4dGVuZGVkIG9uZXMuXG4gICMgTGV4aW5nIHJlZ3VsYXIgZXhwcmVzc2lvbnMgaXMgZGlmZmljdWx0IHRvIGRpc3Rpbmd1aXNoIGZyb20gZGl2aXNpb24sIHNvIHdlXG4gICMgYm9ycm93IHNvbWUgYmFzaWMgaGV1cmlzdGljcyBmcm9tIEphdmFTY3JpcHQgYW5kIFJ1YnkuXG4gIHJlZ2V4VG9rZW46IC0+XG4gICAgc3dpdGNoXG4gICAgICB3aGVuIG1hdGNoID0gUkVHRVhfSUxMRUdBTC5leGVjIEBjaHVua1xuICAgICAgICBAZXJyb3IgXCJyZWd1bGFyIGV4cHJlc3Npb25zIGNhbm5vdCBiZWdpbiB3aXRoICN7bWF0Y2hbMl19XCIsXG4gICAgICAgICAgb2Zmc2V0OiBtYXRjaC5pbmRleCArIG1hdGNoWzFdLmxlbmd0aFxuICAgICAgd2hlbiBtYXRjaCA9IEBtYXRjaFdpdGhJbnRlcnBvbGF0aW9ucyBIRVJFR0VYLCAnLy8vJ1xuICAgICAgICB7dG9rZW5zLCBpbmRleH0gPSBtYXRjaFxuICAgICAgICBjb21tZW50cyA9IFtdXG4gICAgICAgIHdoaWxlIG1hdGNoZWRDb21tZW50ID0gSEVSRUdFWF9DT01NRU5ULmV4ZWMgQGNodW5rWzAuLi5pbmRleF1cbiAgICAgICAgICB7aW5kZXg6IGNvbW1lbnRJbmRleH0gPSBtYXRjaGVkQ29tbWVudFxuICAgICAgICAgIFtmdWxsTWF0Y2gsIGxlYWRpbmdXaGl0ZXNwYWNlLCBjb21tZW50XSA9IG1hdGNoZWRDb21tZW50XG4gICAgICAgICAgY29tbWVudHMucHVzaCB7Y29tbWVudCwgb2Zmc2V0SW5DaHVuazogY29tbWVudEluZGV4ICsgbGVhZGluZ1doaXRlc3BhY2UubGVuZ3RofVxuICAgICAgICBjb21tZW50VG9rZW5zID0gZmxhdHRlbihcbiAgICAgICAgICBmb3IgY29tbWVudE9wdHMgaW4gY29tbWVudHNcbiAgICAgICAgICAgIEBjb21tZW50VG9rZW4gY29tbWVudE9wdHMuY29tbWVudCwgT2JqZWN0LmFzc2lnbiBjb21tZW50T3B0cywgaGVyZWdleDogeWVzLCByZXR1cm5Db21tZW50VG9rZW5zOiB5ZXNcbiAgICAgICAgKVxuICAgICAgd2hlbiBtYXRjaCA9IFJFR0VYLmV4ZWMgQGNodW5rXG4gICAgICAgIFtyZWdleCwgYm9keSwgY2xvc2VkXSA9IG1hdGNoXG4gICAgICAgIEB2YWxpZGF0ZUVzY2FwZXMgYm9keSwgaXNSZWdleDogeWVzLCBvZmZzZXRJbkNodW5rOiAxXG4gICAgICAgIGluZGV4ID0gcmVnZXgubGVuZ3RoXG4gICAgICAgIHByZXYgPSBAcHJldigpXG4gICAgICAgIGlmIHByZXZcbiAgICAgICAgICBpZiBwcmV2LnNwYWNlZCBhbmQgcHJldlswXSBpbiBDQUxMQUJMRVxuICAgICAgICAgICAgcmV0dXJuIDAgaWYgbm90IGNsb3NlZCBvciBQT1NTSUJMWV9ESVZJU0lPTi50ZXN0IHJlZ2V4XG4gICAgICAgICAgZWxzZSBpZiBwcmV2WzBdIGluIE5PVF9SRUdFWFxuICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgQGVycm9yICdtaXNzaW5nIC8gKHVuY2xvc2VkIHJlZ2V4KScgdW5sZXNzIGNsb3NlZFxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gMFxuXG4gICAgW2ZsYWdzXSA9IFJFR0VYX0ZMQUdTLmV4ZWMgQGNodW5rW2luZGV4Li5dXG4gICAgZW5kID0gaW5kZXggKyBmbGFncy5sZW5ndGhcbiAgICBvcmlnaW4gPSBAbWFrZVRva2VuICdSRUdFWCcsIG51bGwsIGxlbmd0aDogZW5kXG4gICAgc3dpdGNoXG4gICAgICB3aGVuIG5vdCBWQUxJRF9GTEFHUy50ZXN0IGZsYWdzXG4gICAgICAgIEBlcnJvciBcImludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWdzICN7ZmxhZ3N9XCIsIG9mZnNldDogaW5kZXgsIGxlbmd0aDogZmxhZ3MubGVuZ3RoXG4gICAgICB3aGVuIHJlZ2V4IG9yIHRva2Vucy5sZW5ndGggaXMgMVxuICAgICAgICBkZWxpbWl0ZXIgPSBpZiBib2R5IHRoZW4gJy8nIGVsc2UgJy8vLydcbiAgICAgICAgYm9keSA/PSB0b2tlbnNbMF1bMV1cbiAgICAgICAgQHZhbGlkYXRlVW5pY29kZUNvZGVQb2ludEVzY2FwZXMgYm9keSwge2RlbGltaXRlcn1cbiAgICAgICAgQHRva2VuICdSRUdFWCcsIFwiLyN7Ym9keX0vI3tmbGFnc31cIiwge2xlbmd0aDogZW5kLCBvcmlnaW4sIGRhdGE6IHtkZWxpbWl0ZXJ9fVxuICAgICAgZWxzZVxuICAgICAgICBAdG9rZW4gJ1JFR0VYX1NUQVJUJywgJygnLCAgICB7bGVuZ3RoOiAwLCBvcmlnaW4sIGdlbmVyYXRlZDogeWVzfVxuICAgICAgICBAdG9rZW4gJ0lERU5USUZJRVInLCAnUmVnRXhwJywgbGVuZ3RoOiAwLCBnZW5lcmF0ZWQ6IHllc1xuICAgICAgICBAdG9rZW4gJ0NBTExfU1RBUlQnLCAnKCcsICAgICAgbGVuZ3RoOiAwLCBnZW5lcmF0ZWQ6IHllc1xuICAgICAgICBAbWVyZ2VJbnRlcnBvbGF0aW9uVG9rZW5zIHRva2Vucywge2RvdWJsZTogeWVzLCBoZXJlZ2V4OiB7ZmxhZ3N9LCBlbmRPZmZzZXQ6IGVuZCAtIGZsYWdzLmxlbmd0aCwgcXVvdGU6ICcvLy8nfSwgKHN0cikgPT5cbiAgICAgICAgICBAdmFsaWRhdGVVbmljb2RlQ29kZVBvaW50RXNjYXBlcyBzdHIsIHtkZWxpbWl0ZXJ9XG4gICAgICAgIGlmIGZsYWdzXG4gICAgICAgICAgQHRva2VuICcsJywgJywnLCAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBpbmRleCAtIDEsIGxlbmd0aDogMCwgZ2VuZXJhdGVkOiB5ZXNcbiAgICAgICAgICBAdG9rZW4gJ1NUUklORycsICdcIicgKyBmbGFncyArICdcIicsIG9mZnNldDogaW5kZXgsICAgICBsZW5ndGg6IGZsYWdzLmxlbmd0aFxuICAgICAgICBAdG9rZW4gJyknLCAnKScsICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogZW5kLCAgICAgICBsZW5ndGg6IDAsIGdlbmVyYXRlZDogeWVzXG4gICAgICAgIEB0b2tlbiAnUkVHRVhfRU5EJywgJyknLCAgICAgICAgICAgICAgb2Zmc2V0OiBlbmQsICAgICAgIGxlbmd0aDogMCwgZ2VuZXJhdGVkOiB5ZXNcblxuICAgICMgRXhwbGljaXRseSBhdHRhY2ggYW55IGhlcmVnZXggY29tbWVudHMgdG8gdGhlIFJFR0VYL1JFR0VYX0VORCB0b2tlbi5cbiAgICBpZiBjb21tZW50VG9rZW5zPy5sZW5ndGhcbiAgICAgIGFkZFRva2VuRGF0YSBAdG9rZW5zW0B0b2tlbnMubGVuZ3RoIC0gMV0sXG4gICAgICAgIGhlcmVnZXhDb21tZW50VG9rZW5zOiBjb21tZW50VG9rZW5zXG5cbiAgICBlbmRcblxuICAjIE1hdGNoZXMgbmV3bGluZXMsIGluZGVudHMsIGFuZCBvdXRkZW50cywgYW5kIGRldGVybWluZXMgd2hpY2ggaXMgd2hpY2guXG4gICMgSWYgd2UgY2FuIGRldGVjdCB0aGF0IHRoZSBjdXJyZW50IGxpbmUgaXMgY29udGludWVkIG9udG8gdGhlIG5leHQgbGluZSxcbiAgIyB0aGVuIHRoZSBuZXdsaW5lIGlzIHN1cHByZXNzZWQ6XG4gICNcbiAgIyAgICAgZWxlbWVudHNcbiAgIyAgICAgICAuZWFjaCggLi4uIClcbiAgIyAgICAgICAubWFwKCAuLi4gKVxuICAjXG4gICMgS2VlcHMgdHJhY2sgb2YgdGhlIGxldmVsIG9mIGluZGVudGF0aW9uLCBiZWNhdXNlIGEgc2luZ2xlIG91dGRlbnQgdG9rZW5cbiAgIyBjYW4gY2xvc2UgbXVsdGlwbGUgaW5kZW50cywgc28gd2UgbmVlZCB0byBrbm93IGhvdyBmYXIgaW4gd2UgaGFwcGVuIHRvIGJlLlxuICBsaW5lVG9rZW46ICh7Y2h1bmsgPSBAY2h1bmssIG9mZnNldCA9IDB9ID0ge30pIC0+XG4gICAgcmV0dXJuIDAgdW5sZXNzIG1hdGNoID0gTVVMVElfREVOVC5leGVjIGNodW5rXG4gICAgaW5kZW50ID0gbWF0Y2hbMF1cblxuICAgIHByZXYgPSBAcHJldigpXG4gICAgYmFja3NsYXNoID0gcHJldj9bMF0gaXMgJ1xcXFwnXG4gICAgQHNlZW5Gb3IgPSBubyB1bmxlc3MgKGJhY2tzbGFzaCBvciBAc2VlbkZvcj8uZW5kc0xlbmd0aCA8IEBlbmRzLmxlbmd0aCkgYW5kIEBzZWVuRm9yXG4gICAgQHNlZW5JbXBvcnQgPSBubyB1bmxlc3MgKGJhY2tzbGFzaCBhbmQgQHNlZW5JbXBvcnQpIG9yIEBpbXBvcnRTcGVjaWZpZXJMaXN0XG4gICAgQHNlZW5FeHBvcnQgPSBubyB1bmxlc3MgKGJhY2tzbGFzaCBhbmQgQHNlZW5FeHBvcnQpIG9yIEBleHBvcnRTcGVjaWZpZXJMaXN0XG5cbiAgICBzaXplID0gaW5kZW50Lmxlbmd0aCAtIDEgLSBpbmRlbnQubGFzdEluZGV4T2YgJ1xcbidcbiAgICBub05ld2xpbmVzID0gQHVuZmluaXNoZWQoKVxuXG4gICAgbmV3SW5kZW50TGl0ZXJhbCA9IGlmIHNpemUgPiAwIHRoZW4gaW5kZW50Wy1zaXplLi5dIGVsc2UgJydcbiAgICB1bmxlc3MgL14oLj8pXFwxKiQvLmV4ZWMgbmV3SW5kZW50TGl0ZXJhbFxuICAgICAgQGVycm9yICdtaXhlZCBpbmRlbnRhdGlvbicsIG9mZnNldDogaW5kZW50Lmxlbmd0aFxuICAgICAgcmV0dXJuIGluZGVudC5sZW5ndGhcblxuICAgIG1pbkxpdGVyYWxMZW5ndGggPSBNYXRoLm1pbiBuZXdJbmRlbnRMaXRlcmFsLmxlbmd0aCwgQGluZGVudExpdGVyYWwubGVuZ3RoXG4gICAgaWYgbmV3SW5kZW50TGl0ZXJhbFsuLi5taW5MaXRlcmFsTGVuZ3RoXSBpc250IEBpbmRlbnRMaXRlcmFsWy4uLm1pbkxpdGVyYWxMZW5ndGhdXG4gICAgICBAZXJyb3IgJ2luZGVudGF0aW9uIG1pc21hdGNoJywgb2Zmc2V0OiBpbmRlbnQubGVuZ3RoXG4gICAgICByZXR1cm4gaW5kZW50Lmxlbmd0aFxuXG4gICAgaWYgc2l6ZSAtIEBjb250aW51YXRpb25MaW5lQWRkaXRpb25hbEluZGVudCBpcyBAaW5kZW50XG4gICAgICBpZiBub05ld2xpbmVzIHRoZW4gQHN1cHByZXNzTmV3bGluZXMoKSBlbHNlIEBuZXdsaW5lVG9rZW4gb2Zmc2V0XG4gICAgICByZXR1cm4gaW5kZW50Lmxlbmd0aFxuXG4gICAgaWYgc2l6ZSA+IEBpbmRlbnRcbiAgICAgIGlmIG5vTmV3bGluZXNcbiAgICAgICAgQGNvbnRpbnVhdGlvbkxpbmVBZGRpdGlvbmFsSW5kZW50ID0gc2l6ZSAtIEBpbmRlbnQgdW5sZXNzIGJhY2tzbGFzaFxuICAgICAgICBpZiBAY29udGludWF0aW9uTGluZUFkZGl0aW9uYWxJbmRlbnRcbiAgICAgICAgICBwcmV2LmNvbnRpbnVhdGlvbkxpbmVJbmRlbnQgPSBAaW5kZW50ICsgQGNvbnRpbnVhdGlvbkxpbmVBZGRpdGlvbmFsSW5kZW50XG4gICAgICAgIEBzdXBwcmVzc05ld2xpbmVzKClcbiAgICAgICAgcmV0dXJuIGluZGVudC5sZW5ndGhcbiAgICAgIHVubGVzcyBAdG9rZW5zLmxlbmd0aFxuICAgICAgICBAYmFzZUluZGVudCA9IEBpbmRlbnQgPSBzaXplXG4gICAgICAgIEBpbmRlbnRMaXRlcmFsID0gbmV3SW5kZW50TGl0ZXJhbFxuICAgICAgICByZXR1cm4gaW5kZW50Lmxlbmd0aFxuICAgICAgZGlmZiA9IHNpemUgLSBAaW5kZW50ICsgQG91dGRlYnRcbiAgICAgIEB0b2tlbiAnSU5ERU5UJywgZGlmZiwgb2Zmc2V0OiBvZmZzZXQgKyBpbmRlbnQubGVuZ3RoIC0gc2l6ZSwgbGVuZ3RoOiBzaXplXG4gICAgICBAaW5kZW50cy5wdXNoIGRpZmZcbiAgICAgIEBlbmRzLnB1c2gge3RhZzogJ09VVERFTlQnfVxuICAgICAgQG91dGRlYnQgPSBAY29udGludWF0aW9uTGluZUFkZGl0aW9uYWxJbmRlbnQgPSAwXG4gICAgICBAaW5kZW50ID0gc2l6ZVxuICAgICAgQGluZGVudExpdGVyYWwgPSBuZXdJbmRlbnRMaXRlcmFsXG4gICAgZWxzZSBpZiBzaXplIDwgQGJhc2VJbmRlbnRcbiAgICAgIEBlcnJvciAnbWlzc2luZyBpbmRlbnRhdGlvbicsIG9mZnNldDogb2Zmc2V0ICsgaW5kZW50Lmxlbmd0aFxuICAgIGVsc2VcbiAgICAgIGVuZHNDb250aW51YXRpb25MaW5lSW5kZW50YXRpb24gPSBAY29udGludWF0aW9uTGluZUFkZGl0aW9uYWxJbmRlbnQgPiAwXG4gICAgICBAY29udGludWF0aW9uTGluZUFkZGl0aW9uYWxJbmRlbnQgPSAwXG4gICAgICBAb3V0ZGVudFRva2VuIHttb3ZlT3V0OiBAaW5kZW50IC0gc2l6ZSwgbm9OZXdsaW5lcywgb3V0ZGVudExlbmd0aDogaW5kZW50Lmxlbmd0aCwgb2Zmc2V0LCBpbmRlbnRTaXplOiBzaXplLCBlbmRzQ29udGludWF0aW9uTGluZUluZGVudGF0aW9ufVxuICAgIGluZGVudC5sZW5ndGhcblxuICAjIFJlY29yZCBhbiBvdXRkZW50IHRva2VuIG9yIG11bHRpcGxlIHRva2VucywgaWYgd2UgaGFwcGVuIHRvIGJlIG1vdmluZyBiYWNrXG4gICMgaW53YXJkcyBwYXN0IHNldmVyYWwgcmVjb3JkZWQgaW5kZW50cy4gU2V0cyBuZXcgQGluZGVudCB2YWx1ZS5cbiAgb3V0ZGVudFRva2VuOiAoe21vdmVPdXQsIG5vTmV3bGluZXMsIG91dGRlbnRMZW5ndGggPSAwLCBvZmZzZXQgPSAwLCBpbmRlbnRTaXplLCBlbmRzQ29udGludWF0aW9uTGluZUluZGVudGF0aW9ufSkgLT5cbiAgICBkZWNyZWFzZWRJbmRlbnQgPSBAaW5kZW50IC0gbW92ZU91dFxuICAgIHdoaWxlIG1vdmVPdXQgPiAwXG4gICAgICBsYXN0SW5kZW50ID0gQGluZGVudHNbQGluZGVudHMubGVuZ3RoIC0gMV1cbiAgICAgIGlmIG5vdCBsYXN0SW5kZW50XG4gICAgICAgIEBvdXRkZWJ0ID0gbW92ZU91dCA9IDBcbiAgICAgIGVsc2UgaWYgQG91dGRlYnQgYW5kIG1vdmVPdXQgPD0gQG91dGRlYnRcbiAgICAgICAgQG91dGRlYnQgLT0gbW92ZU91dFxuICAgICAgICBtb3ZlT3V0ICAgPSAwXG4gICAgICBlbHNlXG4gICAgICAgIGRlbnQgPSBAaW5kZW50cy5wb3AoKSArIEBvdXRkZWJ0XG4gICAgICAgIGlmIG91dGRlbnRMZW5ndGggYW5kIEBjaHVua1tvdXRkZW50TGVuZ3RoXSBpbiBJTkRFTlRBQkxFX0NMT1NFUlNcbiAgICAgICAgICBkZWNyZWFzZWRJbmRlbnQgLT0gZGVudCAtIG1vdmVPdXRcbiAgICAgICAgICBtb3ZlT3V0ID0gZGVudFxuICAgICAgICBAb3V0ZGVidCA9IDBcbiAgICAgICAgIyBwYWlyIG1pZ2h0IGNhbGwgb3V0ZGVudFRva2VuLCBzbyBwcmVzZXJ2ZSBkZWNyZWFzZWRJbmRlbnRcbiAgICAgICAgQHBhaXIgJ09VVERFTlQnXG4gICAgICAgIEB0b2tlbiAnT1VUREVOVCcsIG1vdmVPdXQsIGxlbmd0aDogb3V0ZGVudExlbmd0aCwgaW5kZW50U2l6ZTogaW5kZW50U2l6ZSArIG1vdmVPdXQgLSBkZW50XG4gICAgICAgIG1vdmVPdXQgLT0gZGVudFxuICAgIEBvdXRkZWJ0IC09IG1vdmVPdXQgaWYgZGVudFxuICAgIEBzdXBwcmVzc1NlbWljb2xvbnMoKVxuXG4gICAgdW5sZXNzIEB0YWcoKSBpcyAnVEVSTUlOQVRPUicgb3Igbm9OZXdsaW5lc1xuICAgICAgdGVybWluYXRvclRva2VuID0gQHRva2VuICdURVJNSU5BVE9SJywgJ1xcbicsIG9mZnNldDogb2Zmc2V0ICsgb3V0ZGVudExlbmd0aCwgbGVuZ3RoOiAwXG4gICAgICB0ZXJtaW5hdG9yVG9rZW4uZW5kc0NvbnRpbnVhdGlvbkxpbmVJbmRlbnRhdGlvbiA9IHtwcmVDb250aW51YXRpb25MaW5lSW5kZW50OiBAaW5kZW50fSBpZiBlbmRzQ29udGludWF0aW9uTGluZUluZGVudGF0aW9uXG4gICAgQGluZGVudCA9IGRlY3JlYXNlZEluZGVudFxuICAgIEBpbmRlbnRMaXRlcmFsID0gQGluZGVudExpdGVyYWxbLi4uZGVjcmVhc2VkSW5kZW50XVxuICAgIHRoaXNcblxuICAjIE1hdGNoZXMgYW5kIGNvbnN1bWVzIG5vbi1tZWFuaW5nZnVsIHdoaXRlc3BhY2UuIFRhZyB0aGUgcHJldmlvdXMgdG9rZW5cbiAgIyBhcyBiZWluZyDigJxzcGFjZWTigJ0sIGJlY2F1c2UgdGhlcmUgYXJlIHNvbWUgY2FzZXMgd2hlcmUgaXQgbWFrZXMgYSBkaWZmZXJlbmNlLlxuICB3aGl0ZXNwYWNlVG9rZW46IC0+XG4gICAgcmV0dXJuIDAgdW5sZXNzIChtYXRjaCA9IFdISVRFU1BBQ0UuZXhlYyBAY2h1bmspIG9yXG4gICAgICAgICAgICAgICAgICAgIChubGluZSA9IEBjaHVuay5jaGFyQXQoMCkgaXMgJ1xcbicpXG4gICAgcHJldiA9IEBwcmV2KClcbiAgICBwcmV2W2lmIG1hdGNoIHRoZW4gJ3NwYWNlZCcgZWxzZSAnbmV3TGluZSddID0gdHJ1ZSBpZiBwcmV2XG4gICAgaWYgbWF0Y2ggdGhlbiBtYXRjaFswXS5sZW5ndGggZWxzZSAwXG5cbiAgIyBHZW5lcmF0ZSBhIG5ld2xpbmUgdG9rZW4uIENvbnNlY3V0aXZlIG5ld2xpbmVzIGdldCBtZXJnZWQgdG9nZXRoZXIuXG4gIG5ld2xpbmVUb2tlbjogKG9mZnNldCkgLT5cbiAgICBAc3VwcHJlc3NTZW1pY29sb25zKClcbiAgICBAdG9rZW4gJ1RFUk1JTkFUT1InLCAnXFxuJywge29mZnNldCwgbGVuZ3RoOiAwfSB1bmxlc3MgQHRhZygpIGlzICdURVJNSU5BVE9SJ1xuICAgIHRoaXNcblxuICAjIFVzZSBhIGBcXGAgYXQgYSBsaW5lLWVuZGluZyB0byBzdXBwcmVzcyB0aGUgbmV3bGluZS5cbiAgIyBUaGUgc2xhc2ggaXMgcmVtb3ZlZCBoZXJlIG9uY2UgaXRzIGpvYiBpcyBkb25lLlxuICBzdXBwcmVzc05ld2xpbmVzOiAtPlxuICAgIHByZXYgPSBAcHJldigpXG4gICAgaWYgcHJldlsxXSBpcyAnXFxcXCdcbiAgICAgIGlmIHByZXYuY29tbWVudHMgYW5kIEB0b2tlbnMubGVuZ3RoID4gMVxuICAgICAgICAjIGBAdG9rZW5zLmxlbmd0aGAgc2hvdWxkIGJlIGF0IGxlYXN0IDIgKHNvbWUgY29kZSwgdGhlbiBgXFxgKS5cbiAgICAgICAgIyBJZiBzb21ldGhpbmcgcHV0cyBhIGBcXGAgYWZ0ZXIgbm90aGluZywgdGhleSBkZXNlcnZlIHRvIGxvc2UgYW55XG4gICAgICAgICMgY29tbWVudHMgdGhhdCB0cmFpbCBpdC5cbiAgICAgICAgYXR0YWNoQ29tbWVudHNUb05vZGUgcHJldi5jb21tZW50cywgQHRva2Vuc1tAdG9rZW5zLmxlbmd0aCAtIDJdXG4gICAgICBAdG9rZW5zLnBvcCgpXG4gICAgdGhpc1xuXG4gIGpzeFRva2VuOiAtPlxuICAgIGZpcnN0Q2hhciA9IEBjaHVua1swXVxuICAgICMgQ2hlY2sgdGhlIHByZXZpb3VzIHRva2VuIHRvIGRldGVjdCBpZiBhdHRyaWJ1dGUgaXMgc3ByZWFkLlxuICAgIHByZXZDaGFyID0gaWYgQHRva2Vucy5sZW5ndGggPiAwIHRoZW4gQHRva2Vuc1tAdG9rZW5zLmxlbmd0aCAtIDFdWzBdIGVsc2UgJydcbiAgICBpZiBmaXJzdENoYXIgaXMgJzwnXG4gICAgICBtYXRjaCA9IEpTWF9JREVOVElGSUVSLmV4ZWMoQGNodW5rWzEuLi5dKSBvciBKU1hfRlJBR01FTlRfSURFTlRJRklFUi5leGVjKEBjaHVua1sxLi4uXSlcbiAgICAgIHJldHVybiAwIHVubGVzcyBtYXRjaCBhbmQgKFxuICAgICAgICBAanN4RGVwdGggPiAwIG9yXG4gICAgICAgICMgTm90IHRoZSByaWdodCBoYW5kIHNpZGUgb2YgYW4gdW5zcGFjZWQgY29tcGFyaXNvbiAoaS5lLiBgYTxiYCkuXG4gICAgICAgIG5vdCAocHJldiA9IEBwcmV2KCkpIG9yXG4gICAgICAgIHByZXYuc3BhY2VkIG9yXG4gICAgICAgIHByZXZbMF0gbm90IGluIENPTVBBUkFCTEVfTEVGVF9TSURFXG4gICAgICApXG4gICAgICBbaW5wdXQsIGlkXSA9IG1hdGNoXG4gICAgICBmdWxsSWQgPSBpZFxuICAgICAgaWYgJy4nIGluIGlkXG4gICAgICAgIFtpZCwgcHJvcGVydGllcy4uLl0gPSBpZC5zcGxpdCAnLidcbiAgICAgIGVsc2VcbiAgICAgICAgcHJvcGVydGllcyA9IFtdXG4gICAgICB0YWdUb2tlbiA9IEB0b2tlbiAnSlNYX1RBRycsIGlkLFxuICAgICAgICBsZW5ndGg6IGlkLmxlbmd0aCArIDFcbiAgICAgICAgZGF0YTpcbiAgICAgICAgICBvcGVuaW5nQnJhY2tldFRva2VuOiBAbWFrZVRva2VuICc8JywgJzwnXG4gICAgICAgICAgdGFnTmFtZVRva2VuOiBAbWFrZVRva2VuICdJREVOVElGSUVSJywgaWQsIG9mZnNldDogMVxuICAgICAgb2Zmc2V0ID0gaWQubGVuZ3RoICsgMVxuICAgICAgZm9yIHByb3BlcnR5IGluIHByb3BlcnRpZXNcbiAgICAgICAgQHRva2VuICcuJywgJy4nLCB7b2Zmc2V0fVxuICAgICAgICBvZmZzZXQgKz0gMVxuICAgICAgICBAdG9rZW4gJ1BST1BFUlRZJywgcHJvcGVydHksIHtvZmZzZXR9XG4gICAgICAgIG9mZnNldCArPSBwcm9wZXJ0eS5sZW5ndGhcbiAgICAgIEB0b2tlbiAnQ0FMTF9TVEFSVCcsICcoJywgZ2VuZXJhdGVkOiB5ZXNcbiAgICAgIEB0b2tlbiAnWycsICdbJywgZ2VuZXJhdGVkOiB5ZXNcbiAgICAgIEBlbmRzLnB1c2gge3RhZzogJy8+Jywgb3JpZ2luOiB0YWdUb2tlbiwgbmFtZTogaWQsIHByb3BlcnRpZXN9XG4gICAgICBAanN4RGVwdGgrK1xuICAgICAgcmV0dXJuIGZ1bGxJZC5sZW5ndGggKyAxXG4gICAgZWxzZSBpZiBqc3hUYWcgPSBAYXRKU1hUYWcoKVxuICAgICAgaWYgQGNodW5rWy4uLjJdIGlzICcvPicgIyBTZWxmLWNsb3NpbmcgdGFnLlxuICAgICAgICBAcGFpciAnLz4nXG4gICAgICAgIEB0b2tlbiAnXScsICddJyxcbiAgICAgICAgICBsZW5ndGg6IDJcbiAgICAgICAgICBnZW5lcmF0ZWQ6IHllc1xuICAgICAgICBAdG9rZW4gJ0NBTExfRU5EJywgJyknLFxuICAgICAgICAgIGxlbmd0aDogMlxuICAgICAgICAgIGdlbmVyYXRlZDogeWVzXG4gICAgICAgICAgZGF0YTpcbiAgICAgICAgICAgIHNlbGZDbG9zaW5nU2xhc2hUb2tlbjogQG1ha2VUb2tlbiAnLycsICcvJ1xuICAgICAgICAgICAgY2xvc2luZ0JyYWNrZXRUb2tlbjogQG1ha2VUb2tlbiAnPicsICc+Jywgb2Zmc2V0OiAxXG4gICAgICAgIEBqc3hEZXB0aC0tXG4gICAgICAgIHJldHVybiAyXG4gICAgICBlbHNlIGlmIGZpcnN0Q2hhciBpcyAneydcbiAgICAgICAgaWYgcHJldkNoYXIgaXMgJzonXG4gICAgICAgICAgIyBUaGlzIHRva2VuIHJlcHJlc2VudHMgdGhlIHN0YXJ0IG9mIGEgSlNYIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgICAgICMgdGhhdOKAmXMgYW4gZXhwcmVzc2lvbiAoZS5nLiB0aGUgYHtifWAgaW4gYDxkaXYgYT17Yn0gLz5gKS5cbiAgICAgICAgICAjIE91ciBncmFtbWFyIHJlcHJlc2VudHMgdGhlIGJlZ2lubmluZ3Mgb2YgZXhwcmVzc2lvbnMgYXMgYChgXG4gICAgICAgICAgIyB0b2tlbnMsIHNvIG1ha2UgdGhpcyBpbnRvIGEgYChgIHRva2VuIHRoYXQgZGlzcGxheXMgYXMgYHtgLlxuICAgICAgICAgIHRva2VuID0gQHRva2VuICcoJywgJ3snXG4gICAgICAgICAgQGpzeE9iakF0dHJpYnV0ZVtAanN4RGVwdGhdID0gbm9cbiAgICAgICAgICAjIHRhZyBhdHRyaWJ1dGUgbmFtZSBhcyBKU1hcbiAgICAgICAgICBhZGRUb2tlbkRhdGEgQHRva2Vuc1tAdG9rZW5zLmxlbmd0aCAtIDNdLFxuICAgICAgICAgICAganN4OiB5ZXNcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRva2VuID0gQHRva2VuICd7JywgJ3snXG4gICAgICAgICAgQGpzeE9iakF0dHJpYnV0ZVtAanN4RGVwdGhdID0geWVzXG4gICAgICAgIEBlbmRzLnB1c2gge3RhZzogJ30nLCBvcmlnaW46IHRva2VufVxuICAgICAgICByZXR1cm4gMVxuICAgICAgZWxzZSBpZiBmaXJzdENoYXIgaXMgJz4nICMgZW5kIG9mIG9wZW5pbmcgdGFnXG4gICAgICAgICMgSWdub3JlIHRlcm1pbmF0b3JzIGluc2lkZSBhIHRhZy5cbiAgICAgICAge29yaWdpbjogb3BlbmluZ1RhZ1Rva2VufSA9IEBwYWlyICcvPicgIyBBcyBpZiB0aGUgY3VycmVudCB0YWcgd2FzIHNlbGYtY2xvc2luZy5cbiAgICAgICAgQHRva2VuICddJywgJ10nLFxuICAgICAgICAgIGdlbmVyYXRlZDogeWVzXG4gICAgICAgICAgZGF0YTpcbiAgICAgICAgICAgIGNsb3NpbmdCcmFja2V0VG9rZW46IEBtYWtlVG9rZW4gJz4nLCAnPidcbiAgICAgICAgQHRva2VuICcsJywgJ0pTWF9DT01NQScsIGdlbmVyYXRlZDogeWVzXG4gICAgICAgIHt0b2tlbnMsIGluZGV4OiBlbmR9ID1cbiAgICAgICAgICBAbWF0Y2hXaXRoSW50ZXJwb2xhdGlvbnMgSU5TSURFX0pTWCwgJz4nLCAnPC8nLCBKU1hfSU5URVJQT0xBVElPTlxuICAgICAgICBAbWVyZ2VJbnRlcnBvbGF0aW9uVG9rZW5zIHRva2Vucywge2VuZE9mZnNldDogZW5kLCBqc3g6IHllc30sICh2YWx1ZSkgPT5cbiAgICAgICAgICBAdmFsaWRhdGVVbmljb2RlQ29kZVBvaW50RXNjYXBlcyB2YWx1ZSwgZGVsaW1pdGVyOiAnPidcbiAgICAgICAgbWF0Y2ggPSBKU1hfSURFTlRJRklFUi5leGVjKEBjaHVua1tlbmQuLi5dKSBvciBKU1hfRlJBR01FTlRfSURFTlRJRklFUi5leGVjKEBjaHVua1tlbmQuLi5dKVxuICAgICAgICBpZiBub3QgbWF0Y2ggb3IgbWF0Y2hbMV0gaXNudCBcIiN7anN4VGFnLm5hbWV9I3soXCIuI3twcm9wZXJ0eX1cIiBmb3IgcHJvcGVydHkgaW4ganN4VGFnLnByb3BlcnRpZXMpLmpvaW4gJyd9XCJcbiAgICAgICAgICBAZXJyb3IgXCJleHBlY3RlZCBjb3JyZXNwb25kaW5nIEpTWCBjbG9zaW5nIHRhZyBmb3IgI3tqc3hUYWcubmFtZX1cIixcbiAgICAgICAgICAgIGpzeFRhZy5vcmlnaW4uZGF0YS50YWdOYW1lVG9rZW5bMl1cbiAgICAgICAgWywgZnVsbFRhZ05hbWVdID0gbWF0Y2hcbiAgICAgICAgYWZ0ZXJUYWcgPSBlbmQgKyBmdWxsVGFnTmFtZS5sZW5ndGhcbiAgICAgICAgaWYgQGNodW5rW2FmdGVyVGFnXSBpc250ICc+J1xuICAgICAgICAgIEBlcnJvciBcIm1pc3NpbmcgY2xvc2luZyA+IGFmdGVyIHRhZyBuYW1lXCIsIG9mZnNldDogYWZ0ZXJUYWcsIGxlbmd0aDogMVxuICAgICAgICAjIC0yLysyIGZvciB0aGUgb3BlbmluZyBgPC9gIGFuZCArMSBmb3IgdGhlIGNsb3NpbmcgYD5gLlxuICAgICAgICBlbmRUb2tlbiA9IEB0b2tlbiAnQ0FMTF9FTkQnLCAnKScsXG4gICAgICAgICAgb2Zmc2V0OiBlbmQgLSAyXG4gICAgICAgICAgbGVuZ3RoOiBmdWxsVGFnTmFtZS5sZW5ndGggKyAzXG4gICAgICAgICAgZ2VuZXJhdGVkOiB5ZXNcbiAgICAgICAgICBkYXRhOlxuICAgICAgICAgICAgY2xvc2luZ1RhZ09wZW5pbmdCcmFja2V0VG9rZW46IEBtYWtlVG9rZW4gJzwnLCAnPCcsIG9mZnNldDogZW5kIC0gMlxuICAgICAgICAgICAgY2xvc2luZ1RhZ1NsYXNoVG9rZW46IEBtYWtlVG9rZW4gJy8nLCAnLycsIG9mZnNldDogZW5kIC0gMVxuICAgICAgICAgICAgIyBUT0RPOiBpbmRpdmlkdWFsIHRva2VucyBmb3IgY29tcGxleCB0YWcgbmFtZT8gZWcgPCAvIEEgLiBCID5cbiAgICAgICAgICAgIGNsb3NpbmdUYWdOYW1lVG9rZW46IEBtYWtlVG9rZW4gJ0lERU5USUZJRVInLCBmdWxsVGFnTmFtZSwgb2Zmc2V0OiBlbmRcbiAgICAgICAgICAgIGNsb3NpbmdUYWdDbG9zaW5nQnJhY2tldFRva2VuOiBAbWFrZVRva2VuICc+JywgJz4nLCBvZmZzZXQ6IGVuZCArIGZ1bGxUYWdOYW1lLmxlbmd0aFxuICAgICAgICAjIG1ha2UgdGhlIGNsb3NpbmcgdGFnIGxvY2F0aW9uIGRhdGEgbW9yZSBlYXNpbHkgYWNjZXNzaWJsZSB0byB0aGUgZ3JhbW1hclxuICAgICAgICBhZGRUb2tlbkRhdGEgb3BlbmluZ1RhZ1Rva2VuLCBlbmRUb2tlbi5kYXRhXG4gICAgICAgIEBqc3hEZXB0aC0tXG4gICAgICAgIHJldHVybiBhZnRlclRhZyArIDFcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIDBcbiAgICBlbHNlIGlmIEBhdEpTWFRhZyAxXG4gICAgICBpZiBmaXJzdENoYXIgaXMgJ30nXG4gICAgICAgIEBwYWlyIGZpcnN0Q2hhclxuICAgICAgICBpZiBAanN4T2JqQXR0cmlidXRlW0Bqc3hEZXB0aF1cbiAgICAgICAgICBAdG9rZW4gJ30nLCAnfSdcbiAgICAgICAgICBAanN4T2JqQXR0cmlidXRlW0Bqc3hEZXB0aF0gPSBub1xuICAgICAgICBlbHNlXG4gICAgICAgICAgQHRva2VuICcpJywgJ30nXG4gICAgICAgIEB0b2tlbiAnLCcsICcsJywgZ2VuZXJhdGVkOiB5ZXNcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIDBcbiAgICBlbHNlXG4gICAgICByZXR1cm4gMFxuXG4gIGF0SlNYVGFnOiAoZGVwdGggPSAwKSAtPlxuICAgIHJldHVybiBubyBpZiBAanN4RGVwdGggaXMgMFxuICAgIGkgPSBAZW5kcy5sZW5ndGggLSAxXG4gICAgaS0tIHdoaWxlIEBlbmRzW2ldPy50YWcgaXMgJ09VVERFTlQnIG9yIGRlcHRoLS0gPiAwICMgSWdub3JlIGluZGVudHMuXG4gICAgbGFzdCA9IEBlbmRzW2ldXG4gICAgbGFzdD8udGFnIGlzICcvPicgYW5kIGxhc3RcblxuICAjIFdlIHRyZWF0IGFsbCBvdGhlciBzaW5nbGUgY2hhcmFjdGVycyBhcyBhIHRva2VuLiBFLmcuOiBgKCApICwgLiAhYFxuICAjIE11bHRpLWNoYXJhY3RlciBvcGVyYXRvcnMgYXJlIGFsc28gbGl0ZXJhbCB0b2tlbnMsIHNvIHRoYXQgSmlzb24gY2FuIGFzc2lnblxuICAjIHRoZSBwcm9wZXIgb3JkZXIgb2Ygb3BlcmF0aW9ucy4gVGhlcmUgYXJlIHNvbWUgc3ltYm9scyB0aGF0IHdlIHRhZyBzcGVjaWFsbHlcbiAgIyBoZXJlLiBgO2AgYW5kIG5ld2xpbmVzIGFyZSBib3RoIHRyZWF0ZWQgYXMgYSBgVEVSTUlOQVRPUmAsIHdlIGRpc3Rpbmd1aXNoXG4gICMgcGFyZW50aGVzZXMgdGhhdCBpbmRpY2F0ZSBhIG1ldGhvZCBjYWxsIGZyb20gcmVndWxhciBwYXJlbnRoZXNlcywgYW5kIHNvIG9uLlxuICBsaXRlcmFsVG9rZW46IC0+XG4gICAgaWYgbWF0Y2ggPSBPUEVSQVRPUi5leGVjIEBjaHVua1xuICAgICAgW3ZhbHVlXSA9IG1hdGNoXG4gICAgICBAdGFnUGFyYW1ldGVycygpIGlmIENPREUudGVzdCB2YWx1ZVxuICAgIGVsc2VcbiAgICAgIHZhbHVlID0gQGNodW5rLmNoYXJBdCAwXG4gICAgdGFnICA9IHZhbHVlXG4gICAgcHJldiA9IEBwcmV2KClcblxuICAgIGlmIHByZXYgYW5kIHZhbHVlIGluIFsnPScsIENPTVBPVU5EX0FTU0lHTi4uLl1cbiAgICAgIHNraXBUb2tlbiA9IGZhbHNlXG4gICAgICBpZiB2YWx1ZSBpcyAnPScgYW5kIHByZXZbMV0gaW4gWyd8fCcsICcmJiddIGFuZCBub3QgcHJldi5zcGFjZWRcbiAgICAgICAgcHJldlswXSA9ICdDT01QT1VORF9BU1NJR04nXG4gICAgICAgIHByZXZbMV0gKz0gJz0nXG4gICAgICAgIHByZXYuZGF0YS5vcmlnaW5hbCArPSAnPScgaWYgcHJldi5kYXRhPy5vcmlnaW5hbFxuICAgICAgICBwcmV2WzJdLnJhbmdlID0gW1xuICAgICAgICAgIHByZXZbMl0ucmFuZ2VbMF1cbiAgICAgICAgICBwcmV2WzJdLnJhbmdlWzFdICsgMVxuICAgICAgICBdXG4gICAgICAgIHByZXZbMl0ubGFzdF9jb2x1bW4gKz0gMVxuICAgICAgICBwcmV2WzJdLmxhc3RfY29sdW1uX2V4Y2x1c2l2ZSArPSAxXG4gICAgICAgIHByZXYgPSBAdG9rZW5zW0B0b2tlbnMubGVuZ3RoIC0gMl1cbiAgICAgICAgc2tpcFRva2VuID0gdHJ1ZVxuICAgICAgaWYgcHJldiBhbmQgcHJldlswXSBpc250ICdQUk9QRVJUWSdcbiAgICAgICAgb3JpZ2luID0gcHJldi5vcmlnaW4gPyBwcmV2XG4gICAgICAgIG1lc3NhZ2UgPSBpc1VuYXNzaWduYWJsZSBwcmV2WzFdLCBvcmlnaW5bMV1cbiAgICAgICAgQGVycm9yIG1lc3NhZ2UsIG9yaWdpblsyXSBpZiBtZXNzYWdlXG4gICAgICByZXR1cm4gdmFsdWUubGVuZ3RoIGlmIHNraXBUb2tlblxuXG4gICAgaWYgdmFsdWUgaXMgJygnIGFuZCBwcmV2P1swXSBpcyAnSU1QT1JUJ1xuICAgICAgcHJldlswXSA9ICdEWU5BTUlDX0lNUE9SVCdcblxuICAgIGlmIHZhbHVlIGlzICd7JyBhbmQgQHNlZW5JbXBvcnRcbiAgICAgIEBpbXBvcnRTcGVjaWZpZXJMaXN0ID0geWVzXG4gICAgZWxzZSBpZiBAaW1wb3J0U3BlY2lmaWVyTGlzdCBhbmQgdmFsdWUgaXMgJ30nXG4gICAgICBAaW1wb3J0U3BlY2lmaWVyTGlzdCA9IG5vXG4gICAgZWxzZSBpZiB2YWx1ZSBpcyAneycgYW5kIHByZXY/WzBdIGlzICdFWFBPUlQnXG4gICAgICBAZXhwb3J0U3BlY2lmaWVyTGlzdCA9IHllc1xuICAgIGVsc2UgaWYgQGV4cG9ydFNwZWNpZmllckxpc3QgYW5kIHZhbHVlIGlzICd9J1xuICAgICAgQGV4cG9ydFNwZWNpZmllckxpc3QgPSBub1xuXG4gICAgaWYgdmFsdWUgaXMgJzsnXG4gICAgICBAZXJyb3IgJ3VuZXhwZWN0ZWQgOycgaWYgcHJldj9bMF0gaW4gWyc9JywgVU5GSU5JU0hFRC4uLl1cbiAgICAgIEBzZWVuRm9yID0gQHNlZW5JbXBvcnQgPSBAc2VlbkV4cG9ydCA9IG5vXG4gICAgICB0YWcgPSAnVEVSTUlOQVRPUidcbiAgICBlbHNlIGlmIHZhbHVlIGlzICcqJyBhbmQgcHJldj9bMF0gaXMgJ0VYUE9SVCdcbiAgICAgIHRhZyA9ICdFWFBPUlRfQUxMJ1xuICAgIGVsc2UgaWYgdmFsdWUgaW4gTUFUSCAgICAgICAgICAgIHRoZW4gdGFnID0gJ01BVEgnXG4gICAgZWxzZSBpZiB2YWx1ZSBpbiBDT01QQVJFICAgICAgICAgdGhlbiB0YWcgPSAnQ09NUEFSRSdcbiAgICBlbHNlIGlmIHZhbHVlIGluIENPTVBPVU5EX0FTU0lHTiB0aGVuIHRhZyA9ICdDT01QT1VORF9BU1NJR04nXG4gICAgZWxzZSBpZiB2YWx1ZSBpbiBVTkFSWSAgICAgICAgICAgdGhlbiB0YWcgPSAnVU5BUlknXG4gICAgZWxzZSBpZiB2YWx1ZSBpbiBVTkFSWV9NQVRIICAgICAgdGhlbiB0YWcgPSAnVU5BUllfTUFUSCdcbiAgICBlbHNlIGlmIHZhbHVlIGluIFNISUZUICAgICAgICAgICB0aGVuIHRhZyA9ICdTSElGVCdcbiAgICBlbHNlIGlmIHZhbHVlIGlzICc/JyBhbmQgcHJldj8uc3BhY2VkIHRoZW4gdGFnID0gJ0JJTj8nXG4gICAgZWxzZSBpZiBwcmV2XG4gICAgICBpZiB2YWx1ZSBpcyAnKCcgYW5kIG5vdCBwcmV2LnNwYWNlZCBhbmQgcHJldlswXSBpbiBDQUxMQUJMRVxuICAgICAgICBwcmV2WzBdID0gJ0ZVTkNfRVhJU1QnIGlmIHByZXZbMF0gaXMgJz8nXG4gICAgICAgIHRhZyA9ICdDQUxMX1NUQVJUJ1xuICAgICAgZWxzZSBpZiB2YWx1ZSBpcyAnWycgYW5kICgocHJldlswXSBpbiBJTkRFWEFCTEUgYW5kIG5vdCBwcmV2LnNwYWNlZCkgb3JcbiAgICAgICAgIChwcmV2WzBdIGlzICc6OicpKSAjIGAucHJvdG90eXBlYCBjYW7igJl0IGJlIGEgbWV0aG9kIHlvdSBjYW4gY2FsbC5cbiAgICAgICAgdGFnID0gJ0lOREVYX1NUQVJUJ1xuICAgICAgICBzd2l0Y2ggcHJldlswXVxuICAgICAgICAgIHdoZW4gJz8nICB0aGVuIHByZXZbMF0gPSAnSU5ERVhfU09BSydcbiAgICB0b2tlbiA9IEBtYWtlVG9rZW4gdGFnLCB2YWx1ZVxuICAgIHN3aXRjaCB2YWx1ZVxuICAgICAgd2hlbiAnKCcsICd7JywgJ1snIHRoZW4gQGVuZHMucHVzaCB7dGFnOiBJTlZFUlNFU1t2YWx1ZV0sIG9yaWdpbjogdG9rZW59XG4gICAgICB3aGVuICcpJywgJ30nLCAnXScgdGhlbiBAcGFpciB2YWx1ZVxuICAgIEB0b2tlbnMucHVzaCBAbWFrZVRva2VuIHRhZywgdmFsdWVcbiAgICB2YWx1ZS5sZW5ndGhcblxuICAjIFRva2VuIE1hbmlwdWxhdG9yc1xuICAjIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICMgQSBzb3VyY2Ugb2YgYW1iaWd1aXR5IGluIG91ciBncmFtbWFyIHVzZWQgdG8gYmUgcGFyYW1ldGVyIGxpc3RzIGluIGZ1bmN0aW9uXG4gICMgZGVmaW5pdGlvbnMgdmVyc3VzIGFyZ3VtZW50IGxpc3RzIGluIGZ1bmN0aW9uIGNhbGxzLiBXYWxrIGJhY2t3YXJkcywgdGFnZ2luZ1xuICAjIHBhcmFtZXRlcnMgc3BlY2lhbGx5IGluIG9yZGVyIHRvIG1ha2UgdGhpbmdzIGVhc2llciBmb3IgdGhlIHBhcnNlci5cbiAgdGFnUGFyYW1ldGVyczogLT5cbiAgICByZXR1cm4gQHRhZ0RvSWlmZSgpIGlmIEB0YWcoKSBpc250ICcpJ1xuICAgIHN0YWNrID0gW11cbiAgICB7dG9rZW5zfSA9IHRoaXNcbiAgICBpID0gdG9rZW5zLmxlbmd0aFxuICAgIHBhcmFtRW5kVG9rZW4gPSB0b2tlbnNbLS1pXVxuICAgIHBhcmFtRW5kVG9rZW5bMF0gPSAnUEFSQU1fRU5EJ1xuICAgIHdoaWxlIHRvayA9IHRva2Vuc1stLWldXG4gICAgICBzd2l0Y2ggdG9rWzBdXG4gICAgICAgIHdoZW4gJyknXG4gICAgICAgICAgc3RhY2sucHVzaCB0b2tcbiAgICAgICAgd2hlbiAnKCcsICdDQUxMX1NUQVJUJ1xuICAgICAgICAgIGlmIHN0YWNrLmxlbmd0aCB0aGVuIHN0YWNrLnBvcCgpXG4gICAgICAgICAgZWxzZSBpZiB0b2tbMF0gaXMgJygnXG4gICAgICAgICAgICB0b2tbMF0gPSAnUEFSQU1fU1RBUlQnXG4gICAgICAgICAgICByZXR1cm4gQHRhZ0RvSWlmZSBpIC0gMVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHBhcmFtRW5kVG9rZW5bMF0gPSAnQ0FMTF9FTkQnXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgIHRoaXNcblxuICAjIFRhZyBgZG9gIGZvbGxvd2VkIGJ5IGEgZnVuY3Rpb24gZGlmZmVyZW50bHkgdGhhbiBgZG9gIGZvbGxvd2VkIGJ5IGVnIGFuXG4gICMgaWRlbnRpZmllciB0byBhbGxvdyBmb3IgZGlmZmVyZW50IGdyYW1tYXIgcHJlY2VkZW5jZVxuICB0YWdEb0lpZmU6ICh0b2tlbkluZGV4KSAtPlxuICAgIHRvayA9IEB0b2tlbnNbdG9rZW5JbmRleCA/IEB0b2tlbnMubGVuZ3RoIC0gMV1cbiAgICByZXR1cm4gdGhpcyB1bmxlc3MgdG9rP1swXSBpcyAnRE8nXG4gICAgdG9rWzBdID0gJ0RPX0lJRkUnXG4gICAgdGhpc1xuXG4gICMgQ2xvc2UgdXAgYWxsIHJlbWFpbmluZyBvcGVuIGJsb2NrcyBhdCB0aGUgZW5kIG9mIHRoZSBmaWxlLlxuICBjbG9zZUluZGVudGF0aW9uOiAtPlxuICAgIEBvdXRkZW50VG9rZW4gbW92ZU91dDogQGluZGVudCwgaW5kZW50U2l6ZTogMFxuXG4gICMgTWF0Y2ggdGhlIGNvbnRlbnRzIG9mIGEgZGVsaW1pdGVkIHRva2VuIGFuZCBleHBhbmQgdmFyaWFibGVzIGFuZCBleHByZXNzaW9uc1xuICAjIGluc2lkZSBpdCB1c2luZyBSdWJ5LWxpa2Ugbm90YXRpb24gZm9yIHN1YnN0aXR1dGlvbiBvZiBhcmJpdHJhcnlcbiAgIyBleHByZXNzaW9ucy5cbiAgI1xuICAjICAgICBcIkhlbGxvICN7bmFtZS5jYXBpdGFsaXplKCl9LlwiXG4gICNcbiAgIyBJZiBpdCBlbmNvdW50ZXJzIGFuIGludGVycG9sYXRpb24sIHRoaXMgbWV0aG9kIHdpbGwgcmVjdXJzaXZlbHkgY3JlYXRlIGEgbmV3XG4gICMgTGV4ZXIgYW5kIHRva2VuaXplIHVudGlsIHRoZSBge2Agb2YgYCN7YCBpcyBiYWxhbmNlZCB3aXRoIGEgYH1gLlxuICAjXG4gICMgIC0gYHJlZ2V4YCBtYXRjaGVzIHRoZSBjb250ZW50cyBvZiBhIHRva2VuIChidXQgbm90IGBkZWxpbWl0ZXJgLCBhbmQgbm90XG4gICMgICAgYCN7YCBpZiBpbnRlcnBvbGF0aW9ucyBhcmUgZGVzaXJlZCkuXG4gICMgIC0gYGRlbGltaXRlcmAgaXMgdGhlIGRlbGltaXRlciBvZiB0aGUgdG9rZW4uIEV4YW1wbGVzIGFyZSBgJ2AsIGBcImAsIGAnJydgLFxuICAjICAgIGBcIlwiXCJgIGFuZCBgLy8vYC5cbiAgIyAgLSBgY2xvc2luZ0RlbGltaXRlcmAgaXMgZGlmZmVyZW50IGZyb20gYGRlbGltaXRlcmAgb25seSBpbiBKU1hcbiAgIyAgLSBgaW50ZXJwb2xhdG9yc2AgbWF0Y2hlcyB0aGUgc3RhcnQgb2YgYW4gaW50ZXJwb2xhdGlvbiwgZm9yIEpTWCBpdCdzIGJvdGhcbiAgIyAgICBge2AgYW5kIGA8YCAoaS5lLiBuZXN0ZWQgSlNYIHRhZylcbiAgI1xuICAjIFRoaXMgbWV0aG9kIGFsbG93cyB1cyB0byBoYXZlIHN0cmluZ3Mgd2l0aGluIGludGVycG9sYXRpb25zIHdpdGhpbiBzdHJpbmdzLFxuICAjIGFkIGluZmluaXR1bS5cbiAgbWF0Y2hXaXRoSW50ZXJwb2xhdGlvbnM6IChyZWdleCwgZGVsaW1pdGVyLCBjbG9zaW5nRGVsaW1pdGVyID0gZGVsaW1pdGVyLCBpbnRlcnBvbGF0b3JzID0gL14jXFx7LykgLT5cbiAgICB0b2tlbnMgPSBbXVxuICAgIG9mZnNldEluQ2h1bmsgPSBkZWxpbWl0ZXIubGVuZ3RoXG4gICAgcmV0dXJuIG51bGwgdW5sZXNzIEBjaHVua1suLi5vZmZzZXRJbkNodW5rXSBpcyBkZWxpbWl0ZXJcbiAgICBzdHIgPSBAY2h1bmtbb2Zmc2V0SW5DaHVuay4uXVxuICAgIGxvb3BcbiAgICAgIFtzdHJQYXJ0XSA9IHJlZ2V4LmV4ZWMgc3RyXG5cbiAgICAgIEB2YWxpZGF0ZUVzY2FwZXMgc3RyUGFydCwge2lzUmVnZXg6IGRlbGltaXRlci5jaGFyQXQoMCkgaXMgJy8nLCBvZmZzZXRJbkNodW5rfVxuXG4gICAgICAjIFB1c2ggYSBmYWtlIGAnTkVPU1RSSU5HJ2AgdG9rZW4sIHdoaWNoIHdpbGwgZ2V0IHR1cm5lZCBpbnRvIGEgcmVhbCBzdHJpbmcgbGF0ZXIuXG4gICAgICB0b2tlbnMucHVzaCBAbWFrZVRva2VuICdORU9TVFJJTkcnLCBzdHJQYXJ0LCBvZmZzZXQ6IG9mZnNldEluQ2h1bmtcblxuICAgICAgc3RyID0gc3RyW3N0clBhcnQubGVuZ3RoLi5dXG4gICAgICBvZmZzZXRJbkNodW5rICs9IHN0clBhcnQubGVuZ3RoXG5cbiAgICAgIGJyZWFrIHVubGVzcyBtYXRjaCA9IGludGVycG9sYXRvcnMuZXhlYyBzdHJcbiAgICAgIFtpbnRlcnBvbGF0b3JdID0gbWF0Y2hcblxuICAgICAgIyBUbyByZW1vdmUgdGhlIGAjYCBpbiBgI3tgLlxuICAgICAgaW50ZXJwb2xhdGlvbk9mZnNldCA9IGludGVycG9sYXRvci5sZW5ndGggLSAxXG4gICAgICBbbGluZSwgY29sdW1uLCBvZmZzZXRdID0gQGdldExpbmVBbmRDb2x1bW5Gcm9tQ2h1bmsgb2Zmc2V0SW5DaHVuayArIGludGVycG9sYXRpb25PZmZzZXRcbiAgICAgIHJlc3QgPSBzdHJbaW50ZXJwb2xhdGlvbk9mZnNldC4uXVxuICAgICAge3Rva2VuczogbmVzdGVkLCBpbmRleH0gPVxuICAgICAgICBuZXcgTGV4ZXIoKS50b2tlbml6ZSByZXN0LCB7bGluZSwgY29sdW1uLCBvZmZzZXQsIHVudGlsQmFsYW5jZWQ6IG9uLCBAbG9jYXRpb25EYXRhQ29tcGVuc2F0aW9uc31cbiAgICAgICMgQWNjb3VudCBmb3IgdGhlIGAjYCBpbiBgI3tgLlxuICAgICAgaW5kZXggKz0gaW50ZXJwb2xhdGlvbk9mZnNldFxuXG4gICAgICBicmFjZUludGVycG9sYXRvciA9IHN0cltpbmRleCAtIDFdIGlzICd9J1xuICAgICAgaWYgYnJhY2VJbnRlcnBvbGF0b3JcbiAgICAgICAgIyBUdXJuIHRoZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBge2AgYW5kIGB9YCBpbnRvIHBhcmVudGhlc2VzLiBVbm5lY2Vzc2FyeVxuICAgICAgICAjIHBhcmVudGhlc2VzIHdpbGwgYmUgcmVtb3ZlZCBsYXRlci5cbiAgICAgICAgW29wZW4sIC4uLiwgY2xvc2VdID0gbmVzdGVkXG4gICAgICAgIG9wZW5bMF0gID0gJ0lOVEVSUE9MQVRJT05fU1RBUlQnXG4gICAgICAgIG9wZW5bMV0gID0gJygnXG4gICAgICAgIG9wZW5bMl0uZmlyc3RfY29sdW1uIC09IGludGVycG9sYXRpb25PZmZzZXRcbiAgICAgICAgb3BlblsyXS5yYW5nZSA9IFtcbiAgICAgICAgICBvcGVuWzJdLnJhbmdlWzBdIC0gaW50ZXJwb2xhdGlvbk9mZnNldFxuICAgICAgICAgIG9wZW5bMl0ucmFuZ2VbMV1cbiAgICAgICAgXVxuICAgICAgICBjbG9zZVswXSAgPSAnSU5URVJQT0xBVElPTl9FTkQnXG4gICAgICAgIGNsb3NlWzFdID0gJyknXG4gICAgICAgIGNsb3NlLm9yaWdpbiA9IFsnJywgJ2VuZCBvZiBpbnRlcnBvbGF0aW9uJywgY2xvc2VbMl1dXG5cbiAgICAgICMgUmVtb3ZlIGxlYWRpbmcgYCdURVJNSU5BVE9SJ2AgKGlmIGFueSkuXG4gICAgICBuZXN0ZWQuc3BsaWNlIDEsIDEgaWYgbmVzdGVkWzFdP1swXSBpcyAnVEVSTUlOQVRPUidcbiAgICAgICMgUmVtb3ZlIHRyYWlsaW5nIGAnSU5ERU5UJy8nT1VUREVOVCdgIHBhaXIgKGlmIGFueSkuXG4gICAgICBuZXN0ZWQuc3BsaWNlIC0zLCAyIGlmIG5lc3RlZFtuZXN0ZWQubGVuZ3RoIC0gM10/WzBdIGlzICdJTkRFTlQnIGFuZCBuZXN0ZWRbbmVzdGVkLmxlbmd0aCAtIDJdWzBdIGlzICdPVVRERU5UJ1xuXG4gICAgICB1bmxlc3MgYnJhY2VJbnRlcnBvbGF0b3JcbiAgICAgICAgIyBXZSBhcmUgbm90IHVzaW5nIGB7YCBhbmQgYH1gLCBzbyB3cmFwIHRoZSBpbnRlcnBvbGF0ZWQgdG9rZW5zIGluc3RlYWQuXG4gICAgICAgIG9wZW4gPSBAbWFrZVRva2VuICdJTlRFUlBPTEFUSU9OX1NUQVJUJywgJygnLCBvZmZzZXQ6IG9mZnNldEluQ2h1bmssICAgICAgICAgbGVuZ3RoOiAwLCBnZW5lcmF0ZWQ6IHllc1xuICAgICAgICBjbG9zZSA9IEBtYWtlVG9rZW4gJ0lOVEVSUE9MQVRJT05fRU5EJywgJyknLCAgb2Zmc2V0OiBvZmZzZXRJbkNodW5rICsgaW5kZXgsIGxlbmd0aDogMCwgZ2VuZXJhdGVkOiB5ZXNcbiAgICAgICAgbmVzdGVkID0gW29wZW4sIG5lc3RlZC4uLiwgY2xvc2VdXG5cbiAgICAgICMgUHVzaCBhIGZha2UgYCdUT0tFTlMnYCB0b2tlbiwgd2hpY2ggd2lsbCBnZXQgdHVybmVkIGludG8gcmVhbCB0b2tlbnMgbGF0ZXIuXG4gICAgICB0b2tlbnMucHVzaCBbJ1RPS0VOUycsIG5lc3RlZF1cblxuICAgICAgc3RyID0gc3RyW2luZGV4Li5dXG4gICAgICBvZmZzZXRJbkNodW5rICs9IGluZGV4XG5cbiAgICB1bmxlc3Mgc3RyWy4uLmNsb3NpbmdEZWxpbWl0ZXIubGVuZ3RoXSBpcyBjbG9zaW5nRGVsaW1pdGVyXG4gICAgICBAZXJyb3IgXCJtaXNzaW5nICN7Y2xvc2luZ0RlbGltaXRlcn1cIiwgbGVuZ3RoOiBkZWxpbWl0ZXIubGVuZ3RoXG5cbiAgICB7dG9rZW5zLCBpbmRleDogb2Zmc2V0SW5DaHVuayArIGNsb3NpbmdEZWxpbWl0ZXIubGVuZ3RofVxuXG4gICMgTWVyZ2UgdGhlIGFycmF5IGB0b2tlbnNgIG9mIHRoZSBmYWtlIHRva2VuIHR5cGVzIGAnVE9LRU5TJ2AgYW5kIGAnTkVPU1RSSU5HJ2BcbiAgIyAoYXMgcmV0dXJuZWQgYnkgYG1hdGNoV2l0aEludGVycG9sYXRpb25zYCkgaW50byB0aGUgdG9rZW4gc3RyZWFtLiBUaGUgdmFsdWVcbiAgIyBvZiBgJ05FT1NUUklORydgcyBhcmUgY29udmVydGVkIHVzaW5nIGBmbmAgYW5kIHR1cm5lZCBpbnRvIHN0cmluZ3MgdXNpbmdcbiAgIyBgb3B0aW9uc2AgZmlyc3QuXG4gIG1lcmdlSW50ZXJwb2xhdGlvblRva2VuczogKHRva2Vucywgb3B0aW9ucywgZm4pIC0+XG4gICAge3F1b3RlLCBpbmRlbnQsIGRvdWJsZSwgaGVyZWdleCwgZW5kT2Zmc2V0LCBqc3h9ID0gb3B0aW9uc1xuXG4gICAgaWYgdG9rZW5zLmxlbmd0aCA+IDFcbiAgICAgIGxwYXJlbiA9IEB0b2tlbiAnU1RSSU5HX1NUQVJUJywgJygnLCBsZW5ndGg6IHF1b3RlPy5sZW5ndGggPyAwLCBkYXRhOiB7cXVvdGV9LCBnZW5lcmF0ZWQ6IG5vdCBxdW90ZT8ubGVuZ3RoXG5cbiAgICBmaXJzdEluZGV4ID0gQHRva2Vucy5sZW5ndGhcbiAgICAkID0gdG9rZW5zLmxlbmd0aCAtIDFcbiAgICBmb3IgdG9rZW4sIGkgaW4gdG9rZW5zXG4gICAgICBbdGFnLCB2YWx1ZV0gPSB0b2tlblxuICAgICAgc3dpdGNoIHRhZ1xuICAgICAgICB3aGVuICdUT0tFTlMnXG4gICAgICAgICAgIyBUaGVyZSBhcmUgY29tbWVudHMgKGFuZCBub3RoaW5nIGVsc2UpIGluIHRoaXMgaW50ZXJwb2xhdGlvbi5cbiAgICAgICAgICBpZiB2YWx1ZS5sZW5ndGggaXMgMiBhbmQgKHZhbHVlWzBdLmNvbW1lbnRzIG9yIHZhbHVlWzFdLmNvbW1lbnRzKVxuICAgICAgICAgICAgcGxhY2Vob2xkZXJUb2tlbiA9IEBtYWtlVG9rZW4gJ0pTJywgJycsIGdlbmVyYXRlZDogeWVzXG4gICAgICAgICAgICAjIFVzZSB0aGUgc2FtZSBsb2NhdGlvbiBkYXRhIGFzIHRoZSBmaXJzdCBwYXJlbnRoZXNpcy5cbiAgICAgICAgICAgIHBsYWNlaG9sZGVyVG9rZW5bMl0gPSB2YWx1ZVswXVsyXVxuICAgICAgICAgICAgZm9yIHZhbCBpbiB2YWx1ZSB3aGVuIHZhbC5jb21tZW50c1xuICAgICAgICAgICAgICBwbGFjZWhvbGRlclRva2VuLmNvbW1lbnRzID89IFtdXG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyVG9rZW4uY29tbWVudHMucHVzaCB2YWwuY29tbWVudHMuLi5cbiAgICAgICAgICAgIHZhbHVlLnNwbGljZSAxLCAwLCBwbGFjZWhvbGRlclRva2VuXG4gICAgICAgICAgIyBQdXNoIGFsbCB0aGUgdG9rZW5zIGluIHRoZSBmYWtlIGAnVE9LRU5TJ2AgdG9rZW4uIFRoZXNlIGFscmVhZHkgaGF2ZVxuICAgICAgICAgICMgc2FuZSBsb2NhdGlvbiBkYXRhLlxuICAgICAgICAgIGxvY2F0aW9uVG9rZW4gPSB2YWx1ZVswXVxuICAgICAgICAgIHRva2Vuc1RvUHVzaCA9IHZhbHVlXG4gICAgICAgIHdoZW4gJ05FT1NUUklORydcbiAgICAgICAgICAjIENvbnZlcnQgYCdORU9TVFJJTkcnYCBpbnRvIGAnU1RSSU5HJ2AuXG4gICAgICAgICAgY29udmVydGVkID0gZm4uY2FsbCB0aGlzLCB0b2tlblsxXSwgaVxuICAgICAgICAgIGFkZFRva2VuRGF0YSB0b2tlbiwgaW5pdGlhbENodW5rOiB5ZXMgaWYgaSBpcyAwXG4gICAgICAgICAgYWRkVG9rZW5EYXRhIHRva2VuLCBmaW5hbENodW5rOiB5ZXMgICBpZiBpIGlzICRcbiAgICAgICAgICBhZGRUb2tlbkRhdGEgdG9rZW4sIHtpbmRlbnQsIHF1b3RlLCBkb3VibGV9XG4gICAgICAgICAgYWRkVG9rZW5EYXRhIHRva2VuLCB7aGVyZWdleH0gaWYgaGVyZWdleFxuICAgICAgICAgIGFkZFRva2VuRGF0YSB0b2tlbiwge2pzeH0gaWYganN4XG4gICAgICAgICAgdG9rZW5bMF0gPSAnU1RSSU5HJ1xuICAgICAgICAgIHRva2VuWzFdID0gJ1wiJyArIGNvbnZlcnRlZCArICdcIidcbiAgICAgICAgICBpZiB0b2tlbnMubGVuZ3RoIGlzIDEgYW5kIHF1b3RlP1xuICAgICAgICAgICAgdG9rZW5bMl0uZmlyc3RfY29sdW1uIC09IHF1b3RlLmxlbmd0aFxuICAgICAgICAgICAgaWYgdG9rZW5bMV0uc3Vic3RyKC0yLCAxKSBpcyAnXFxuJ1xuICAgICAgICAgICAgICB0b2tlblsyXS5sYXN0X2xpbmUgKz0gMVxuICAgICAgICAgICAgICB0b2tlblsyXS5sYXN0X2NvbHVtbiA9IHF1b3RlLmxlbmd0aCAtIDFcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgdG9rZW5bMl0ubGFzdF9jb2x1bW4gKz0gcXVvdGUubGVuZ3RoXG4gICAgICAgICAgICAgIHRva2VuWzJdLmxhc3RfY29sdW1uIC09IDEgaWYgdG9rZW5bMV0ubGVuZ3RoIGlzIDJcbiAgICAgICAgICAgIHRva2VuWzJdLmxhc3RfY29sdW1uX2V4Y2x1c2l2ZSArPSBxdW90ZS5sZW5ndGhcbiAgICAgICAgICAgIHRva2VuWzJdLnJhbmdlID0gW1xuICAgICAgICAgICAgICB0b2tlblsyXS5yYW5nZVswXSAtIHF1b3RlLmxlbmd0aFxuICAgICAgICAgICAgICB0b2tlblsyXS5yYW5nZVsxXSArIHF1b3RlLmxlbmd0aFxuICAgICAgICAgICAgXVxuICAgICAgICAgIGxvY2F0aW9uVG9rZW4gPSB0b2tlblxuICAgICAgICAgIHRva2Vuc1RvUHVzaCA9IFt0b2tlbl1cbiAgICAgIEB0b2tlbnMucHVzaCB0b2tlbnNUb1B1c2guLi5cblxuICAgIGlmIGxwYXJlblxuICAgICAgWy4uLiwgbGFzdFRva2VuXSA9IHRva2Vuc1xuICAgICAgbHBhcmVuLm9yaWdpbiA9IFsnU1RSSU5HJywgbnVsbCxcbiAgICAgICAgZmlyc3RfbGluZTogICAgICAgICAgICBscGFyZW5bMl0uZmlyc3RfbGluZVxuICAgICAgICBmaXJzdF9jb2x1bW46ICAgICAgICAgIGxwYXJlblsyXS5maXJzdF9jb2x1bW5cbiAgICAgICAgbGFzdF9saW5lOiAgICAgICAgICAgICBsYXN0VG9rZW5bMl0ubGFzdF9saW5lXG4gICAgICAgIGxhc3RfY29sdW1uOiAgICAgICAgICAgbGFzdFRva2VuWzJdLmxhc3RfY29sdW1uXG4gICAgICAgIGxhc3RfbGluZV9leGNsdXNpdmU6ICAgbGFzdFRva2VuWzJdLmxhc3RfbGluZV9leGNsdXNpdmVcbiAgICAgICAgbGFzdF9jb2x1bW5fZXhjbHVzaXZlOiBsYXN0VG9rZW5bMl0ubGFzdF9jb2x1bW5fZXhjbHVzaXZlXG4gICAgICAgIHJhbmdlOiBbXG4gICAgICAgICAgbHBhcmVuWzJdLnJhbmdlWzBdXG4gICAgICAgICAgbGFzdFRva2VuWzJdLnJhbmdlWzFdXG4gICAgICAgIF1cbiAgICAgIF1cbiAgICAgIGxwYXJlblsyXSA9IGxwYXJlbi5vcmlnaW5bMl0gdW5sZXNzIHF1b3RlPy5sZW5ndGhcbiAgICAgIHJwYXJlbiA9IEB0b2tlbiAnU1RSSU5HX0VORCcsICcpJywgb2Zmc2V0OiBlbmRPZmZzZXQgLSAocXVvdGUgPyAnJykubGVuZ3RoLCBsZW5ndGg6IHF1b3RlPy5sZW5ndGggPyAwLCBnZW5lcmF0ZWQ6IG5vdCBxdW90ZT8ubGVuZ3RoXG5cbiAgIyBQYWlycyB1cCBhIGNsb3NpbmcgdG9rZW4sIGVuc3VyaW5nIHRoYXQgYWxsIGxpc3RlZCBwYWlycyBvZiB0b2tlbnMgYXJlXG4gICMgY29ycmVjdGx5IGJhbGFuY2VkIHRocm91Z2hvdXQgdGhlIGNvdXJzZSBvZiB0aGUgdG9rZW4gc3RyZWFtLlxuICBwYWlyOiAodGFnKSAtPlxuICAgIFsuLi4sIHByZXZdID0gQGVuZHNcbiAgICB1bmxlc3MgdGFnIGlzIHdhbnRlZCA9IHByZXY/LnRhZ1xuICAgICAgQGVycm9yIFwidW5tYXRjaGVkICN7dGFnfVwiIHVubGVzcyAnT1VUREVOVCcgaXMgd2FudGVkXG4gICAgICAjIEF1dG8tY2xvc2UgYElOREVOVGAgdG8gc3VwcG9ydCBzeW50YXggbGlrZSB0aGlzOlxuICAgICAgI1xuICAgICAgIyAgICAgZWwuY2xpY2soKGV2ZW50KSAtPlxuICAgICAgIyAgICAgICBlbC5oaWRlKCkpXG4gICAgICAjXG4gICAgICBbLi4uLCBsYXN0SW5kZW50XSA9IEBpbmRlbnRzXG4gICAgICBAb3V0ZGVudFRva2VuIG1vdmVPdXQ6IGxhc3RJbmRlbnQsIG5vTmV3bGluZXM6IHRydWVcbiAgICAgIHJldHVybiBAcGFpciB0YWdcbiAgICBAZW5kcy5wb3AoKVxuXG4gICMgSGVscGVyc1xuICAjIC0tLS0tLS1cblxuICAjIENvbXBlbnNhdGUgZm9yIHRoZSB0aGluZ3Mgd2Ugc3RyaXAgb3V0IGluaXRpYWxseSAoZS5nLiBjYXJyaWFnZSByZXR1cm5zKVxuICAjIHNvIHRoYXQgbG9jYXRpb24gZGF0YSBzdGF5cyBhY2N1cmF0ZSB3aXRoIHJlc3BlY3QgdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLlxuICBnZXRMb2NhdGlvbkRhdGFDb21wZW5zYXRpb246IChzdGFydCwgZW5kKSAtPlxuICAgIHRvdGFsQ29tcGVuc2F0aW9uID0gMFxuICAgIGluaXRpYWxFbmQgPSBlbmRcbiAgICBjdXJyZW50ID0gc3RhcnRcbiAgICB3aGlsZSBjdXJyZW50IDw9IGVuZFxuICAgICAgYnJlYWsgaWYgY3VycmVudCBpcyBlbmQgYW5kIHN0YXJ0IGlzbnQgaW5pdGlhbEVuZFxuICAgICAgY29tcGVuc2F0aW9uID0gQGxvY2F0aW9uRGF0YUNvbXBlbnNhdGlvbnNbY3VycmVudF1cbiAgICAgIGlmIGNvbXBlbnNhdGlvbj9cbiAgICAgICAgdG90YWxDb21wZW5zYXRpb24gKz0gY29tcGVuc2F0aW9uXG4gICAgICAgIGVuZCArPSBjb21wZW5zYXRpb25cbiAgICAgIGN1cnJlbnQrK1xuICAgIHJldHVybiB0b3RhbENvbXBlbnNhdGlvblxuXG4gICMgUmV0dXJucyB0aGUgbGluZSBhbmQgY29sdW1uIG51bWJlciBmcm9tIGFuIG9mZnNldCBpbnRvIHRoZSBjdXJyZW50IGNodW5rLlxuICAjXG4gICMgYG9mZnNldGAgaXMgYSBudW1iZXIgb2YgY2hhcmFjdGVycyBpbnRvIGBAY2h1bmtgLlxuICBnZXRMaW5lQW5kQ29sdW1uRnJvbUNodW5rOiAob2Zmc2V0KSAtPlxuICAgIGNvbXBlbnNhdGlvbiA9IEBnZXRMb2NhdGlvbkRhdGFDb21wZW5zYXRpb24gQGNodW5rT2Zmc2V0LCBAY2h1bmtPZmZzZXQgKyBvZmZzZXRcblxuICAgIGlmIG9mZnNldCBpcyAwXG4gICAgICByZXR1cm4gW0BjaHVua0xpbmUsIEBjaHVua0NvbHVtbiArIGNvbXBlbnNhdGlvbiwgQGNodW5rT2Zmc2V0ICsgY29tcGVuc2F0aW9uXVxuXG4gICAgaWYgb2Zmc2V0ID49IEBjaHVuay5sZW5ndGhcbiAgICAgIHN0cmluZyA9IEBjaHVua1xuICAgIGVsc2VcbiAgICAgIHN0cmluZyA9IEBjaHVua1suLm9mZnNldC0xXVxuXG4gICAgbGluZUNvdW50ID0gY291bnQgc3RyaW5nLCAnXFxuJ1xuXG4gICAgY29sdW1uID0gQGNodW5rQ29sdW1uXG4gICAgaWYgbGluZUNvdW50ID4gMFxuICAgICAgWy4uLiwgbGFzdExpbmVdID0gc3RyaW5nLnNwbGl0ICdcXG4nXG4gICAgICBjb2x1bW4gPSBsYXN0TGluZS5sZW5ndGhcbiAgICAgIHByZXZpb3VzTGluZXNDb21wZW5zYXRpb24gPSBAZ2V0TG9jYXRpb25EYXRhQ29tcGVuc2F0aW9uIEBjaHVua09mZnNldCwgQGNodW5rT2Zmc2V0ICsgb2Zmc2V0IC0gY29sdW1uXG4gICAgICAjIERvbid0IHJlY29tcGVuc2F0ZSBmb3IgaW5pdGlhbGx5IGluc2VydGVkIG5ld2xpbmUuXG4gICAgICBwcmV2aW91c0xpbmVzQ29tcGVuc2F0aW9uID0gMCBpZiBwcmV2aW91c0xpbmVzQ29tcGVuc2F0aW9uIDwgMFxuICAgICAgY29sdW1uQ29tcGVuc2F0aW9uID0gQGdldExvY2F0aW9uRGF0YUNvbXBlbnNhdGlvbihcbiAgICAgICAgQGNodW5rT2Zmc2V0ICsgb2Zmc2V0ICsgcHJldmlvdXNMaW5lc0NvbXBlbnNhdGlvbiAtIGNvbHVtblxuICAgICAgICBAY2h1bmtPZmZzZXQgKyBvZmZzZXQgKyBwcmV2aW91c0xpbmVzQ29tcGVuc2F0aW9uXG4gICAgICApXG4gICAgZWxzZVxuICAgICAgY29sdW1uICs9IHN0cmluZy5sZW5ndGhcbiAgICAgIGNvbHVtbkNvbXBlbnNhdGlvbiA9IGNvbXBlbnNhdGlvblxuXG4gICAgW0BjaHVua0xpbmUgKyBsaW5lQ291bnQsIGNvbHVtbiArIGNvbHVtbkNvbXBlbnNhdGlvbiwgQGNodW5rT2Zmc2V0ICsgb2Zmc2V0ICsgY29tcGVuc2F0aW9uXVxuXG4gIG1ha2VMb2NhdGlvbkRhdGE6ICh7IG9mZnNldEluQ2h1bmssIGxlbmd0aCB9KSAtPlxuICAgIGxvY2F0aW9uRGF0YSA9IHJhbmdlOiBbXVxuICAgIFtsb2NhdGlvbkRhdGEuZmlyc3RfbGluZSwgbG9jYXRpb25EYXRhLmZpcnN0X2NvbHVtbiwgbG9jYXRpb25EYXRhLnJhbmdlWzBdXSA9XG4gICAgICBAZ2V0TGluZUFuZENvbHVtbkZyb21DaHVuayBvZmZzZXRJbkNodW5rXG5cbiAgICAjIFVzZSBsZW5ndGggLSAxIGZvciB0aGUgZmluYWwgb2Zmc2V0IC0gd2XigJlyZSBzdXBwbHlpbmcgdGhlIGxhc3RfbGluZSBhbmQgdGhlIGxhc3RfY29sdW1uLFxuICAgICMgc28gaWYgbGFzdF9jb2x1bW4gPT0gZmlyc3RfY29sdW1uLCB0aGVuIHdl4oCZcmUgbG9va2luZyBhdCBhIGNoYXJhY3RlciBvZiBsZW5ndGggMS5cbiAgICBsYXN0Q2hhcmFjdGVyID0gaWYgbGVuZ3RoID4gMCB0aGVuIChsZW5ndGggLSAxKSBlbHNlIDBcbiAgICBbbG9jYXRpb25EYXRhLmxhc3RfbGluZSwgbG9jYXRpb25EYXRhLmxhc3RfY29sdW1uLCBlbmRPZmZzZXRdID1cbiAgICAgIEBnZXRMaW5lQW5kQ29sdW1uRnJvbUNodW5rIG9mZnNldEluQ2h1bmsgKyBsYXN0Q2hhcmFjdGVyXG4gICAgW2xvY2F0aW9uRGF0YS5sYXN0X2xpbmVfZXhjbHVzaXZlLCBsb2NhdGlvbkRhdGEubGFzdF9jb2x1bW5fZXhjbHVzaXZlXSA9XG4gICAgICBAZ2V0TGluZUFuZENvbHVtbkZyb21DaHVuayBvZmZzZXRJbkNodW5rICsgbGFzdENoYXJhY3RlciArIChpZiBsZW5ndGggPiAwIHRoZW4gMSBlbHNlIDApXG4gICAgbG9jYXRpb25EYXRhLnJhbmdlWzFdID0gaWYgbGVuZ3RoID4gMCB0aGVuIGVuZE9mZnNldCArIDEgZWxzZSBlbmRPZmZzZXRcblxuICAgIGxvY2F0aW9uRGF0YVxuXG4gICMgU2FtZSBhcyBgdG9rZW5gLCBleGNlcHQgdGhpcyBqdXN0IHJldHVybnMgdGhlIHRva2VuIHdpdGhvdXQgYWRkaW5nIGl0XG4gICMgdG8gdGhlIHJlc3VsdHMuXG4gIG1ha2VUb2tlbjogKHRhZywgdmFsdWUsIHtvZmZzZXQ6IG9mZnNldEluQ2h1bmsgPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsIG9yaWdpbiwgZ2VuZXJhdGVkLCBpbmRlbnRTaXplfSA9IHt9KSAtPlxuICAgIHRva2VuID0gW3RhZywgdmFsdWUsIEBtYWtlTG9jYXRpb25EYXRhIHtvZmZzZXRJbkNodW5rLCBsZW5ndGh9XVxuICAgIHRva2VuLm9yaWdpbiA9IG9yaWdpbiBpZiBvcmlnaW5cbiAgICB0b2tlbi5nZW5lcmF0ZWQgPSB5ZXMgaWYgZ2VuZXJhdGVkXG4gICAgdG9rZW4uaW5kZW50U2l6ZSA9IGluZGVudFNpemUgaWYgaW5kZW50U2l6ZT9cbiAgICB0b2tlblxuXG4gICMgQWRkIGEgdG9rZW4gdG8gdGhlIHJlc3VsdHMuXG4gICMgYG9mZnNldGAgaXMgdGhlIG9mZnNldCBpbnRvIHRoZSBjdXJyZW50IGBAY2h1bmtgIHdoZXJlIHRoZSB0b2tlbiBzdGFydHMuXG4gICMgYGxlbmd0aGAgaXMgdGhlIGxlbmd0aCBvZiB0aGUgdG9rZW4gaW4gdGhlIGBAY2h1bmtgLCBhZnRlciB0aGUgb2Zmc2V0LiAgSWZcbiAgIyBub3Qgc3BlY2lmaWVkLCB0aGUgbGVuZ3RoIG9mIGB2YWx1ZWAgd2lsbCBiZSB1c2VkLlxuICAjXG4gICMgUmV0dXJucyB0aGUgbmV3IHRva2VuLlxuICB0b2tlbjogKHRhZywgdmFsdWUsIHtvZmZzZXQsIGxlbmd0aCwgb3JpZ2luLCBkYXRhLCBnZW5lcmF0ZWQsIGluZGVudFNpemV9ID0ge30pIC0+XG4gICAgdG9rZW4gPSBAbWFrZVRva2VuIHRhZywgdmFsdWUsIHtvZmZzZXQsIGxlbmd0aCwgb3JpZ2luLCBnZW5lcmF0ZWQsIGluZGVudFNpemV9XG4gICAgYWRkVG9rZW5EYXRhIHRva2VuLCBkYXRhIGlmIGRhdGFcbiAgICBAdG9rZW5zLnB1c2ggdG9rZW5cbiAgICB0b2tlblxuXG4gICMgUGVlayBhdCB0aGUgbGFzdCB0YWcgaW4gdGhlIHRva2VuIHN0cmVhbS5cbiAgdGFnOiAtPlxuICAgIFsuLi4sIHRva2VuXSA9IEB0b2tlbnNcbiAgICB0b2tlbj9bMF1cblxuICAjIFBlZWsgYXQgdGhlIGxhc3QgdmFsdWUgaW4gdGhlIHRva2VuIHN0cmVhbS5cbiAgdmFsdWU6ICh1c2VPcmlnaW4gPSBubykgLT5cbiAgICBbLi4uLCB0b2tlbl0gPSBAdG9rZW5zXG4gICAgaWYgdXNlT3JpZ2luIGFuZCB0b2tlbj8ub3JpZ2luP1xuICAgICAgdG9rZW4ub3JpZ2luWzFdXG4gICAgZWxzZVxuICAgICAgdG9rZW4/WzFdXG5cbiAgIyBHZXQgdGhlIHByZXZpb3VzIHRva2VuIGluIHRoZSB0b2tlbiBzdHJlYW0uXG4gIHByZXY6IC0+XG4gICAgQHRva2Vuc1tAdG9rZW5zLmxlbmd0aCAtIDFdXG5cbiAgIyBBcmUgd2UgaW4gdGhlIG1pZHN0IG9mIGFuIHVuZmluaXNoZWQgZXhwcmVzc2lvbj9cbiAgdW5maW5pc2hlZDogLT5cbiAgICBMSU5FX0NPTlRJTlVFUi50ZXN0KEBjaHVuaykgb3JcbiAgICBAdGFnKCkgaW4gVU5GSU5JU0hFRFxuXG4gIHZhbGlkYXRlVW5pY29kZUNvZGVQb2ludEVzY2FwZXM6IChzdHIsIG9wdGlvbnMpIC0+XG4gICAgcmVwbGFjZVVuaWNvZGVDb2RlUG9pbnRFc2NhcGVzIHN0ciwgbWVyZ2Ugb3B0aW9ucywge0BlcnJvcn1cblxuICAjIFZhbGlkYXRlcyBlc2NhcGVzIGluIHN0cmluZ3MgYW5kIHJlZ2V4ZXMuXG4gIHZhbGlkYXRlRXNjYXBlczogKHN0ciwgb3B0aW9ucyA9IHt9KSAtPlxuICAgIGludmFsaWRFc2NhcGVSZWdleCA9XG4gICAgICBpZiBvcHRpb25zLmlzUmVnZXhcbiAgICAgICAgUkVHRVhfSU5WQUxJRF9FU0NBUEVcbiAgICAgIGVsc2VcbiAgICAgICAgU1RSSU5HX0lOVkFMSURfRVNDQVBFXG4gICAgbWF0Y2ggPSBpbnZhbGlkRXNjYXBlUmVnZXguZXhlYyBzdHJcbiAgICByZXR1cm4gdW5sZXNzIG1hdGNoXG4gICAgW1tdLCBiZWZvcmUsIG9jdGFsLCBoZXgsIHVuaWNvZGVDb2RlUG9pbnQsIHVuaWNvZGVdID0gbWF0Y2hcbiAgICBtZXNzYWdlID1cbiAgICAgIGlmIG9jdGFsXG4gICAgICAgIFwib2N0YWwgZXNjYXBlIHNlcXVlbmNlcyBhcmUgbm90IGFsbG93ZWRcIlxuICAgICAgZWxzZVxuICAgICAgICBcImludmFsaWQgZXNjYXBlIHNlcXVlbmNlXCJcbiAgICBpbnZhbGlkRXNjYXBlID0gXCJcXFxcI3tvY3RhbCBvciBoZXggb3IgdW5pY29kZUNvZGVQb2ludCBvciB1bmljb2RlfVwiXG4gICAgQGVycm9yIFwiI3ttZXNzYWdlfSAje2ludmFsaWRFc2NhcGV9XCIsXG4gICAgICBvZmZzZXQ6IChvcHRpb25zLm9mZnNldEluQ2h1bmsgPyAwKSArIG1hdGNoLmluZGV4ICsgYmVmb3JlLmxlbmd0aFxuICAgICAgbGVuZ3RoOiBpbnZhbGlkRXNjYXBlLmxlbmd0aFxuXG4gIHN1cHByZXNzU2VtaWNvbG9uczogLT5cbiAgICB3aGlsZSBAdmFsdWUoKSBpcyAnOydcbiAgICAgIEB0b2tlbnMucG9wKClcbiAgICAgIEBlcnJvciAndW5leHBlY3RlZCA7JyBpZiBAcHJldigpP1swXSBpbiBbJz0nLCBVTkZJTklTSEVELi4uXVxuXG4gICMgVGhyb3dzIGFuIGVycm9yIGF0IGVpdGhlciBhIGdpdmVuIG9mZnNldCBmcm9tIHRoZSBjdXJyZW50IGNodW5rIG9yIGF0IHRoZVxuICAjIGxvY2F0aW9uIG9mIGEgdG9rZW4gKGB0b2tlblsyXWApLlxuICBlcnJvcjogKG1lc3NhZ2UsIG9wdGlvbnMgPSB7fSkgPT5cbiAgICBsb2NhdGlvbiA9XG4gICAgICBpZiAnZmlyc3RfbGluZScgb2Ygb3B0aW9uc1xuICAgICAgICBvcHRpb25zXG4gICAgICBlbHNlXG4gICAgICAgIFtmaXJzdF9saW5lLCBmaXJzdF9jb2x1bW5dID0gQGdldExpbmVBbmRDb2x1bW5Gcm9tQ2h1bmsgb3B0aW9ucy5vZmZzZXQgPyAwXG4gICAgICAgIHtmaXJzdF9saW5lLCBmaXJzdF9jb2x1bW4sIGxhc3RfY29sdW1uOiBmaXJzdF9jb2x1bW4gKyAob3B0aW9ucy5sZW5ndGggPyAxKSAtIDF9XG4gICAgdGhyb3dTeW50YXhFcnJvciBtZXNzYWdlLCBsb2NhdGlvblxuXG4jIEhlbHBlciBmdW5jdGlvbnNcbiMgLS0tLS0tLS0tLS0tLS0tLVxuXG5pc1VuYXNzaWduYWJsZSA9IChuYW1lLCBkaXNwbGF5TmFtZSA9IG5hbWUpIC0+IHN3aXRjaFxuICB3aGVuIG5hbWUgaW4gW0pTX0tFWVdPUkRTLi4uLCBDT0ZGRUVfS0VZV09SRFMuLi5dXG4gICAgXCJrZXl3b3JkICcje2Rpc3BsYXlOYW1lfScgY2FuJ3QgYmUgYXNzaWduZWRcIlxuICB3aGVuIG5hbWUgaW4gU1RSSUNUX1BST1NDUklCRURcbiAgICBcIicje2Rpc3BsYXlOYW1lfScgY2FuJ3QgYmUgYXNzaWduZWRcIlxuICB3aGVuIG5hbWUgaW4gUkVTRVJWRURcbiAgICBcInJlc2VydmVkIHdvcmQgJyN7ZGlzcGxheU5hbWV9JyBjYW4ndCBiZSBhc3NpZ25lZFwiXG4gIGVsc2VcbiAgICBmYWxzZVxuXG5leHBvcnRzLmlzVW5hc3NpZ25hYmxlID0gaXNVbmFzc2lnbmFibGVcblxuIyBgZnJvbWAgaXNu4oCZdCBhIENvZmZlZVNjcmlwdCBrZXl3b3JkLCBidXQgaXQgYmVoYXZlcyBsaWtlIG9uZSBpbiBgaW1wb3J0YCBhbmRcbiMgYGV4cG9ydGAgc3RhdGVtZW50cyAoaGFuZGxlZCBhYm92ZSkgYW5kIGluIHRoZSBkZWNsYXJhdGlvbiBsaW5lIG9mIGEgYGZvcmBcbiMgbG9vcC4gVHJ5IHRvIGRldGVjdCB3aGVuIGBmcm9tYCBpcyBhIHZhcmlhYmxlIGlkZW50aWZpZXIgYW5kIHdoZW4gaXQgaXMgdGhpc1xuIyDigJxzb21ldGltZXPigJ0ga2V5d29yZC5cbmlzRm9yRnJvbSA9IChwcmV2KSAtPlxuICAjIGBmb3IgaSBmcm9tIGl0ZXJhYmxlYFxuICBpZiBwcmV2WzBdIGlzICdJREVOVElGSUVSJ1xuICAgIHllc1xuICAjIGBmb3IgZnJvbeKApmBcbiAgZWxzZSBpZiBwcmV2WzBdIGlzICdGT1InXG4gICAgbm9cbiAgIyBgZm9yIHtmcm9tfeKApmAsIGBmb3IgW2Zyb21d4oCmYCwgYGZvciB7YSwgZnJvbX3igKZgLCBgZm9yIHthOiBmcm9tfeKApmBcbiAgZWxzZSBpZiBwcmV2WzFdIGluIFsneycsICdbJywgJywnLCAnOiddXG4gICAgbm9cbiAgZWxzZVxuICAgIHllc1xuXG5hZGRUb2tlbkRhdGEgPSAodG9rZW4sIGRhdGEpIC0+XG4gIE9iamVjdC5hc3NpZ24gKHRva2VuLmRhdGEgPz0ge30pLCBkYXRhXG5cbiMgQ29uc3RhbnRzXG4jIC0tLS0tLS0tLVxuXG4jIEtleXdvcmRzIHRoYXQgQ29mZmVlU2NyaXB0IHNoYXJlcyBpbiBjb21tb24gd2l0aCBKYXZhU2NyaXB0LlxuSlNfS0VZV09SRFMgPSBbXG4gICd0cnVlJywgJ2ZhbHNlJywgJ251bGwnLCAndGhpcydcbiAgJ25ldycsICdkZWxldGUnLCAndHlwZW9mJywgJ2luJywgJ2luc3RhbmNlb2YnXG4gICdyZXR1cm4nLCAndGhyb3cnLCAnYnJlYWsnLCAnY29udGludWUnLCAnZGVidWdnZXInLCAneWllbGQnLCAnYXdhaXQnXG4gICdpZicsICdlbHNlJywgJ3N3aXRjaCcsICdmb3InLCAnd2hpbGUnLCAnZG8nLCAndHJ5JywgJ2NhdGNoJywgJ2ZpbmFsbHknXG4gICdjbGFzcycsICdleHRlbmRzJywgJ3N1cGVyJ1xuICAnaW1wb3J0JywgJ2V4cG9ydCcsICdkZWZhdWx0J1xuXVxuXG4jIENvZmZlZVNjcmlwdC1vbmx5IGtleXdvcmRzLlxuQ09GRkVFX0tFWVdPUkRTID0gW1xuICAndW5kZWZpbmVkJywgJ0luZmluaXR5JywgJ05hTidcbiAgJ3RoZW4nLCAndW5sZXNzJywgJ3VudGlsJywgJ2xvb3AnLCAnb2YnLCAnYnknLCAnd2hlbidcbl1cblxuQ09GRkVFX0FMSUFTX01BUCA9XG4gIGFuZCAgOiAnJiYnXG4gIG9yICAgOiAnfHwnXG4gIGlzICAgOiAnPT0nXG4gIGlzbnQgOiAnIT0nXG4gIG5vdCAgOiAnISdcbiAgeWVzICA6ICd0cnVlJ1xuICBubyAgIDogJ2ZhbHNlJ1xuICBvbiAgIDogJ3RydWUnXG4gIG9mZiAgOiAnZmFsc2UnXG5cbkNPRkZFRV9BTElBU0VTICA9IChrZXkgZm9yIGtleSBvZiBDT0ZGRUVfQUxJQVNfTUFQKVxuQ09GRkVFX0tFWVdPUkRTID0gQ09GRkVFX0tFWVdPUkRTLmNvbmNhdCBDT0ZGRUVfQUxJQVNFU1xuXG4jIFRoZSBsaXN0IG9mIGtleXdvcmRzIHRoYXQgYXJlIHJlc2VydmVkIGJ5IEphdmFTY3JpcHQsIGJ1dCBub3QgdXNlZCwgb3IgYXJlXG4jIHVzZWQgYnkgQ29mZmVlU2NyaXB0IGludGVybmFsbHkuIFdlIHRocm93IGFuIGVycm9yIHdoZW4gdGhlc2UgYXJlIGVuY291bnRlcmVkLFxuIyB0byBhdm9pZCBoYXZpbmcgYSBKYXZhU2NyaXB0IGVycm9yIGF0IHJ1bnRpbWUuXG5SRVNFUlZFRCA9IFtcbiAgJ2Nhc2UnLCAnZnVuY3Rpb24nLCAndmFyJywgJ3ZvaWQnLCAnd2l0aCcsICdjb25zdCcsICdsZXQnLCAnZW51bSdcbiAgJ25hdGl2ZScsICdpbXBsZW1lbnRzJywgJ2ludGVyZmFjZScsICdwYWNrYWdlJywgJ3ByaXZhdGUnXG4gICdwcm90ZWN0ZWQnLCAncHVibGljJywgJ3N0YXRpYydcbl1cblxuU1RSSUNUX1BST1NDUklCRUQgPSBbJ2FyZ3VtZW50cycsICdldmFsJ11cblxuIyBUaGUgc3VwZXJzZXQgb2YgYm90aCBKYXZhU2NyaXB0IGtleXdvcmRzIGFuZCByZXNlcnZlZCB3b3Jkcywgbm9uZSBvZiB3aGljaCBtYXlcbiMgYmUgdXNlZCBhcyBpZGVudGlmaWVycyBvciBwcm9wZXJ0aWVzLlxuZXhwb3J0cy5KU19GT1JCSURERU4gPSBKU19LRVlXT1JEUy5jb25jYXQoUkVTRVJWRUQpLmNvbmNhdChTVFJJQ1RfUFJPU0NSSUJFRClcblxuIyBUaGUgY2hhcmFjdGVyIGNvZGUgb2YgdGhlIG5hc3R5IE1pY3Jvc29mdCBtYWRuZXNzIG90aGVyd2lzZSBrbm93biBhcyB0aGUgQk9NLlxuQk9NID0gNjUyNzlcblxuIyBUb2tlbiBtYXRjaGluZyByZWdleGVzLlxuSURFTlRJRklFUiA9IC8vLyBeXG4gICg/IVxcZClcbiAgKCAoPzogKD8hXFxzKVskXFx3XFx4N2YtXFx1ZmZmZl0gKSsgKVxuICAoIFteXFxuXFxTXSogOiAoPyE6KSApPyAgIyBJcyB0aGlzIGEgcHJvcGVydHkgbmFtZT9cbi8vL1xuXG4jIExpa2UgYElERU5USUZJRVJgLCBidXQgaW5jbHVkZXMgYC1gc1xuSlNYX0lERU5USUZJRVJfUEFSVCA9IC8vLyAoPzogKD8hXFxzKVtcXC0kXFx3XFx4N2YtXFx1ZmZmZl0gKSsgLy8vLnNvdXJjZVxuXG4jIEluIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL2pzeC8gc3BlYywgSlNYRWxlbWVudE5hbWUgY2FuIGJlXG4jIEpTWElkZW50aWZpZXIsIEpTWE5hbWVzcGFjZWROYW1lIChKU1hJZGVudGlmaWVyIDogSlNYSWRlbnRpZmllciksIG9yXG4jIEpTWE1lbWJlckV4cHJlc3Npb24gKHR3byBvciBtb3JlIEpTWElkZW50aWZpZXIgY29ubmVjdGVkIGJ5IGAuYHMpLlxuSlNYX0lERU5USUZJRVIgPSAvLy8gXlxuICAoPyFbXFxkPF0pICMgTXVzdCBub3Qgc3RhcnQgd2l0aCBgPGAuXG4gICggI3tKU1hfSURFTlRJRklFUl9QQVJUfVxuICAgICg/OiBcXHMqIDogXFxzKiAje0pTWF9JREVOVElGSUVSX1BBUlR9ICAgICAgICMgSlNYTmFtZXNwYWNlZE5hbWVcbiAgICB8ICg/OiBcXHMqIFxcLiBcXHMqICN7SlNYX0lERU5USUZJRVJfUEFSVH0gKSsgIyBKU1hNZW1iZXJFeHByZXNzaW9uXG4gICAgKT8gKVxuLy8vXG5cbiMgRnJhZ21lbnQ6IDw+PC8+XG5KU1hfRlJBR01FTlRfSURFTlRJRklFUiA9IC8vLyBeXG4gICgpPiAjIEVuZHMgaW1tZWRpYXRlbHkgd2l0aCBgPmAuXG4vLy9cblxuIyBJbiBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9qc3gvIHNwZWMsIEpTWEF0dHJpYnV0ZU5hbWUgY2FuIGJlIGVpdGhlclxuIyBKU1hJZGVudGlmaWVyIG9yIEpTWE5hbWVzcGFjZWROYW1lIHdoaWNoIGlzIEpTWElkZW50aWZpZXIgOiBKU1hJZGVudGlmaWVyXG5KU1hfQVRUUklCVVRFID0gLy8vIF5cbiAgKD8hXFxkKVxuICAoICN7SlNYX0lERU5USUZJRVJfUEFSVH1cbiAgICAoPzogXFxzKiA6IFxccyogI3tKU1hfSURFTlRJRklFUl9QQVJUfSAgICAgICAjIEpTWE5hbWVzcGFjZWROYW1lXG4gICAgKT8gKVxuICAoIFteXFxTXSogPSAoPyE9KSApPyAgIyBJcyB0aGlzIGFuIGF0dHJpYnV0ZSB3aXRoIGEgdmFsdWU/XG4vLy9cblxuTlVNQkVSICAgICA9IC8vL1xuICBeIDBiWzAxXSg/Ol8/WzAxXSkqbj8gICAgICAgICAgICAgICAgICAgICAgICAgfCAjIGJpbmFyeVxuICBeIDBvWzAtN10oPzpfP1swLTddKSpuPyAgICAgICAgICAgICAgICAgICAgICAgfCAjIG9jdGFsXG4gIF4gMHhbXFxkYS1mXSg/Ol8/W1xcZGEtZl0pKm4/ICAgICAgICAgICAgICAgICAgIHwgIyBoZXhcbiAgXiBcXGQrKD86X1xcZCspKm4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAjIGRlY2ltYWwgYmlnaW50XG4gIF4gKD86XFxkKyg/Ol9cXGQrKSopPyAgICAgIFxcLj8gXFxkKyg/Ol9cXGQrKSogICAgICAgIyBkZWNpbWFsXG4gICAgICAgICAgICAgICAgICAgICAoPzplWystXT8gXFxkKyg/Ol9cXGQrKSogKT9cbiAgIyBkZWNpbWFsIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtZXJpYyBsaXRlcmFsIHNlcGFyYXRvcnMgZm9yIHJlZmVyZW5jZTpcbiAgIyBcXGQqXFwuP1xcZCsgKD86ZVsrLV0/XFxkKyk/XG4vLy9pXG5cbk9QRVJBVE9SICAgPSAvLy8gXiAoXG4gID86IFstPV0+ICAgICAgICAgICAgICMgZnVuY3Rpb25cbiAgIHwgWy0rKi8lPD4mfF4hPz1dPSAgIyBjb21wb3VuZCBhc3NpZ24gLyBjb21wYXJlXG4gICB8ID4+Pj0/ICAgICAgICAgICAgICMgemVyby1maWxsIHJpZ2h0IHNoaWZ0XG4gICB8IChbLSs6XSlcXDEgICAgICAgICAjIGRvdWJsZXNcbiAgIHwgKFsmfDw+Ki8lXSlcXDI9PyAgICMgbG9naWMgLyBzaGlmdCAvIHBvd2VyIC8gZmxvb3IgZGl2aXNpb24gLyBtb2R1bG9cbiAgIHwgXFw/KFxcLnw6OikgICAgICAgICAjIHNvYWsgYWNjZXNzXG4gICB8IFxcLnsyLDN9ICAgICAgICAgICAjIHJhbmdlIG9yIHNwbGF0XG4pIC8vL1xuXG5XSElURVNQQUNFID0gL15bXlxcblxcU10rL1xuXG5DT01NRU5UICAgID0gL14oXFxzKikjIyMoW14jXVtcXHNcXFNdKj8pKD86IyMjKFteXFxuXFxTXSopfCMjIyQpfF4oKD86XFxzKiMoPyEjI1teI10pLiopKykvXG5cbkNPREUgICAgICAgPSAvXlstPV0+L1xuXG5NVUxUSV9ERU5UID0gL14oPzpcXG5bXlxcblxcU10qKSsvXG5cbkpTVE9LRU4gICAgICA9IC8vL14gYCg/IWBgKSAoKD86IFteYFxcXFxdIHwgXFxcXFtcXHNcXFNdICAgICAgICAgICApKikgYCAgIC8vL1xuSEVSRV9KU1RPS0VOID0gLy8vXiBgYGAgICAgICgoPzogW15gXFxcXF0gfCBcXFxcW1xcc1xcU10gfCBgKD8hYGApICkqKSBgYGAgLy8vXG5cbiMgU3RyaW5nLW1hdGNoaW5nLXJlZ2V4ZXMuXG5TVFJJTkdfU1RBUlQgICA9IC9eKD86JycnfFwiXCJcInwnfFwiKS9cblxuU1RSSU5HX1NJTkdMRSAgPSAvLy8gXig/OiBbXlxcXFwnXSAgfCBcXFxcW1xcc1xcU10gICAgICAgICAgICAgICAgICAgICAgKSogLy8vXG5TVFJJTkdfRE9VQkxFICA9IC8vLyBeKD86IFteXFxcXFwiI10gfCBcXFxcW1xcc1xcU10gfCAgICAgICAgICAgXFwjKD8hXFx7KSApKiAvLy9cbkhFUkVET0NfU0lOR0xFID0gLy8vIF4oPzogW15cXFxcJ10gIHwgXFxcXFtcXHNcXFNdIHwgJyg/IScnKSAgICAgICAgICAgICkqIC8vL1xuSEVSRURPQ19ET1VCTEUgPSAvLy8gXig/OiBbXlxcXFxcIiNdIHwgXFxcXFtcXHNcXFNdIHwgXCIoPyFcIlwiKSB8IFxcIyg/IVxceykgKSogLy8vXG5cbklOU0lERV9KU1ggPSAvLy8gXig/OlxuICAgIFteXG4gICAgICBcXHsgIyBTdGFydCBvZiBDb2ZmZWVTY3JpcHQgaW50ZXJwb2xhdGlvbi5cbiAgICAgIDwgICMgTWF5YmUgSlNYIHRhZyAoYDxgIG5vdCBhbGxvd2VkIGV2ZW4gaWYgYmFyZSkuXG4gICAgXVxuICApKiAvLy8gIyBTaW1pbGFyIHRvIGBIRVJFRE9DX0RPVUJMRWAgYnV0IHRoZXJlIGlzIG5vIGVzY2FwaW5nLlxuSlNYX0lOVEVSUE9MQVRJT04gPSAvLy8gXig/OlxuICAgICAgXFx7ICAgICAgICMgQ29mZmVlU2NyaXB0IGludGVycG9sYXRpb24uXG4gICAgfCA8KD8hLykgICAjIEpTWCBvcGVuaW5nIHRhZy5cbiAgKS8vL1xuXG5IRVJFRE9DX0lOREVOVCAgICAgPSAvXFxuKyhbXlxcblxcU10qKSg/PVxcUykvZ1xuXG4jIFJlZ2V4LW1hdGNoaW5nLXJlZ2V4ZXMuXG5SRUdFWCA9IC8vLyBeXG4gIC8gKD8hLykgKChcbiAgPzogW14gWyAvIFxcbiBcXFxcIF0gICMgRXZlcnkgb3RoZXIgdGhpbmcuXG4gICB8IFxcXFxbXlxcbl0gICAgICAgICAjIEFueXRoaW5nIGJ1dCBuZXdsaW5lcyBlc2NhcGVkLlxuICAgfCBcXFsgICAgICAgICAgICAgICMgQ2hhcmFjdGVyIGNsYXNzLlxuICAgICAgICg/OiBcXFxcW15cXG5dIHwgW14gXFxdIFxcbiBcXFxcIF0gKSpcbiAgICAgXFxdXG4gICkqKSAoLyk/XG4vLy9cblxuUkVHRVhfRkxBR1MgID0gL15cXHcqL1xuVkFMSURfRkxBR1MgID0gL14oPyEuKiguKS4qXFwxKVtkZ2ltc3V2eV0qJC9cblxuSEVSRUdFWCAgICAgID0gLy8vIF5cbiAgKD86XG4gICAgICAjIE1hdGNoIGFueSBjaGFyYWN0ZXIsIGV4Y2VwdCB0aG9zZSB0aGF0IG5lZWQgc3BlY2lhbCBoYW5kbGluZyBiZWxvdy5cbiAgICAgIFteXFxcXC8jXFxzXVxuICAgICAgIyBNYXRjaCBgXFxgIGZvbGxvd2VkIGJ5IGFueSBjaGFyYWN0ZXIuXG4gICAgfCBcXFxcW1xcc1xcU11cbiAgICAgICMgTWF0Y2ggYW55IGAvYCBleGNlcHQgYC8vL2AuXG4gICAgfCAvKD8hLy8pXG4gICAgICAjIE1hdGNoIGAjYCB3aGljaCBpcyBub3QgcGFydCBvZiBpbnRlcnBvbGF0aW9uLCBlLmcuIGAje31gLlxuICAgIHwgXFwjKD8hXFx7KVxuICAgICAgIyBDb21tZW50cyBjb25zdW1lIGV2ZXJ5dGhpbmcgdW50aWwgdGhlIGVuZCBvZiB0aGUgbGluZSwgaW5jbHVkaW5nIGAvLy9gLlxuICAgIHwgXFxzKyg/OiMoPyFcXHspLiopP1xuICApKlxuLy8vXG5cbkhFUkVHRVhfQ09NTUVOVCA9IC8oXFxzKykoIyg/IXspLiopL2dtXG5cblJFR0VYX0lMTEVHQUwgPSAvLy8gXiAoIC8gfCAvezN9XFxzKikgKFxcKikgLy8vXG5cblBPU1NJQkxZX0RJVklTSU9OICAgPSAvLy8gXiAvPT9cXHMgLy8vXG5cbiMgT3RoZXIgcmVnZXhlcy5cbkhFUkVDT01NRU5UX0lMTEVHQUwgPSAvXFwqXFwvL1xuXG5MSU5FX0NPTlRJTlVFUiAgICAgID0gLy8vIF4gXFxzKiAoPzogLCB8IFxcPz9cXC4oPyFbLlxcZF0pIHwgXFw/Pzo6ICkgLy8vXG5cblNUUklOR19JTlZBTElEX0VTQ0FQRSA9IC8vL1xuICAoICg/Ol58W15cXFxcXSkgKD86XFxcXFxcXFwpKiApICAgICAgICAjIE1ha2Ugc3VyZSB0aGUgZXNjYXBlIGlzbuKAmXQgZXNjYXBlZC5cbiAgXFxcXCAoXG4gICAgID86ICgwXFxkfFsxLTddKSAgICAgICAgICAgICAgICAjIG9jdGFsIGVzY2FwZVxuICAgICAgfCAoeCg/IVtcXGRhLWZBLUZdezJ9KS57MCwyfSkgIyBoZXggZXNjYXBlXG4gICAgICB8ICh1XFx7KD8hW1xcZGEtZkEtRl17MSx9XFx9KVtefV0qXFx9PykgIyB1bmljb2RlIGNvZGUgcG9pbnQgZXNjYXBlXG4gICAgICB8ICh1KD8hXFx7fFtcXGRhLWZBLUZdezR9KS57MCw0fSkgIyB1bmljb2RlIGVzY2FwZVxuICApXG4vLy9cblJFR0VYX0lOVkFMSURfRVNDQVBFID0gLy8vXG4gICggKD86XnxbXlxcXFxdKSAoPzpcXFxcXFxcXCkqICkgICAgICAgICMgTWFrZSBzdXJlIHRoZSBlc2NhcGUgaXNu4oCZdCBlc2NhcGVkLlxuICBcXFxcIChcbiAgICAgPzogKDBcXGQpICAgICAgICAgICAgICAgICAgICAgICMgb2N0YWwgZXNjYXBlXG4gICAgICB8ICh4KD8hW1xcZGEtZkEtRl17Mn0pLnswLDJ9KSAjIGhleCBlc2NhcGVcbiAgICAgIHwgKHVcXHsoPyFbXFxkYS1mQS1GXXsxLH1cXH0pW159XSpcXH0/KSAjIHVuaWNvZGUgY29kZSBwb2ludCBlc2NhcGVcbiAgICAgIHwgKHUoPyFcXHt8W1xcZGEtZkEtRl17NH0pLnswLDR9KSAjIHVuaWNvZGUgZXNjYXBlXG4gIClcbi8vL1xuXG5UUkFJTElOR19TUEFDRVMgICAgID0gL1xccyskL1xuXG4jIENvbXBvdW5kIGFzc2lnbm1lbnQgdG9rZW5zLlxuQ09NUE9VTkRfQVNTSUdOID0gW1xuICAnLT0nLCAnKz0nLCAnLz0nLCAnKj0nLCAnJT0nLCAnfHw9JywgJyYmPScsICc/PScsICc8PD0nLCAnPj49JywgJz4+Pj0nXG4gICcmPScsICdePScsICd8PScsICcqKj0nLCAnLy89JywgJyUlPSdcbl1cblxuIyBVbmFyeSB0b2tlbnMuXG5VTkFSWSA9IFsnTkVXJywgJ1RZUEVPRicsICdERUxFVEUnXVxuXG5VTkFSWV9NQVRIID0gWychJywgJ34nXVxuXG4jIEJpdC1zaGlmdGluZyB0b2tlbnMuXG5TSElGVCA9IFsnPDwnLCAnPj4nLCAnPj4+J11cblxuIyBDb21wYXJpc29uIHRva2Vucy5cbkNPTVBBUkUgPSBbJz09JywgJyE9JywgJzwnLCAnPicsICc8PScsICc+PSddXG5cbiMgTWF0aGVtYXRpY2FsIHRva2Vucy5cbk1BVEggPSBbJyonLCAnLycsICclJywgJy8vJywgJyUlJ11cblxuIyBSZWxhdGlvbmFsIHRva2VucyB0aGF0IGFyZSBuZWdhdGFibGUgd2l0aCBgbm90YCBwcmVmaXguXG5SRUxBVElPTiA9IFsnSU4nLCAnT0YnLCAnSU5TVEFOQ0VPRiddXG5cbiMgQm9vbGVhbiB0b2tlbnMuXG5CT09MID0gWydUUlVFJywgJ0ZBTFNFJ11cblxuIyBUb2tlbnMgd2hpY2ggY291bGQgbGVnaXRpbWF0ZWx5IGJlIGludm9rZWQgb3IgaW5kZXhlZC4gQW4gb3BlbmluZ1xuIyBwYXJlbnRoZXNlcyBvciBicmFja2V0IGZvbGxvd2luZyB0aGVzZSB0b2tlbnMgd2lsbCBiZSByZWNvcmRlZCBhcyB0aGUgc3RhcnRcbiMgb2YgYSBmdW5jdGlvbiBpbnZvY2F0aW9uIG9yIGluZGV4aW5nIG9wZXJhdGlvbi5cbkNBTExBQkxFICA9IFsnSURFTlRJRklFUicsICdQUk9QRVJUWScsICcpJywgJ10nLCAnPycsICdAJywgJ1RISVMnLCAnU1VQRVInLCAnRFlOQU1JQ19JTVBPUlQnXVxuSU5ERVhBQkxFID0gQ0FMTEFCTEUuY29uY2F0IFtcbiAgJ05VTUJFUicsICdJTkZJTklUWScsICdOQU4nLCAnU1RSSU5HJywgJ1NUUklOR19FTkQnLCAnUkVHRVgnLCAnUkVHRVhfRU5EJ1xuICAnQk9PTCcsICdOVUxMJywgJ1VOREVGSU5FRCcsICd9JywgJzo6J1xuXVxuXG4jIFRva2VucyB3aGljaCBjYW4gYmUgdGhlIGxlZnQtaGFuZCBzaWRlIG9mIGEgbGVzcy10aGFuIGNvbXBhcmlzb24sIGkuZS4gYGE8YmAuXG5DT01QQVJBQkxFX0xFRlRfU0lERSA9IFsnSURFTlRJRklFUicsICcpJywgJ10nLCAnTlVNQkVSJ11cblxuIyBUb2tlbnMgd2hpY2ggYSByZWd1bGFyIGV4cHJlc3Npb24gd2lsbCBuZXZlciBpbW1lZGlhdGVseSBmb2xsb3cgKGV4Y2VwdCBzcGFjZWRcbiMgQ0FMTEFCTEVzIGluIHNvbWUgY2FzZXMpLCBidXQgd2hpY2ggYSBkaXZpc2lvbiBvcGVyYXRvciBjYW4uXG4jXG4jIFNlZTogaHR0cDovL3d3dy1hcmNoaXZlLm1vemlsbGEub3JnL2pzL2xhbmd1YWdlL2pzMjAtMjAwMi0wNC9yYXRpb25hbGUvc3ludGF4Lmh0bWwjcmVndWxhci1leHByZXNzaW9uc1xuTk9UX1JFR0VYID0gSU5ERVhBQkxFLmNvbmNhdCBbJysrJywgJy0tJ11cblxuIyBUb2tlbnMgdGhhdCwgd2hlbiBpbW1lZGlhdGVseSBwcmVjZWRpbmcgYSBgV0hFTmAsIGluZGljYXRlIHRoYXQgdGhlIGBXSEVOYFxuIyBvY2N1cnMgYXQgdGhlIHN0YXJ0IG9mIGEgbGluZS4gV2UgZGlzYW1iaWd1YXRlIHRoZXNlIGZyb20gdHJhaWxpbmcgd2hlbnMgdG9cbiMgYXZvaWQgYW4gYW1iaWd1aXR5IGluIHRoZSBncmFtbWFyLlxuTElORV9CUkVBSyA9IFsnSU5ERU5UJywgJ09VVERFTlQnLCAnVEVSTUlOQVRPUiddXG5cbiMgQWRkaXRpb25hbCBpbmRlbnQgaW4gZnJvbnQgb2YgdGhlc2UgaXMgaWdub3JlZC5cbklOREVOVEFCTEVfQ0xPU0VSUyA9IFsnKScsICd9JywgJ10nXVxuIl19
//# sourceURL=/home/flow/jzr/coffeescript/src/lexer.coffee