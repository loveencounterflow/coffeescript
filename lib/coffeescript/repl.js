// Generated by CoffeeScript 2.7.0
(function() {
  var CoffeeScript, addHistory, addMultilineHandler, fs, getCommandId, merge, nodeREPL, path, replDefaults, runInContext, sawSIGINT, transpile, updateSyntaxError, vm;

  fs = require('fs');

  path = require('path');

  vm = require('vm');

  nodeREPL = require('repl');

  CoffeeScript = require('./');

  ({merge, updateSyntaxError} = require('./helpers'));

  sawSIGINT = false;

  transpile = false;

  replDefaults = {
    prompt: 'coffee> ',
    historyFile: (function() {
      var historyPath;
      historyPath = process.env.XDG_CACHE_HOME || process.env.HOME;
      if (historyPath) {
        return path.join(historyPath, '.coffee_history');
      }
    })(),
    historyMaxInputSize: 10240,
    eval: function(input, context, filename, cb) {
      var Assign, Block, Call, Code, Literal, Root, Value, ast, err, isAsync, js, ref, ref1, referencedVars, result, token, tokens;
      // XXX: multiline hack.
      input = input.replace(/\uFF00/g, '\n');
      // Node's REPL sends the input ending with a newline and then wrapped in
      // parens. Unwrap all that.
      input = input.replace(/^\(([\s\S]*)\n\)$/m, '$1');
      // Node's REPL v6.9.1+ sends the input wrapped in a try/catch statement.
      // Unwrap that too.
      input = input.replace(/^\s*try\s*{([\s\S]*)}\s*catch.*$/m, '$1');
      // Require AST nodes to do some AST manipulation.
      ({Block, Assign, Value, Literal, Call, Code, Root} = require('./nodes'));
      try {
        // Tokenize the clean input.
        tokens = CoffeeScript.tokens(input);
        // Filter out tokens generated just to hold comments.
        if (tokens.length >= 2 && tokens[0].generated && ((ref = tokens[0].comments) != null ? ref.length : void 0) !== 0 && `${tokens[0][1]}` === '' && tokens[1][0] === 'TERMINATOR') {
          tokens = tokens.slice(2);
        }
        if (tokens.length >= 1 && tokens[tokens.length - 1].generated && ((ref1 = tokens[tokens.length - 1].comments) != null ? ref1.length : void 0) !== 0 && `${tokens[tokens.length - 1][1]}` === '') {
          tokens.pop();
        }
        // Collect referenced variable names just like in `CoffeeScript.compile`.
        referencedVars = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = tokens.length; i < len; i++) {
            token = tokens[i];
            if (token[0] === 'IDENTIFIER') {
              results.push(token[1]);
            }
          }
          return results;
        })();
        // Generate the AST of the tokens.
        ast = CoffeeScript.nodes(tokens).body;
        // Add assignment to `__` variable to force the input to be an expression.
        ast = new Block([new Assign(new Value(new Literal('__')), ast, '=')]);
        // Wrap the expression in a closure to support top-level `await`.
        ast = new Code([], ast);
        isAsync = ast.isAsync;
        // Invoke the wrapping closure.
        ast = new Root(new Block([new Call(ast)]));
        js = ast.compile({
          bare: true,
          locals: Object.keys(context),
          referencedVars,
          sharedScope: true
        });
        if (transpile) {
          js = transpile.transpile(js, transpile.options).code;
          // Strip `"use strict"`, to avoid an exception on assigning to
          // undeclared variable `__`.
          js = js.replace(/^"use strict"|^'use strict'/, '');
        }
        result = runInContext(js, context, filename);
        // Await an async result, if necessary.
        if (isAsync) {
          result.then(function(resolvedResult) {
            if (!sawSIGINT) {
              return cb(null, resolvedResult);
            }
          });
          return sawSIGINT = false;
        } else {
          return cb(null, result);
        }
      } catch (error) {
        err = error;
        // AST's `compile` does not add source code information to syntax errors.
        updateSyntaxError(err, input);
        return cb(err);
      }
    }
  };

  runInContext = function(js, context, filename) {
    if (context === global) {
      return vm.runInThisContext(js, filename);
    } else {
      return vm.runInContext(js, context, filename);
    }
  };

  addMultilineHandler = function(repl) {
    var inputStream, multiline, nodeLineListener, origPrompt, outputStream, ref;
    ({inputStream, outputStream} = repl);
    // Node 0.11.12 changed API, prompt is now _prompt.
    origPrompt = (ref = repl._prompt) != null ? ref : repl.prompt;
    multiline = {
      enabled: false,
      initialPrompt: origPrompt.replace(/^[^> ]*/, function(x) {
        return x.replace(/./g, '-');
      }),
      prompt: origPrompt.replace(/^[^> ]*>?/, function(x) {
        return x.replace(/./g, '.');
      }),
      buffer: ''
    };
    // Proxy node's line listener
    nodeLineListener = repl.listeners('line')[0];
    repl.removeListener('line', nodeLineListener);
    repl.on('line', function(cmd) {
      if (multiline.enabled) {
        multiline.buffer += `${cmd}\n`;
        repl.setPrompt(multiline.prompt);
        repl.prompt(true);
      } else {
        repl.setPrompt(origPrompt);
        nodeLineListener(cmd);
      }
    });
    // Handle Ctrl-v
    return inputStream.on('keypress', function(char, key) {
      if (!(key && key.ctrl && !key.meta && !key.shift && key.name === 'v')) {
        return;
      }
      if (multiline.enabled) {
        // allow arbitrarily switching between modes any time before multiple lines are entered
        if (!multiline.buffer.match(/\n/)) {
          multiline.enabled = !multiline.enabled;
          repl.setPrompt(origPrompt);
          repl.prompt(true);
          return;
        }
        // no-op unless the current line is empty
        if ((repl.line != null) && !repl.line.match(/^\s*$/)) {
          return;
        }
        // eval, print, loop
        multiline.enabled = !multiline.enabled;
        repl.line = '';
        repl.cursor = 0;
        repl.output.cursorTo(0);
        repl.output.clearLine(1);
        // XXX: multiline hack
        multiline.buffer = multiline.buffer.replace(/\n/g, '\uFF00');
        repl.emit('line', multiline.buffer);
        multiline.buffer = '';
      } else {
        multiline.enabled = !multiline.enabled;
        repl.setPrompt(multiline.initialPrompt);
        repl.prompt(true);
      }
    });
  };

  // Store and load command history from a file
  addHistory = function(repl, filename, maxSize) {
    var buffer, fd, lastLine, readFd, size, stat;
    lastLine = null;
    try {
      // Get file info and at most maxSize of command history
      stat = fs.statSync(filename);
      size = Math.min(maxSize, stat.size);
      // Read last `size` bytes from the file
      readFd = fs.openSync(filename, 'r');
      buffer = Buffer.alloc(size);
      fs.readSync(readFd, buffer, 0, size, stat.size - size);
      fs.closeSync(readFd);
      // Set the history on the interpreter
      repl.history = buffer.toString().split('\n').reverse();
      if (stat.size > maxSize) {
        // If the history file was truncated we should pop off a potential partial line
        repl.history.pop();
      }
      if (repl.history[0] === '') {
        // Shift off the final blank newline
        repl.history.shift();
      }
      repl.historyIndex = -1;
      lastLine = repl.history[0];
    } catch (error) {}
    fd = fs.openSync(filename, 'a');
    repl.addListener('line', function(code) {
      if (code && code.length && code !== '.history' && code !== '.exit' && lastLine !== code) {
        // Save the latest command in the file
        fs.writeSync(fd, `${code}\n`);
        return lastLine = code;
      }
    });
    // XXX: The SIGINT event from REPLServer is undocumented, so this is a bit fragile
    repl.on('SIGINT', function() {
      return sawSIGINT = true;
    });
    repl.on('exit', function() {
      return fs.closeSync(fd);
    });
    // Add a command to show the history stack
    return repl.commands[getCommandId(repl, 'history')] = {
      help: 'Show command history',
      action: function() {
        repl.outputStream.write(`${repl.history.slice(0).reverse().join('\n')}\n`);
        return repl.displayPrompt();
      }
    };
  };

  getCommandId = function(repl, commandName) {
    var commandsHaveLeadingDot;
    // Node 0.11 changed API, a command such as '.help' is now stored as 'help'
    commandsHaveLeadingDot = repl.commands['.help'] != null;
    if (commandsHaveLeadingDot) {
      return `.${commandName}`;
    } else {
      return commandName;
    }
  };

  module.exports = {
    start: function(opts = {}) {
      var Module, build, major, minor, originalModuleLoad, repl;
      [major, minor, build] = process.versions.node.split('.').map(function(n) {
        return parseInt(n, 10);
      });
      if (major < 6) {
        console.warn("Node 6+ required for CoffeeScript REPL");
        process.exit(1);
      }
      CoffeeScript.register();
      process.argv = ['coffee'].concat(process.argv.slice(2));
      if (opts.transpile) {
        transpile = {};
        try {
          transpile.transpile = require('@babel/core').transform;
        } catch (error) {
          try {
            transpile.transpile = require('babel-core').transform;
          } catch (error) {
            console.error(`To use --transpile with an interactive REPL, @babel/core must be installed either in the current folder or globally:
  npm install --save-dev @babel/core
or
  npm install --global @babel/core
And you must save options to configure Babel in one of the places it looks to find its options.
See https://coffeescript.org/#transpilation`);
            process.exit(1);
          }
        }
        transpile.options = {
          filename: path.resolve(process.cwd(), '<repl>')
        };
        // Since the REPL compilation path is unique (in `eval` above), we need
        // another way to get the `options` object attached to a module so that
        // it knows later on whether it needs to be transpiled. In the case of
        // the REPL, the only applicable option is `transpile`.
        Module = require('module');
        originalModuleLoad = Module.prototype.load;
        Module.prototype.load = function(filename) {
          this.options = {
            transpile: transpile.options
          };
          return originalModuleLoad.call(this, filename);
        };
      }
      opts = merge(replDefaults, opts);
      repl = nodeREPL.start(opts);
      if (opts.prelude) {
        runInContext(opts.prelude, repl.context, 'prelude');
      }
      repl.on('exit', function() {
        if (!repl.closed) {
          return repl.outputStream.write('\n');
        }
      });
      addMultilineHandler(repl);
      if (opts.historyFile) {
        addHistory(repl, opts.historyFile, opts.historyMaxInputSize);
      }
      // Adapt help inherited from the node REPL
      repl.commands[getCommandId(repl, 'load')].help = 'Load code from a file into this REPL session';
      return repl;
    }
  };

}).call(this);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVwbC5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8iLCJzb3VyY2VzIjpbInNyYy9yZXBsLmNvZmZlZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFBQSxNQUFBLFlBQUEsRUFBQSxVQUFBLEVBQUEsbUJBQUEsRUFBQSxFQUFBLEVBQUEsWUFBQSxFQUFBLEtBQUEsRUFBQSxRQUFBLEVBQUEsSUFBQSxFQUFBLFlBQUEsRUFBQSxZQUFBLEVBQUEsU0FBQSxFQUFBLFNBQUEsRUFBQSxpQkFBQSxFQUFBOztFQUFBLEVBQUEsR0FBSyxPQUFBLENBQVEsSUFBUjs7RUFDTCxJQUFBLEdBQU8sT0FBQSxDQUFRLE1BQVI7O0VBQ1AsRUFBQSxHQUFLLE9BQUEsQ0FBUSxJQUFSOztFQUNMLFFBQUEsR0FBVyxPQUFBLENBQVEsTUFBUjs7RUFDWCxZQUFBLEdBQWUsT0FBQSxDQUFRLElBQVI7O0VBQ2YsQ0FBQSxDQUFDLEtBQUQsRUFBUSxpQkFBUixDQUFBLEdBQTZCLE9BQUEsQ0FBUSxXQUFSLENBQTdCOztFQUVBLFNBQUEsR0FBWTs7RUFDWixTQUFBLEdBQVk7O0VBRVosWUFBQSxHQUNFO0lBQUEsTUFBQSxFQUFRLFVBQVI7SUFDQSxXQUFBLEVBQWdCLENBQUEsUUFBQSxDQUFBLENBQUE7QUFDbEIsVUFBQTtNQUFJLFdBQUEsR0FBYyxPQUFPLENBQUMsR0FBRyxDQUFDLGNBQVosSUFBOEIsT0FBTyxDQUFDLEdBQUcsQ0FBQztNQUN4RCxJQUE0QyxXQUE1QztlQUFBLElBQUksQ0FBQyxJQUFMLENBQVUsV0FBVixFQUF1QixpQkFBdkIsRUFBQTs7SUFGYyxDQUFBLEdBRGhCO0lBSUEsbUJBQUEsRUFBcUIsS0FKckI7SUFLQSxJQUFBLEVBQU0sUUFBQSxDQUFDLEtBQUQsRUFBUSxPQUFSLEVBQWlCLFFBQWpCLEVBQTJCLEVBQTNCLENBQUE7QUFDUixVQUFBLE1BQUEsRUFBQSxLQUFBLEVBQUEsSUFBQSxFQUFBLElBQUEsRUFBQSxPQUFBLEVBQUEsSUFBQSxFQUFBLEtB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LENBQWUsSUFBZjtNQUNQLElBQXNELElBQUksQ0FBQyxPQUEzRDtRQUFBLFlBQUEsQ0FBYSxJQUFJLENBQUMsT0FBbEIsRUFBMkIsSUFBSSxDQUFDLE9BQWhDLEVBQXlDLFNBQXpDLEVBQUE7O01BQ0EsSUFBSSxDQUFDLEVBQUwsQ0FBUSxNQUFSLEVBQWdCLFFBQUEsQ0FBQSxDQUFBO1FBQUcsSUFBZ0MsQ0FBSSxJQUFJLENBQUMsTUFBekM7aUJBQUEsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFsQixDQUF3QixJQUF4QixFQUFBOztNQUFILENBQWhCO01BQ0EsbUJBQUEsQ0FBb0IsSUFBcEI7TUFDQSxJQUErRCxJQUFJLENBQUMsV0FBcEU7UUFBQSxVQUFBLENBQVcsSUFBWCxFQUFpQixJQUFJLENBQUMsV0FBdEIsRUFBbUMsSUFBSSxDQUFDLG1CQUF4QyxFQUFBO09BekNKOztNQTJDSSxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQUEsQ0FBYSxJQUFiLEVBQW1CLE1BQW5CLENBQUQsQ0FBNEIsQ0FBQyxJQUExQyxHQUFpRDthQUNqRDtJQTdDSztFQUFQO0FBOUtGIiwic291cmNlc0NvbnRlbnQiOlsiZnMgPSByZXF1aXJlICdmcydcbnBhdGggPSByZXF1aXJlICdwYXRoJ1xudm0gPSByZXF1aXJlICd2bSdcbm5vZGVSRVBMID0gcmVxdWlyZSAncmVwbCdcbkNvZmZlZVNjcmlwdCA9IHJlcXVpcmUgJy4vJ1xue21lcmdlLCB1cGRhdGVTeW50YXhFcnJvcn0gPSByZXF1aXJlICcuL2hlbHBlcnMnXG5cbnNhd1NJR0lOVCA9IG5vXG50cmFuc3BpbGUgPSBub1xuXG5yZXBsRGVmYXVsdHMgPVxuICBwcm9tcHQ6ICdjb2ZmZWU+ICcsXG4gIGhpc3RvcnlGaWxlOiBkbyAtPlxuICAgIGhpc3RvcnlQYXRoID0gcHJvY2Vzcy5lbnYuWERHX0NBQ0hFX0hPTUUgb3IgcHJvY2Vzcy5lbnYuSE9NRVxuICAgIHBhdGguam9pbiBoaXN0b3J5UGF0aCwgJy5jb2ZmZWVfaGlzdG9yeScgaWYgaGlzdG9yeVBhdGhcbiAgaGlzdG9yeU1heElucHV0U2l6ZTogMTAyNDBcbiAgZXZhbDogKGlucHV0LCBjb250ZXh0LCBmaWxlbmFtZSwgY2IpIC0+XG4gICAgIyBYWFg6IG11bHRpbGluZSBoYWNrLlxuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSAvXFx1RkYwMC9nLCAnXFxuJ1xuICAgICMgTm9kZSdzIFJFUEwgc2VuZHMgdGhlIGlucHV0IGVuZGluZyB3aXRoIGEgbmV3bGluZSBhbmQgdGhlbiB3cmFwcGVkIGluXG4gICAgIyBwYXJlbnMuIFVud3JhcCBhbGwgdGhhdC5cbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UgL15cXCgoW1xcc1xcU10qKVxcblxcKSQvbSwgJyQxJ1xuICAgICMgTm9kZSdzIFJFUEwgdjYuOS4xKyBzZW5kcyB0aGUgaW5wdXQgd3JhcHBlZCBpbiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG4gICAgIyBVbndyYXAgdGhhdCB0b28uXG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlIC9eXFxzKnRyeVxccyp7KFtcXHNcXFNdKil9XFxzKmNhdGNoLiokL20sICckMSdcblxuICAgICMgUmVxdWlyZSBBU1Qgbm9kZXMgdG8gZG8gc29tZSBBU1QgbWFuaXB1bGF0aW9uLlxuICAgIHtCbG9jaywgQXNzaWduLCBWYWx1ZSwgTGl0ZXJhbCwgQ2FsbCwgQ29kZSwgUm9vdH0gPSByZXF1aXJlICcuL25vZGVzJ1xuXG4gICAgdHJ5XG4gICAgICAjIFRva2VuaXplIHRoZSBjbGVhbiBpbnB1dC5cbiAgICAgIHRva2VucyA9IENvZmZlZVNjcmlwdC50b2tlbnMgaW5wdXRcbiAgICAgICMgRmlsdGVyIG91dCB0b2tlbnMgZ2VuZXJhdGVkIGp1c3QgdG8gaG9sZCBjb21tZW50cy5cbiAgICAgIGlmIHRva2Vucy5sZW5ndGggPj0gMiBhbmQgdG9rZW5zWzBdLmdlbmVyYXRlZCBhbmRcbiAgICAgICAgIHRva2Vuc1swXS5jb21tZW50cz8ubGVuZ3RoIGlzbnQgMCBhbmQgXCIje3Rva2Vuc1swXVsxXX1cIiBpcyAnJyBhbmRcbiAgICAgICAgIHRva2Vuc1sxXVswXSBpcyAnVEVSTUlOQVRPUidcbiAgICAgICAgdG9rZW5zID0gdG9rZW5zWzIuLi5dXG4gICAgICBpZiB0b2tlbnMubGVuZ3RoID49IDEgYW5kIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0uZ2VuZXJhdGVkIGFuZFxuICAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS5jb21tZW50cz8ubGVuZ3RoIGlzbnQgMCBhbmQgXCIje3Rva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV1bMV19XCIgaXMgJydcbiAgICAgICAgdG9rZW5zLnBvcCgpXG4gICAgICAjIENvbGxlY3QgcmVmZXJlbmNlZCB2YXJpYWJsZSBuYW1lcyBqdXN0IGxpa2UgaW4gYENvZmZlZVNjcmlwdC5jb21waWxlYC5cbiAgICAgIHJlZmVyZW5jZWRWYXJzID0gKHRva2VuWzFdIGZvciB0b2tlbiBpbiB0b2tlbnMgd2hlbiB0b2tlblswXSBpcyAnSURFTlRJRklFUicpXG4gICAgICAjIEdlbmVyYXRlIHRoZSBBU1Qgb2YgdGhlIHRva2Vucy5cbiAgICAgIGFzdCA9IENvZmZlZVNjcmlwdC5ub2Rlcyh0b2tlbnMpLmJvZHlcbiAgICAgICMgQWRkIGFzc2lnbm1lbnQgdG8gYF9fYCB2YXJpYWJsZSB0byBmb3JjZSB0aGUgaW5wdXQgdG8gYmUgYW4gZXhwcmVzc2lvbi5cbiAgICAgIGFzdCA9IG5ldyBCbG9jayBbbmV3IEFzc2lnbiAobmV3IFZhbHVlIG5ldyBMaXRlcmFsICdfXycpLCBhc3QsICc9J11cbiAgICAgICMgV3JhcCB0aGUgZXhwcmVzc2lvbiBpbiBhIGNsb3N1cmUgdG8gc3VwcG9ydCB0b3AtbGV2ZWwgYGF3YWl0YC5cbiAgICAgIGFzdCAgICAgPSBuZXcgQ29kZSBbXSwgYXN0XG4gICAgICBpc0FzeW5jID0gYXN0LmlzQXN5bmNcbiAgICAgICMgSW52b2tlIHRoZSB3cmFwcGluZyBjbG9zdXJlLlxuICAgICAgYXN0ICAgID0gbmV3IFJvb3QgbmV3IEJsb2NrIFtuZXcgQ2FsbCBhc3RdXG4gICAgICBqcyAgICAgPSBhc3QuY29tcGlsZSB7YmFyZTogeWVzLCBsb2NhbHM6IE9iamVjdC5rZXlzKGNvbnRleHQpLCByZWZlcmVuY2VkVmFycywgc2hhcmVkU2NvcGU6IHllc31cbiAgICAgIGlmIHRyYW5zcGlsZVxuICAgICAgICBqcyA9IHRyYW5zcGlsZS50cmFuc3BpbGUoanMsIHRyYW5zcGlsZS5vcHRpb25zKS5jb2RlXG4gICAgICAgICMgU3RyaXAgYFwidXNlIHN0cmljdFwiYCwgdG8gYXZvaWQgYW4gZXhjZXB0aW9uIG9uIGFzc2lnbmluZyB0b1xuICAgICAgICAjIHVuZGVjbGFyZWQgdmFyaWFibGUgYF9fYC5cbiAgICAgICAganMgPSBqcy5yZXBsYWNlIC9eXCJ1c2Ugc3RyaWN0XCJ8Xid1c2Ugc3RyaWN0Jy8sICcnXG4gICAgICByZXN1bHQgPSBydW5JbkNvbnRleHQganMsIGNvbnRleHQsIGZpbGVuYW1lXG4gICAgICAjIEF3YWl0IGFuIGFzeW5jIHJlc3VsdCwgaWYgbmVjZXNzYXJ5LlxuICAgICAgaWYgaXNBc3luY1xuICAgICAgICByZXN1bHQudGhlbiAocmVzb2x2ZWRSZXN1bHQpIC0+XG4gICAgICAgICAgY2IgbnVsbCwgcmVzb2x2ZWRSZXN1bHQgdW5sZXNzIHNhd1NJR0lOVFxuICAgICAgICBzYXdTSUdJTlQgPSBub1xuICAgICAgZWxzZVxuICAgICAgICBjYiBudWxsLCByZXN1bHRcbiAgICBjYXRjaCBlcnJcbiAgICAgICMgQVNUJ3MgYGNvbXBpbGVgIGRvZXMgbm90IGFkZCBzb3VyY2UgY29kZSBpbmZvcm1hdGlvbiB0byBzeW50YXggZXJyb3JzLlxuICAgICAgdXBkYXRlU3ludGF4RXJyb3IgZXJyLCBpbnB1dFxuICAgICAgY2IgZXJyXG5cbnJ1bkluQ29udGV4dCA9IChqcywgY29udGV4dCwgZmlsZW5hbWUpIC0+XG4gIGlmIGNvbnRleHQgaXMgZ2xvYmFsXG4gICAgdm0ucnVuSW5UaGlzQ29udGV4dCBqcywgZmlsZW5hbWVcbiAgZWxzZVxuICAgIHZtLnJ1bkluQ29udGV4dCBqcywgY29udGV4dCwgZmlsZW5hbWVcblxuYWRkTXVsdGlsaW5lSGFuZGxlciA9IChyZXBsKSAtPlxuICB7aW5wdXRTdHJlYW0sIG91dHB1dFN0cmVhbX0gPSByZXBsXG4gICMgTm9kZSAwLjExLjEyIGNoYW5nZWQgQVBJLCBwcm9tcHQgaXMgbm93IF9wcm9tcHQuXG4gIG9yaWdQcm9tcHQgPSByZXBsLl9wcm9tcHQgPyByZXBsLnByb21wdFxuXG4gIG11bHRpbGluZSA9XG4gICAgZW5hYmxlZDogb2ZmXG4gICAgaW5pdGlhbFByb21wdDogb3JpZ1Byb21wdC5yZXBsYWNlIC9eW14+IF0qLywgKHgpIC0+IHgucmVwbGFjZSAvLi9nLCAnLSdcbiAgICBwcm9tcHQ6IG9yaWdQcm9tcHQucmVwbGFjZSAvXltePiBdKj4/LywgKHgpIC0+IHgucmVwbGFjZSAvLi9nLCAnLidcbiAgICBidWZmZXI6ICcnXG5cbiAgIyBQcm94eSBub2RlJ3MgbGluZSBsaXN0ZW5lclxuICBub2RlTGluZUxpc3RlbmVyID0gcmVwbC5saXN0ZW5lcnMoJ2xpbmUnKVswXVxuICByZXBsLnJlbW92ZUxpc3RlbmVyICdsaW5lJywgbm9kZUxpbmVMaXN0ZW5lclxuICByZXBsLm9uICdsaW5lJywgKGNtZCkgLT5cbiAgICBpZiBtdWx0aWxpbmUuZW5hYmxlZFxuICAgICAgbXVsdGlsaW5lLmJ1ZmZlciArPSBcIiN7Y21kfVxcblwiXG4gICAgICByZXBsLnNldFByb21wdCBtdWx0aWxpbmUucHJvbXB0XG4gICAgICByZXBsLnByb21wdCB0cnVlXG4gICAgZWxzZVxuICAgICAgcmVwbC5zZXRQcm9tcHQgb3JpZ1Byb21wdFxuICAgICAgbm9kZUxpbmVMaXN0ZW5lciBjbWRcbiAgICByZXR1cm5cblxuICAjIEhhbmRsZSBDdHJsLXZcbiAgaW5wdXRTdHJlYW0ub24gJ2tleXByZXNzJywgKGNoYXIsIGtleSkgLT5cbiAgICByZXR1cm4gdW5sZXNzIGtleSBhbmQga2V5LmN0cmwgYW5kIG5vdCBrZXkubWV0YSBhbmQgbm90IGtleS5zaGlmdCBhbmQga2V5Lm5hbWUgaXMgJ3YnXG4gICAgaWYgbXVsdGlsaW5lLmVuYWJsZWRcbiAgICAgICMgYWxsb3cgYXJiaXRyYXJpbHkgc3dpdGNoaW5nIGJldHdlZW4gbW9kZXMgYW55IHRpbWUgYmVmb3JlIG11bHRpcGxlIGxpbmVzIGFyZSBlbnRlcmVkXG4gICAgICB1bmxlc3MgbXVsdGlsaW5lLmJ1ZmZlci5tYXRjaCAvXFxuL1xuICAgICAgICBtdWx0aWxpbmUuZW5hYmxlZCA9IG5vdCBtdWx0aWxpbmUuZW5hYmxlZFxuICAgICAgICByZXBsLnNldFByb21wdCBvcmlnUHJvbXB0XG4gICAgICAgIHJlcGwucHJvbXB0IHRydWVcbiAgICAgICAgcmV0dXJuXG4gICAgICAjIG5vLW9wIHVubGVzcyB0aGUgY3VycmVudCBsaW5lIGlzIGVtcHR5XG4gICAgICByZXR1cm4gaWYgcmVwbC5saW5lPyBhbmQgbm90IHJlcGwubGluZS5tYXRjaCAvXlxccyokL1xuICAgICAgIyBldmFsLCBwcmludCwgbG9vcFxuICAgICAgbXVsdGlsaW5lLmVuYWJsZWQgPSBub3QgbXVsdGlsaW5lLmVuYWJsZWRcbiAgICAgIHJlcGwubGluZSA9ICcnXG4gICAgICByZXBsLmN1cnNvciA9IDBcbiAgICAgIHJlcGwub3V0cHV0LmN1cnNvclRvIDBcbiAgICAgIHJlcGwub3V0cHV0LmNsZWFyTGluZSAxXG4gICAgICAjIFhYWDogbXVsdGlsaW5lIGhhY2tcbiAgICAgIG11bHRpbGluZS5idWZmZXIgPSBtdWx0aWxpbmUuYnVmZmVyLnJlcGxhY2UgL1xcbi9nLCAnXFx1RkYwMCdcbiAgICAgIHJlcGwuZW1pdCAnbGluZScsIG11bHRpbGluZS5idWZmZXJcbiAgICAgIG11bHRpbGluZS5idWZmZXIgPSAnJ1xuICAgIGVsc2VcbiAgICAgIG11bHRpbGluZS5lbmFibGVkID0gbm90IG11bHRpbGluZS5lbmFibGVkXG4gICAgICByZXBsLnNldFByb21wdCBtdWx0aWxpbmUuaW5pdGlhbFByb21wdFxuICAgICAgcmVwbC5wcm9tcHQgdHJ1ZVxuICAgIHJldHVyblxuXG4jIFN0b3JlIGFuZCBsb2FkIGNvbW1hbmQgaGlzdG9yeSBmcm9tIGEgZmlsZVxuYWRkSGlzdG9yeSA9IChyZXBsLCBmaWxlbmFtZSwgbWF4U2l6ZSkgLT5cbiAgbGFzdExpbmUgPSBudWxsXG4gIHRyeVxuICAgICMgR2V0IGZpbGUgaW5mbyBhbmQgYXQgbW9zdCBtYXhTaXplIG9mIGNvbW1hbmQgaGlzdG9yeVxuICAgIHN0YXQgPSBmcy5zdGF0U3luYyBmaWxlbmFtZVxuICAgIHNpemUgPSBNYXRoLm1pbiBtYXhTaXplLCBzdGF0LnNpemVcbiAgICAjIFJlYWQgbGFzdCBgc2l6ZWAgYnl0ZXMgZnJvbSB0aGUgZmlsZVxuICAgIHJlYWRGZCA9IGZzLm9wZW5TeW5jIGZpbGVuYW1lLCAncidcbiAgICBidWZmZXIgPSBCdWZmZXIuYWxsb2Mgc2l6ZVxuICAgIGZzLnJlYWRTeW5jIHJlYWRGZCwgYnVmZmVyLCAwLCBzaXplLCBzdGF0LnNpemUgLSBzaXplXG4gICAgZnMuY2xvc2VTeW5jIHJlYWRGZFxuICAgICMgU2V0IHRoZSBoaXN0b3J5IG9uIHRoZSBpbnRlcnByZXRlclxuICAgIHJlcGwuaGlzdG9yeSA9IGJ1ZmZlci50b1N0cmluZygpLnNwbGl0KCdcXG4nKS5yZXZlcnNlKClcbiAgICAjIElmIHRoZSBoaXN0b3J5IGZpbGUgd2FzIHRydW5jYXRlZCB3ZSBzaG91bGQgcG9wIG9mZiBhIHBvdGVudGlhbCBwYXJ0aWFsIGxpbmVcbiAgICByZXBsLmhpc3RvcnkucG9wKCkgaWYgc3RhdC5zaXplID4gbWF4U2l6ZVxuICAgICMgU2hpZnQgb2ZmIHRoZSBmaW5hbCBibGFuayBuZXdsaW5lXG4gICAgcmVwbC5oaXN0b3J5LnNoaWZ0KCkgaWYgcmVwbC5oaXN0b3J5WzBdIGlzICcnXG4gICAgcmVwbC5oaXN0b3J5SW5kZXggPSAtMVxuICAgIGxhc3RMaW5lID0gcmVwbC5oaXN0b3J5WzBdXG5cbiAgZmQgPSBmcy5vcGVuU3luYyBmaWxlbmFtZSwgJ2EnXG5cbiAgcmVwbC5hZGRMaXN0ZW5lciAnbGluZScsIChjb2RlKSAtPlxuICAgIGlmIGNvZGUgYW5kIGNvZGUubGVuZ3RoIGFuZCBjb2RlIGlzbnQgJy5oaXN0b3J5JyBhbmQgY29kZSBpc250ICcuZXhpdCcgYW5kIGxhc3RMaW5lIGlzbnQgY29kZVxuICAgICAgIyBTYXZlIHRoZSBsYXRlc3QgY29tbWFuZCBpbiB0aGUgZmlsZVxuICAgICAgZnMud3JpdGVTeW5jIGZkLCBcIiN7Y29kZX1cXG5cIlxuICAgICAgbGFzdExpbmUgPSBjb2RlXG5cbiAgIyBYWFg6IFRoZSBTSUdJTlQgZXZlbnQgZnJvbSBSRVBMU2VydmVyIGlzIHVuZG9jdW1lbnRlZCwgc28gdGhpcyBpcyBhIGJpdCBmcmFnaWxlXG4gIHJlcGwub24gJ1NJR0lOVCcsIC0+IHNhd1NJR0lOVCA9IHllc1xuICByZXBsLm9uICdleGl0JywgLT4gZnMuY2xvc2VTeW5jIGZkXG5cbiAgIyBBZGQgYSBjb21tYW5kIHRvIHNob3cgdGhlIGhpc3Rvcnkgc3RhY2tcbiAgcmVwbC5jb21tYW5kc1tnZXRDb21tYW5kSWQocmVwbCwgJ2hpc3RvcnknKV0gPVxuICAgIGhlbHA6ICdTaG93IGNvbW1hbmQgaGlzdG9yeSdcbiAgICBhY3Rpb246IC0+XG4gICAgICByZXBsLm91dHB1dFN0cmVhbS53cml0ZSBcIiN7cmVwbC5oaXN0b3J5Wy4uXS5yZXZlcnNlKCkuam9pbiAnXFxuJ31cXG5cIlxuICAgICAgcmVwbC5kaXNwbGF5UHJvbXB0KClcblxuZ2V0Q29tbWFuZElkID0gKHJlcGwsIGNvbW1hbmROYW1lKSAtPlxuICAjIE5vZGUgMC4xMSBjaGFuZ2VkIEFQSSwgYSBjb21tYW5kIHN1Y2ggYXMgJy5oZWxwJyBpcyBub3cgc3RvcmVkIGFzICdoZWxwJ1xuICBjb21tYW5kc0hhdmVMZWFkaW5nRG90ID0gcmVwbC5jb21tYW5kc1snLmhlbHAnXT9cbiAgaWYgY29tbWFuZHNIYXZlTGVhZGluZ0RvdCB0aGVuIFwiLiN7Y29tbWFuZE5hbWV9XCIgZWxzZSBjb21tYW5kTmFtZVxuXG5tb2R1bGUuZXhwb3J0cyA9XG4gIHN0YXJ0OiAob3B0cyA9IHt9KSAtPlxuICAgIFttYWpvciwgbWlub3IsIGJ1aWxkXSA9IHByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdCgnLicpLm1hcCAobikgLT4gcGFyc2VJbnQobiwgMTApXG5cbiAgICBpZiBtYWpvciA8IDZcbiAgICAgIGNvbnNvbGUud2FybiBcIk5vZGUgNisgcmVxdWlyZWQgZm9yIENvZmZlZVNjcmlwdCBSRVBMXCJcbiAgICAgIHByb2Nlc3MuZXhpdCAxXG5cbiAgICBDb2ZmZWVTY3JpcHQucmVnaXN0ZXIoKVxuICAgIHByb2Nlc3MuYXJndiA9IFsnY29mZmVlJ10uY29uY2F0IHByb2Nlc3MuYXJndlsyLi5dXG4gICAgaWYgb3B0cy50cmFuc3BpbGVcbiAgICAgIHRyYW5zcGlsZSA9IHt9XG4gICAgICB0cnlcbiAgICAgICAgdHJhbnNwaWxlLnRyYW5zcGlsZSA9IHJlcXVpcmUoJ0BiYWJlbC9jb3JlJykudHJhbnNmb3JtXG4gICAgICBjYXRjaFxuICAgICAgICB0cnlcbiAgICAgICAgICB0cmFuc3BpbGUudHJhbnNwaWxlID0gcmVxdWlyZSgnYmFiZWwtY29yZScpLnRyYW5zZm9ybVxuICAgICAgICBjYXRjaFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IgJycnXG4gICAgICAgICAgICBUbyB1c2UgLS10cmFuc3BpbGUgd2l0aCBhbiBpbnRlcmFjdGl2ZSBSRVBMLCBAYmFiZWwvY29yZSBtdXN0IGJlIGluc3RhbGxlZCBlaXRoZXIgaW4gdGhlIGN1cnJlbnQgZm9sZGVyIG9yIGdsb2JhbGx5OlxuICAgICAgICAgICAgICBucG0gaW5zdGFsbCAtLXNhdmUtZGV2IEBiYWJlbC9jb3JlXG4gICAgICAgICAgICBvclxuICAgICAgICAgICAgICBucG0gaW5zdGFsbCAtLWdsb2JhbCBAYmFiZWwvY29yZVxuICAgICAgICAgICAgQW5kIHlvdSBtdXN0IHNhdmUgb3B0aW9ucyB0byBjb25maWd1cmUgQmFiZWwgaW4gb25lIG9mIHRoZSBwbGFjZXMgaXQgbG9va3MgdG8gZmluZCBpdHMgb3B0aW9ucy5cbiAgICAgICAgICAgIFNlZSBodHRwczovL2NvZmZlZXNjcmlwdC5vcmcvI3RyYW5zcGlsYXRpb25cbiAgICAgICAgICAnJydcbiAgICAgICAgICBwcm9jZXNzLmV4aXQgMVxuICAgICAgdHJhbnNwaWxlLm9wdGlvbnMgPVxuICAgICAgICBmaWxlbmFtZTogcGF0aC5yZXNvbHZlIHByb2Nlc3MuY3dkKCksICc8cmVwbD4nXG4gICAgICAjIFNpbmNlIHRoZSBSRVBMIGNvbXBpbGF0aW9uIHBhdGggaXMgdW5pcXVlIChpbiBgZXZhbGAgYWJvdmUpLCB3ZSBuZWVkXG4gICAgICAjIGFub3RoZXIgd2F5IHRvIGdldCB0aGUgYG9wdGlvbnNgIG9iamVjdCBhdHRhY2hlZCB0byBhIG1vZHVsZSBzbyB0aGF0XG4gICAgICAjIGl0IGtub3dzIGxhdGVyIG9uIHdoZXRoZXIgaXQgbmVlZHMgdG8gYmUgdHJhbnNwaWxlZC4gSW4gdGhlIGNhc2Ugb2ZcbiAgICAgICMgdGhlIFJFUEwsIHRoZSBvbmx5IGFwcGxpY2FibGUgb3B0aW9uIGlzIGB0cmFuc3BpbGVgLlxuICAgICAgTW9kdWxlID0gcmVxdWlyZSAnbW9kdWxlJ1xuICAgICAgb3JpZ2luYWxNb2R1bGVMb2FkID0gTW9kdWxlOjpsb2FkXG4gICAgICBNb2R1bGU6OmxvYWQgPSAoZmlsZW5hbWUpIC0+XG4gICAgICAgIEBvcHRpb25zID0gdHJhbnNwaWxlOiB0cmFuc3BpbGUub3B0aW9uc1xuICAgICAgICBvcmlnaW5hbE1vZHVsZUxvYWQuY2FsbCBALCBmaWxlbmFtZVxuICAgIG9wdHMgPSBtZXJnZSByZXBsRGVmYXVsdHMsIG9wdHNcbiAgICByZXBsID0gbm9kZVJFUEwuc3RhcnQgb3B0c1xuICAgIHJ1bkluQ29udGV4dCBvcHRzLnByZWx1ZGUsIHJlcGwuY29udGV4dCwgJ3ByZWx1ZGUnIGlmIG9wdHMucHJlbHVkZVxuICAgIHJlcGwub24gJ2V4aXQnLCAtPiByZXBsLm91dHB1dFN0cmVhbS53cml0ZSAnXFxuJyBpZiBub3QgcmVwbC5jbG9zZWRcbiAgICBhZGRNdWx0aWxpbmVIYW5kbGVyIHJlcGxcbiAgICBhZGRIaXN0b3J5IHJlcGwsIG9wdHMuaGlzdG9yeUZpbGUsIG9wdHMuaGlzdG9yeU1heElucHV0U2l6ZSBpZiBvcHRzLmhpc3RvcnlGaWxlXG4gICAgIyBBZGFwdCBoZWxwIGluaGVyaXRlZCBmcm9tIHRoZSBub2RlIFJFUExcbiAgICByZXBsLmNvbW1hbmRzW2dldENvbW1hbmRJZChyZXBsLCAnbG9hZCcpXS5oZWxwID0gJ0xvYWQgY29kZSBmcm9tIGEgZmlsZSBpbnRvIHRoaXMgUkVQTCBzZXNzaW9uJ1xuICAgIHJlcGxcbiJdfQ==
//# sourceURL=/home/flow/jzr/coffeescript/src/repl.coffee