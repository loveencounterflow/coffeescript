// Generated by CoffeeScript 2.7.0
(function() {
  var LONG_FLAG, MULTI_FLAG, OPTIONAL, OptionParser, SHORT_FLAG, buildRule, buildRules, normalizeArguments, repeat,
    splice = [].splice;

  ({repeat} = require('./helpers'));

  // A simple **OptionParser** class to parse option flags from the command-line.
  // Use it like so:

  //     parser  = new OptionParser switches, helpBanner
  //     options = parser.parse process.argv

  // The first non-option is considered to be the start of the file (and file
  // option) list, and all subsequent arguments are left unparsed.

  // The `coffee` command uses an instance of **OptionParser** to parse its
  // command-line arguments in `src/command.coffee`.
  exports.OptionParser = OptionParser = class OptionParser {
    // Initialize with a list of valid options, in the form:

    //     [short-flag, long-flag, description]

    // Along with an optional banner for the usage help.
    constructor(ruleDeclarations, banner) {
      this.banner = banner;
      this.rules = buildRules(ruleDeclarations);
    }

    // Parse the list of arguments, populating an `options` object with all of the
    // specified options, and return it. Options after the first non-option
    // argument are treated as arguments. `options.arguments` will be an array
    // containing the remaining arguments. This is a simpler API than many option
    // parsers that allow you to attach callback actions for every flag. Instead,
    // you're responsible for interpreting the options object.
    parse(args) {
      var argument, hasArgument, i, isList, len, name, options, positional, rules;
      // The CoffeeScript option parser is a little odd; options after the first
      // non-option argument are treated as non-option arguments themselves.
      // Optional arguments are normalized by expanding merged flags into multiple
      // flags. This allows you to have `-wl` be the same as `--watch --lint`.
      // Note that executable scripts with a shebang (`#!`) line should use the
      // line `#!/usr/bin/env coffee`, or `#!/absolute/path/to/coffee`, without a
      // `--` argument after, because that will fail on Linux (see #3946).
      ({rules, positional} = normalizeArguments(args, this.rules.flagDict));
      options = {};
// The `argument` field is added to the rule instance non-destructively by
// `normalizeArguments`.
      for (i = 0, len = rules.length; i < len; i++) {
        ({hasArgument, argument, isList, name} = rules[i]);
        if (hasArgument) {
          if (isList) {
            if (options[name] == null) {
              options[name] = [];
            }
            options[name].push(argument);
          } else {
            options[name] = argument;
          }
        } else {
          options[name] = true;
        }
      }
      if (positional[0] === '--') {
        options.doubleDashed = true;
        positional = positional.slice(1);
      }
      options.arguments = positional;
      return options;
    }

    // Return the help text for this **OptionParser**, listing and describing all
    // of the valid options, for `--help` and such.
    help() {
      var i, len, letPart, lines, ref, rule, spaces;
      lines = [];
      if (this.banner) {
        lines.unshift(`${this.banner}\n`);
      }
      ref = this.rules.ruleList;
      for (i = 0, len = ref.length; i < len; i++) {
        rule = ref[i];
        spaces = 15 - rule.longFlag.length;
        spaces = spaces > 0 ? repeat(' ', spaces) : '';
        letPart = rule.shortFlag ? rule.shortFlag + ', ' : '    ';
        lines.push('  ' + letPart + rule.longFlag + spaces + rule.description);
      }
      return `\n${lines.join('\n')}\n`;
    }

  };

  // Helpers
  // -------

  // Regex matchers for option flags on the command line and their rules.
  LONG_FLAG = /^(--\w[\w\-]*)/;

  SHORT_FLAG = /^(-\w)$/;

  MULTI_FLAG = /^-(\w{2,})/;

  // Matches the long flag part of a rule for an option with an argument. Not
  // applied to anything in process.argv.
  OPTIONAL = /\[(\w+(\*?))\]/;

  // Build and return the list of option rules. If the optional *short-flag* is
  // unspecified, leave it out by padding with `null`.
  buildRules = function(ruleDeclarations) {
    var flag, flagDict, i, j, len, len1, ref, rule, ruleList, tuple;
    ruleList = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = ruleDeclarations.length; i < len; i++) {
        tuple = ruleDeclarations[i];
        if (tuple.length < 3) {
          tuple.unshift(null);
        }
        results.push(buildRule(...tuple));
      }
      return results;
    })();
    flagDict = {};
    for (i = 0, len = ruleList.length; i < len; i++) {
      rule = ruleList[i];
      ref = [rule.shortFlag, rule.longFlag];
      // `shortFlag` is null if not provided in the rule.
      for (j = 0, len1 = ref.length; j < len1; j++) {
        flag = ref[j];
        if (!(flag != null)) {
          continue;
        }
        if (flagDict[flag] != null) {
          throw new Error(`flag ${flag} for switch ${rule.name} was already declared for switch ${flagDict[flag].name}`);
        }
        flagDict[flag] = rule;
      }
    }
    return {ruleList, flagDict};
  };

  // Build a rule from a `-o` short flag, a `--output [DIR]` long flag, and the
  // description of what the option does.
  buildRule = function(shortFlag, longFlag, description) {
    var match;
    match = longFlag.match(OPTIONAL);
    shortFlag = shortFlag != null ? shortFlag.match(SHORT_FLAG)[1] : void 0;
    longFlag = longFlag.match(LONG_FLAG)[1];
    return {
      name: longFlag.replace(/^--/, ''),
      shortFlag: shortFlag,
      longFlag: longFlag,
      description: description,
      hasArgument: !!(match && match[1]),
      isList: !!(match && match[2])
    };
  };

  normalizeArguments = function(args, flagDict) {
    var arg, argIndex, flag, i, innerOpts, j, lastOpt, len, len1, multiFlags, multiOpts, needsArgOpt, positional, ref, rule, rules, singleRule, withArg;
    rules = [];
    positional = [];
    needsArgOpt = null;
    for (argIndex = i = 0, len = args.length; i < len; argIndex = ++i) {
      arg = args[argIndex];
      // If the previous argument given to the script was an option that uses the
      // next command-line argument as its argument, create copy of the optionâ€™s
      // rule with an `argument` field.
      if (needsArgOpt != null) {
        withArg = Object.assign({}, needsArgOpt.rule, {
          argument: arg
        });
        rules.push(withArg);
        needsArgOpt = null;
        continue;
      }
      multiFlags = (ref = arg.match(MULTI_FLAG)) != null ? ref[1].split('').map(function(flagName) {
        return `-${flagName}`;
      }) : void 0;
      if (multiFlags != null) {
        multiOpts = multiFlags.map(function(flag) {
          var rule;
          rule = flagDict[flag];
          if (rule == null) {
            throw new Error(`unrecognized option ${flag} in multi-flag ${arg}`);
          }
          return {rule, flag};
        });
        // Only the last flag in a multi-flag may have an argument.
        [...innerOpts] = multiOpts, [lastOpt] = splice.call(innerOpts, -1);
        for (j = 0, len1 = innerOpts.length; j < len1; j++) {
          ({rule, flag} = innerOpts[j]);
          if (rule.hasArgument) {
            throw new Error(`cannot use option ${flag} in multi-flag ${arg} except as the last option, because it needs an argument`);
          }
          rules.push(rule);
        }
        if (lastOpt.rule.hasArgument) {
          needsArgOpt = lastOpt;
        } else {
          rules.push(lastOpt.rule);
        }
      } else if ([LONG_FLAG, SHORT_FLAG].some(function(pat) {
        return arg.match(pat) != null;
      })) {
        singleRule = flagDict[arg];
        if (singleRule == null) {
          throw new Error(`unrecognized option ${arg}`);
        }
        if (singleRule.hasArgument) {
          needsArgOpt = {
            rule: singleRule,
            flag: arg
          };
        } else {
          rules.push(singleRule);
        }
      } else {
        // This is a positional argument.
        positional = args.slice(argIndex);
        break;
      }
    }
    if (needsArgOpt != null) {
      throw new Error(`value required for ${needsArgOpt.flag}, but it was the last argument provided`);
    }
    return {rules, positional};
  };

}).call(this);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3B0cGFyc2UuanMiLCJzb3VyY2VSb290IjoiLi4vLi4vIiwic291cmNlcyI6WyJzcmMvb3B0cGFyc2UuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUFBLE1BQUEsU0FBQSxFQUFBLFVBQUEsRUFBQSxRQUFBLEVBQUEsWUFBQSxFQUFBLFVBQUEsRUFBQSxTQUFBLEVBQUEsVUFBQSxFQUFBLGtCQUFBLEVBQUEsTUFBQTtJQUFBOztFQUFBLENBQUEsQ0FBQyxNQUFELENBQUEsR0FBVyxPQUFBLENBQVEsV0FBUixDQUFYLEVBQUE7Ozs7Ozs7Ozs7Ozs7RUFhQSxPQUFPLENBQUMsWUFBUixHQUE2QixlQUFOLE1BQUEsYUFBQSxDQUFBOzs7Ozs7SUFPckIsV0FBYSxDQUFDLGdCQUFELFFBQUEsQ0FBQTtNQUFtQixJQUFDLENBQUE7TUFDL0IsSUFBQyxDQUFBLEtBQUQsR0FBUyxVQUFBLENBQVcsZ0JBQVg7SUFERSxDQUxmOzs7Ozs7OztJQWNFLEtBQU8sQ0FBQyxJQUFELENBQUE7QUFDVCxVQUFBLFFBQUEsRUFBQSxXQUFBLEVBQUEsQ0FBQSxFQUFBLE1BQUEsRUFBQSxHQUFBLEVBQUEsSUFBQSxFQUFBLE9BQUEsRUFBQSxVQUFBLEVBQUEsS0FBQTs7Ozs7Ozs7TUFPSSxDQUFBLENBQUMsS0FBRCxFQUFRLFVBQVIsQ0FBQSxHQUFzQixrQkFBQSxDQUFtQixJQUFuQixFQUF5QixJQUFDLENBQUEsS0FBSyxDQUFDLFFBQWhDLENBQXRCO01BQ0EsT0FBQSxHQUFVLENBQUEsRUFSZDs7O01BWUksS0FBQSx1Q0FBQTtTQUFJLENBQUMsV0FBRCxFQUFjLFFBQWQsRUFBd0IsTUFBeEIsRUFBZ0MsSUFBaEM7UUFDRixJQUFHLFdBQUg7VUFDRSxJQUFHLE1BQUg7O2NBQ0UsT0FBTyxDQUFDLElBQUQsSUFBVTs7WUFDakIsT0FBTyxDQUFDLElBQUQsQ0FBTSxDQUFDLElBQWQsQ0FBbUIsUUFBbkIsRUFGRjtXQUFBLE1BQUE7WUFJRSxPQUFPLENBQUMsSUFB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LFVBQUEsR0FBYSxJQUFJO0FBQ2pCLGNBWEc7O0lBOUJQO0lBMkNBLElBQUcsbUJBQUg7TUFDRSxNQUFNLElBQUksS0FBSixDQUFVLENBQUEsbUJBQUEsQ0FBQSxDQUFzQixXQUFXLENBQUMsSUFBbEMsQ0FBQSx1Q0FBQSxDQUFWLEVBRFI7O1dBR0EsQ0FBQyxLQUFELEVBQVEsVUFBUjtFQWxEbUI7QUFsSHJCIiwic291cmNlc0NvbnRlbnQiOlsie3JlcGVhdH0gPSByZXF1aXJlICcuL2hlbHBlcnMnXG5cbiMgQSBzaW1wbGUgKipPcHRpb25QYXJzZXIqKiBjbGFzcyB0byBwYXJzZSBvcHRpb24gZmxhZ3MgZnJvbSB0aGUgY29tbWFuZC1saW5lLlxuIyBVc2UgaXQgbGlrZSBzbzpcbiNcbiMgICAgIHBhcnNlciAgPSBuZXcgT3B0aW9uUGFyc2VyIHN3aXRjaGVzLCBoZWxwQmFubmVyXG4jICAgICBvcHRpb25zID0gcGFyc2VyLnBhcnNlIHByb2Nlc3MuYXJndlxuI1xuIyBUaGUgZmlyc3Qgbm9uLW9wdGlvbiBpcyBjb25zaWRlcmVkIHRvIGJlIHRoZSBzdGFydCBvZiB0aGUgZmlsZSAoYW5kIGZpbGVcbiMgb3B0aW9uKSBsaXN0LCBhbmQgYWxsIHN1YnNlcXVlbnQgYXJndW1lbnRzIGFyZSBsZWZ0IHVucGFyc2VkLlxuI1xuIyBUaGUgYGNvZmZlZWAgY29tbWFuZCB1c2VzIGFuIGluc3RhbmNlIG9mICoqT3B0aW9uUGFyc2VyKiogdG8gcGFyc2UgaXRzXG4jIGNvbW1hbmQtbGluZSBhcmd1bWVudHMgaW4gYHNyYy9jb21tYW5kLmNvZmZlZWAuXG5leHBvcnRzLk9wdGlvblBhcnNlciA9IGNsYXNzIE9wdGlvblBhcnNlclxuXG4gICMgSW5pdGlhbGl6ZSB3aXRoIGEgbGlzdCBvZiB2YWxpZCBvcHRpb25zLCBpbiB0aGUgZm9ybTpcbiAgI1xuICAjICAgICBbc2hvcnQtZmxhZywgbG9uZy1mbGFnLCBkZXNjcmlwdGlvbl1cbiAgI1xuICAjIEFsb25nIHdpdGggYW4gb3B0aW9uYWwgYmFubmVyIGZvciB0aGUgdXNhZ2UgaGVscC5cbiAgY29uc3RydWN0b3I6IChydWxlRGVjbGFyYXRpb25zLCBAYmFubmVyKSAtPlxuICAgIEBydWxlcyA9IGJ1aWxkUnVsZXMgcnVsZURlY2xhcmF0aW9uc1xuXG4gICMgUGFyc2UgdGhlIGxpc3Qgb2YgYXJndW1lbnRzLCBwb3B1bGF0aW5nIGFuIGBvcHRpb25zYCBvYmplY3Qgd2l0aCBhbGwgb2YgdGhlXG4gICMgc3BlY2lmaWVkIG9wdGlvbnMsIGFuZCByZXR1cm4gaXQuIE9wdGlvbnMgYWZ0ZXIgdGhlIGZpcnN0IG5vbi1vcHRpb25cbiAgIyBhcmd1bWVudCBhcmUgdHJlYXRlZCBhcyBhcmd1bWVudHMuIGBvcHRpb25zLmFyZ3VtZW50c2Agd2lsbCBiZSBhbiBhcnJheVxuICAjIGNvbnRhaW5pbmcgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMuIFRoaXMgaXMgYSBzaW1wbGVyIEFQSSB0aGFuIG1hbnkgb3B0aW9uXG4gICMgcGFyc2VycyB0aGF0IGFsbG93IHlvdSB0byBhdHRhY2ggY2FsbGJhY2sgYWN0aW9ucyBmb3IgZXZlcnkgZmxhZy4gSW5zdGVhZCxcbiAgIyB5b3UncmUgcmVzcG9uc2libGUgZm9yIGludGVycHJldGluZyB0aGUgb3B0aW9ucyBvYmplY3QuXG4gIHBhcnNlOiAoYXJncykgLT5cbiAgICAjIFRoZSBDb2ZmZWVTY3JpcHQgb3B0aW9uIHBhcnNlciBpcyBhIGxpdHRsZSBvZGQ7IG9wdGlvbnMgYWZ0ZXIgdGhlIGZpcnN0XG4gICAgIyBub24tb3B0aW9uIGFyZ3VtZW50IGFyZSB0cmVhdGVkIGFzIG5vbi1vcHRpb24gYXJndW1lbnRzIHRoZW1zZWx2ZXMuXG4gICAgIyBPcHRpb25hbCBhcmd1bWVudHMgYXJlIG5vcm1hbGl6ZWQgYnkgZXhwYW5kaW5nIG1lcmdlZCBmbGFncyBpbnRvIG11bHRpcGxlXG4gICAgIyBmbGFncy4gVGhpcyBhbGxvd3MgeW91IHRvIGhhdmUgYC13bGAgYmUgdGhlIHNhbWUgYXMgYC0td2F0Y2ggLS1saW50YC5cbiAgICAjIE5vdGUgdGhhdCBleGVjdXRhYmxlIHNjcmlwdHMgd2l0aCBhIHNoZWJhbmcgKGAjIWApIGxpbmUgc2hvdWxkIHVzZSB0aGVcbiAgICAjIGxpbmUgYCMhL3Vzci9iaW4vZW52IGNvZmZlZWAsIG9yIGAjIS9hYnNvbHV0ZS9wYXRoL3RvL2NvZmZlZWAsIHdpdGhvdXQgYVxuICAgICMgYC0tYCBhcmd1bWVudCBhZnRlciwgYmVjYXVzZSB0aGF0IHdpbGwgZmFpbCBvbiBMaW51eCAoc2VlICMzOTQ2KS5cbiAgICB7cnVsZXMsIHBvc2l0aW9uYWx9ID0gbm9ybWFsaXplQXJndW1lbnRzIGFyZ3MsIEBydWxlcy5mbGFnRGljdFxuICAgIG9wdGlvbnMgPSB7fVxuXG4gICAgIyBUaGUgYGFyZ3VtZW50YCBmaWVsZCBpcyBhZGRlZCB0byB0aGUgcnVsZSBpbnN0YW5jZSBub24tZGVzdHJ1Y3RpdmVseSBieVxuICAgICMgYG5vcm1hbGl6ZUFyZ3VtZW50c2AuXG4gICAgZm9yIHtoYXNBcmd1bWVudCwgYXJndW1lbnQsIGlzTGlzdCwgbmFtZX0gaW4gcnVsZXNcbiAgICAgIGlmIGhhc0FyZ3VtZW50XG4gICAgICAgIGlmIGlzTGlzdFxuICAgICAgICAgIG9wdGlvbnNbbmFtZV0gPz0gW11cbiAgICAgICAgICBvcHRpb25zW25hbWVdLnB1c2ggYXJndW1lbnRcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG9wdGlvbnNbbmFtZV0gPSBhcmd1bWVudFxuICAgICAgZWxzZVxuICAgICAgICBvcHRpb25zW25hbWVdID0gdHJ1ZVxuXG4gICAgaWYgcG9zaXRpb25hbFswXSBpcyAnLS0nXG4gICAgICBvcHRpb25zLmRvdWJsZURhc2hlZCA9IHllc1xuICAgICAgcG9zaXRpb25hbCA9IHBvc2l0aW9uYWxbMS4uXVxuXG4gICAgb3B0aW9ucy5hcmd1bWVudHMgPSBwb3NpdGlvbmFsXG4gICAgb3B0aW9uc1xuXG4gICMgUmV0dXJuIHRoZSBoZWxwIHRleHQgZm9yIHRoaXMgKipPcHRpb25QYXJzZXIqKiwgbGlzdGluZyBhbmQgZGVzY3JpYmluZyBhbGxcbiAgIyBvZiB0aGUgdmFsaWQgb3B0aW9ucywgZm9yIGAtLWhlbHBgIGFuZCBzdWNoLlxuICBoZWxwOiAtPlxuICAgIGxpbmVzID0gW11cbiAgICBsaW5lcy51bnNoaWZ0IFwiI3tAYmFubmVyfVxcblwiIGlmIEBiYW5uZXJcbiAgICBmb3IgcnVsZSBpbiBAcnVsZXMucnVsZUxpc3RcbiAgICAgIHNwYWNlcyAgPSAxNSAtIHJ1bGUubG9uZ0ZsYWcubGVuZ3RoXG4gICAgICBzcGFjZXMgID0gaWYgc3BhY2VzID4gMCB0aGVuIHJlcGVhdCAnICcsIHNwYWNlcyBlbHNlICcnXG4gICAgICBsZXRQYXJ0ID0gaWYgcnVsZS5zaG9ydEZsYWcgdGhlbiBydWxlLnNob3J0RmxhZyArICcsICcgZWxzZSAnICAgICdcbiAgICAgIGxpbmVzLnB1c2ggJyAgJyArIGxldFBhcnQgKyBydWxlLmxvbmdGbGFnICsgc3BhY2VzICsgcnVsZS5kZXNjcmlwdGlvblxuICAgIFwiXFxuI3sgbGluZXMuam9pbignXFxuJykgfVxcblwiXG5cbiMgSGVscGVyc1xuIyAtLS0tLS0tXG5cbiMgUmVnZXggbWF0Y2hlcnMgZm9yIG9wdGlvbiBmbGFncyBvbiB0aGUgY29tbWFuZCBsaW5lIGFuZCB0aGVpciBydWxlcy5cbkxPTkdfRkxBRyAgPSAvXigtLVxcd1tcXHdcXC1dKikvXG5TSE9SVF9GTEFHID0gL14oLVxcdykkL1xuTVVMVElfRkxBRyA9IC9eLShcXHd7Mix9KS9cbiMgTWF0Y2hlcyB0aGUgbG9uZyBmbGFnIHBhcnQgb2YgYSBydWxlIGZvciBhbiBvcHRpb24gd2l0aCBhbiBhcmd1bWVudC4gTm90XG4jIGFwcGxpZWQgdG8gYW55dGhpbmcgaW4gcHJvY2Vzcy5hcmd2LlxuT1BUSU9OQUwgICA9IC9cXFsoXFx3KyhcXCo/KSlcXF0vXG5cbiMgQnVpbGQgYW5kIHJldHVybiB0aGUgbGlzdCBvZiBvcHRpb24gcnVsZXMuIElmIHRoZSBvcHRpb25hbCAqc2hvcnQtZmxhZyogaXNcbiMgdW5zcGVjaWZpZWQsIGxlYXZlIGl0IG91dCBieSBwYWRkaW5nIHdpdGggYG51bGxgLlxuYnVpbGRSdWxlcyA9IChydWxlRGVjbGFyYXRpb25zKSAtPlxuICBydWxlTGlzdCA9IGZvciB0dXBsZSBpbiBydWxlRGVjbGFyYXRpb25zXG4gICAgdHVwbGUudW5zaGlmdCBudWxsIGlmIHR1cGxlLmxlbmd0aCA8IDNcbiAgICBidWlsZFJ1bGUgdHVwbGUuLi5cbiAgZmxhZ0RpY3QgPSB7fVxuICBmb3IgcnVsZSBpbiBydWxlTGlzdFxuICAgICMgYHNob3J0RmxhZ2AgaXMgbnVsbCBpZiBub3QgcHJvdmlkZWQgaW4gdGhlIHJ1bGUuXG4gICAgZm9yIGZsYWcgaW4gW3J1bGUuc2hvcnRGbGFnLCBydWxlLmxvbmdGbGFnXSB3aGVuIGZsYWc/XG4gICAgICBpZiBmbGFnRGljdFtmbGFnXT9cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yIFwiZmxhZyAje2ZsYWd9IGZvciBzd2l0Y2ggI3tydWxlLm5hbWV9XG4gICAgICAgICAgd2FzIGFscmVhZHkgZGVjbGFyZWQgZm9yIHN3aXRjaCAje2ZsYWdEaWN0W2ZsYWddLm5hbWV9XCJcbiAgICAgIGZsYWdEaWN0W2ZsYWddID0gcnVsZVxuXG4gIHtydWxlTGlzdCwgZmxhZ0RpY3R9XG5cbiMgQnVpbGQgYSBydWxlIGZyb20gYSBgLW9gIHNob3J0IGZsYWcsIGEgYC0tb3V0cHV0IFtESVJdYCBsb25nIGZsYWcsIGFuZCB0aGVcbiMgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGUgb3B0aW9uIGRvZXMuXG5idWlsZFJ1bGUgPSAoc2hvcnRGbGFnLCBsb25nRmxhZywgZGVzY3JpcHRpb24pIC0+XG4gIG1hdGNoICAgICA9IGxvbmdGbGFnLm1hdGNoKE9QVElPTkFMKVxuICBzaG9ydEZsYWcgPSBzaG9ydEZsYWc/Lm1hdGNoKFNIT1JUX0ZMQUcpWzFdXG4gIGxvbmdGbGFnICA9IGxvbmdGbGFnLm1hdGNoKExPTkdfRkxBRylbMV1cbiAge1xuICAgIG5hbWU6ICAgICAgICAgbG9uZ0ZsYWcucmVwbGFjZSAvXi0tLywgJydcbiAgICBzaG9ydEZsYWc6ICAgIHNob3J0RmxhZ1xuICAgIGxvbmdGbGFnOiAgICAgbG9uZ0ZsYWdcbiAgICBkZXNjcmlwdGlvbjogIGRlc2NyaXB0aW9uXG4gICAgaGFzQXJndW1lbnQ6ICAhIShtYXRjaCBhbmQgbWF0Y2hbMV0pXG4gICAgaXNMaXN0OiAgICAgICAhIShtYXRjaCBhbmQgbWF0Y2hbMl0pXG4gIH1cblxubm9ybWFsaXplQXJndW1lbnRzID0gKGFyZ3MsIGZsYWdEaWN0KSAtPlxuICBydWxlcyA9IFtdXG4gIHBvc2l0aW9uYWwgPSBbXVxuICBuZWVkc0FyZ09wdCA9IG51bGxcbiAgZm9yIGFyZywgYXJnSW5kZXggaW4gYXJnc1xuICAgICMgSWYgdGhlIHByZXZpb3VzIGFyZ3VtZW50IGdpdmVuIHRvIHRoZSBzY3JpcHQgd2FzIGFuIG9wdGlvbiB0aGF0IHVzZXMgdGhlXG4gICAgIyBuZXh0IGNvbW1hbmQtbGluZSBhcmd1bWVudCBhcyBpdHMgYXJndW1lbnQsIGNyZWF0ZSBjb3B5IG9mIHRoZSBvcHRpb27igJlzXG4gICAgIyBydWxlIHdpdGggYW4gYGFyZ3VtZW50YCBmaWVsZC5cbiAgICBpZiBuZWVkc0FyZ09wdD9cbiAgICAgIHdpdGhBcmcgPSBPYmplY3QuYXNzaWduIHt9LCBuZWVkc0FyZ09wdC5ydWxlLCB7YXJndW1lbnQ6IGFyZ31cbiAgICAgIHJ1bGVzLnB1c2ggd2l0aEFyZ1xuICAgICAgbmVlZHNBcmdPcHQgPSBudWxsXG4gICAgICBjb250aW51ZVxuXG4gICAgbXVsdGlGbGFncyA9IGFyZy5tYXRjaChNVUxUSV9GTEFHKT9bMV1cbiAgICAgIC5zcGxpdCgnJylcbiAgICAgIC5tYXAgKGZsYWdOYW1lKSAtPiBcIi0je2ZsYWdOYW1lfVwiXG4gICAgaWYgbXVsdGlGbGFncz9cbiAgICAgIG11bHRpT3B0cyA9IG11bHRpRmxhZ3MubWFwIChmbGFnKSAtPlxuICAgICAgICBydWxlID0gZmxhZ0RpY3RbZmxhZ11cbiAgICAgICAgdW5sZXNzIHJ1bGU/XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yIFwidW5yZWNvZ25pemVkIG9wdGlvbiAje2ZsYWd9IGluIG11bHRpLWZsYWcgI3thcmd9XCJcbiAgICAgICAge3J1bGUsIGZsYWd9XG4gICAgICAjIE9ubHkgdGhlIGxhc3QgZmxhZyBpbiBhIG11bHRpLWZsYWcgbWF5IGhhdmUgYW4gYXJndW1lbnQuXG4gICAgICBbaW5uZXJPcHRzLi4uLCBsYXN0T3B0XSA9IG11bHRpT3B0c1xuICAgICAgZm9yIHtydWxlLCBmbGFnfSBpbiBpbm5lck9wdHNcbiAgICAgICAgaWYgcnVsZS5oYXNBcmd1bWVudFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvciBcImNhbm5vdCB1c2Ugb3B0aW9uICN7ZmxhZ30gaW4gbXVsdGktZmxhZyAje2FyZ30gZXhjZXB0XG4gICAgICAgICAgYXMgdGhlIGxhc3Qgb3B0aW9uLCBiZWNhdXNlIGl0IG5lZWRzIGFuIGFyZ3VtZW50XCJcbiAgICAgICAgcnVsZXMucHVzaCBydWxlXG4gICAgICBpZiBsYXN0T3B0LnJ1bGUuaGFzQXJndW1lbnRcbiAgICAgICAgbmVlZHNBcmdPcHQgPSBsYXN0T3B0XG4gICAgICBlbHNlXG4gICAgICAgIHJ1bGVzLnB1c2ggbGFzdE9wdC5ydWxlXG4gICAgZWxzZSBpZiAoW0xPTkdfRkxBRywgU0hPUlRfRkxBR10uc29tZSAocGF0KSAtPiBhcmcubWF0Y2gocGF0KT8pXG4gICAgICBzaW5nbGVSdWxlID0gZmxhZ0RpY3RbYXJnXVxuICAgICAgdW5sZXNzIHNpbmdsZVJ1bGU/XG4gICAgICAgIHRocm93IG5ldyBFcnJvciBcInVucmVjb2duaXplZCBvcHRpb24gI3thcmd9XCJcbiAgICAgIGlmIHNpbmdsZVJ1bGUuaGFzQXJndW1lbnRcbiAgICAgICAgbmVlZHNBcmdPcHQgPSB7cnVsZTogc2luZ2xlUnVsZSwgZmxhZzogYXJnfVxuICAgICAgZWxzZVxuICAgICAgICBydWxlcy5wdXNoIHNpbmdsZVJ1bGVcbiAgICBlbHNlXG4gICAgICAjIFRoaXMgaXMgYSBwb3NpdGlvbmFsIGFyZ3VtZW50LlxuICAgICAgcG9zaXRpb25hbCA9IGFyZ3NbYXJnSW5kZXguLl1cbiAgICAgIGJyZWFrXG5cbiAgaWYgbmVlZHNBcmdPcHQ/XG4gICAgdGhyb3cgbmV3IEVycm9yIFwidmFsdWUgcmVxdWlyZWQgZm9yICN7bmVlZHNBcmdPcHQuZmxhZ30sIGJ1dCBpdCB3YXMgdGhlIGxhc3RcbiAgICBhcmd1bWVudCBwcm92aWRlZFwiXG4gIHtydWxlcywgcG9zaXRpb25hbH1cbiJdfQ==
//# sourceURL=/home/flow/jzr/coffeescript/src/optparse.coffee