// Generated by CoffeeScript 2.7.0
(function() {
  // `nodes.coffee` contains all of the node classes for the syntax tree. Most
  // nodes are created as the result of actions in the [grammar](grammar.html),
  // but some are created by other nodes as a method of code generation. To convert
  // the syntax tree into a string of JavaScript code, call `compile()` on the root.
  var Access, Arr, Assign, AwaitReturn, Base, Block, BooleanLiteral, Call, Catch, Class, ClassProperty, ClassPrototypeProperty, Code, CodeFragment, ComputedPropertyName, DefaultLiteral, Directive, DynamicImport, DynamicImportCall, Elision, EmptyInterpolation, ExecutableClassBody, Existence, Expansion, ExportAllDeclaration, ExportDeclaration, ExportDefaultDeclaration, ExportNamedDeclaration, ExportSpecifier, ExportSpecifierList, Extends, For, FuncDirectiveReturn, FuncGlyph, HEREGEX_OMIT, HereComment, HoistTarget, IdentifierLiteral, If, ImportClause, ImportDeclaration, ImportDefaultSpecifier, ImportNamespaceSpecifier, ImportSpecifier, ImportSpecifierList, In, Index, InfinityLiteral, Interpolation, JSXAttribute, JSXAttributes, JSXElement, JSXEmptyExpression, JSXExpressionContainer, JSXIdentifier, JSXNamespacedName, JSXTag, JSXText, JS_FORBIDDEN, LEADING_BLANK_LINE, LEVEL_ACCESS, LEVEL_COND, LEVEL_LIST, LEVEL_OP, LEVEL_PAREN, LEVEL_TOP, LineComment, Literal, MetaProperty, ModuleDeclaration, ModuleSpecifier, ModuleSpecifierList, NEGATE, NO, NaNLiteral, NullLiteral, NumberLiteral, Obj, ObjectProperty, Op, Param, Parens, PassthroughLiteral, PropertyName, Range, RegexLiteral, RegexWithInterpolations, Return, Root, SIMPLENUM, SIMPLE_STRING_OMIT, STRING_OMIT, Scope, Sequence, Slice, Splat, StatementLiteral, StringLiteral, StringWithInterpolations, Super, SuperCall, Switch, SwitchCase, SwitchWhen, TAB, THIS, TRAILING_BLANK_LINE, TaggedTemplateCall, TemplateElement, ThisLiteral, Throw, Try, UTILITIES, UndefinedLiteral, Value, While, YES, YieldReturn, addDataToNode, astAsBlockIfNeeded, attachCommentsToNode, compact, del, emptyExpressionLocationData, ends, extend, extractSameLineLocationDataFirst, extractSameLineLocationDataLast, flatten, fragmentsToText, greater, hasLineComments, indentInitial, isAstLocGreater, isFunction, isLiteralArguments, isLiteralThis, isLocationDataEndGreater, isLocationDataStartGreater, isNumber, isPlainObject, isUnassignable, jisonLocationDataToAstLocationData, lesser, locationDataToString, makeDelimitedLiteral, merge, mergeAstLocationData, mergeLocationData, moveComments, multident, parseNumber, replaceUnicodeCodePointEscapes, shouldCacheOrIsAssignable, sniffDirectives, some, starts, throwSyntaxError, unfoldSoak, unshiftAfterComments, utility, zeroWidthLocationDataFromEndLocation,
    indexOf = [].indexOf,
    splice = [].splice,
    slice1 = [].slice;

  Error.stackTraceLimit = 2e308;

  ({Scope} = require('./scope'));

  ({isUnassignable, JS_FORBIDDEN} = require('./lexer'));

  // Import the helpers we plan to use.
  ({compact, flatten, extend, merge, del, starts, ends, some, addDataToNode, attachCommentsToNode, locationDataToString, throwSyntaxError, replaceUnicodeCodePointEscapes, isFunction, isPlainObject, isNumber, parseNumber} = require('./helpers'));

  // Functions required by parser.
  exports.extend = extend;

  exports.addDataToNode = addDataToNode;

  // Constant functions for nodes that don’t need customization.
  YES = function() {
    return true;
  };

  NO = function() {
    return false;
  };

  THIS = function() {
    return this;
  };

  NEGATE = function() {
    this.negated = !this.negated;
    return this;
  };

  //### CodeFragment

  // The various nodes defined below all compile to a collection of **CodeFragment** objects.
  // A CodeFragments is a block of generated code, and the location in the source file where the code
  // came from. CodeFragments can be assembled together into working code just by catting together
  // all the CodeFragments' `code` snippets, in order.
  exports.CodeFragment = CodeFragment = class CodeFragment {
    constructor(parent, code) {
      var ref1;
      this.code = `${code}`;
      this.type = (parent != null ? (ref1 = parent.constructor) != null ? ref1.name : void 0 : void 0) || 'unknown';
      this.locationData = parent != null ? parent.locationData : void 0;
      this.comments = parent != null ? parent.comments : void 0;
    }

    toString() {
      // This is only intended for debugging.
      return `${this.code}${this.locationData ? ": " + locationDataToString(this.locationData) : ''}`;
    }

  };

  // Convert an array of CodeFragments into a string.
  fragmentsToText = function(fragments) {
    var fragment;
    return ((function() {
      var j, len1, results1;
      results1 = [];
      for (j = 0, len1 = fragments.length; j < len1; j++) {
        fragment = fragments[j];
        results1.push(fragment.code);
      }
      return results1;
    })()).join('');
  };

  //### Base

  // The **Base** is the abstract base class for all nodes in the syntax tree.
  // Each subclass implements the `compileNode` method, which performs the
  // code generation for that node. To compile a node to JavaScript,
  // call `compile` on it, which wraps `compileNode` in some generic extra smarts,
  // to know when the generated code needs to be wrapped up in a closure.
  // An options hash is passed and cloned throughout, containing information about
  // the environment from higher in the tree (such as if a returned value is
  // being requested by the surrounding function), information about the current
  // scope, and indentation level.
  exports.Base = Base = (function() {
    class Base {
      compile(o, lvl) {
        return fragmentsToText(this.compileToFragments(o, lvl));
      }

      // Occasionally a node is compiled multiple times, for example to get the name
      // of a variable to add to scope tracking. When we know that a “premature”
      // compilation won’t result in comments being output, set those comments aside
      // so that they’re preserved for a later `compile` call that will result in
      // the comments being included in the output.
      compileWithoutComments(o, lvl, method = 'compile') {
        var fragments, unwrapped;
        if (this.comments) {
          this.ignoreTheseCommentsTemporarily = this.comments;
          delete this.comments;
        }
        unwrapped = this.unwrapAll();
        if (unwrapped.comments) {
          unwrapped.ignoreTheseCommentsTemporarily = unwrapped.comments;
          delete unwrapped.comments;
        }
        fragments = this[method](o, lvl);
        if (this.ignoreTheseCommentsTemporarily) {
          this.comments = this.ignoreTheseCommentsTemporarily;
          delete this.ignoreTheseCommentsTemporarily;
        }
        if (unwrapped.ignoreTheseCommentsTemporarily) {
          unwrapped.comments = unwrapped.ignoreTheseCommentsTemporarily;
          delete unwrapped.ignoreTheseCommentsTemporarily;
        }
        return fragments;
      }

      compileNodeWithoutComments(o, lvl) {
        return this.compileWithoutComments(o, lvl, 'compileNode');
      }

      // Common logic for determining whether to wrap this node in a closure before
      // compiling it, or to compile directly. We need to wrap if this node is a
      // *statement*, and it's not a *pureStatement*, and we're not at
      // the top level of a block (which would be unnecessary), and we haven't
      // already been asked to return the result (because statements know how to
      // return results).
      compileToFragments(o, lvl) {
        var fragments, node;
        o = extend({}, o);
        if (lvl) {
          o.level = lvl;
        }
        node = this.unfoldSoak(o) || this;
        node.tab = o.indent;
        fragments = o.level === LEVEL_TOP || !node.isStatement(o) ? node.compileNode(o) : node.compileClosure(o);
        this.compileCommentFragments(o, node, fragments);
        return fragments;
      }

      compileToFragmentsWithoutComments(o, lvl) {
        return this.compileWithoutComments(o, lvl, 'compileToFragments');
      }

      // Statements converted into expressions via closure-wrapping share a scope
      // object with their parent closure, to preserve the expected lexical scope.
      compileClosure(o) {
        var args, argumentsNode, func, meth, parts, ref1, ref2;
        this.checkForPureStatementInExpression();
        o.sharedScope = true;
        func = new Code([], Block.wrap([this]));
        args = [];
        if (this.contains((function(node) {
          return node instanceof SuperCall;
        }))) {
          func.bound = true;
        } else if ((argumentsNode = this.contains(isLiteralArguments)) || this.contains(isLiteralThis)) {
          args = [new ThisLiteral()];
          if (argumentsNode) {
            meth = 'apply';
            args.push(new IdentifierLiteral('arguments'));
          } else {
            meth = 'call';
          }
          func = new Value(func, [new Access(new PropertyName(meth))]);
        }
        parts = (new Call(func, args)).compileNode(o);
        switch (false) {
          case !(func.isGenerator || ((ref1 = func.base) != null ? ref1.isGenerator : void 0)):
            parts.unshift(this.makeCode("(yield* "));
            parts.push(this.makeCode(")"));
            break;
          case !(func.isAsync || ((ref2 = func.base) != null ? ref2.isAsync : void 0)):
            parts.unshift(this.makeCode("(await "));
            parts.push(this.makeCode(")"));
        }
        return parts;
      }

      compileCommentFragments(o, node, fragments) {
        var base1, base2, comment, commentFragment, j, len1, ref1, unshiftCommentFragment;
        if (!node.comments) {
          return fragments;
        }
        // This is where comments, that are attached to nodes as a `comments`
        // property, become `CodeFragment`s. “Inline block comments,” e.g.
        // `/* */`-delimited comments that are interspersed within code on a line,
        // are added to the current `fragments` stream. All other fragments are
        // attached as properties to the nearest preceding or following fragment,
        // to remain stowaways until they get properly output in `compileComments`
        // later on.
        unshiftCommentFragment = function(commentFragment) {
          var precedingFragment;
          if (commentFragment.unshift) {
            // Find the first non-comment fragment and insert `commentFragment`
            // before it.
            return unshiftAfterComments(fragments, commentFragment);
          } else {
            if (fragments.length !== 0) {
              precedingFragment = fragments[fragments.length - 1];
              if (commentFragment.newLine && precedingFragment.code !== '' && !/\n\s*$/.test(precedingFragment.code)) {
                commentFragment.code = `\n${commentFragment.code}`;
              }
            }
            return fragments.push(commentFragment);
          }
        };
        ref1 = node.comments;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          comment = ref1[j];
          if (!(indexOf.call(this.compiledComments, comment) < 0)) {
            continue;
          }
          this.compiledComments.push(comment); // Don’t output this comment twice.
          // For block/here comments, denoted by `###`, that are inline comments
          // like `1 + ### comment ### 2`, create fragments and insert them into
          // the fragments array.
          // Otherwise attach comment fragments to their closest fragment for now,
          // so they can be inserted into the output later after all the newlines
          // have been added.
          if (comment.here) { // Block comment, delimited by `###`.
            commentFragment = new HereComment(comment).compileNode(o); // Line comment, delimited by `#`.
          } else {
            commentFragment = new LineComment(comment).compileNode(o);
          }
          if ((commentFragment.isHereComment && !commentFragment.newLine) || node.includeCommentFragments()) {
            // Inline block comments, like `1 + /* comment */ 2`, or a node whose
            // `compileToFragments` method has logic for outputting comments.
            unshiftCommentFragment(commentFragment);
          } else {
            if (fragments.length === 0) {
              fragments.push(this.makeCode(''));
            }
            if (commentFragment.unshift) {
              if ((base1 = fragments[0]).precedingComments == null) {
                base1.precedingComments = [];
              }
              fragments[0].precedingComments.push(commentFragment);
            } else {
              if ((base2 = fragments[fragments.length - 1]).followingComments == null) {
                base2.followingComments = [];
              }
              fragments[fragments.length - 1].followingComments.push(commentFragment);
            }
          }
        }
        return fragments;
      }

      // If the code generation wishes to use the result of a complex expression
      // in multiple places, ensure that the expression is only ever evaluated once,
      // by assigning it to a temporary variable. Pass a level to precompile.

      // If `level` is passed, then returns `[val, ref]`, where `val` is the compiled value, and `ref`
      // is the compiled reference. If `level` is not passed, this returns `[val, ref]` where
      // the two values are raw nodes which have not been compiled.
      cache(o, level, shouldCache) {
        var complex, ref, sub;
        complex = shouldCache != null ? shouldCache(this) : this.shouldCache();
        if (complex) {
          ref = new IdentifierLiteral(o.scope.freeVariable('ref'));
          sub = new Assign(ref, this);
          if (level) {
            return [sub.compileToFragments(o, level), [this.makeCode(ref.value)]];
          } else {
            return [sub, ref];
          }
        } else {
          ref = level ? this.compileToFragments(o, level) : this;
          return [ref, ref];
        }
      }

      // Occasionally it may be useful to make an expression behave as if it was 'hoisted', whereby the
      // result of the expression is available before its location in the source, but the expression's
      // variable scope corresponds to the source position. This is used extensively to deal with executable
      // class bodies in classes.

      // Calling this method mutates the node, proxying the `compileNode` and `compileToFragments`
      // methods to store their result for later replacing the `target` node, which is returned by the
      // call.
      hoist() {
        var compileNode, compileToFragments, target;
        this.hoisted = true;
        target = new HoistTarget(this);
        compileNode = this.compileNode;
        compileToFragments = this.compileToFragments;
        this.compileNode = function(o) {
          return target.update(compileNode, o);
        };
        this.compileToFragments = function(o) {
          return target.update(compileToFragments, o);
        };
        return target;
      }

      cacheToCodeFragments(cacheValues) {
        return [fragmentsToText(cacheValues[0]), fragmentsToText(cacheValues[1])];
      }

      // Construct a node that returns the current node’s result.
      // Note that this is overridden for smarter behavior for
      // many statement nodes (e.g. `If`, `For`).
      makeReturn(results, mark) {
        var node;
        if (mark) {
          // Mark this node as implicitly returned, so that it can be part of the
          // node metadata returned in the AST.
          this.canBeReturned = true;
          return;
        }
        node = this.unwrapAll();
        if (results) {
          return new Call(new Literal(`${results}.push`), [node]);
        } else {
          return new Return(node);
        }
      }

      // Does this node, or any of its children, contain a node of a certain kind?
      // Recursively traverses down the *children* nodes and returns the first one
      // that verifies `pred`. Otherwise return undefined. `contains` does not cross
      // scope boundaries.
      contains(pred) {
        var node;
        node = void 0;
        this.traverseChildren(false, function(n) {
          if (pred(n)) {
            node = n;
            return false;
          }
        });
        return node;
      }

      // Pull out the last node of a node list.
      lastNode(list) {
        if (list.length === 0) {
          return null;
        } else {
          return list[list.length - 1];
        }
      }

      // Debugging representation of the node, for inspecting the parse tree.
      // This is what `coffee --nodes` prints out.
      toString(idt = '', name = this.constructor.name) {
        var tree;
        tree = '\n' + idt + name;
        if (this.soak) {
          tree += '?';
        }
        this.eachChild(function(node) {
          return tree += node.toString(idt + TAB);
        });
        return tree;
      }

      checkForPureStatementInExpression() {
        var jumpNode;
        if (jumpNode = this.jumps()) {
          return jumpNode.error('cannot use a pure statement in an expression');
        }
      }

      // Plain JavaScript object representation of the node, that can be serialized
      // as JSON. This is what the `ast` option in the Node API returns.
      // We try to follow the [Babel AST spec](https://github.com/babel/babel/blob/master/packages/babel-parser/ast/spec.md)
      // as closely as possible, for improved interoperability with other tools.
      // **WARNING: DO NOT OVERRIDE THIS METHOD IN CHILD CLASSES.**
      // Only override the component `ast*` methods as needed.
      ast(o, level) {
        var astNode;
        // Merge `level` into `o` and perform other universal checks.
        o = this.astInitialize(o, level);
        // Create serializable representation of this node.
        astNode = this.astNode(o);
        // Mark AST nodes that correspond to expressions that (implicitly) return.
        // We can’t do this as part of `astNode` because we need to assemble child
        // nodes first before marking the parent being returned.
        if ((this.astNode != null) && this.canBeReturned) {
          Object.assign(astNode, {
            returns: true
          });
        }
        return astNode;
      }

      astInitialize(o, level) {
        o = Object.assign({}, o);
        if (level != null) {
          o.level = level;
        }
        if (o.level > LEVEL_TOP) {
          this.checkForPureStatementInExpression();
        }
        if (this.isStatement(o) && o.level !== LEVEL_TOP && (o.scope != null)) {
          // `@makeReturn` must be called before `astProperties`, because the latter may call
          // `.ast()` for child nodes and those nodes would need the return logic from `makeReturn`
          // already executed by then.
          this.makeReturn(null, true);
        }
        return o;
      }

      astNode(o) {
        // Every abstract syntax tree node object has four categories of properties:
        // - type, stored in the `type` field and a string like `NumberLiteral`.
        // - location data, stored in the `loc`, `start`, `end` and `range` fields.
        // - properties specific to this node, like `parsedValue`.
        // - properties that are themselves child nodes, like `body`.
        // These fields are all intermixed in the Babel spec; `type` and `start` and
        // `parsedValue` are all top level fields in the AST node object. We have
        // separate methods for returning each category, that we merge together here.
        return Object.assign({}, {
          type: this.astType(o)
        }, this.astProperties(o), this.astLocationData());
      }

      // By default, a node class has no specific properties.
      astProperties() {
        return {};
      }

      // By default, a node class’s AST `type` is its class name.
      astType() {
        return this.constructor.name;
      }

      // The AST location data is a rearranged version of our Jison location data,
      // mutated into the structure that the Babel spec uses.
      astLocationData() {
        return jisonLocationDataToAstLocationData(this.locationData);
      }

      // Determines whether an AST node needs an `ExpressionStatement` wrapper.
      // Typically matches our `isStatement()` logic but this allows overriding.
      isStatementAst(o) {
        return this.isStatement(o);
      }

      // Passes each child to a function, breaking when the function returns `false`.
      eachChild(func) {
        var attr, child, j, k, len1, len2, ref1, ref2;
        if (!this.children) {
          return this;
        }
        ref1 = this.children;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          attr = ref1[j];
          if (this[attr]) {
            ref2 = flatten([this[attr]]);
            for (k = 0, len2 = ref2.length; k < len2; k++) {
              child = ref2[k];
              if (func(child) === false) {
                return this;
              }
            }
          }
        }
        return this;
      }

      traverseChildren(crossScope, func) {
        return this.eachChild(function(child) {
          var recur;
          recur = func(child);
          if (recur !== false) {
            return child.traverseChildren(crossScope, func);
          }
        });
      }

      // `replaceInContext` will traverse children looking for a node for which `match` returns
      // true. Once found, the matching node will be replaced by the result of calling `replacement`.
      replaceInContext(match, replacement) {
        var attr, child, children, i, j, k, len1, len2, ref1, ref2;
        if (!this.children) {
          return false;
        }
        ref1 = this.children;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          attr = ref1[j];
          if (children = this[attr]) {
            if (Array.isArray(children)) {
              for (i = k = 0, len2 = children.length; k < len2; i = ++k) {
                child = children[i];
                if (match(child)) {
                  splice.apply(children, [i, i - i + 1].concat(ref2 = replacement(child, this))), ref2;
                  return true;
                } else {
                  if (child.replaceInContext(match, replacement)) {
                    return true;
                  }
                }
              }
            } else if (match(children)) {
              this[attr] = replacement(children, this);
              return true;
            } else {
              if (children.replaceInContext(match, replacement)) {
                return true;
              }
            }
          }
        }
      }

      invert() {
        return new Op('!', this);
      }

      unwrapAll() {
        var node;
        node = this;
        while (node !== (node = node.unwrap())) {
          continue;
        }
        return node;
      }

      // For this node and all descendents, set the location data to `locationData`
      // if the location data is not already set.
      updateLocationDataIfMissing(locationData, force) {
        if (force) {
          this.forceUpdateLocation = true;
        }
        if (this.locationData && !this.forceUpdateLocation) {
          return this;
        }
        delete this.forceUpdateLocation;
        this.locationData = locationData;
        return this.eachChild(function(child) {
          return child.updateLocationDataIfMissing(locationData);
        });
      }

      // Add location data from another node
      withLocationDataFrom({locationData}) {
        return this.updateLocationDataIfMissing(locationData);
      }

      // Add location data and comments from another node
      withLocationDataAndCommentsFrom(node) {
        var comments;
        this.withLocationDataFrom(node);
        ({comments} = node);
        if (comments != null ? comments.length : void 0) {
          this.comments = comments;
        }
        return this;
      }

      // Throw a SyntaxError associated with this node’s location.
      error(message) {
        return throwSyntaxError(message, this.locationData);
      }

      makeCode(code) {
        return new CodeFragment(this, code);
      }

      wrapInParentheses(fragments) {
        return [this.makeCode('('), ...fragments, this.makeCode(')')];
      }

      wrapInBraces(fragments) {
        return [this.makeCode('{'), ...fragments, this.makeCode('}')];
      }

      // `fragmentsList` is an array of arrays of fragments. Each array in fragmentsList will be
      // concatenated together, with `joinStr` added in between each, to produce a final flat array
      // of fragments.
      joinFragmentArrays(fragmentsList, joinStr) {
        var answer, fragments, i, j, len1;
        answer = [];
        for (i = j = 0, len1 = fragmentsList.length; j < len1; i = ++j) {
          fragments = fragmentsList[i];
          if (i) {
            answer.push(this.makeCode(joinStr));
          }
          answer = answer.concat(fragments);
        }
        return answer;
      }

    };

    // Default implementations of the common node properties and methods. Nodes
    // will override these with custom logic, if needed.

    // `children` are the properties to recurse into when tree walking. The
    // `children` list *is* the structure of the AST. The `parent` pointer, and
    // the pointer to the `children` are how you can traverse the tree.
    Base.prototype.children = [];

    // `isStatement` has to do with “everything is an expression”. A few things
    // can’t be expressions, such as `break`. Things that `isStatement` returns
    // `true` for are things that can’t be used as expressions. There are some
    // error messages that come from `nodes.coffee` due to statements ending up
    // in expression position.
    Base.prototype.isStatement = NO;

    // Track comments that have been compiled into fragments, to avoid outputting
    // them twice.
    Base.prototype.compiledComments = [];

    // `includeCommentFragments` lets `compileCommentFragments` know whether this node
    // has special awareness of how to handle comments within its output.
    Base.prototype.includeCommentFragments = NO;

    // `jumps` tells you if an expression, or an internal part of an expression,
    // has a flow control construct (like `break`, `continue`, or `return`)
    // that jumps out of the normal flow of control and can’t be used as a value.
    // (Note that `throw` is not considered a flow control construct.)
    // This is important because flow control in the middle of an expression
    // makes no sense; we have to disallow it.
    Base.prototype.jumps = NO;

    // If `node.shouldCache() is false`, it is safe to use `node` more than once.
    // Otherwise you need to store the value of `node` in a variable and output
    // that variable several times instead. Kind of like this: `5` need not be
    // cached. `returnFive()`, however, could have side effects as a result of
    // evaluating it more than once, and therefore we need to cache it. The
    // parameter is named `shouldCache` rather than `mustCache` because there are
    // also cases where we might not need to cache but where we want to, for
    // example a long expression that may well be idempotent but we want to cache
    // for brevity.
    Base.prototype.shouldCache = YES;

    Base.prototype.isChainable = NO;

    Base.prototype.isAssignable = NO;

    Base.prototype.isNumber = NO;

    Base.prototype.unwrap = THIS;

    Base.prototype.unfoldSoak = NO;

    // Is this node used to assign a certain variable?
    Base.prototype.assigns = NO;

    return Base;

  }).call(this);

  //### HoistTarget

  // A **HoistTargetNode** represents the output location in the node tree for a hoisted node.
  // See Base#hoist.
  exports.HoistTarget = HoistTarget = class HoistTarget extends Base {
    // Expands hoisted fragments in the given array
    static expand(fragments) {
      var fragment, i, j, ref1;
      for (i = j = fragments.length - 1; j >= 0; i = j += -1) {
        fragment = fragments[i];
        if (fragment.fragments) {
          splice.apply(fragments, [i, i - i + 1].concat(ref1 = this.expand(fragment.fragments))), ref1;
        }
      }
      return fragments;
    }

    constructor(source1) {
      super();
      this.source = source1;
      // Holds presentational options to apply when the source node is compiled.
      this.options = {};
      // Placeholder fragments to be replaced by the source node’s compilation.
      this.targetFragments = {
        fragments: []
      };
    }

    isStatement(o) {
      return this.source.isStatement(o);
    }

    // Update the target fragments with the result of compiling the source.
    // Calls the given compile function with the node and options (overriden with the target
    // presentational options).
    update(compile, o) {
      return this.targetFragments.fragments = compile.call(this.source, merge(o, this.options));
    }

    // Copies the target indent and level, and returns the placeholder fragments
    compileToFragments(o, level) {
      this.options.indent = o.indent;
      this.options.level = level != null ? level : o.level;
      return [this.targetFragments];
    }

    compileNode(o) {
      return this.compileToFragments(o);
    }

    compileClosure(o) {
      return this.compileToFragments(o);
    }

  };

  //### Root

  // The root node of the node tree
  exports.Root = Root = (function() {
    class Root extends Base {
      constructor(body1) {
        super();
        this.body = body1;
        this.isAsync = (new Code([], this.body)).isAsync;
      }

      // Wrap everything in a safety closure, unless requested not to. It would be
      // better not to generate them in the first place, but for now, clean up
      // obvious double-parentheses.
      compileNode(o) {
        var fragments, functionKeyword;
        o.indent = o.bare ? '' : TAB;
        o.level = LEVEL_TOP;
        o.compiling = true;
        this.initializeScope(o);
        fragments = this.body.compileRoot(o);
        if (o.bare) {
          return fragments;
        }
        functionKeyword = `${this.isAsync ? 'async ' : ''}function`;
        return [].concat(this.makeCode(`(${functionKeyword}() {\n`), fragments, this.makeCode("\n}).call(this);\n"));
      }

      initializeScope(o) {
        var j, len1, name, ref1, ref2, results1;
        o.scope = new Scope(null, this.body, null, (ref1 = o.referencedVars) != null ? ref1 : []);
        ref2 = o.locals || [];
        results1 = [];
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          name = ref2[j];
          // Mark given local variables in the root scope as parameters so they don’t
          // end up being declared on the root block.
          results1.push(o.scope.parameter(name));
        }
        return results1;
      }

      commentsAst() {
        var comment, commentToken, j, len1, ref1, results1;
        if (this.allComments == null) {
          this.allComments = (function() {
            var j, len1, ref1, ref2, results1;
            ref2 = (ref1 = this.allCommentTokens) != null ? ref1 : [];
            results1 = [];
            for (j = 0, len1 = ref2.length; j < len1; j++) {
              commentToken = ref2[j];
              if (!commentToken.heregex) {
                if (commentToken.here) {
                  results1.push(new HereComment(commentToken));
                } else {
                  results1.push(new LineComment(commentToken));
                }
              }
            }
            return results1;
          }).call(this);
        }
        ref1 = this.allComments;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          comment = ref1[j];
          results1.push(comment.ast());
        }
        return results1;
      }

      astNode(o) {
        o.level = LEVEL_TOP;
        this.initializeScope(o);
        return super.astNode(o);
      }

      astType() {
        return 'File';
      }

      astProperties(o) {
        this.body.isRootBlock = true;
        return {
          program: Object.assign(this.body.ast(o), this.astLocationData()),
          comments: this.commentsAst()
        };
      }

    };

    Root.prototype.children = ['body'];

    return Root;

  }).call(this);

  //### Block

  // The block is the list of expressions that forms the body of an
  // indented block of code -- the implementation of a function, a clause in an
  // `if`, `switch`, or `try`, and so on...
  exports.Block = Block = (function() {
    class Block extends Base {
      constructor(nodes) {
        super();
        this.expressions = compact(flatten(nodes || []));
      }

      // Tack an expression on to the end of this expression list.
      push(node) {
        this.expressions.push(node);
        return this;
      }

      // Remove and return the last expression of this expression list.
      pop() {
        return this.expressions.pop();
      }

      // Add an expression at the beginning of this expression list.
      unshift(node) {
        this.expressions.unshift(node);
        return this;
      }

      // If this Block consists of just a single node, unwrap it by pulling
      // it back out.
      unwrap() {
        if (this.expressions.length === 1) {
          return this.expressions[0];
        } else {
          return this;
        }
      }

      // Is this an empty block of code?
      isEmpty() {
        return !this.expressions.length;
      }

      isStatement(o) {
        var exp, j, len1, ref1;
        ref1 = this.expressions;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          exp = ref1[j];
          if (exp.isStatement(o)) {
            return true;
          }
        }
        return false;
      }

      jumps(o) {
        var exp, j, jumpNode, len1, ref1;
        ref1 = this.expressions;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          exp = ref1[j];
          if (jumpNode = exp.jumps(o)) {
            return jumpNode;
          }
        }
      }

      // A Block node does not return its entire body, rather it
      // ensures that the final expression is returned.
      makeReturn(results, mark) {
        var expr, expressions, last, lastExp, len, penult, ref1, ref2;
        len = this.expressions.length;
        ref1 = this.expressions, [lastExp] = slice1.call(ref1, -1);
        lastExp = (lastExp != null ? lastExp.unwrap() : void 0) || false;
        // We also need to check that we’re not returning a JSX tag if there’s an
        // adjacent one at the same level; JSX doesn’t allow that.
        if (lastExp && lastExp instanceof Parens && lastExp.body.expressions.length > 1) {
          ({
            body: {expressions}
          } = lastExp);
          [penult, last] = slice1.call(expressions, -2);
          penult = penult.unwrap();
          last = last.unwrap();
          if (penult instanceof JSXElement && last instanceof JSXElement) {
            expressions[expressions.length - 1].error('Adjacent JSX elements must be wrapped in an enclosing tag');
          }
        }
        if (mark) {
          if ((ref2 = this.expressions[len - 1]) != null) {
            ref2.makeReturn(results, mark);
          }
          return;
        }
        while (len--) {
          expr = this.expressions[len];
          this.expressions[len] = expr.makeReturn(results);
          if (expr instanceof Return && !expr.expression) {
            this.expressions.splice(len, 1);
          }
          break;
        }
        return this;
      }

      compile(o, lvl) {
        if (!o.scope) {
          return new Root(this).withLocationDataFrom(this).compile(o, lvl);
        }
        return super.compile(o, lvl);
      }

      // Compile all expressions within the **Block** body. If we need to return
      // the result, and it’s an expression, simply return it. If it’s a statement,
      // ask the statement to do so.
      compileNode(o) {
        var answer, compiledNodes, fragments, index, j, lastFragment, len1, node, ref1, top;
        this.tab = o.indent;
        top = o.level === LEVEL_TOP;
        compiledNodes = [];
        ref1 = this.expressions;
        for (index = j = 0, len1 = ref1.length; j < len1; index = ++j) {
          node = ref1[index];
          if (node.hoisted) {
            // This is a hoisted expression.
            // We want to compile this and ignore the result.
            node.compileToFragments(o);
            continue;
          }
          node = node.unfoldSoak(o) || node;
          if (node instanceof Block) {
            // This is a nested block. We don’t do anything special here like
            // enclose it in a new scope; we just compile the statements in this
            // block along with our own.
            compiledNodes.push(node.compileNode(o));
          } else if (top) {
            node.front = true;
            fragments = node.compileToFragments(o);
            if (!node.isStatement(o)) {
              fragments = indentInitial(fragments, this);
              [lastFragment] = slice1.call(fragments, -1);
              if (!(lastFragment.code === '' || lastFragment.isComment)) {
                fragments.push(this.makeCode(';'));
              }
            }
            compiledNodes.push(fragments);
          } else {
            compiledNodes.push(node.compileToFragments(o, LEVEL_LIST));
          }
        }
        if (top) {
          if (this.spaced) {
            return [].concat(this.joinFragmentArrays(compiledNodes, '\n\n'), this.makeCode('\n'));
          } else {
            return this.joinFragmentArrays(compiledNodes, '\n');
          }
        }
        if (compiledNodes.length) {
          answer = this.joinFragmentArrays(compiledNodes, ', ');
        } else {
          answer = [this.makeCode('void 0')];
        }
        if (compiledNodes.length > 1 && o.level >= LEVEL_LIST) {
          return this.wrapInParentheses(answer);
        } else {
          return answer;
        }
      }

      compileRoot(o) {
        var fragments;
        this.spaced = true;
        fragments = this.compileWithDeclarations(o);
        HoistTarget.expand(fragments);
        return this.compileComments(fragments);
      }

      // Compile the expressions body for the contents of a function, with
      // declarations of all inner variables pushed up to the top.
      compileWithDeclarations(o) {
        var assigns, declaredVariable, declaredVariables, declaredVariablesIndex, declars, exp, fragments, i, j, k, len1, len2, post, ref1, rest, scope, spaced;
        fragments = [];
        post = [];
        ref1 = this.expressions;
        for (i = j = 0, len1 = ref1.length; j < len1; i = ++j) {
          exp = ref1[i];
          exp = exp.unwrap();
          if (!(exp instanceof Literal)) {
            break;
          }
        }
        o = merge(o, {
          level: LEVEL_TOP
        });
        if (i) {
          rest = this.expressions.splice(i, 9e9);
          [spaced, this.spaced] = [this.spaced, false];
          [fragments, this.spaced] = [this.compileNode(o), spaced];
          this.expressions = rest;
        }
        post = this.compileNode(o);
        ({scope} = o);
        if (scope.expressions === this) {
          declars = o.scope.hasDeclarations();
          assigns = scope.hasAssignments;
          if (declars || assigns) {
            if (i) {
              fragments.push(this.makeCode('\n'));
            }
            fragments.push(this.makeCode(`${this.tab}var `));
            if (declars) {
              declaredVariables = scope.declaredVariables();
              for (declaredVariablesIndex = k = 0, len2 = declaredVariables.length; k < len2; declaredVariablesIndex = ++k) {
                declaredVariable = declaredVariables[declaredVariablesIndex];
                fragments.push(this.makeCode(declaredVariable));
                if (Object.prototype.hasOwnProperty.call(o.scope.comments, declaredVariable)) {
                  fragments.push(...o.scope.comments[declaredVariable]);
                }
                if (declaredVariablesIndex !== declaredVariables.length - 1) {
                  fragments.push(this.makeCode(', '));
                }
              }
            }
            if (assigns) {
              if (declars) {
                fragments.push(this.makeCode(`,\n${this.tab + TAB}`));
              }
              fragments.push(this.makeCode(scope.assignedVariables().join(`,\n${this.tab + TAB}`)));
            }
            fragments.push(this.makeCode(`;\n${this.spaced ? '\n' : ''}`));
          } else if (fragments.length && post.length) {
            fragments.push(this.makeCode("\n"));
          }
        }
        return fragments.concat(post);
      }

      compileComments(fragments) {
        var code, commentFragment, fragment, fragmentIndent, fragmentIndex, indent, j, k, l, len1, len2, len3, newLineIndex, onNextLine, p, pastFragment, pastFragmentIndex, q, ref1, ref2, ref3, ref4, trail, upcomingFragment, upcomingFragmentIndex;
        for (fragmentIndex = j = 0, len1 = fragments.length; j < len1; fragmentIndex = ++j) {
          fragment = fragments[fragmentIndex];
          // Insert comments into the output at the next or previous newline.
          // If there are no newlines at which to place comments, create them.
          if (fragment.precedingComments) {
            // Determine the indentation level of the fragment that we are about
            // to insert comments before, and use that indentation level for our
            // inserted comments. At this point, the fragments’ `code` property
            // is the generated output JavaScript, and CoffeeScript always
            // generates output indented by two spaces; so all we need to do is
            // search for a `code` property that begins with at least two spaces.
            fragmentIndent = '';
            ref1 = fragments.slice(0, (fragmentIndex + 1));
            for (k = ref1.length - 1; k >= 0; k += -1) {
              pastFragment = ref1[k];
              indent = /^ {2,}/m.exec(pastFragment.code);
              if (indent) {
                fragmentIndent = indent[0];
                break;
              } else if (indexOf.call(pastFragment.code, '\n') >= 0) {
                break;
              }
            }
            code = `\n${fragmentIndent}` + ((function() {
              var l, len2, ref2, results1;
              ref2 = fragment.precedingComments;
              results1 = [];
              for (l = 0, len2 = ref2.length; l < len2; l++) {
                commentFragment = ref2[l];
                if (commentFragment.isHereComment && commentFragment.multiline) {
                  results1.push(multident(commentFragment.code, fragmentIndent, false));
                } else {
                  results1.push(commentFragment.code);
                }
              }
              return results1;
            })()).join(`\n${fragmentIndent}`).replace(/^(\s*)$/gm, '');
            ref2 = fragments.slice(0, (fragmentIndex + 1));
            for (pastFragmentIndex = l = ref2.length - 1; l >= 0; pastFragmentIndex = l += -1) {
              pastFragment = ref2[pastFragmentIndex];
              newLineIndex = pastFragment.code.lastIndexOf('\n');
              if (newLineIndex === -1) {
                // Keep searching previous fragments until we can’t go back any
                // further, either because there are no fragments left or we’ve
                // discovered that we’re in a code block that is interpolated
                // inside a string.
                if (pastFragmentIndex === 0) {
                  pastFragment.code = '\n' + pastFragment.code;
                  newLineIndex = 0;
                } else if (pastFragment.isStringWithInterpolations && pastFragment.code === '{') {
                  code = code.slice(1) + '\n'; // Move newline to end.
                  newLineIndex = 1;
                } else {
                  continue;
                }
              }
              delete fragment.precedingComments;
              pastFragment.code = pastFragment.code.slice(0, newLineIndex) + code + pastFragment.code.slice(newLineIndex);
              break;
            }
          }
          // Yes, this is awfully similar to the previous `if` block, but if you
          // look closely you’ll find lots of tiny differences that make this
          // confusing if it were abstracted into a function that both blocks share.
          if (fragment.followingComments) {
            // Does the first trailing comment follow at the end of a line of code,
            // like `; // Comment`, or does it start a new line after a line of code?
            trail = fragment.followingComments[0].trail;
            fragmentIndent = '';
            // Find the indent of the next line of code, if we have any non-trailing
            // comments to output. We need to first find the next newline, as these
            // comments will be output after that; and then the indent of the line
            // that follows the next newline.
            if (!(trail && fragment.followingComments.length === 1)) {
              onNextLine = false;
              ref3 = fragments.slice(fragmentIndex);
              for (p = 0, len2 = ref3.length; p < len2; p++) {
                upcomingFragment = ref3[p];
                if (!onNextLine) {
                  if (indexOf.call(upcomingFragment.code, '\n') >= 0) {
                    onNextLine = true;
                  } else {
                    continue;
                  }
                } else {
                  indent = /^ {2,}/m.exec(upcomingFragment.code);
                  if (indent) {
                    fragmentIndent = indent[0];
                    break;
                  } else if (indexOf.call(upcomingFragment.code, '\n') >= 0) {
                    break;
                  }
                }
              }
            }
            // Is this comment following the indent inserted by bare mode?
            // If so, there’s no need to indent this further.
            code = fragmentIndex === 1 && /^\s+$/.test(fragments[0].code) ? '' : trail ? ' ' : `\n${fragmentIndent}`;
            // Assemble properly indented comments.
            code += ((function() {
              var len3, q, ref4, results1;
              ref4 = fragment.followingComments;
              results1 = [];
              for (q = 0, len3 = ref4.length; q < len3; q++) {
                commentFragment = ref4[q];
                if (commentFragment.isHereComment && commentFragment.multiline) {
                  results1.push(multident(commentFragment.code, fragmentIndent, false));
                } else {
                  results1.push(commentFragment.code);
                }
              }
              return results1;
            })()).join(`\n${fragmentIndent}`).replace(/^(\s*)$/gm, '');
            ref4 = fragments.slice(fragmentIndex);
            for (upcomingFragmentIndex = q = 0, len3 = ref4.length; q < len3; upcomingFragmentIndex = ++q) {
              upcomingFragment = ref4[upcomingFragmentIndex];
              newLineIndex = upcomingFragment.code.indexOf('\n');
              if (newLineIndex === -1) {
                // Keep searching upcoming fragments until we can’t go any
                // further, either because there are no fragments left or we’ve
                // discovered that we’re in a code block that is interpolated
                // inside a string.
                if (upcomingFragmentIndex === fragments.length - 1) {
                  upcomingFragment.code = upcomingFragment.code + '\n';
                  newLineIndex = upcomingFragment.code.length;
                } else if (upcomingFragment.isStringWithInterpolations && upcomingFragment.code === '}') {
                  code = `${code}\n`;
                  newLineIndex = 0;
                } else {
                  continue;
                }
              }
              delete fragment.followingComments;
              if (upcomingFragment.code === '\n') {
                // Avoid inserting extra blank lines.
                code = code.replace(/^\n/, '');
              }
              upcomingFragment.code = upcomingFragment.code.slice(0, newLineIndex) + code + upcomingFragment.code.slice(newLineIndex);
              break;
            }
          }
        }
        return fragments;
      }

      // Wrap up the given nodes as a **Block**, unless it already happens
      // to be one.
      static wrap(nodes) {
        if (nodes.length === 1 && nodes[0] instanceof Block) {
          return nodes[0];
        }
        return new Block(nodes);
      }

      astNode(o) {
        if (((o.level != null) && o.level !== LEVEL_TOP) && this.expressions.length) {
          return (new Sequence(this.expressions).withLocationDataFrom(this)).ast(o);
        }
        return super.astNode(o);
      }

      astType() {
        if (this.isRootBlock) {
          return 'Program';
        } else if (this.isClassBody) {
          return 'ClassBody';
        } else {
          return 'BlockStatement';
        }
      }

      astProperties(o) {
        var body, checkForDirectives, directives, expression, expressionAst, j, len1, ref1;
        checkForDirectives = del(o, 'checkForDirectives');
        if (this.isRootBlock || checkForDirectives) {
          sniffDirectives(this.expressions, {
            notFinalExpression: checkForDirectives
          });
        }
        directives = [];
        body = [];
        ref1 = this.expressions;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          expression = ref1[j];
          expressionAst = expression.ast(o);
          // Ignore generated PassthroughLiteral
          if (expressionAst == null) {
            continue;
          } else if (expression instanceof Directive) {
            directives.push(expressionAst);
          // If an expression is a statement, it can be added to the body as is.
          } else if (expression.isStatementAst(o)) {
            body.push(expressionAst);
          } else {
            // Otherwise, we need to wrap it in an `ExpressionStatement` AST node.
            body.push(Object.assign({
              type: 'ExpressionStatement',
              expression: expressionAst
            }, expression.astLocationData()));
          }
        }
        // For now, we’re not including `sourceType` on the `Program` AST node.
        // Its value could be either `'script'` or `'module'`, and there’s no way
        // for CoffeeScript to always know which it should be. The presence of an
        // `import` or `export` statement in source code would imply that it should
        // be a `module`, but a project may consist of mostly such files and also
        // an outlier file that lacks `import` or `export` but is still imported
        // into the project and therefore expects to be treated as a `module`.
        // Determining the value of `sourceType` is essentially the same challenge
        // posed by determining the parse goal of a JavaScript file, also `module`
        // or `script`, and so if Node figures out a way to do so for `.js` files
        // then CoffeeScript can copy Node’s algorithm.

          // sourceType: 'module'
        return {body, directives};
      }

      astLocationData() {
        if (this.isRootBlock && (this.locationData == null)) {
          return;
        }
        return super.astLocationData();
      }

    };

    Block.prototype.children = ['expressions'];

    return Block;

  }).call(this);

  // A directive e.g. 'use strict'.
  // Currently only used during AST generation.
  exports.Directive = Directive = class Directive extends Base {
    constructor(value1) {
      super();
      this.value = value1;
    }

    astProperties(o) {
      return {
        value: Object.assign({}, this.value.ast(o), {
          type: 'DirectiveLiteral'
        })
      };
    }

  };

  //### Literal

  // `Literal` is a base class for static values that can be passed through
  // directly into JavaScript without translation, such as: strings, numbers,
  // `true`, `false`, `null`...
  exports.Literal = Literal = (function() {
    class Literal extends Base {
      constructor(value1) {
        super();
        this.value = value1;
      }

      assigns(name) {
        return name === this.value;
      }

      compileNode(o) {
        return [this.makeCode(this.value)];
      }

      astProperties() {
        return {
          value: this.value
        };
      }

      toString() {
        // This is only intended for debugging.
        return ` ${this.isStatement() ? super.toString() : this.constructor.name}: ${this.value}`;
      }

    };

    Literal.prototype.shouldCache = NO;

    return Literal;

  }).call(this);

  exports.NumberLiteral = NumberLiteral = class NumberLiteral extends Literal {
    constructor(value1, {parsedValue} = {}) {
      super();
      this.value = value1;
      this.parsedValue = parsedValue;
      if (this.parsedValue == null) {
        if (isNumber(this.value)) {
          this.parsedValue = this.value;
          this.value = `${this.value}`;
        } else {
          this.parsedValue = parseNumber(this.value);
        }
      }
    }

    isBigInt() {
      return /n$/.test(this.value);
    }

    astType() {
      if (this.isBigInt()) {
        return 'BigIntLiteral';
      } else {
        return 'NumericLiteral';
      }
    }

    astProperties() {
      return {
        value: this.isBigInt() ? this.parsedValue.toString() : this.parsedValue,
        extra: {
          rawValue: this.isBigInt() ? this.parsedValue.toString() : this.parsedValue,
          raw: this.value
        }
      };
    }

  };

  exports.InfinityLiteral = InfinityLiteral = class InfinityLiteral extends NumberLiteral {
    constructor(value1, {originalValue: originalValue = 'Infinity'} = {}) {
      super();
      this.value = value1;
      this.originalValue = originalValue;
    }

    compileNode() {
      return [this.makeCode('2e308')];
    }

    astNode(o) {
      if (this.originalValue !== 'Infinity') {
        return new NumberLiteral(this.value).withLocationDataFrom(this).ast(o);
      }
      return super.astNode(o);
    }

    astType() {
      return 'Identifier';
    }

    astProperties() {
      return {
        name: 'Infinity',
        declaration: false
      };
    }

  };

  exports.NaNLiteral = NaNLiteral = class NaNLiteral extends NumberLiteral {
    constructor() {
      super('NaN');
    }

    compileNode(o) {
      var code;
      code = [this.makeCode('0/0')];
      if (o.level >= LEVEL_OP) {
        return this.wrapInParentheses(code);
      } else {
        return code;
      }
    }

    astType() {
      return 'Identifier';
    }

    astProperties() {
      return {
        name: 'NaN',
        declaration: false
      };
    }

  };

  exports.StringLiteral = StringLiteral = class StringLiteral extends Literal {
    constructor(originalValue, {
        quote,
        initialChunk,
        finalChunk,
        indent: indent1,
        double: double1,
        heregex: heregex1
      } = {}) {
      var heredoc, indentRegex, val;
      super('');
      this.originalValue = originalValue;
      this.quote = quote;
      this.initialChunk = initialChunk;
      this.finalChunk = finalChunk;
      this.indent = indent1;
      this.double = double1;
      this.heregex = heregex1;
      if (this.quote === '///') {
        this.quote = null;
      }
      this.fromSourceString = this.quote != null;
      if (this.quote == null) {
        this.quote = '"';
      }
      heredoc = this.isFromHeredoc();
      val = this.originalValue;
      if (this.heregex) {
        val = val.replace(HEREGEX_OMIT, '$1$2');
        val = replaceUnicodeCodePointEscapes(val, {
          flags: this.heregex.flags
        });
      } else {
        val = val.replace(STRING_OMIT, '$1');
        val = !this.fromSourceString ? val : heredoc ? (this.indent ? indentRegex = RegExp(`\\n${this.indent}`, "g") : void 0, indentRegex ? val = val.replace(indentRegex, '\n') : void 0, this.initialChunk ? val = val.replace(LEADING_BLANK_LINE, '') : void 0, this.finalChunk ? val = val.replace(TRAILING_BLANK_LINE, '') : void 0, val) : val.replace(SIMPLE_STRING_OMIT, (match, offset) => {
          if ((this.initialChunk && offset === 0) || (this.finalChunk && offset + match.length === val.length)) {
            return '';
          } else {
            return ' ';
          }
        });
      }
      this.delimiter = this.quote.charAt(0);
      this.value = makeDelimitedLiteral(val, {delimiter: this.delimiter, double: this.double});
      this.unquotedValueForTemplateLiteral = makeDelimitedLiteral(val, {
        delimiter: '`',
        double: this.double,
        escapeNewlines: false,
        includeDelimiters: false,
        convertTrailingNullEscapes: true
      });
      this.unquotedValueForJSX = makeDelimitedLiteral(val, {
        double: this.double,
        escapeNewlines: false,
        includeDelimiters: false,
        escapeDelimiter: false
      });
    }

    compileNode(o) {
      if (this.shouldGenerateTemplateLiteral()) {
        return StringWithInterpolations.fromStringLiteral(this).compileNode(o);
      }
      if (this.jsx) {
        return [this.makeCode(this.unquotedValueForJSX)];
      }
      return super.compileNode(o);
    }

    // `StringLiteral`s can represent either entire literal strings
    // or pieces of text inside of e.g. an interpolated string.
    // When parsed as the former but needing to be treated as the latter
    // (e.g. the string part of a tagged template literal), this will return
    // a copy of the `StringLiteral` with the quotes trimmed from its location
    // data (like it would have if parsed as part of an interpolated string).
    withoutQuotesInLocationData() {
      var copy, endsWithNewline, locationData;
      endsWithNewline = this.originalValue.slice(-1) === '\n';
      locationData = Object.assign({}, this.locationData);
      locationData.first_column += this.quote.length;
      if (endsWithNewline) {
        locationData.last_line -= 1;
        locationData.last_column = locationData.last_line === locationData.first_line ? locationData.first_column + this.originalValue.length - '\n'.length : this.originalValue.slice(0, -1).length - '\n'.length - this.originalValue.slice(0, -1).lastIndexOf('\n');
      } else {
        locationData.last_column -= this.quote.length;
      }
      locationData.last_column_exclusive -= this.quote.length;
      locationData.range = [locationData.range[0] + this.quote.length, locationData.range[1] - this.quote.length];
      copy = new StringLiteral(this.originalValue, {quote: this.quote, initialChunk: this.initialChunk, finalChunk: this.finalChunk, indent: this.indent, double: this.double, heregex: this.heregex});
      copy.locationData = locationData;
      return copy;
    }

    isFromHeredoc() {
      return this.quote.length === 3;
    }

    shouldGenerateTemplateLiteral() {
      return this.isFromHeredoc();
    }

    astNode(o) {
      if (this.shouldGenerateTemplateLiteral()) {
        return StringWithInterpolations.fromStringLiteral(this).ast(o);
      }
      return super.astNode(o);
    }

    astProperties() {
      return {
        value: this.originalValue,
        extra: {
          raw: `${this.delimiter}${this.originalValue}${this.delimiter}`
        }
      };
    }

  };

  exports.RegexLiteral = RegexLiteral = (function() {
    class RegexLiteral extends Literal {
      constructor(value, {delimiter: delimiter1 = '/', heregexCommentTokens: heregexCommentTokens = []} = {}) {
        var endDelimiterIndex, heregex, val;
        super('');
        this.delimiter = delimiter1;
        this.heregexCommentTokens = heregexCommentTokens;
        heregex = this.delimiter === '///';
        endDelimiterIndex = value.lastIndexOf('/');
        this.flags = value.slice(endDelimiterIndex + 1);
        val = this.originalValue = value.slice(1, endDelimiterIndex);
        if (heregex) {
          val = val.replace(HEREGEX_OMIT, '$1$2');
        }
        val = replaceUnicodeCodePointEscapes(val, {flags: this.flags});
        this.value = `${makeDelimitedLiteral(val, {
          delimiter: '/'
        })}${this.flags}`;
      }

      astType() {
        return 'RegExpLiteral';
      }

      astProperties(o) {
        var heregexCommentToken, pattern;
        [, pattern] = this.REGEX_REGEX.exec(this.value);
        return {
          value: void 0,
          pattern,
          flags: this.flags,
          delimiter: this.delimiter,
          originalPattern: this.originalValue,
          extra: {
            raw: this.value,
            originalRaw: `${this.delimiter}${this.originalValue}${this.delimiter}${this.flags}`,
            rawValue: void 0
          },
          comments: (function() {
            var j, len1, ref1, results1;
            ref1 = this.heregexCommentTokens;
            results1 = [];
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              heregexCommentToken = ref1[j];
              if (heregexCommentToken.here) {
                results1.push(new HereComment(heregexCommentToken).ast(o));
              } else {
                results1.push(new LineComment(heregexCommentToken).ast(o));
              }
            }
            return results1;
          }).call(this)
        };
      }

    };

    RegexLiteral.prototype.REGEX_REGEX = /^\/(.*)\/\w*$/;

    return RegexLiteral;

  }).call(this);

  exports.PassthroughLiteral = PassthroughLiteral = class PassthroughLiteral extends Literal {
    constructor(originalValue, {here, generated} = {}) {
      super('');
      this.originalValue = originalValue;
      this.here = here;
      this.generated = generated;
      this.value = this.originalValue.replace(/\\+(`|$)/g, function(string) {
        // `string` is always a value like '\`', '\\\`', '\\\\\`', etc.
        // By reducing it to its latter half, we turn '\`' to '`', '\\\`' to '\`', etc.
        return string.slice(-Math.ceil(string.length / 2));
      });
    }

    astNode(o) {
      if (this.generated) {
        return null;
      }
      return super.astNode(o);
    }

    astProperties() {
      return {
        value: this.originalValue,
        here: !!this.here
      };
    }

  };

  exports.IdentifierLiteral = IdentifierLiteral = (function() {
    class IdentifierLiteral extends Literal {
      eachName(iterator) {
        return iterator(this);
      }

      astType() {
        if (this.jsx) {
          return 'JSXIdentifier';
        } else {
          return 'Identifier';
        }
      }

      astProperties() {
        return {
          name: this.value,
          declaration: !!this.isDeclaration
        };
      }

    };

    IdentifierLiteral.prototype.isAssignable = YES;

    return IdentifierLiteral;

  }).call(this);

  exports.PropertyName = PropertyName = (function() {
    class PropertyName extends Literal {
      astType() {
        if (this.jsx) {
          return 'JSXIdentifier';
        } else {
          return 'Identifier';
        }
      }

      astProperties() {
        return {
          name: this.value,
          declaration: false
        };
      }

    };

    PropertyName.prototype.isAssignable = YES;

    return PropertyName;

  }).call(this);

  exports.ComputedPropertyName = ComputedPropertyName = class ComputedPropertyName extends PropertyName {
    compileNode(o) {
      return [this.makeCode('['), ...this.value.compileToFragments(o, LEVEL_LIST), this.makeCode(']')];
    }

    astNode(o) {
      return this.value.ast(o);
    }

  };

  exports.StatementLiteral = StatementLiteral = (function() {
    class StatementLiteral extends Literal {
      jumps(o) {
        if (this.value === 'break' && !((o != null ? o.loop : void 0) || (o != null ? o.block : void 0))) {
          return this;
        }
        if (this.value === 'continue' && !(o != null ? o.loop : void 0)) {
          return this;
        }
      }

      compileNode(o) {
        return [this.makeCode(`${this.tab}${this.value};`)];
      }

      astType() {
        switch (this.value) {
          case 'continue':
            return 'ContinueStatement';
          case 'break':
            return 'BreakStatement';
          case 'debugger':
            return 'DebuggerStatement';
        }
      }

    };

    StatementLiteral.prototype.isStatement = YES;

    StatementLiteral.prototype.makeReturn = THIS;

    return StatementLiteral;

  }).call(this);

  exports.ThisLiteral = ThisLiteral = class ThisLiteral extends Literal {
    constructor(value) {
      super('this');
      this.shorthand = value === '@';
    }

    compileNode(o) {
      var code, ref1;
      code = ((ref1 = o.scope.method) != null ? ref1.bound : void 0) ? o.scope.method.context : this.value;
      return [this.makeCode(code)];
    }

    astType() {
      return 'ThisExpression';
    }

    astProperties() {
      return {
        shorthand: this.shorthand
      };
    }

  };

  exports.UndefinedLiteral = UndefinedLiteral = class UndefinedLiteral extends Literal {
    constructor() {
      super('undefined');
    }

    compileNode(o) {
      return [this.makeCode(o.level >= LEVEL_ACCESS ? '(void 0)' : 'void 0')];
    }

    astType() {
      return 'Identifier';
    }

    astProperties() {
      return {
        name: this.value,
        declaration: false
      };
    }

  };

  exports.NullLiteral = NullLiteral = class NullLiteral extends Literal {
    constructor() {
      super('null');
    }

  };

  exports.BooleanLiteral = BooleanLiteral = class BooleanLiteral extends Literal {
    constructor(value, {originalValue} = {}) {
      super(value);
      this.originalValue = originalValue;
      if (this.originalValue == null) {
        this.originalValue = this.value;
      }
    }

    astProperties() {
      return {
        value: this.value === 'true' ? true : false,
        name: this.originalValue
      };
    }

  };

  exports.DefaultLiteral = DefaultLiteral = class DefaultLiteral extends Literal {
    astType() {
      return 'Identifier';
    }

    astProperties() {
      return {
        name: 'default',
        declaration: false
      };
    }

  };

  //### Return

  // A `return` is a *pureStatement*—wrapping it in a closure wouldn’t make sense.
  exports.Return = Return = (function() {
    class Return extends Base {
      constructor(expression1, {belongsToFuncDirectiveReturn} = {}) {
        super();
        this.expression = expression1;
        this.belongsToFuncDirectiveReturn = belongsToFuncDirectiveReturn;
      }

      compileToFragments(o, level) {
        var expr, ref1;
        expr = (ref1 = this.expression) != null ? ref1.makeReturn() : void 0;
        if (expr && !(expr instanceof Return)) {
          return expr.compileToFragments(o, level);
        } else {
          return super.compileToFragments(o, level);
        }
      }

      compileNode(o) {
        var answer, fragment, j, len1;
        answer = [];
        // TODO: If we call `expression.compile()` here twice, we’ll sometimes
        // get back different results!
        if (this.expression) {
          answer = this.expression.compileToFragments(o, LEVEL_PAREN);
          unshiftAfterComments(answer, this.makeCode(`${this.tab}return `));
// Since the `return` got indented by `@tab`, preceding comments that are
// multiline need to be indented.
          for (j = 0, len1 = answer.length; j < len1; j++) {
            fragment = answer[j];
            if (fragment.isHereComment && indexOf.call(fragment.code, '\n') >= 0) {
              fragment.code = multident(fragment.code, this.tab);
            } else if (fragment.isLineComment) {
              fragment.code = `${this.tab}${fragment.code}`;
            } else {
              break;
            }
          }
        } else {
          answer.push(this.makeCode(`${this.tab}return`));
        }
        answer.push(this.makeCode(';'));
        return answer;
      }

      checkForPureStatementInExpression() {
        // don’t flag `return` from `await return`/`yield return` as invalid.
        if (this.belongsToFuncDirectiveReturn) {
          return;
        }
        return super.checkForPureStatementInExpression();
      }

      astType() {
        return 'ReturnStatement';
      }

      astProperties(o) {
        var ref1, ref2;
        return {
          argument: (ref1 = (ref2 = this.expression) != null ? ref2.ast(o, LEVEL_PAREN) : void 0) != null ? ref1 : null
        };
      }

    };

    Return.prototype.children = ['expression'];

    Return.prototype.isStatement = YES;

    Return.prototype.makeReturn = THIS;

    Return.prototype.jumps = THIS;

    return Return;

  }).call(this);

  // Parent class for `YieldReturn`/`AwaitReturn`.
  exports.FuncDirectiveReturn = FuncDirectiveReturn = (function() {
    class FuncDirectiveReturn extends Return {
      constructor(expression, {returnKeyword}) {
        super(expression);
        this.returnKeyword = returnKeyword;
      }

      compileNode(o) {
        this.checkScope(o);
        return super.compileNode(o);
      }

      checkScope(o) {
        if (o.scope.parent == null) {
          return this.error(`${this.keyword} can only occur inside functions`);
        }
      }

      astNode(o) {
        this.checkScope(o);
        return new Op(this.keyword, new Return(this.expression, {
          belongsToFuncDirectiveReturn: true
        }).withLocationDataFrom(this.expression != null ? {
          locationData: mergeLocationData(this.returnKeyword.locationData, this.expression.locationData)
        } : this.returnKeyword)).withLocationDataFrom(this).ast(o);
      }

    };

    FuncDirectiveReturn.prototype.isStatementAst = NO;

    return FuncDirectiveReturn;

  }).call(this);

  // `yield return` works exactly like `return`, except that it turns the function
  // into a generator.
  exports.YieldReturn = YieldReturn = (function() {
    class YieldReturn extends FuncDirectiveReturn {};

    YieldReturn.prototype.keyword = 'yield';

    return YieldReturn;

  }).call(this);

  exports.AwaitReturn = AwaitReturn = (function() {
    class AwaitReturn extends FuncDirectiveReturn {};

    AwaitReturn.prototype.keyword = 'await';

    return AwaitReturn;

  }).call(this);

  //### Value

  // A value, variable or literal or parenthesized, indexed or dotted into,
  // or vanilla.
  exports.Value = Value = (function() {
    class Value extends Base {
      constructor(base, props, tag, isDefaultValue = false) {
        var ref1, ref2;
        super();
        if (!props && base instanceof Value) {
          return base;
        }
        this.base = base;
        this.properties = props || [];
        this.tag = tag;
        if (tag) {
          this[tag] = true;
        }
        this.isDefaultValue = isDefaultValue;
        // If this is a `@foo =` assignment, if there are comments on `@` move them
        // to be on `foo`.
        if (((ref1 = this.base) != null ? ref1.comments : void 0) && this.base instanceof ThisLiteral && (((ref2 = this.properties[0]) != null ? ref2.name : void 0) != null)) {
          moveComments(this.base, this.properties[0].name);
        }
      }

      // Add a property (or *properties* ) `Access` to the list.
      add(props) {
        this.properties = this.properties.concat(props);
        this.forceUpdateLocation = true;
        return this;
      }

      hasProperties() {
        return this.properties.length !== 0;
      }

      bareLiteral(type) {
        return !this.properties.length && this.base instanceof type;
      }

      // Some boolean checks for the benefit of other nodes.
      isArray() {
        return this.bareLiteral(Arr);
      }

      isRange() {
        return this.bareLiteral(Range);
      }

      shouldCache() {
        return this.hasProperties() || this.base.shouldCache();
      }

      isAssignable(opts) {
        return this.hasProperties() || this.base.isAssignable(opts);
      }

      isNumber() {
        return this.bareLiteral(NumberLiteral);
      }

      isString() {
        return this.bareLiteral(StringLiteral);
      }

      isRegex() {
        return this.bareLiteral(RegexLiteral);
      }

      isUndefined() {
        return this.bareLiteral(UndefinedLiteral);
      }

      isNull() {
        return this.bareLiteral(NullLiteral);
      }

      isBoolean() {
        return this.bareLiteral(BooleanLiteral);
      }

      isAtomic() {
        var j, len1, node, ref1;
        ref1 = this.properties.concat(this.base);
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          node = ref1[j];
          if (node.soak || node instanceof Call || node instanceof Op && node.operator === 'do') {
            return false;
          }
        }
        return true;
      }

      isNotCallable() {
        return this.isNumber() || this.isString() || this.isRegex() || this.isArray() || this.isRange() || this.isSplice() || this.isObject() || this.isUndefined() || this.isNull() || this.isBoolean();
      }

      isStatement(o) {
        return !this.properties.length && this.base.isStatement(o);
      }

      isJSXTag() {
        return this.base instanceof JSXTag;
      }

      assigns(name) {
        return !this.properties.length && this.base.assigns(name);
      }

      jumps(o) {
        return !this.properties.length && this.base.jumps(o);
      }

      isObject(onlyGenerated) {
        if (this.properties.length) {
          return false;
        }
        return (this.base instanceof Obj) && (!onlyGenerated || this.base.generated);
      }

      isElision() {
        if (!(this.base instanceof Arr)) {
          return false;
        }
        return this.base.hasElision();
      }

      isSplice() {
        var lastProperty, ref1;
        ref1 = this.properties, [lastProperty] = slice1.call(ref1, -1);
        return lastProperty instanceof Slice;
      }

      looksStatic(className) {
        var name, ref1, thisLiteral;
        if (!(((thisLiteral = this.base) instanceof ThisLiteral || (name = this.base).value === className) && this.properties.length === 1 && ((ref1 = this.properties[0].name) != null ? ref1.value : void 0) !== 'prototype')) {
          return false;
        }
        return {
          staticClassName: thisLiteral != null ? thisLiteral : name
        };
      }

      // The value can be unwrapped as its inner node, if there are no attached
      // properties.
      unwrap() {
        if (this.properties.length) {
          return this;
        } else {
          return this.base;
        }
      }

      // A reference has base part (`this` value) and name part.
      // We cache them separately for compiling complex expressions.
      // `a()[b()] ?= c` -> `(_base = a())[_name = b()] ? _base[_name] = c`
      cacheReference(o) {
        var base, bref, name, nref, ref1;
        ref1 = this.properties, [name] = slice1.call(ref1, -1);
        if (this.properties.length < 2 && !this.base.shouldCache() && !(name != null ? name.shouldCache() : void 0)) {
          return [this, this]; // `a` `a.b`
        }
        base = new Value(this.base, this.properties.slice(0, -1));
        if (base.shouldCache()) { // `a().b`
          bref = new IdentifierLiteral(o.scope.freeVariable('base'));
          base = new Value(new Parens(new Assign(bref, base)));
        }
        if (!name) { // `a()`
          return [base, bref];
        }
        if (name.shouldCache()) { // `a[b()]`
          nref = new IdentifierLiteral(o.scope.freeVariable('name'));
          name = new Index(new Assign(nref, name.index));
          nref = new Index(nref);
        }
        return [base.add(name), new Value(bref || base.base, [nref || name])];
      }

      // We compile a value to JavaScript by compiling and joining each property.
      // Things get much more interesting if the chain of properties has *soak*
      // operators `?.` interspersed. Then we have to take care not to accidentally
      // evaluate anything twice when building the soak chain.
      compileNode(o) {
        var fragments, j, len1, prop, props;
        this.base.front = this.front;
        props = this.properties;
        if (props.length && (this.base.cached != null)) {
          // Cached fragments enable correct order of the compilation,
          // and reuse of variables in the scope.
          // Example:
          // `a(x = 5).b(-> x = 6)` should compile in the same order as
          // `a(x = 5); b(-> x = 6)`
          // (see issue #4437, https://github.com/jashkenas/coffeescript/issues/4437)
          fragments = this.base.cached;
        } else {
          fragments = this.base.compileToFragments(o, (props.length ? LEVEL_ACCESS : null));
        }
        if (props.length && SIMPLENUM.test(fragmentsToText(fragments))) {
          fragments.push(this.makeCode('.'));
        }
        for (j = 0, len1 = props.length; j < len1; j++) {
          prop = props[j];
          fragments.push(...(prop.compileToFragments(o)));
        }
        return fragments;
      }

      // Unfold a soak into an `If`: `a?.b` -> `a.b if a?`
      unfoldSoak(o) {
        return this.unfoldedSoak != null ? this.unfoldedSoak : this.unfoldedSoak = (() => {
          var fst, i, ifn, j, len1, prop, ref, ref1, snd;
          ifn = this.base.unfoldSoak(o);
          if (ifn) {
            ifn.body.properties.push(...this.properties);
            return ifn;
          }
          ref1 = this.properties;
          for (i = j = 0, len1 = ref1.length; j < len1; i = ++j) {
            prop = ref1[i];
            if (!prop.soak) {
              continue;
            }
            prop.soak = false;
            fst = new Value(this.base, this.properties.slice(0, i));
            snd = new Value(this.base, this.properties.slice(i));
            if (fst.shouldCache()) {
              ref = new IdentifierLiteral(o.scope.freeVariable('ref'));
              fst = new Parens(new Assign(ref, fst));
              snd.base = ref;
            }
            return new If(new Existence(fst), snd, {
              soak: true
            });
          }
          return false;
        })();
      }

      eachName(iterator, {checkAssignability = true} = {}) {
        if (this.hasProperties()) {
          return iterator(this);
        } else if (!checkAssignability || this.base.isAssignable()) {
          return this.base.eachName(iterator);
        } else {
          return this.error('tried to assign to unassignable value');
        }
      }

      // For AST generation, we need an `object` that’s this `Value` minus its last
      // property, if it has properties.
      object() {
        var initialProperties, object;
        if (!this.hasProperties()) {
          return this;
        }
        // Get all properties except the last one; for a `Value` with only one
        // property, `initialProperties` is an empty array.
        initialProperties = this.properties.slice(0, this.properties.length - 1);
        // Create the `object` that becomes the new “base” for the split-off final
        // property.
        object = new Value(this.base, initialProperties, this.tag, this.isDefaultValue);
        // Add location data to our new node, so that it has correct location data
        // for source maps or later conversion into AST location data.
        // This new `Value` has only one property, so the location data is just
        // that of the parent `Value`’s base.
        // This new `Value` has multiple properties, so the location data spans
        // from the parent `Value`’s base to the last property that’s included
        // in this new node (a.k.a. the second-to-last property of the parent).
        object.locationData = initialProperties.length === 0 ? this.base.locationData : mergeLocationData(this.base.locationData, initialProperties[initialProperties.length - 1].locationData);
        return object;
      }

      containsSoak() {
        var j, len1, property, ref1;
        if (!this.hasProperties()) {
          return false;
        }
        ref1 = this.properties;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          property = ref1[j];
          if (property.soak) {
            return true;
          }
        }
        if (this.base instanceof Call && this.base.soak) {
          return true;
        }
        return false;
      }

      astNode(o) {
        if (!this.hasProperties()) {
          // If the `Value` has no properties, the AST node is just whatever this
          // node’s `base` is.
          return this.base.ast(o);
        }
        // Otherwise, call `Base::ast` which in turn calls the `astType` and
        // `astProperties` methods below.
        return super.astNode(o);
      }

      astType() {
        if (this.isJSXTag()) {
          return 'JSXMemberExpression';
        } else if (this.containsSoak()) {
          return 'OptionalMemberExpression';
        } else {
          return 'MemberExpression';
        }
      }

      // If this `Value` has properties, the *last* property (e.g. `c` in `a.b.c`)
      // becomes the `property`, and the preceding properties (e.g. `a.b`) become
      // a child `Value` node assigned to the `object` property.
      astProperties(o) {
        var computed, property, ref1, ref2;
        ref1 = this.properties, [property] = slice1.call(ref1, -1);
        if (this.isJSXTag()) {
          property.name.jsx = true;
        }
        computed = property instanceof Index || !(((ref2 = property.name) != null ? ref2.unwrap() : void 0) instanceof PropertyName);
        return {
          object: this.object().ast(o, LEVEL_ACCESS),
          property: property.ast(o, (computed ? LEVEL_PAREN : void 0)),
          computed,
          optional: !!property.soak,
          shorthand: !!property.shorthand
        };
      }

      astLocationData() {
        if (!this.isJSXTag()) {
          return super.astLocationData();
        }
        // don't include leading < of JSX tag in location data
        return mergeAstLocationData(jisonLocationDataToAstLocationData(this.base.tagNameLocationData), jisonLocationDataToAstLocationData(this.properties[this.properties.length - 1].locationData));
      }

    };

    Value.prototype.children = ['base', 'properties'];

    return Value;

  }).call(this);

  exports.MetaProperty = MetaProperty = (function() {
    class MetaProperty extends Base {
      constructor(meta, property1) {
        super();
        this.meta = meta;
        this.property = property1;
      }

      checkValid(o) {
        if (this.meta.value === 'new') {
          if (this.property instanceof Access && this.property.name.value === 'target') {
            if (o.scope.parent == null) {
              return this.error("new.target can only occur inside functions");
            }
          } else {
            return this.error("the only valid meta property for new is new.target");
          }
        } else if (this.meta.value === 'import') {
          if (!(this.property instanceof Access && this.property.name.value === 'meta')) {
            return this.error("the only valid meta property for import is import.meta");
          }
        }
      }

      compileNode(o) {
        var fragments;
        this.checkValid(o);
        fragments = [];
        fragments.push(...this.meta.compileToFragments(o, LEVEL_ACCESS));
        fragments.push(...this.property.compileToFragments(o));
        return fragments;
      }

      astProperties(o) {
        this.checkValid(o);
        return {
          meta: this.meta.ast(o, LEVEL_ACCESS),
          property: this.property.ast(o)
        };
      }

    };

    MetaProperty.prototype.children = ['meta', 'property'];

    return MetaProperty;

  }).call(this);

  //### HereComment

  // Comment delimited by `###` (becoming `/* */`).
  exports.HereComment = HereComment = class HereComment extends Base {
    constructor({
        content: content1,
        newLine,
        unshift,
        locationData: locationData1
      }) {
      super();
      this.content = content1;
      this.newLine = newLine;
      this.unshift = unshift;
      this.locationData = locationData1;
    }

    compileNode(o) {
      var fragment, hasLeadingMarks, indent, j, leadingWhitespace, len1, line, multiline, ref1;
      multiline = indexOf.call(this.content, '\n') >= 0;
      // Unindent multiline comments. They will be reindented later.
      if (multiline) {
        indent = null;
        ref1 = this.content.split('\n');
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          line = ref1[j];
          leadingWhitespace = /^\s*/.exec(line)[0];
          if (!indent || leadingWhitespace.length < indent.length) {
            indent = leadingWhitespace;
          }
        }
        if (indent) {
          this.content = this.content.replace(RegExp(`\\n${indent}`, "g"), '\n');
        }
      }
      hasLeadingMarks = /\n\s*[#|\*]/.test(this.content);
      if (hasLeadingMarks) {
        this.content = this.content.replace(/^([ \t]*)#(?=\s)/gm, ' *');
      }
      this.content = `/*${this.content}${hasLeadingMarks ? ' ' : ''}*/`;
      fragment = this.makeCode(this.content);
      fragment.newLine = this.newLine;
      fragment.unshift = this.unshift;
      fragment.multiline = multiline;
      // Don’t rely on `fragment.type`, which can break when the compiler is minified.
      fragment.isComment = fragment.isHereComment = true;
      return fragment;
    }

    astType() {
      return 'CommentBlock';
    }

    astProperties() {
      return {
        value: this.content
      };
    }

  };

  //### LineComment

  // Comment running from `#` to the end of a line (becoming `//`).
  exports.LineComment = LineComment = class LineComment extends Base {
    constructor({
        content: content1,
        newLine,
        unshift,
        locationData: locationData1,
        precededByBlankLine
      }) {
      super();
      this.content = content1;
      this.newLine = newLine;
      this.unshift = unshift;
      this.locationData = locationData1;
      this.precededByBlankLine = precededByBlankLine;
    }

    compileNode(o) {
      var fragment;
      fragment = this.makeCode(/^\s*$/.test(this.content) ? '' : `${this.precededByBlankLine ? `\n${o.indent}` : ''}//${this.content}`);
      fragment.newLine = this.newLine;
      fragment.unshift = this.unshift;
      fragment.trail = !this.newLine && !this.unshift;
      // Don’t rely on `fragment.type`, which can break when the compiler is minified.
      fragment.isComment = fragment.isLineComment = true;
      return fragment;
    }

    astType() {
      return 'CommentLine';
    }

    astProperties() {
      return {
        value: this.content
      };
    }

  };

  //### JSX
  exports.JSXIdentifier = JSXIdentifier = class JSXIdentifier extends IdentifierLiteral {
    astType() {
      return 'JSXIdentifier';
    }

  };

  exports.JSXTag = JSXTag = class JSXTag extends JSXIdentifier {
    constructor(value, {tagNameLocationData, closingTagOpeningBracketLocationData, closingTagSlashLocationData, closingTagNameLocationData, closingTagClosingBracketLocationData}) {
      super(value);
      this.tagNameLocationData = tagNameLocationData;
      this.closingTagOpeningBracketLocationData = closingTagOpeningBracketLocationData;
      this.closingTagSlashLocationData = closingTagSlashLocationData;
      this.closingTagNameLocationData = closingTagNameLocationData;
      this.closingTagClosingBracketLocationData = closingTagClosingBracketLocationData;
    }

    astProperties() {
      return {
        name: this.value
      };
    }

  };

  exports.JSXExpressionContainer = JSXExpressionContainer = (function() {
    class JSXExpressionContainer extends Base {
      constructor(expression1, {locationData} = {}) {
        super();
        this.expression = expression1;
        this.expression.jsxAttribute = true;
        this.locationData = locationData != null ? locationData : this.expression.locationData;
      }

      compileNode(o) {
        return this.expression.compileNode(o);
      }

      astProperties(o) {
        return {
          expression: astAsBlockIfNeeded(this.expression, o)
        };
      }

    };

    JSXExpressionContainer.prototype.children = ['expression'];

    return JSXExpressionContainer;

  }).call(this);

  exports.JSXEmptyExpression = JSXEmptyExpression = class JSXEmptyExpression extends Base {};

  exports.JSXText = JSXText = class JSXText extends Base {
    constructor(stringLiteral) {
      super();
      this.value = stringLiteral.unquotedValueForJSX;
      this.locationData = stringLiteral.locationData;
    }

    astProperties() {
      return {
        value: this.value,
        extra: {
          raw: this.value
        }
      };
    }

  };

  exports.JSXAttribute = JSXAttribute = (function() {
    class JSXAttribute extends Base {
      constructor({
          name: name1,
          value
        }) {
        var ref1;
        super();
        this.name = name1;
        this.value = value != null ? (value = value.base, value instanceof StringLiteral && !value.shouldGenerateTemplateLiteral() ? value : new JSXExpressionContainer(value)) : null;
        if ((ref1 = this.value) != null) {
          ref1.comments = value.comments;
        }
      }

      compileNode(o) {
        var compiledName, val;
        compiledName = this.name.compileToFragments(o, LEVEL_LIST);
        if (this.value == null) {
          return compiledName;
        }
        val = this.value.compileToFragments(o, LEVEL_LIST);
        return compiledName.concat(this.makeCode('='), val);
      }

      astProperties(o) {
        var name, ref1, ref2;
        name = this.name;
        if (indexOf.call(name.value, ':') >= 0) {
          name = new JSXNamespacedName(name);
        }
        return {
          name: name.ast(o),
          value: (ref1 = (ref2 = this.value) != null ? ref2.ast(o) : void 0) != null ? ref1 : null
        };
      }

    };

    JSXAttribute.prototype.children = ['name', 'value'];

    return JSXAttribute;

  }).call(this);

  exports.JSXAttributes = JSXAttributes = (function() {
    class JSXAttributes extends Base {
      constructor(arr) {
        var attribute, base, j, k, len1, len2, object, property, ref1, ref2, value, variable;
        super();
        this.attributes = [];
        ref1 = arr.objects;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          object = ref1[j];
          this.checkValidAttribute(object);
          ({base} = object);
          if (base instanceof IdentifierLiteral) {
            // attribute with no value eg disabled
            attribute = new JSXAttribute({
              name: new JSXIdentifier(base.value).withLocationDataAndCommentsFrom(base)
            });
            attribute.locationData = base.locationData;
            this.attributes.push(attribute);
          } else if (!base.generated) {
            // object spread attribute eg {...props}
            attribute = base.properties[0];
            attribute.jsx = true;
            attribute.locationData = base.locationData;
            this.attributes.push(attribute);
          } else {
            ref2 = base.properties;
            // Obj containing attributes with values eg a="b" c={d}
            for (k = 0, len2 = ref2.length; k < len2; k++) {
              property = ref2[k];
              ({variable, value} = property);
              attribute = new JSXAttribute({
                name: new JSXIdentifier(variable.base.value).withLocationDataAndCommentsFrom(variable.base),
                value
              });
              attribute.locationData = property.locationData;
              this.attributes.push(attribute);
            }
          }
        }
        this.locationData = arr.locationData;
      }

      // Catch invalid attributes: <div {a:"b", props} {props} "value" />
      checkValidAttribute(object) {
        var attribute, properties;
        ({
          base: attribute
        } = object);
        properties = (attribute != null ? attribute.properties : void 0) || [];
        if (!(attribute instanceof Obj || attribute instanceof IdentifierLiteral) || (attribute instanceof Obj && !attribute.generated && (properties.length > 1 || !(properties[0] instanceof Splat)))) {
          return object.error(`Unexpected token. Allowed JSX attributes are: id="val", src={source}, {props...} or attribute.`);
        }
      }

      compileNode(o) {
        var attribute, fragments, j, len1, ref1;
        fragments = [];
        ref1 = this.attributes;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          attribute = ref1[j];
          fragments.push(this.makeCode(' '));
          fragments.push(...attribute.compileToFragments(o, LEVEL_TOP));
        }
        return fragments;
      }

      astNode(o) {
        var attribute, j, len1, ref1, results1;
        ref1 = this.attributes;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          attribute = ref1[j];
          results1.push(attribute.ast(o));
        }
        return results1;
      }

    };

    JSXAttributes.prototype.children = ['attributes'];

    return JSXAttributes;

  }).call(this);

  exports.JSXNamespacedName = JSXNamespacedName = (function() {
    class JSXNamespacedName extends Base {
      constructor(tag) {
        var name, namespace;
        super();
        [namespace, name] = tag.value.split(':');
        this.namespace = new JSXIdentifier(namespace).withLocationDataFrom({
          locationData: extractSameLineLocationDataFirst(namespace.length)(tag.locationData)
        });
        this.name = new JSXIdentifier(name).withLocationDataFrom({
          locationData: extractSameLineLocationDataLast(name.length)(tag.locationData)
        });
        this.locationData = tag.locationData;
      }

      astProperties(o) {
        return {
          namespace: this.namespace.ast(o),
          name: this.name.ast(o)
        };
      }

    };

    JSXNamespacedName.prototype.children = ['namespace', 'name'];

    return JSXNamespacedName;

  }).call(this);

  // Node for a JSX element
  exports.JSXElement = JSXElement = (function() {
    class JSXElement extends Base {
      constructor({
          tagName: tagName1,
          attributes,
          content: content1
        }) {
        super();
        this.tagName = tagName1;
        this.attributes = attributes;
        this.content = content1;
      }

      compileNode(o) {
        var fragments, ref1, tag;
        if ((ref1 = this.content) != null) {
          ref1.base.jsx = true;
        }
        fragments = [this.makeCode('<')];
        fragments.push(...(tag = this.tagName.compileToFragments(o, LEVEL_ACCESS)));
        fragments.push(...this.attributes.compileToFragments(o));
        if (this.content) {
          fragments.push(this.makeCode('>'));
          fragments.push(...this.content.compileNode(o, LEVEL_LIST));
          fragments.push(...[this.makeCode('</'), ...tag, this.makeCode('>')]);
        } else {
          fragments.push(this.makeCode(' />'));
        }
        return fragments;
      }

      isFragment() {
        return !this.tagName.base.value.length;
      }

      astNode(o) {
        var tagName;
        // The location data spanning the opening element < ... > is captured by
        // the generated Arr which contains the element's attributes
        this.openingElementLocationData = jisonLocationDataToAstLocationData(this.attributes.locationData);
        tagName = this.tagName.base;
        tagName.locationData = tagName.tagNameLocationData;
        if (this.content != null) {
          this.closingElementLocationData = mergeAstLocationData(jisonLocationDataToAstLocationData(tagName.closingTagOpeningBracketLocationData), jisonLocationDataToAstLocationData(tagName.closingTagClosingBracketLocationData));
        }
        return super.astNode(o);
      }

      astType() {
        if (this.isFragment()) {
          return 'JSXFragment';
        } else {
          return 'JSXElement';
        }
      }

      elementAstProperties(o) {
        var closingElement, columnDiff, currentExpr, openingElement, rangeDiff, ref1, shiftAstLocationData, tagNameAst;
        tagNameAst = () => {
          var tag;
          tag = this.tagName.unwrap();
          if ((tag != null ? tag.value : void 0) && indexOf.call(tag.value, ':') >= 0) {
            tag = new JSXNamespacedName(tag);
          }
          return tag.ast(o);
        };
        openingElement = Object.assign({
          type: 'JSXOpeningElement',
          name: tagNameAst(),
          selfClosing: this.closingElementLocationData == null,
          attributes: this.attributes.ast(o)
        }, this.openingElementLocationData);
        closingElement = null;
        if (this.closingElementLocationData != null) {
          closingElement = Object.assign({
            type: 'JSXClosingElement',
            name: Object.assign(tagNameAst(), jisonLocationDataToAstLocationData(this.tagName.base.closingTagNameLocationData))
          }, this.closingElementLocationData);
          if ((ref1 = closingElement.name.type) === 'JSXMemberExpression' || ref1 === 'JSXNamespacedName') {
            rangeDiff = closingElement.range[0] - openingElement.range[0] + '/'.length;
            columnDiff = closingElement.loc.start.column - openingElement.loc.start.column + '/'.length;
            shiftAstLocationData = (node) => {
              node.range = [node.range[0] + rangeDiff, node.range[1] + rangeDiff];
              node.start += rangeDiff;
              node.end += rangeDiff;
              node.loc.start = {
                line: this.closingElementLocationData.loc.start.line,
                column: node.loc.start.column + columnDiff
              };
              return node.loc.end = {
                line: this.closingElementLocationData.loc.start.line,
                column: node.loc.end.column + columnDiff
              };
            };
            if (closingElement.name.type === 'JSXMemberExpression') {
              currentExpr = closingElement.name;
              while (currentExpr.type === 'JSXMemberExpression') {
                if (currentExpr !== closingElement.name) {
                  shiftAstLocationData(currentExpr);
                }
                shiftAstLocationData(currentExpr.property);
                currentExpr = currentExpr.object;
              }
              shiftAstLocationData(currentExpr); // JSXNamespacedName
            } else {
              shiftAstLocationData(closingElement.name.namespace);
              shiftAstLocationData(closingElement.name.name);
            }
          }
        }
        return {openingElement, closingElement};
      }

      fragmentAstProperties(o) {
        var closingFragment, openingFragment;
        openingFragment = Object.assign({
          type: 'JSXOpeningFragment'
        }, this.openingElementLocationData);
        closingFragment = Object.assign({
          type: 'JSXClosingFragment'
        }, this.closingElementLocationData);
        return {openingFragment, closingFragment};
      }

      contentAst(o) {
        var base1, child, children, content, element, emptyExpression, expression, j, len1, results1, unwrapped;
        if (!(this.content && !(typeof (base1 = this.content.base).isEmpty === "function" ? base1.isEmpty() : void 0))) {
          return [];
        }
        content = this.content.unwrapAll();
        children = (function() {
          var j, len1, ref1, results1;
          if (content instanceof StringLiteral) {
            return [new JSXText(content)]; // StringWithInterpolations
          } else {
            ref1 = this.content.unwrapAll().extractElements(o, {
              includeInterpolationWrappers: true,
              isJsx: true
            });
            results1 = [];
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              element = ref1[j];
              if (element instanceof StringLiteral) {
                results1.push(new JSXText(element)); // Interpolation
              } else {
                ({expression} = element);
                if (expression == null) {
                  emptyExpression = new JSXEmptyExpression();
                  emptyExpression.locationData = emptyExpressionLocationData({
                    interpolationNode: element,
                    openingBrace: '{',
                    closingBrace: '}'
                  });
                  results1.push(new JSXExpressionContainer(emptyExpression, {
                    locationData: element.locationData
                  }));
                } else {
                  unwrapped = expression.unwrapAll();
                  // distinguish `<a><b /></a>` from `<a>{<b />}</a>`
                  if (unwrapped instanceof JSXElement && unwrapped.locationData.range[0] === element.locationData.range[0]) {
                    results1.push(unwrapped);
                  } else {
                    results1.push(new JSXExpressionContainer(unwrapped, {
                      locationData: element.locationData
                    }));
                  }
                }
              }
            }
            return results1;
          }
        }).call(this);
        results1 = [];
        for (j = 0, len1 = children.length; j < len1; j++) {
          child = children[j];
          if (!(child instanceof JSXText && child.value.length === 0)) {
            results1.push(child.ast(o));
          }
        }
        return results1;
      }

      astProperties(o) {
        return Object.assign(this.isFragment() ? this.fragmentAstProperties(o) : this.elementAstProperties(o), {
          children: this.contentAst(o)
        });
      }

      astLocationData() {
        if (this.closingElementLocationData != null) {
          return mergeAstLocationData(this.openingElementLocationData, this.closingElementLocationData);
        } else {
          return this.openingElementLocationData;
        }
      }

    };

    JSXElement.prototype.children = ['tagName', 'attributes', 'content'];

    return JSXElement;

  }).call(this);

  //### Call

  // Node for a function invocation.
  exports.Call = Call = (function() {
    class Call extends Base {
      constructor(variable1, args1 = [], soak1, token1) {
        var ref1;
        super();
        this.variable = variable1;
        this.args = args1;
        this.soak = soak1;
        this.token = token1;
        this.implicit = this.args.implicit;
        this.isNew = false;
        if (this.variable instanceof Value && this.variable.isNotCallable()) {
          this.variable.error("literal is not a function");
        }
        if (this.variable.base instanceof JSXTag) {
          return new JSXElement({
            tagName: this.variable,
            attributes: new JSXAttributes(this.args[0].base),
            content: this.args[1]
          });
        }
        // `@variable` never gets output as a result of this node getting created as
        // part of `RegexWithInterpolations`, so for that case move any comments to
        // the `args` property that gets passed into `RegexWithInterpolations` via
        // the grammar.
        if (((ref1 = this.variable.base) != null ? ref1.value : void 0) === 'RegExp' && this.args.length !== 0) {
          moveComments(this.variable, this.args[0]);
        }
      }

      // When setting the location, we sometimes need to update the start location to
      // account for a newly-discovered `new` operator to the left of us. This
      // expands the range on the left, but not the right.
      updateLocationDataIfMissing(locationData) {
        var base, ref1;
        if (this.locationData && this.needsUpdatedStartLocation) {
          this.locationData = Object.assign({}, this.locationData, {
            first_line: locationData.first_line,
            first_column: locationData.first_column,
            range: [locationData.range[0], this.locationData.range[1]]
          });
          base = ((ref1 = this.variable) != null ? ref1.base : void 0) || this.variable;
          if (base.needsUpdatedStartLocation) {
            this.variable.locationData = Object.assign({}, this.variable.locationData, {
              first_line: locationData.first_line,
              first_column: locationData.first_column,
              range: [locationData.range[0], this.variable.locationData.range[1]]
            });
            base.updateLocationDataIfMissing(locationData);
          }
          delete this.needsUpdatedStartLocation;
        }
        return super.updateLocationDataIfMissing(locationData);
      }

      // Tag this invocation as creating a new instance.
      newInstance() {
        var base, ref1;
        base = ((ref1 = this.variable) != null ? ref1.base : void 0) || this.variable;
        if (base instanceof Call && !base.isNew) {
          base.newInstance();
        } else {
          this.isNew = true;
        }
        this.needsUpdatedStartLocation = true;
        return this;
      }

      // Soaked chained invocations unfold into if/else ternary structures.
      unfoldSoak(o) {
        var call, ifn, j, left, len1, list, ref1, rite;
        if (this.soak) {
          if (this.variable instanceof Super) {
            left = new Literal(this.variable.compile(o));
            rite = new Value(left);
            if (this.variable.accessor == null) {
              this.variable.error("Unsupported reference to 'super'");
            }
          } else {
            if (ifn = unfoldSoak(o, this, 'variable')) {
              return ifn;
            }
            [left, rite] = new Value(this.variable).cacheReference(o);
          }
          rite = new Call(rite, this.args);
          rite.isNew = this.isNew;
          left = new Literal(`typeof ${left.compile(o)} === \"function\"`);
          return new If(left, new Value(rite), {
            soak: true
          });
        }
        call = this;
        list = [];
        while (true) {
          if (call.variable instanceof Call) {
            list.push(call);
            call = call.variable;
            continue;
          }
          if (!(call.variable instanceof Value)) {
            break;
          }
          list.push(call);
          if (!((call = call.variable.base) instanceof Call)) {
            break;
          }
        }
        ref1 = list.reverse();
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          call = ref1[j];
          if (ifn) {
            if (call.variable instanceof Call) {
              call.variable = ifn;
            } else {
              call.variable.base = ifn;
            }
          }
          ifn = unfoldSoak(o, call, 'variable');
        }
        return ifn;
      }

      // Compile a vanilla function call.
      compileNode(o) {
        var arg, argCode, argIndex, cache, compiledArgs, fragments, j, len1, ref1, ref2, ref3, ref4, varAccess;
        this.checkForNewSuper();
        if ((ref1 = this.variable) != null) {
          ref1.front = this.front;
        }
        compiledArgs = [];
        // If variable is `Accessor` fragments are cached and used later
        // in `Value::compileNode` to ensure correct order of the compilation,
        // and reuse of variables in the scope.
        // Example:
        // `a(x = 5).b(-> x = 6)` should compile in the same order as
        // `a(x = 5); b(-> x = 6)`
        // (see issue #4437, https://github.com/jashkenas/coffeescript/issues/4437)
        varAccess = ((ref2 = this.variable) != null ? (ref3 = ref2.properties) != null ? ref3[0] : void 0 : void 0) instanceof Access;
        argCode = (function() {
          var j, len1, ref4, results1;
          ref4 = this.args || [];
          results1 = [];
          for (j = 0, len1 = ref4.length; j < len1; j++) {
            arg = ref4[j];
            if (arg instanceof Code) {
              results1.push(arg);
            }
          }
          return results1;
        }).call(this);
        if (argCode.length > 0 && varAccess && !this.variable.base.cached) {
          [cache] = this.variable.base.cache(o, LEVEL_ACCESS, function() {
            return false;
          });
          this.variable.base.cached = cache;
        }
        ref4 = this.args;
        for (argIndex = j = 0, len1 = ref4.length; j < len1; argIndex = ++j) {
          arg = ref4[argIndex];
          if (argIndex) {
            compiledArgs.push(this.makeCode(", "));
          }
          compiledArgs.push(...(arg.compileToFragments(o, LEVEL_LIST)));
        }
        fragments = [];
        if (this.isNew) {
          fragments.push(this.makeCode('new '));
        }
        fragments.push(...this.variable.compileToFragments(o, LEVEL_ACCESS));
        fragments.push(this.makeCode('('), ...compiledArgs, this.makeCode(')'));
        return fragments;
      }

      checkForNewSuper() {
        if (this.isNew) {
          if (this.variable instanceof Super) {
            return this.variable.error("Unsupported reference to 'super'");
          }
        }
      }

      containsSoak() {
        var ref1;
        if (this.soak) {
          return true;
        }
        if ((ref1 = this.variable) != null ? typeof ref1.containsSoak === "function" ? ref1.containsSoak() : void 0 : void 0) {
          return true;
        }
        return false;
      }

      astNode(o) {
        var ref1;
        if (this.soak && this.variable instanceof Super && ((ref1 = o.scope.namedMethod()) != null ? ref1.ctor : void 0)) {
          this.variable.error("Unsupported reference to 'super'");
        }
        this.checkForNewSuper();
        return super.astNode(o);
      }

      astType() {
        if (this.isNew) {
          return 'NewExpression';
        } else if (this.containsSoak()) {
          return 'OptionalCallExpression';
        } else {
          return 'CallExpression';
        }
      }

      astProperties(o) {
        var arg;
        return {
          callee: this.variable.ast(o, LEVEL_ACCESS),
          arguments: (function() {
            var j, len1, ref1, results1;
            ref1 = this.args;
            results1 = [];
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              arg = ref1[j];
              results1.push(arg.ast(o, LEVEL_LIST));
            }
            return results1;
          }).call(this),
          optional: !!this.soak,
          implicit: !!this.implicit
        };
      }

    };

    Call.prototype.children = ['variable', 'args'];

    return Call;

  }).call(this);

  //### Super

  // Takes care of converting `super()` calls into calls against the prototype's
  // function of the same name.
  // When `expressions` are set the call will be compiled in such a way that the
  // expressions are evaluated without altering the return value of the `SuperCall`
  // expression.
  exports.SuperCall = SuperCall = (function() {
    class SuperCall extends Call {
      isStatement(o) {
        var ref1;
        return ((ref1 = this.expressions) != null ? ref1.length : void 0) && o.level === LEVEL_TOP;
      }

      compileNode(o) {
        var ref, ref1, replacement, superCall;
        if (!((ref1 = this.expressions) != null ? ref1.length : void 0)) {
          return super.compileNode(o);
        }
        superCall = new Literal(fragmentsToText(super.compileNode(o)));
        replacement = new Block(this.expressions.slice());
        if (o.level > LEVEL_TOP) {
          // If we might be in an expression we need to cache and return the result
          [superCall, ref] = superCall.cache(o, null, YES);
          replacement.push(ref);
        }
        replacement.unshift(superCall);
        return replacement.compileToFragments(o, o.level === LEVEL_TOP ? o.level : LEVEL_LIST);
      }

    };

    SuperCall.prototype.children = Call.prototype.children.concat(['expressions']);

    return SuperCall;

  }).call(this);

  exports.Super = Super = (function() {
    class Super extends Base {
      constructor(accessor, superLiteral) {
        super();
        this.accessor = accessor;
        this.superLiteral = superLiteral;
      }

      compileNode(o) {
        var fragments, method, name, nref, ref1, ref2, salvagedComments, variable;
        this.checkInInstanceMethod(o);
        method = o.scope.namedMethod();
        if (!((method.ctor != null) || (this.accessor != null))) {
          ({name, variable} = method);
          if (name.shouldCache() || (name instanceof Index && name.index.isAssignable())) {
            nref = new IdentifierLiteral(o.scope.parent.freeVariable('name'));
            name.index = new Assign(nref, name.index);
          }
          this.accessor = nref != null ? new Index(nref) : name;
        }
        if ((ref1 = this.accessor) != null ? (ref2 = ref1.name) != null ? ref2.comments : void 0 : void 0) {
          // A `super()` call gets compiled to e.g. `super.method()`, which means
          // the `method` property name gets compiled for the first time here, and
          // again when the `method:` property of the class gets compiled. Since
          // this compilation happens first, comments attached to `method:` would
          // get incorrectly output near `super.method()`, when we want them to
          // get output on the second pass when `method:` is output. So set them
          // aside during this compilation pass, and put them back on the object so
          // that they’re there for the later compilation.
          salvagedComments = this.accessor.name.comments;
          delete this.accessor.name.comments;
        }
        fragments = (new Value(new Literal('super'), this.accessor ? [this.accessor] : [])).compileToFragments(o);
        if (salvagedComments) {
          attachCommentsToNode(salvagedComments, this.accessor.name);
        }
        return fragments;
      }

      checkInInstanceMethod(o) {
        var method;
        method = o.scope.namedMethod();
        if (!(method != null ? method.isMethod : void 0)) {
          return this.error('cannot use super outside of an instance method');
        }
      }

      astNode(o) {
        var ref1;
        this.checkInInstanceMethod(o);
        if (this.accessor != null) {
          return (new Value(new Super().withLocationDataFrom((ref1 = this.superLiteral) != null ? ref1 : this), [this.accessor]).withLocationDataFrom(this)).ast(o);
        }
        return super.astNode(o);
      }

    };

    Super.prototype.children = ['accessor'];

    return Super;

  }).call(this);

  //### RegexWithInterpolations

  // Regexes with interpolations are in fact just a variation of a `Call` (a
  // `RegExp()` call to be precise) with a `StringWithInterpolations` inside.
  exports.RegexWithInterpolations = RegexWithInterpolations = (function() {
    class RegexWithInterpolations extends Base {
      constructor(call1, {heregexCommentTokens: heregexCommentTokens = []} = {}) {
        super();
        this.call = call1;
        this.heregexCommentTokens = heregexCommentTokens;
      }

      compileNode(o) {
        return this.call.compileNode(o);
      }

      astType() {
        return 'InterpolatedRegExpLiteral';
      }

      astProperties(o) {
        var heregexCommentToken, ref1, ref2;
        return {
          interpolatedPattern: this.call.args[0].ast(o),
          flags: (ref1 = (ref2 = this.call.args[1]) != null ? ref2.unwrap().originalValue : void 0) != null ? ref1 : '',
          comments: (function() {
            var j, len1, ref3, results1;
            ref3 = this.heregexCommentTokens;
            results1 = [];
            for (j = 0, len1 = ref3.length; j < len1; j++) {
              heregexCommentToken = ref3[j];
              if (heregexCommentToken.here) {
                results1.push(new HereComment(heregexCommentToken).ast(o));
              } else {
                results1.push(new LineComment(heregexCommentToken).ast(o));
              }
            }
            return results1;
          }).call(this)
        };
      }

    };

    RegexWithInterpolations.prototype.children = ['call'];

    return RegexWithInterpolations;

  }).call(this);

  //### TaggedTemplateCall
  exports.TaggedTemplateCall = TaggedTemplateCall = class TaggedTemplateCall extends Call {
    constructor(variable, arg, soak) {
      if (arg instanceof StringLiteral) {
        arg = StringWithInterpolations.fromStringLiteral(arg);
      }
      super(variable, [arg], soak);
    }

    compileNode(o) {
      return this.variable.compileToFragments(o, LEVEL_ACCESS).concat(this.args[0].compileToFragments(o, LEVEL_LIST));
    }

    astType() {
      return 'TaggedTemplateExpression';
    }

    astProperties(o) {
      return {
        tag: this.variable.ast(o, LEVEL_ACCESS),
        quasi: this.args[0].ast(o, LEVEL_LIST)
      };
    }

  };

  //### Extends

  // Node to extend an object's prototype with an ancestor object.
  // After `goog.inherits` from the
  // [Closure Library](https://github.com/google/closure-library/blob/master/closure/goog/base.js).
  exports.Extends = Extends = (function() {
    class Extends extends Base {
      constructor(child1, parent1) {
        super();
        this.child = child1;
        this.parent = parent1;
      }

      // Hooks one constructor into another's prototype chain.
      compileToFragments(o) {
        return new Call(new Value(new Literal(utility('extend', o))), [this.child, this.parent]).compileToFragments(o);
      }

    };

    Extends.prototype.children = ['child', 'parent'];

    return Extends;

  }).call(this);

  //### Access

  // A `.` access into a property of a value, or the `::` shorthand for
  // an access into the object's prototype.
  exports.Access = Access = (function() {
    class Access extends Base {
      constructor(name1, {
          soak: soak1,
          shorthand
        } = {}) {
        super();
        this.name = name1;
        this.soak = soak1;
        this.shorthand = shorthand;
      }

      compileToFragments(o) {
        var name, node;
        name = this.name.compileToFragments(o);
        node = this.name.unwrap();
        if (node instanceof PropertyName) {
          return [this.makeCode('.'), ...name];
        } else {
          return [this.makeCode('['), ...name, this.makeCode(']')];
        }
      }

      astNode(o) {
        // Babel doesn’t have an AST node for `Access`, but rather just includes
        // this Access node’s child `name` Identifier node as the `property` of
        // the `MemberExpression` node.
        return this.name.ast(o);
      }

    };

    Access.prototype.children = ['name'];

    Access.prototype.shouldCache = NO;

    return Access;

  }).call(this);

  //### Index

  // A `[ ... ]` indexed access into an array or object.
  exports.Index = Index = (function() {
    class Index extends Base {
      constructor(index1) {
        super();
        this.index = index1;
      }

      compileToFragments(o) {
        return [].concat(this.makeCode("["), this.index.compileToFragments(o, LEVEL_PAREN), this.makeCode("]"));
      }

      shouldCache() {
        return this.index.shouldCache();
      }

      astNode(o) {
        // Babel doesn’t have an AST node for `Index`, but rather just includes
        // this Index node’s child `index` Identifier node as the `property` of
        // the `MemberExpression` node. The fact that the `MemberExpression`’s
        // `property` is an Index means that `computed` is `true` for the
        // `MemberExpression`.
        return this.index.ast(o);
      }

    };

    Index.prototype.children = ['index'];

    return Index;

  }).call(this);

  //### Range

  // A range literal. Ranges can be used to extract portions (slices) of arrays,
  // to specify a range for comprehensions, or as a value, to be expanded into the
  // corresponding array of integers at runtime.
  exports.Range = Range = (function() {
    class Range extends Base {
      constructor(from1, to1, tag) {
        super();
        this.from = from1;
        this.to = to1;
        this.exclusive = tag === 'exclusive';
        this.equals = this.exclusive ? '' : '=';
      }

      // Compiles the range's source variables -- where it starts and where it ends.
      // But only if they need to be cached to avoid double evaluation.
      compileVariables(o) {
        var shouldCache, step;
        o = merge(o, {
          top: true
        });
        shouldCache = del(o, 'shouldCache');
        [this.fromC, this.fromVar] = this.cacheToCodeFragments(this.from.cache(o, LEVEL_LIST, shouldCache));
        [this.toC, this.toVar] = this.cacheToCodeFragments(this.to.cache(o, LEVEL_LIST, shouldCache));
        if (step = del(o, 'step')) {
          [this.step, this.stepVar] = this.cacheToCodeFragments(step.cache(o, LEVEL_LIST, shouldCache));
        }
        this.fromNum = this.from.isNumber() ? parseNumber(this.fromVar) : null;
        this.toNum = this.to.isNumber() ? parseNumber(this.toVar) : null;
        return this.stepNum = (step != null ? step.isNumber() : void 0) ? parseNumber(this.stepVar) : null;
      }

      // When compiled normally, the range returns the contents of the *for loop*
      // needed to iterate over the values in the range. Used by comprehensions.
      compileNode(o) {
        var cond, condPart, from, gt, idx, idxName, known, lowerBound, lt, namedIndex, ref1, ref2, stepCond, stepNotZero, stepPart, to, upperBound, varPart;
        if (!this.fromVar) {
          this.compileVariables(o);
        }
        if (!o.index) {
          return this.compileArray(o);
        }
        // Set up endpoints.
        known = (this.fromNum != null) && (this.toNum != null);
        idx = del(o, 'index');
        idxName = del(o, 'name');
        namedIndex = idxName && idxName !== idx;
        varPart = known && !namedIndex ? `var ${idx} = ${this.fromC}` : `${idx} = ${this.fromC}`;
        if (this.toC !== this.toVar) {
          varPart += `, ${this.toC}`;
        }
        if (this.step !== this.stepVar) {
          varPart += `, ${this.step}`;
        }
        [lt, gt] = [`${idx} <${this.equals}`, `${idx} >${this.equals}`];
        // Generate the condition.
        [from, to] = [this.fromNum, this.toNum];
        // Always check if the `step` isn't zero to avoid the infinite loop.
        stepNotZero = `${(ref1 = this.stepNum) != null ? ref1 : this.stepVar} !== 0`;
        stepCond = `${(ref2 = this.stepNum) != null ? ref2 : this.stepVar} > 0`;
        lowerBound = `${lt} ${known ? to : this.toVar}`;
        upperBound = `${gt} ${known ? to : this.toVar}`;
        condPart = this.step != null ? (this.stepNum != null) && this.stepNum !== 0 ? this.stepNum > 0 ? `${lowerBound}` : `${upperBound}` : `${stepNotZero} && (${stepCond} ? ${lowerBound} : ${upperBound})` : known ? `${from <= to ? lt : gt} ${to}` : `(${this.fromVar} <= ${this.toVar} ? ${lowerBound} : ${upperBound})`;
        cond = this.stepVar ? `${this.stepVar} > 0` : `${this.fromVar} <= ${this.toVar}`;
        // Generate the step.
        stepPart = this.stepVar ? `${idx} += ${this.stepVar}` : known ? namedIndex ? from <= to ? `++${idx}` : `--${idx}` : from <= to ? `${idx}++` : `${idx}--` : namedIndex ? `${cond} ? ++${idx} : --${idx}` : `${cond} ? ${idx}++ : ${idx}--`;
        if (namedIndex) {
          varPart = `${idxName} = ${varPart}`;
        }
        if (namedIndex) {
          stepPart = `${idxName} = ${stepPart}`;
        }
        // The final loop body.
        return [this.makeCode(`${varPart}; ${condPart}; ${stepPart}`)];
      }

      // When used as a value, expand the range into the equivalent array.
      compileArray(o) {
        var args, body, cond, hasArgs, i, idt, known, post, pre, range, ref1, ref2, result, vars;
        known = (this.fromNum != null) && (this.toNum != null);
        if (known && Math.abs(this.fromNum - this.toNum) <= 20) {
          range = (function() {
            var results1 = [];
            for (var j = ref1 = this.fromNum, ref2 = this.toNum; ref1 <= ref2 ? j <= ref2 : j >= ref2; ref1 <= ref2 ? j++ : j--){ results1.push(j); }
            return results1;
          }).apply(this);
          if (this.exclusive) {
            range.pop();
          }
          return [this.makeCode(`[${range.join(', ')}]`)];
        }
        idt = this.tab + TAB;
        i = o.scope.freeVariable('i', {
          single: true,
          reserve: false
        });
        result = o.scope.freeVariable('results', {
          reserve: false
        });
        pre = `\n${idt}var ${result} = [];`;
        if (known) {
          o.index = i;
          body = fragmentsToText(this.compileNode(o));
        } else {
          vars = `${i} = ${this.fromC}` + (this.toC !== this.toVar ? `, ${this.toC}` : '');
          cond = `${this.fromVar} <= ${this.toVar}`;
          body = `var ${vars}; ${cond} ? ${i} <${this.equals} ${this.toVar} : ${i} >${this.equals} ${this.toVar}; ${cond} ? ${i}++ : ${i}--`;
        }
        post = `{ ${result}.push(${i}); }\n${idt}return ${result};\n${o.indent}`;
        hasArgs = function(node) {
          return node != null ? node.contains(isLiteralArguments) : void 0;
        };
        if (hasArgs(this.from) || hasArgs(this.to)) {
          args = ', arguments';
        }
        return [this.makeCode(`(function() {${pre}\n${idt}for (${body})${post}}).apply(this${args != null ? args : ''})`)];
      }

      astProperties(o) {
        var ref1, ref2, ref3, ref4;
        return {
          from: (ref1 = (ref2 = this.from) != null ? ref2.ast(o) : void 0) != null ? ref1 : null,
          to: (ref3 = (ref4 = this.to) != null ? ref4.ast(o) : void 0) != null ? ref3 : null,
          exclusive: this.exclusive
        };
      }

    };

    Range.prototype.children = ['from', 'to'];

    return Range;

  }).call(this);

  //### Slice

  // An array slice literal. Unlike JavaScript’s `Array#slice`, the second parameter
  // specifies the index of the end of the slice, just as the first parameter
  // is the index of the beginning.
  exports.Slice = Slice = (function() {
    class Slice extends Base {
      constructor(range1) {
        super();
        this.range = range1;
      }

      // We have to be careful when trying to slice through the end of the array,
      // `9e9` is used because not all implementations respect `undefined` or `1/0`.
      // `9e9` should be safe because `9e9` > `2**32`, the max array length.
      compileNode(o) {
        var compiled, compiledText, from, fromCompiled, to, toStr;
        ({to, from} = this.range);
        // Handle an expression in the property access, e.g. `a[!b in c..]`.
        if (from != null ? from.shouldCache() : void 0) {
          from = new Value(new Parens(from));
        }
        if (to != null ? to.shouldCache() : void 0) {
          to = new Value(new Parens(to));
        }
        fromCompiled = (from != null ? from.compileToFragments(o, LEVEL_PAREN) : void 0) || [this.makeCode('0')];
        if (to) {
          compiled = to.compileToFragments(o, LEVEL_PAREN);
          compiledText = fragmentsToText(compiled);
          if (!(!this.range.exclusive && +compiledText === -1)) {
            toStr = ', ' + (this.range.exclusive ? compiledText : to.isNumber() ? `${+compiledText + 1}` : (compiled = to.compileToFragments(o, LEVEL_ACCESS), `+${fragmentsToText(compiled)} + 1 || 9e9`));
          }
        }
        return [this.makeCode(`.slice(${fragmentsToText(fromCompiled)}${toStr || ''})`)];
      }

      astNode(o) {
        return this.range.ast(o);
      }

    };

    Slice.prototype.children = ['range'];

    return Slice;

  }).call(this);

  //### Obj

  // An object literal, nothing fancy.
  exports.Obj = Obj = (function() {
    class Obj extends Base {
      constructor(props, generated = false) {
        super();
        this.generated = generated;
        this.objects = this.properties = props || [];
      }

      isAssignable(opts) {
        var j, len1, message, prop, ref1, ref2;
        ref1 = this.properties;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          prop = ref1[j];
          // Check for reserved words.
          message = isUnassignable(prop.unwrapAll().value);
          if (message) {
            prop.error(message);
          }
          if (prop instanceof Assign && prop.context === 'object' && !(((ref2 = prop.value) != null ? ref2.base : void 0) instanceof Arr)) {
            prop = prop.value;
          }
          if (!prop.isAssignable(opts)) {
            return false;
          }
        }
        return true;
      }

      shouldCache() {
        return !this.isAssignable();
      }

      // Check if object contains splat.
      hasSplat() {
        var j, len1, prop, ref1;
        ref1 = this.properties;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          prop = ref1[j];
          if (prop instanceof Splat) {
            return true;
          }
        }
        return false;
      }

      // Move rest property to the end of the list.
      // `{a, rest..., b} = obj` -> `{a, b, rest...} = obj`
      // `foo = ({a, rest..., b}) ->` -> `foo = {a, b, rest...}) ->`
      reorderProperties() {
        var props, splatProp, splatProps;
        props = this.properties;
        splatProps = this.getAndCheckSplatProps();
        splatProp = props.splice(splatProps[0], 1);
        return this.objects = this.properties = [].concat(props, splatProp);
      }

      compileNode(o) {
        var answer, i, idt, indent, isCompact, j, join, k, key, l, lastNode, len1, len2, len3, node, prop, props, ref1, value;
        if (this.hasSplat() && this.lhs) {
          this.reorderProperties();
        }
        props = this.properties;
        if (this.generated) {
          for (j = 0, len1 = props.length; j < len1; j++) {
            node = props[j];
            if (node instanceof Value) {
              node.error('cannot have an implicit value in an implicit object');
            }
          }
        }
        idt = o.indent += TAB;
        lastNode = this.lastNode(this.properties);
        // If this object is the left-hand side of an assignment, all its children
        // are too.
        this.propagateLhs();
        isCompact = true;
        ref1 = this.properties;
        for (k = 0, len2 = ref1.length; k < len2; k++) {
          prop = ref1[k];
          if (prop instanceof Assign && prop.context === 'object') {
            isCompact = false;
          }
        }
        answer = [];
        answer.push(this.makeCode(isCompact ? '' : '\n'));
        for (i = l = 0, len3 = props.length; l < len3; i = ++l) {
          prop = props[i];
          join = i === props.length - 1 ? '' : isCompact ? ', ' : prop === lastNode ? '\n' : ',\n';
          indent = isCompact ? '' : idt;
          key = prop instanceof Assign && prop.context === 'object' ? prop.variable : prop instanceof Assign ? (!this.lhs ? prop.operatorToken.error(`unexpected ${prop.operatorToken.value}`) : void 0, prop.variable) : prop;
          if (key instanceof Value && key.hasProperties()) {
            if (prop.context === 'object' || !key.this) {
              key.error('invalid object key');
            }
            key = key.properties[0].name;
            prop = new Assign(key, prop, 'object');
          }
          if (key === prop) {
            if (prop.shouldCache()) {
              [key, value] = prop.base.cache(o);
              if (key instanceof IdentifierLiteral) {
                key = new PropertyName(key.value);
              }
              prop = new Assign(key, value, 'object');
            } else if (key instanceof Value && key.base instanceof ComputedPropertyName) {
              // `{ [foo()] }` output as `{ [ref = foo()]: ref }`.
              if (prop.base.value.shouldCache()) {
                [key, value] = prop.base.value.cache(o);
                if (key instanceof IdentifierLiteral) {
                  key = new ComputedPropertyName(key.value);
                }
                prop = new Assign(key, value, 'object');
              } else {
                // `{ [expression] }` output as `{ [expression]: expression }`.
                prop = new Assign(key, prop.base.value, 'object');
              }
            } else if (!(typeof prop.bareLiteral === "function" ? prop.bareLiteral(IdentifierLiteral) : void 0) && !(prop instanceof Splat)) {
              prop = new Assign(prop, prop, 'object');
            }
          }
          if (indent) {
            answer.push(this.makeCode(indent));
          }
          answer.push(...prop.compileToFragments(o, LEVEL_TOP));
          if (join) {
            answer.push(this.makeCode(join));
          }
        }
        answer.push(this.makeCode(isCompact ? '' : `\n${this.tab}`));
        answer = this.wrapInBraces(answer);
        if (this.front) {
          return this.wrapInParentheses(answer);
        } else {
          return answer;
        }
      }

      getAndCheckSplatProps() {
        var i, prop, props, splatProps;
        if (!(this.hasSplat() && this.lhs)) {
          return;
        }
        props = this.properties;
        splatProps = (function() {
          var j, len1, results1;
          results1 = [];
          for (i = j = 0, len1 = props.length; j < len1; i = ++j) {
            prop = props[i];
            if (prop instanceof Splat) {
              results1.push(i);
            }
          }
          return results1;
        })();
        if ((splatProps != null ? splatProps.length : void 0) > 1) {
          props[splatProps[1]].error("multiple spread elements are disallowed");
        }
        return splatProps;
      }

      assigns(name) {
        var j, len1, prop, ref1;
        ref1 = this.properties;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          prop = ref1[j];
          if (prop.assigns(name)) {
            return true;
          }
        }
        return false;
      }

      eachName(iterator) {
        var j, len1, prop, ref1, results1;
        ref1 = this.properties;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          prop = ref1[j];
          if (prop instanceof Assign && prop.context === 'object') {
            prop = prop.value;
          }
          prop = prop.unwrapAll();
          if (prop.eachName != null) {
            results1.push(prop.eachName(iterator));
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }

      // Convert “bare” properties to `ObjectProperty`s (or `Splat`s).
      expandProperty(property) {
        var context, key, operatorToken, variable;
        ({variable, context, operatorToken} = property);
        key = property instanceof Assign && context === 'object' ? variable : property instanceof Assign ? (!this.lhs ? operatorToken.error(`unexpected ${operatorToken.value}`) : void 0, variable) : property;
        if (key instanceof Value && key.hasProperties()) {
          if (!(context !== 'object' && key.this)) {
            key.error('invalid object key');
          }
          if (property instanceof Assign) {
            return new ObjectProperty({
              fromAssign: property
            });
          } else {
            return new ObjectProperty({
              key: property
            });
          }
        }
        if (key !== property) {
          return new ObjectProperty({
            fromAssign: property
          });
        }
        if (property instanceof Splat) {
          return property;
        }
        return new ObjectProperty({
          key: property
        });
      }

      expandProperties() {
        var j, len1, property, ref1, results1;
        ref1 = this.properties;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          property = ref1[j];
          results1.push(this.expandProperty(property));
        }
        return results1;
      }

      propagateLhs(setLhs) {
        var j, len1, property, ref1, results1, unwrappedValue, value;
        if (setLhs) {
          this.lhs = true;
        }
        if (!this.lhs) {
          return;
        }
        ref1 = this.properties;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          property = ref1[j];
          if (property instanceof Assign && property.context === 'object') {
            ({value} = property);
            unwrappedValue = value.unwrapAll();
            if (unwrappedValue instanceof Arr || unwrappedValue instanceof Obj) {
              results1.push(unwrappedValue.propagateLhs(true));
            } else if (unwrappedValue instanceof Assign) {
              results1.push(unwrappedValue.nestedLhs = true);
            } else {
              results1.push(void 0);
            }
          } else if (property instanceof Assign) {
            // Shorthand property with default, e.g. `{a = 1} = b`.
            results1.push(property.nestedLhs = true);
          } else if (property instanceof Splat) {
            results1.push(property.propagateLhs(true));
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }

      astNode(o) {
        this.getAndCheckSplatProps();
        return super.astNode(o);
      }

      astType() {
        if (this.lhs) {
          return 'ObjectPattern';
        } else {
          return 'ObjectExpression';
        }
      }

      astProperties(o) {
        var property;
        return {
          implicit: !!this.generated,
          properties: (function() {
            var j, len1, ref1, results1;
            ref1 = this.expandProperties();
            results1 = [];
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              property = ref1[j];
              results1.push(property.ast(o));
            }
            return results1;
          }).call(this)
        };
      }

    };

    Obj.prototype.children = ['properties'];

    return Obj;

  }).call(this);

  exports.ObjectProperty = ObjectProperty = class ObjectProperty extends Base {
    constructor({key, fromAssign}) {
      var context, value;
      super();
      if (fromAssign) {
        ({
          variable: this.key,
          value,
          context
        } = fromAssign);
        if (context === 'object') {
          // All non-shorthand properties (i.e. includes `:`).
          this.value = value;
        } else {
          // Left-hand-side shorthand with default e.g. `{a = 1} = b`.
          this.value = fromAssign;
          this.shorthand = true;
        }
        this.locationData = fromAssign.locationData;
      } else {
        // Shorthand without default e.g. `{a}` or `{@a}` or `{[a]}`.
        this.key = key;
        this.shorthand = true;
        this.locationData = key.locationData;
      }
    }

    astProperties(o) {
      var isComputedPropertyName, keyAst, ref1, ref2;
      isComputedPropertyName = (this.key instanceof Value && this.key.base instanceof ComputedPropertyName) || this.key.unwrap() instanceof StringWithInterpolations;
      keyAst = this.key.ast(o, LEVEL_LIST);
      return {
        key: (keyAst != null ? keyAst.declaration : void 0) ? Object.assign({}, keyAst, {
          declaration: false
        }) : keyAst,
        value: (ref1 = (ref2 = this.value) != null ? ref2.ast(o, LEVEL_LIST) : void 0) != null ? ref1 : keyAst,
        shorthand: !!this.shorthand,
        computed: !!isComputedPropertyName,
        method: false
      };
    }

  };

  //### Arr

  // An array literal.
  exports.Arr = Arr = (function() {
    class Arr extends Base {
      constructor(objs, lhs1 = false) {
        super();
        this.lhs = lhs1;
        this.objects = objs || [];
        this.propagateLhs();
      }

      hasElision() {
        var j, len1, obj, ref1;
        ref1 = this.objects;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          obj = ref1[j];
          if (obj instanceof Elision) {
            return true;
          }
        }
        return false;
      }

      isAssignable(opts) {
        var allowEmptyArray, allowExpansion, allowNontrailingSplat, i, j, len1, obj, ref1;
        ({allowExpansion, allowNontrailingSplat, allowEmptyArray = false} = opts != null ? opts : {});
        if (!this.objects.length) {
          return allowEmptyArray;
        }
        ref1 = this.objects;
        for (i = j = 0, len1 = ref1.length; j < len1; i = ++j) {
          obj = ref1[i];
          if (!allowNontrailingSplat && obj instanceof Splat && i + 1 !== this.objects.length) {
            return false;
          }
          if (!((allowExpansion && obj instanceof Expansion) || (obj.isAssignable(opts) && (!obj.isAtomic || obj.isAtomic())))) {
            return false;
          }
        }
        return true;
      }

      shouldCache() {
        return !this.isAssignable();
      }

      compileNode(o) {
        var answer, compiledObjs, fragment, fragmentIndex, fragmentIsElision, fragments, includesLineCommentsOnNonFirstElement, index, j, k, l, len1, len2, len3, len4, len5, obj, objIndex, olen, p, passedElision, q, ref1, ref2, unwrappedObj;
        if (!this.objects.length) {
          return [this.makeCode('[]')];
        }
        o.indent += TAB;
        fragmentIsElision = function([fragment]) {
          return fragment.type === 'Elision' && fragment.code.trim() === ',';
        };
        // Detect if `Elision`s at the beginning of the array are processed (e.g. [, , , a]).
        passedElision = false;
        answer = [];
        ref1 = this.objects;
        for (objIndex = j = 0, len1 = ref1.length; j < len1; objIndex = ++j) {
          obj = ref1[objIndex];
          unwrappedObj = obj.unwrapAll();
          // Let `compileCommentFragments` know to intersperse block comments
          // into the fragments created when compiling this array.
          if (unwrappedObj.comments && unwrappedObj.comments.filter(function(comment) {
            return !comment.here;
          }).length === 0) {
            unwrappedObj.includeCommentFragments = YES;
          }
        }
        compiledObjs = (function() {
          var k, len2, ref2, results1;
          ref2 = this.objects;
          results1 = [];
          for (k = 0, len2 = ref2.length; k < len2; k++) {
            obj = ref2[k];
            results1.push(obj.compileToFragments(o, LEVEL_LIST));
          }
          return results1;
        }).call(this);
        olen = compiledObjs.length;
        // If `compiledObjs` includes newlines, we will output this as a multiline
        // array (i.e. with a newline and indentation after the `[`). If an element
        // contains line comments, that should also trigger multiline output since
        // by definition line comments will introduce newlines into our output.
        // The exception is if only the first element has line comments; in that
        // case, output as the compact form if we otherwise would have, so that the
        // first element’s line comments get output before or after the array.
        includesLineCommentsOnNonFirstElement = false;
        for (index = k = 0, len2 = compiledObjs.length; k < len2; index = ++k) {
          fragments = compiledObjs[index];
          for (l = 0, len3 = fragments.length; l < len3; l++) {
            fragment = fragments[l];
            if (fragment.isHereComment) {
              fragment.code = fragment.code.trim();
            } else if (index !== 0 && includesLineCommentsOnNonFirstElement === false && hasLineComments(fragment)) {
              includesLineCommentsOnNonFirstElement = true;
            }
          }
          // Add ', ' if all `Elisions` from the beginning of the array are processed (e.g. [, , , a]) and
          // element isn't `Elision` or last element is `Elision` (e.g. [a,,b,,])
          if (index !== 0 && passedElision && (!fragmentIsElision(fragments) || index === olen - 1)) {
            answer.push(this.makeCode(', '));
          }
          passedElision = passedElision || !fragmentIsElision(fragments);
          answer.push(...fragments);
        }
        if (includesLineCommentsOnNonFirstElement || indexOf.call(fragmentsToText(answer), '\n') >= 0) {
          for (fragmentIndex = p = 0, len4 = answer.length; p < len4; fragmentIndex = ++p) {
            fragment = answer[fragmentIndex];
            if (fragment.isHereComment) {
              fragment.code = `${multident(fragment.code, o.indent, false)}\n${o.indent}`;
            } else if (fragment.code === ', ' && !(fragment != null ? fragment.isElision : void 0) && ((ref2 = fragment.type) !== 'StringLiteral' && ref2 !== 'StringWithInterpolations')) {
              fragment.code = `,\n${o.indent}`;
            }
          }
          answer.unshift(this.makeCode(`[\n${o.indent}`));
          answer.push(this.makeCode(`\n${this.tab}]`));
        } else {
          for (q = 0, len5 = answer.length; q < len5; q++) {
            fragment = answer[q];
            if (fragment.isHereComment) {
              fragment.code = `${fragment.code} `;
            }
          }
          answer.unshift(this.makeCode('['));
          answer.push(this.makeCode(']'));
        }
        return answer;
      }

      assigns(name) {
        var j, len1, obj, ref1;
        ref1 = this.objects;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          obj = ref1[j];
          if (obj.assigns(name)) {
            return true;
          }
        }
        return false;
      }

      eachName(iterator) {
        var j, len1, obj, ref1, results1;
        ref1 = this.objects;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          obj = ref1[j];
          obj = obj.unwrapAll();
          results1.push(obj.eachName(iterator));
        }
        return results1;
      }

      // If this array is the left-hand side of an assignment, all its children
      // are too.
      propagateLhs(setLhs) {
        var j, len1, object, ref1, results1, unwrappedObject;
        if (setLhs) {
          this.lhs = true;
        }
        if (!this.lhs) {
          return;
        }
        ref1 = this.objects;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          object = ref1[j];
          if (object instanceof Splat || object instanceof Expansion) {
            object.lhs = true;
          }
          unwrappedObject = object.unwrapAll();
          if (unwrappedObject instanceof Arr || unwrappedObject instanceof Obj) {
            results1.push(unwrappedObject.propagateLhs(true));
          } else if (unwrappedObject instanceof Assign) {
            results1.push(unwrappedObject.nestedLhs = true);
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }

      astType() {
        if (this.lhs) {
          return 'ArrayPattern';
        } else {
          return 'ArrayExpression';
        }
      }

      astProperties(o) {
        var object;
        return {
          elements: (function() {
            var j, len1, ref1, results1;
            ref1 = this.objects;
            results1 = [];
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              object = ref1[j];
              results1.push(object.ast(o, LEVEL_LIST));
            }
            return results1;
          }).call(this)
        };
      }

    };

    Arr.prototype.children = ['objects'];

    return Arr;

  }).call(this);

  //### Class

  // The CoffeeScript class definition.
  // Initialize a **Class** with its name, an optional superclass, and a body.
  exports.Class = Class = (function() {
    class Class extends Base {
      constructor(variable1, parent1, body1) {
        super();
        this.variable = variable1;
        this.parent = parent1;
        this.body = body1;
        if (this.body == null) {
          this.body = new Block();
          this.hasGeneratedBody = true;
        }
      }

      compileNode(o) {
        var executableBody, node, parentName;
        this.name = this.determineName();
        executableBody = this.walkBody(o);
        if (this.parent instanceof Value && !this.parent.hasProperties()) {
          // Special handling to allow `class expr.A extends A` declarations
          parentName = this.parent.base.value;
        }
        this.hasNameClash = (this.name != null) && this.name === parentName;
        node = this;
        if (executableBody || this.hasNameClash) {
          node = new ExecutableClassBody(node, executableBody);
        } else if ((this.name == null) && o.level === LEVEL_TOP) {
          // Anonymous classes are only valid in expressions
          node = new Parens(node);
        }
        if (this.boundMethods.length && this.parent) {
          if (this.variable == null) {
            this.variable = new IdentifierLiteral(o.scope.freeVariable('_class'));
          }
          if (this.variableRef == null) {
            [this.variable, this.variableRef] = this.variable.cache(o);
          }
        }
        if (this.variable) {
          node = new Assign(this.variable, node, null, {moduleDeclaration: this.moduleDeclaration});
        }
        this.compileNode = this.compileClassDeclaration;
        try {
          return node.compileToFragments(o);
        } finally {
          delete this.compileNode;
        }
      }

      compileClassDeclaration(o) {
        var ref1, ref2, result;
        if (this.externalCtor || this.boundMethods.length) {
          if (this.ctor == null) {
            this.ctor = this.makeDefaultConstructor();
          }
        }
        if ((ref1 = this.ctor) != null) {
          ref1.noReturn = true;
        }
        if (this.boundMethods.length) {
          this.proxyBoundMethods();
        }
        o.indent += TAB;
        result = [];
        result.push(this.makeCode("class "));
        if (this.name) {
          result.push(this.makeCode(this.name));
        }
        if (((ref2 = this.variable) != null ? ref2.comments : void 0) != null) {
          this.compileCommentFragments(o, this.variable, result);
        }
        if (this.name) {
          result.push(this.makeCode(' '));
        }
        if (this.parent) {
          result.push(this.makeCode('extends '), ...this.parent.compileToFragments(o), this.makeCode(' '));
        }
        result.push(this.makeCode('{'));
        if (!this.body.isEmpty()) {
          this.body.spaced = true;
          result.push(this.makeCode('\n'));
          result.push(...this.body.compileToFragments(o, LEVEL_TOP));
          result.push(this.makeCode(`\n${this.tab}`));
        }
        result.push(this.makeCode('}'));
        return result;
      }

      // Figure out the appropriate name for this class
      determineName() {
        var message, name, node, ref1, tail;
        if (!this.variable) {
          return null;
        }
        ref1 = this.variable.properties, [tail] = slice1.call(ref1, -1);
        node = tail ? tail instanceof Access && tail.name : this.variable.base;
        if (!(node instanceof IdentifierLiteral || node instanceof PropertyName)) {
          return null;
        }
        name = node.value;
        if (!tail) {
          message = isUnassignable(name);
          if (message) {
            this.variable.error(message);
          }
        }
        if (indexOf.call(JS_FORBIDDEN, name) >= 0) {
          return `_${name}`;
        } else {
          return name;
        }
      }

      walkBody(o) {
        var assign, end, executableBody, expression, expressions, exprs, i, initializer, initializerExpression, j, k, len1, len2, method, properties, pushSlice, ref1, start;
        this.ctor = null;
        this.boundMethods = [];
        executableBody = null;
        initializer = [];
        ({expressions} = this.body);
        i = 0;
        ref1 = expressions.slice();
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          expression = ref1[j];
          if (expression instanceof Value && expression.isObject(true)) {
            ({properties} = expression.base);
            exprs = [];
            end = 0;
            start = 0;
            pushSlice = function() {
              if (end > start) {
                return exprs.push(new Value(new Obj(properties.slice(start, end), true)));
              }
            };
            while (assign = properties[end]) {
              if (initializerExpression = this.addInitializerExpression(assign, o)) {
                pushSlice();
                exprs.push(initializerExpression);
                initializer.push(initializerExpression);
                start = end + 1;
              }
              end++;
            }
            pushSlice();
            splice.apply(expressions, [i, i - i + 1].concat(exprs)), exprs;
            i += exprs.length;
          } else {
            if (initializerExpression = this.addInitializerExpression(expression, o)) {
              initializer.push(initializerExpression);
              expressions[i] = initializerExpression;
            }
            i += 1;
          }
        }
        for (k = 0, len2 = initializer.length; k < len2; k++) {
          method = initializer[k];
          if (method instanceof Code) {
            if (method.ctor) {
              if (this.ctor) {
                method.error('Cannot define more than one constructor in a class');
              }
              this.ctor = method;
            } else if (method.isStatic && method.bound) {
              method.context = this.name;
            } else if (method.bound) {
              this.boundMethods.push(method);
            }
          }
        }
        if (!o.compiling) {
          return;
        }
        if (initializer.length !== expressions.length) {
          this.body.expressions = (function() {
            var l, len3, results1;
            results1 = [];
            for (l = 0, len3 = initializer.length; l < len3; l++) {
              expression = initializer[l];
              results1.push(expression.hoist());
            }
            return results1;
          })();
          return new Block(expressions);
        }
      }

      // Add an expression to the class initializer

      // This is the key method for determining whether an expression in a class
      // body should appear in the initializer or the executable body. If the given
      // `node` is valid in a class body the method will return a (new, modified,
      // or identical) node for inclusion in the class initializer, otherwise
      // nothing will be returned and the node will appear in the executable body.

      // At time of writing, only methods (instance and static) are valid in ES
      // class initializers. As new ES class features (such as class fields) reach
      // Stage 4, this method will need to be updated to support them. We
      // additionally allow `PassthroughLiteral`s (backticked expressions) in the
      // initializer as an escape hatch for ES features that are not implemented
      // (e.g. getters and setters defined via the `get` and `set` keywords as
      // opposed to the `Object.defineProperty` method).
      addInitializerExpression(node, o) {
        if (node.unwrapAll() instanceof PassthroughLiteral) {
          return node;
        } else if (this.validInitializerMethod(node)) {
          return this.addInitializerMethod(node);
        } else if (!o.compiling && this.validClassProperty(node)) {
          return this.addClassProperty(node);
        } else if (!o.compiling && this.validClassPrototypeProperty(node)) {
          return this.addClassPrototypeProperty(node);
        } else {
          return null;
        }
      }

      // Checks if the given node is a valid ES class initializer method.
      validInitializerMethod(node) {
        if (!(node instanceof Assign && node.value instanceof Code)) {
          return false;
        }
        if (node.context === 'object' && !node.variable.hasProperties()) {
          return true;
        }
        return node.variable.looksStatic(this.name) && (this.name || !node.value.bound);
      }

      // Returns a configured class initializer method
      addInitializerMethod(assign) {
        var isConstructor, method, methodName, operatorToken, variable;
        ({
          variable,
          value: method,
          operatorToken
        } = assign);
        method.isMethod = true;
        method.isStatic = variable.looksStatic(this.name);
        if (method.isStatic) {
          method.name = variable.properties[0];
        } else {
          methodName = variable.base;
          method.name = new (methodName.shouldCache() ? Index : Access)(methodName);
          method.name.updateLocationDataIfMissing(methodName.locationData);
          isConstructor = methodName instanceof StringLiteral ? methodName.originalValue === 'constructor' : methodName.value === 'constructor';
          if (isConstructor) {
            method.ctor = (this.parent ? 'derived' : 'base');
          }
          if (method.bound && method.ctor) {
            method.error('Cannot define a constructor as a bound (fat arrow) function');
          }
        }
        method.operatorToken = operatorToken;
        return method;
      }

      validClassProperty(node) {
        if (!(node instanceof Assign)) {
          return false;
        }
        return node.variable.looksStatic(this.name);
      }

      addClassProperty(assign) {
        var operatorToken, staticClassName, value, variable;
        ({variable, value, operatorToken} = assign);
        ({staticClassName} = variable.looksStatic(this.name));
        return new ClassProperty({
          name: variable.properties[0],
          isStatic: true,
          staticClassName,
          value,
          operatorToken
        }).withLocationDataFrom(assign);
      }

      validClassPrototypeProperty(node) {
        if (!(node instanceof Assign)) {
          return false;
        }
        return node.context === 'object' && !node.variable.hasProperties();
      }

      addClassPrototypeProperty(assign) {
        var value, variable;
        ({variable, value} = assign);
        return new ClassPrototypeProperty({
          name: variable.base,
          value
        }).withLocationDataFrom(assign);
      }

      makeDefaultConstructor() {
        var applyArgs, applyCtor, ctor;
        ctor = this.addInitializerMethod(new Assign(new Value(new PropertyName('constructor')), new Code()));
        this.body.unshift(ctor);
        if (this.parent) {
          ctor.body.push(new SuperCall(new Super(), [new Splat(new IdentifierLiteral('arguments'))]));
        }
        if (this.externalCtor) {
          applyCtor = new Value(this.externalCtor, [new Access(new PropertyName('apply'))]);
          applyArgs = [new ThisLiteral(), new IdentifierLiteral('arguments')];
          ctor.body.push(new Call(applyCtor, applyArgs));
          ctor.body.makeReturn();
        }
        return ctor;
      }

      proxyBoundMethods() {
        var method, name;
        this.ctor.thisAssignments = (function() {
          var j, len1, ref1, results1;
          ref1 = this.boundMethods;
          results1 = [];
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            method = ref1[j];
            if (this.parent) {
              method.classVariable = this.variableRef;
            }
            name = new Value(new ThisLiteral(), [method.name]);
            results1.push(new Assign(name, new Call(new Value(name, [new Access(new PropertyName('bind'))]), [new ThisLiteral()])));
          }
          return results1;
        }).call(this);
        return null;
      }

      declareName(o) {
        var alreadyDeclared, name, ref1;
        if (!((name = (ref1 = this.variable) != null ? ref1.unwrap() : void 0) instanceof IdentifierLiteral)) {
          return;
        }
        alreadyDeclared = o.scope.find(name.value);
        return name.isDeclaration = !alreadyDeclared;
      }

      isStatementAst() {
        return true;
      }

      astNode(o) {
        var argumentsNode, jumpNode, ref1;
        if (jumpNode = this.body.jumps()) {
          jumpNode.error('Class bodies cannot contain pure statements');
        }
        if (argumentsNode = this.body.contains(isLiteralArguments)) {
          argumentsNode.error("Class bodies shouldn't reference arguments");
        }
        this.declareName(o);
        this.name = this.determineName();
        this.body.isClassBody = true;
        if (this.hasGeneratedBody) {
          this.body.locationData = zeroWidthLocationDataFromEndLocation(this.locationData);
        }
        this.walkBody(o);
        sniffDirectives(this.body.expressions);
        if ((ref1 = this.ctor) != null) {
          ref1.noReturn = true;
        }
        return super.astNode(o);
      }

      astType(o) {
        if (o.level === LEVEL_TOP) {
          return 'ClassDeclaration';
        } else {
          return 'ClassExpression';
        }
      }

      astProperties(o) {
        var ref1, ref2, ref3, ref4;
        return {
          id: (ref1 = (ref2 = this.variable) != null ? ref2.ast(o) : void 0) != null ? ref1 : null,
          superClass: (ref3 = (ref4 = this.parent) != null ? ref4.ast(o, LEVEL_PAREN) : void 0) != null ? ref3 : null,
          body: this.body.ast(o, LEVEL_TOP)
        };
      }

    };

    Class.prototype.children = ['variable', 'parent', 'body'];

    return Class;

  }).call(this);

  exports.ExecutableClassBody = ExecutableClassBody = (function() {
    class ExecutableClassBody extends Base {
      constructor(_class, body1 = new Block()) {
        super();
        this.class = _class;
        this.body = body1;
      }

      compileNode(o) {
        var args, argumentsNode, directives, externalCtor, ident, jumpNode, klass, params, parent, ref1, wrapper;
        if (jumpNode = this.body.jumps()) {
          jumpNode.error('Class bodies cannot contain pure statements');
        }
        if (argumentsNode = this.body.contains(isLiteralArguments)) {
          argumentsNode.error("Class bodies shouldn't reference arguments");
        }
        params = [];
        args = [new ThisLiteral()];
        wrapper = new Code(params, this.body);
        klass = new Parens(new Call(new Value(wrapper, [new Access(new PropertyName('call'))]), args));
        this.body.spaced = true;
        o.classScope = wrapper.makeScope(o.scope);
        this.name = (ref1 = this.class.name) != null ? ref1 : o.classScope.freeVariable(this.defaultClassVariableName);
        ident = new IdentifierLiteral(this.name);
        directives = this.walkBody();
        this.setContext();
        if (this.class.hasNameClash) {
          parent = new IdentifierLiteral(o.classScope.freeVariable('superClass'));
          wrapper.params.push(new Param(parent));
          args.push(this.class.parent);
          this.class.parent = parent;
        }
        if (this.externalCtor) {
          externalCtor = new IdentifierLiteral(o.classScope.freeVariable('ctor', {
            reserve: false
          }));
          this.class.externalCtor = externalCtor;
          this.externalCtor.variable.base = externalCtor;
        }
        if (this.name !== this.class.name) {
          this.body.expressions.unshift(new Assign(new IdentifierLiteral(this.name), this.class));
        } else {
          this.body.expressions.unshift(this.class);
        }
        this.body.expressions.unshift(...directives);
        this.body.push(ident);
        return klass.compileToFragments(o);
      }

      // Traverse the class's children and:
      // - Hoist valid ES properties into `@properties`
      // - Hoist static assignments into `@properties`
      // - Convert invalid ES properties into class or prototype assignments
      walkBody() {
        var directives, expr, index;
        directives = [];
        index = 0;
        while (expr = this.body.expressions[index]) {
          if (!(expr instanceof Value && expr.isString())) {
            break;
          }
          if (expr.hoisted) {
            index++;
          } else {
            directives.push(...this.body.expressions.splice(index, 1));
          }
        }
        this.traverseChildren(false, (child) => {
          var cont, i, j, len1, node, ref1;
          if (child instanceof Class || child instanceof HoistTarget) {
            return false;
          }
          cont = true;
          if (child instanceof Block) {
            ref1 = child.expressions;
            for (i = j = 0, len1 = ref1.length; j < len1; i = ++j) {
              node = ref1[i];
              if (node instanceof Value && node.isObject(true)) {
                cont = false;
                child.expressions[i] = this.addProperties(node.base.properties);
              } else if (node instanceof Assign && node.variable.looksStatic(this.name)) {
                node.value.isStatic = true;
              }
            }
            child.expressions = flatten(child.expressions);
          }
          return cont;
        });
        return directives;
      }

      setContext() {
        return this.body.traverseChildren(false, (node) => {
          if (node instanceof ThisLiteral) {
            return node.value = this.name;
          } else if (node instanceof Code && node.bound && (node.isStatic || !node.name)) {
            return node.context = this.name;
          }
        });
      }

      // Make class/prototype assignments for invalid ES properties
      addProperties(assigns) {
        var assign, base, name, prototype, result, value, variable;
        result = (function() {
          var j, len1, results1;
          results1 = [];
          for (j = 0, len1 = assigns.length; j < len1; j++) {
            assign = assigns[j];
            variable = assign.variable;
            base = variable != null ? variable.base : void 0;
            value = assign.value;
            delete assign.context;
            if (base.value === 'constructor') {
              if (value instanceof Code) {
                base.error('constructors must be defined at the top level of a class body');
              }
              // The class scope is not available yet, so return the assignment to update later
              assign = this.externalCtor = new Assign(new Value(), value);
            } else if (!assign.variable.this) {
              name = base instanceof ComputedPropertyName ? new Index(base.value) : new (base.shouldCache() ? Index : Access)(base);
              prototype = new Access(new PropertyName('prototype'));
              variable = new Value(new ThisLiteral(), [prototype, name]);
              assign.variable = variable;
            } else if (assign.value instanceof Code) {
              assign.value.isStatic = true;
            }
            results1.push(assign);
          }
          return results1;
        }).call(this);
        return compact(result);
      }

    };

    ExecutableClassBody.prototype.children = ['class', 'body'];

    ExecutableClassBody.prototype.defaultClassVariableName = '_Class';

    return ExecutableClassBody;

  }).call(this);

  exports.ClassProperty = ClassProperty = (function() {
    class ClassProperty extends Base {
      constructor({
          name: name1,
          isStatic,
          staticClassName: staticClassName1,
          value: value1,
          operatorToken: operatorToken1
        }) {
        super();
        this.name = name1;
        this.isStatic = isStatic;
        this.staticClassName = staticClassName1;
        this.value = value1;
        this.operatorToken = operatorToken1;
      }

      astProperties(o) {
        var ref1, ref2, ref3, ref4;
        return {
          key: this.name.ast(o, LEVEL_LIST),
          value: this.value.ast(o, LEVEL_LIST),
          static: !!this.isStatic,
          computed: this.name instanceof Index || this.name instanceof ComputedPropertyName,
          operator: (ref1 = (ref2 = this.operatorToken) != null ? ref2.value : void 0) != null ? ref1 : '=',
          staticClassName: (ref3 = (ref4 = this.staticClassName) != null ? ref4.ast(o) : void 0) != null ? ref3 : null
        };
      }

    };

    ClassProperty.prototype.children = ['name', 'value', 'staticClassName'];

    ClassProperty.prototype.isStatement = YES;

    return ClassProperty;

  }).call(this);

  exports.ClassPrototypeProperty = ClassPrototypeProperty = (function() {
    class ClassPrototypeProperty extends Base {
      constructor({
          name: name1,
          value: value1
        }) {
        super();
        this.name = name1;
        this.value = value1;
      }

      astProperties(o) {
        return {
          key: this.name.ast(o, LEVEL_LIST),
          value: this.value.ast(o, LEVEL_LIST),
          computed: this.name instanceof ComputedPropertyName || this.name instanceof StringWithInterpolations
        };
      }

    };

    ClassPrototypeProperty.prototype.children = ['name', 'value'];

    ClassPrototypeProperty.prototype.isStatement = YES;

    return ClassPrototypeProperty;

  }).call(this);

  //### Import and Export
  exports.ModuleDeclaration = ModuleDeclaration = (function() {
    class ModuleDeclaration extends Base {
      constructor(clause, source1, assertions) {
        super();
        this.clause = clause;
        this.source = source1;
        this.assertions = assertions;
        this.checkSource();
      }

      checkSource() {
        if ((this.source != null) && this.source instanceof StringWithInterpolations) {
          return this.source.error('the name of the module to be imported from must be an uninterpolated string');
        }
      }

      checkScope(o, moduleDeclarationType) {
        // TODO: would be appropriate to flag this error during AST generation (as
        // well as when compiling to JS). But `o.indent` isn’t tracked during AST
        // generation, and there doesn’t seem to be a current alternative way to track
        // whether we’re at the “program top-level”.
        if (o.indent.length !== 0) {
          return this.error(`${moduleDeclarationType} statements must be at top-level scope`);
        }
      }

      astAssertions(o) {
        var ref1;
        if (((ref1 = this.assertions) != null ? ref1.properties : void 0) != null) {
          return this.assertions.properties.map((assertion) => {
            var end, left, loc, right, start;
            ({start, end, loc, left, right} = assertion.ast(o));
            return {
              type: 'ImportAttribute',
              start,
              end,
              loc,
              key: left,
              value: right
            };
          });
        } else {
          return [];
        }
      }

    };

    ModuleDeclaration.prototype.children = ['clause', 'source', 'assertions'];

    ModuleDeclaration.prototype.isStatement = YES;

    ModuleDeclaration.prototype.jumps = THIS;

    ModuleDeclaration.prototype.makeReturn = THIS;

    return ModuleDeclaration;

  }).call(this);

  exports.ImportDeclaration = ImportDeclaration = class ImportDeclaration extends ModuleDeclaration {
    compileNode(o) {
      var code, ref1;
      this.checkScope(o, 'import');
      o.importedSymbols = [];
      code = [];
      code.push(this.makeCode(`${this.tab}import `));
      if (this.clause != null) {
        code.push(...this.clause.compileNode(o));
      }
      if (((ref1 = this.source) != null ? ref1.value : void 0) != null) {
        if (this.clause !== null) {
          code.push(this.makeCode(' from '));
        }
        code.push(this.makeCode(this.source.value));
        if (this.assertions != null) {
          code.push(this.makeCode(' assert '));
          code.push(...this.assertions.compileToFragments(o));
        }
      }
      code.push(this.makeCode(';'));
      return code;
    }

    astNode(o) {
      o.importedSymbols = [];
      return super.astNode(o);
    }

    astProperties(o) {
      var ref1, ref2, ret;
      ret = {
        specifiers: (ref1 = (ref2 = this.clause) != null ? ref2.ast(o) : void 0) != null ? ref1 : [],
        source: this.source.ast(o),
        assertions: this.astAssertions(o)
      };
      if (this.clause) {
        ret.importKind = 'value';
      }
      return ret;
    }

  };

  exports.ImportClause = ImportClause = (function() {
    class ImportClause extends Base {
      constructor(defaultBinding, namedImports) {
        super();
        this.defaultBinding = defaultBinding;
        this.namedImports = namedImports;
      }

      compileNode(o) {
        var code;
        code = [];
        if (this.defaultBinding != null) {
          code.push(...this.defaultBinding.compileNode(o));
          if (this.namedImports != null) {
            code.push(this.makeCode(', '));
          }
        }
        if (this.namedImports != null) {
          code.push(...this.namedImports.compileNode(o));
        }
        return code;
      }

      astNode(o) {
        var ref1, ref2;
        // The AST for `ImportClause` is the non-nested list of import specifiers
        // that will be the `specifiers` property of an `ImportDeclaration` AST
        return compact(flatten([(ref1 = this.defaultBinding) != null ? ref1.ast(o) : void 0, (ref2 = this.namedImports) != null ? ref2.ast(o) : void 0]));
      }

    };

    ImportClause.prototype.children = ['defaultBinding', 'namedImports'];

    return ImportClause;

  }).call(this);

  exports.ExportDeclaration = ExportDeclaration = class ExportDeclaration extends ModuleDeclaration {
    compileNode(o) {
      var code, ref1;
      this.checkScope(o, 'export');
      this.checkForAnonymousClassExport();
      code = [];
      code.push(this.makeCode(`${this.tab}export `));
      if (this instanceof ExportDefaultDeclaration) {
        code.push(this.makeCode('default '));
      }
      if (!(this instanceof ExportDefaultDeclaration) && (this.clause instanceof Assign || this.clause instanceof Class)) {
        code.push(this.makeCode('var '));
        this.clause.moduleDeclaration = 'export';
      }
      if ((this.clause.body != null) && this.clause.body instanceof Block) {
        code = code.concat(this.clause.compileToFragments(o, LEVEL_TOP));
      } else {
        code = code.concat(this.clause.compileNode(o));
      }
      if (((ref1 = this.source) != null ? ref1.value : void 0) != null) {
        code.push(this.makeCode(` from ${this.source.value}`));
        if (this.assertions != null) {
          code.push(this.makeCode(' assert '));
          code.push(...this.assertions.compileToFragments(o));
        }
      }
      code.push(this.makeCode(';'));
      return code;
    }

    // Prevent exporting an anonymous class; all exported members must be named
    checkForAnonymousClassExport() {
      if (!(this instanceof ExportDefaultDeclaration) && this.clause instanceof Class && !this.clause.variable) {
        return this.clause.error('anonymous classes cannot be exported');
      }
    }

    astNode(o) {
      this.checkForAnonymousClassExport();
      return super.astNode(o);
    }

  };

  exports.ExportNamedDeclaration = ExportNamedDeclaration = class ExportNamedDeclaration extends ExportDeclaration {
    astProperties(o) {
      var clauseAst, ref1, ref2, ret;
      ret = {
        source: (ref1 = (ref2 = this.source) != null ? ref2.ast(o) : void 0) != null ? ref1 : null,
        assertions: this.astAssertions(o),
        exportKind: 'value'
      };
      clauseAst = this.clause.ast(o);
      if (this.clause instanceof ExportSpecifierList) {
        ret.specifiers = clauseAst;
        ret.declaration = null;
      } else {
        ret.specifiers = [];
        ret.declaration = clauseAst;
      }
      return ret;
    }

  };

  exports.ExportDefaultDeclaration = ExportDefaultDeclaration = class ExportDefaultDeclaration extends ExportDeclaration {
    astProperties(o) {
      return {
        declaration: this.clause.ast(o),
        assertions: this.astAssertions(o)
      };
    }

  };

  exports.ExportAllDeclaration = ExportAllDeclaration = class ExportAllDeclaration extends ExportDeclaration {
    astProperties(o) {
      return {
        source: this.source.ast(o),
        assertions: this.astAssertions(o),
        exportKind: 'value'
      };
    }

  };

  exports.ModuleSpecifierList = ModuleSpecifierList = (function() {
    class ModuleSpecifierList extends Base {
      constructor(specifiers) {
        super();
        this.specifiers = specifiers;
      }

      compileNode(o) {
        var code, compiledList, fragments, index, j, len1, specifier;
        code = [];
        o.indent += TAB;
        compiledList = (function() {
          var j, len1, ref1, results1;
          ref1 = this.specifiers;
          results1 = [];
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            specifier = ref1[j];
            results1.push(specifier.compileToFragments(o, LEVEL_LIST));
          }
          return results1;
        }).call(this);
        if (this.specifiers.length !== 0) {
          code.push(this.makeCode(`{\n${o.indent}`));
          for (index = j = 0, len1 = compiledList.length; j < len1; index = ++j) {
            fragments = compiledList[index];
            if (index) {
              code.push(this.makeCode(`,\n${o.indent}`));
            }
            code.push(...fragments);
          }
          code.push(this.makeCode("\n}"));
        } else {
          code.push(this.makeCode('{}'));
        }
        return code;
      }

      astNode(o) {
        var j, len1, ref1, results1, specifier;
        ref1 = this.specifiers;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          specifier = ref1[j];
          results1.push(specifier.ast(o));
        }
        return results1;
      }

    };

    ModuleSpecifierList.prototype.children = ['specifiers'];

    return ModuleSpecifierList;

  }).call(this);

  exports.ImportSpecifierList = ImportSpecifierList = class ImportSpecifierList extends ModuleSpecifierList {};

  exports.ExportSpecifierList = ExportSpecifierList = class ExportSpecifierList extends ModuleSpecifierList {};

  exports.ModuleSpecifier = ModuleSpecifier = (function() {
    class ModuleSpecifier extends Base {
      constructor(original, alias, moduleDeclarationType1) {
        var ref1, ref2;
        super();
        this.original = original;
        this.alias = alias;
        this.moduleDeclarationType = moduleDeclarationType1;
        if (this.original.comments || ((ref1 = this.alias) != null ? ref1.comments : void 0)) {
          this.comments = [];
          if (this.original.comments) {
            this.comments.push(...this.original.comments);
          }
          if ((ref2 = this.alias) != null ? ref2.comments : void 0) {
            this.comments.push(...this.alias.comments);
          }
        }
        // The name of the variable entering the local scope
        this.identifier = this.alias != null ? this.alias.value : this.original.value;
      }

      compileNode(o) {
        var code;
        this.addIdentifierToScope(o);
        code = [];
        code.push(this.makeCode(this.original.value));
        if (this.alias != null) {
          code.push(this.makeCode(` as ${this.alias.value}`));
        }
        return code;
      }

      addIdentifierToScope(o) {
        return o.scope.find(this.identifier, this.moduleDeclarationType);
      }

      astNode(o) {
        this.addIdentifierToScope(o);
        return super.astNode(o);
      }

    };

    ModuleSpecifier.prototype.children = ['original', 'alias'];

    return ModuleSpecifier;

  }).call(this);

  exports.ImportSpecifier = ImportSpecifier = class ImportSpecifier extends ModuleSpecifier {
    constructor(imported, local) {
      super(imported, local, 'import');
    }

    addIdentifierToScope(o) {
      var ref1;
      // Per the spec, symbols can’t be imported multiple times
      // (e.g. `import { foo, foo } from 'lib'` is invalid)
      if ((ref1 = this.identifier, indexOf.call(o.importedSymbols, ref1) >= 0) || o.scope.check(this.identifier)) {
        this.error(`'${this.identifier}' has already been declared`);
      } else {
        o.importedSymbols.push(this.identifier);
      }
      return super.addIdentifierToScope(o);
    }

    astProperties(o) {
      var originalAst, ref1, ref2;
      originalAst = this.original.ast(o);
      return {
        imported: originalAst,
        local: (ref1 = (ref2 = this.alias) != null ? ref2.ast(o) : void 0) != null ? ref1 : originalAst,
        importKind: null
      };
    }

  };

  exports.ImportDefaultSpecifier = ImportDefaultSpecifier = class ImportDefaultSpecifier extends ImportSpecifier {
    astProperties(o) {
      return {
        local: this.original.ast(o)
      };
    }

  };

  exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier = class ImportNamespaceSpecifier extends ImportSpecifier {
    astProperties(o) {
      return {
        local: this.alias.ast(o)
      };
    }

  };

  exports.ExportSpecifier = ExportSpecifier = class ExportSpecifier extends ModuleSpecifier {
    constructor(local, exported) {
      super(local, exported, 'export');
    }

    astProperties(o) {
      var originalAst, ref1, ref2;
      originalAst = this.original.ast(o);
      return {
        local: originalAst,
        exported: (ref1 = (ref2 = this.alias) != null ? ref2.ast(o) : void 0) != null ? ref1 : originalAst
      };
    }

  };

  exports.DynamicImport = DynamicImport = class DynamicImport extends Base {
    compileNode() {
      return [this.makeCode('import')];
    }

    astType() {
      return 'Import';
    }

  };

  exports.DynamicImportCall = DynamicImportCall = class DynamicImportCall extends Call {
    compileNode(o) {
      this.checkArguments();
      return super.compileNode(o);
    }

    checkArguments() {
      var ref1;
      if (!((1 <= (ref1 = this.args.length) && ref1 <= 2))) {
        return this.error('import() accepts either one or two arguments');
      }
    }

    astNode(o) {
      this.checkArguments();
      return super.astNode(o);
    }

  };

  //### Assign

  // The **Assign** is used to assign a local variable to value, or to set the
  // property of an object -- including within object literals.
  exports.Assign = Assign = (function() {
    class Assign extends Base {
      constructor(variable1, value1, context1, options = {}) {
        super();
        this.variable = variable1;
        this.value = value1;
        this.context = context1;
        ({param: this.param, subpattern: this.subpattern, operatorToken: this.operatorToken, moduleDeclaration: this.moduleDeclaration, originalContext: this.originalContext = this.context} = options);
        this.propagateLhs();
      }

      isStatement(o) {
        return (o != null ? o.level : void 0) === LEVEL_TOP && (this.context != null) && (this.moduleDeclaration || indexOf.call(this.context, "?") >= 0);
      }

      checkNameAssignability(o, varBase) {
        if (o.scope.type(varBase.value) === 'import') {
          return varBase.error(`'${varBase.value}' is read-only`);
        }
      }

      assigns(name) {
        return this[this.context === 'object' ? 'value' : 'variable'].assigns(name);
      }

      unfoldSoak(o) {
        return unfoldSoak(o, this, 'variable');
      }

      // During AST generation, we need to allow assignment to these constructs
      // that are considered “unassignable” during compile-to-JS, while still
      // flagging things like `[null] = b`.
      addScopeVariables(o, {allowAssignmentToExpansion = false, allowAssignmentToNontrailingSplat = false, allowAssignmentToEmptyArray = false, allowAssignmentToComplexSplat = false} = {}) {
        var varBase;
        if (!(!this.context || this.context === '**=')) {
          return;
        }
        varBase = this.variable.unwrapAll();
        if (!varBase.isAssignable({
          allowExpansion: allowAssignmentToExpansion,
          allowNontrailingSplat: allowAssignmentToNontrailingSplat,
          allowEmptyArray: allowAssignmentToEmptyArray,
          allowComplexSplat: allowAssignmentToComplexSplat
        })) {
          this.variable.error(`'${this.variable.compile(o)}' can't be assigned`);
        }
        return varBase.eachName((name) => {
          var alreadyDeclared, commentFragments, commentsNode, message;
          if (typeof name.hasProperties === "function" ? name.hasProperties() : void 0) {
            return;
          }
          message = isUnassignable(name.value);
          if (message) {
            name.error(message);
          }
          // `moduleDeclaration` can be `'import'` or `'export'`.
          this.checkNameAssignability(o, name);
          if (this.moduleDeclaration) {
            o.scope.add(name.value, this.moduleDeclaration);
            return name.isDeclaration = true;
          } else if (this.param) {
            return o.scope.add(name.value, this.param === 'alwaysDeclare' ? 'var' : 'param');
          } else {
            alreadyDeclared = o.scope.find(name.value);
            if (name.isDeclaration == null) {
              name.isDeclaration = !alreadyDeclared;
            }
            // If this assignment identifier has one or more herecomments
            // attached, output them as part of the declarations line (unless
            // other herecomments are already staged there) for compatibility
            // with Flow typing. Don’t do this if this assignment is for a
            // class, e.g. `ClassName = class ClassName {`, as Flow requires
            // the comment to be between the class name and the `{`.
            if (name.comments && !o.scope.comments[name.value] && !(this.value instanceof Class) && name.comments.every(function(comment) {
              return comment.here && !comment.multiline;
            })) {
              commentsNode = new IdentifierLiteral(name.value);
              commentsNode.comments = name.comments;
              commentFragments = [];
              this.compileCommentFragments(o, commentsNode, commentFragments);
              return o.scope.comments[name.value] = commentFragments;
            }
          }
        });
      }

      // Compile an assignment, delegating to `compileDestructuring` or
      // `compileSplice` if appropriate. Keep track of the name of the base object
      // we've been assigned to, for correct internal references. If the variable
      // has not been seen yet within the current scope, declare it.
      compileNode(o) {
        var answer, compiledName, isValue, name, properties, prototype, ref1, ref2, ref3, ref4, val;
        isValue = this.variable instanceof Value;
        if (isValue) {
          // If `@variable` is an array or an object, we’re destructuring;
          // if it’s also `isAssignable()`, the destructuring syntax is supported
          // in ES and we can output it as is; otherwise we `@compileDestructuring`
          // and convert this ES-unsupported destructuring into acceptable output.
          if (this.variable.isArray() || this.variable.isObject()) {
            if (!this.variable.isAssignable()) {
              if (this.variable.isObject() && this.variable.base.hasSplat()) {
                return this.compileObjectDestruct(o);
              } else {
                return this.compileDestructuring(o);
              }
            }
          }
          if (this.variable.isSplice()) {
            return this.compileSplice(o);
          }
          if (this.isConditional()) {
            return this.compileConditional(o);
          }
          if ((ref1 = this.context) === '//=' || ref1 === '%%=') {
            return this.compileSpecialMath(o);
          }
        }
        this.addScopeVariables(o);
        if (this.value instanceof Code) {
          if (this.value.isStatic) {
            this.value.name = this.variable.properties[0];
          } else if (((ref2 = this.variable.properties) != null ? ref2.length : void 0) >= 2) {
            ref3 = this.variable.properties, [...properties] = ref3, [prototype, name] = splice.call(properties, -2);
            if (((ref4 = prototype.name) != null ? ref4.value : void 0) === 'prototype') {
              this.value.name = name;
            }
          }
        }
        val = this.value.compileToFragments(o, LEVEL_LIST);
        compiledName = this.variable.compileToFragments(o, LEVEL_LIST);
        if (this.context === 'object') {
          if (this.variable.shouldCache()) {
            compiledName.unshift(this.makeCode('['));
            compiledName.push(this.makeCode(']'));
          }
          return compiledName.concat(this.makeCode(': '), val);
        }
        answer = compiledName.concat(this.makeCode(` ${this.context || '='} `), val);
        // Per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Assignment_without_declaration,
        // if we’re destructuring without declaring, the destructuring assignment must be wrapped in parentheses.
        // The assignment is wrapped in parentheses if 'o.level' has lower precedence than LEVEL_LIST (3)
        // (i.e. LEVEL_COND (4), LEVEL_OP (5) or LEVEL_ACCESS (6)), or if we're destructuring object, e.g. {a,b} = obj.
        if (o.level > LEVEL_LIST || isValue && this.variable.base instanceof Obj && !this.nestedLhs && !(this.param === true)) {
          return this.wrapInParentheses(answer);
        } else {
          return answer;
        }
      }

      // Object rest property is not assignable: `{{a}...}`
      compileObjectDestruct(o) {
        var assigns, props, refVal, splat, splatProp;
        this.variable.base.reorderProperties();
        ({
          properties: props
        } = this.variable.base);
        [splat] = slice1.call(props, -1);
        splatProp = splat.name;
        assigns = [];
        refVal = new Value(new IdentifierLiteral(o.scope.freeVariable('ref')));
        props.splice(-1, 1, new Splat(refVal));
        assigns.push(new Assign(new Value(new Obj(props)), this.value).compileToFragments(o, LEVEL_LIST));
        assigns.push(new Assign(new Value(splatProp), refVal).compileToFragments(o, LEVEL_LIST));
        return this.joinFragmentArrays(assigns, ', ');
      }

      // Brief implementation of recursive pattern matching, when assigning array or
      // object literals to a value. Peeks at their properties to assign inner names.
      compileDestructuring(o) {
        var assignObjects, assigns, code, compSlice, compSplice, complexObjects, expIdx, expans, fragments, hasObjAssigns, isExpans, isSplat, leftObjs, loopObjects, obj, objIsUnassignable, objects, olen, processObjects, pushAssign, ref, refExp, restVar, rightObjs, slicer, splatVar, splatVarAssign, splatVarRef, splats, splatsAndExpans, top, value, vvar, vvarText;
        top = o.level === LEVEL_TOP;
        ({value} = this);
        ({objects} = this.variable.base);
        olen = objects.length;
        // Special-case for `{} = a` and `[] = a` (empty patterns).
        // Compile to simply `a`.
        if (olen === 0) {
          code = value.compileToFragments(o);
          if (o.level >= LEVEL_OP) {
            return this.wrapInParentheses(code);
          } else {
            return code;
          }
        }
        [obj] = objects;
        this.disallowLoneExpansion();
        ({splats, expans, splatsAndExpans} = this.getAndCheckSplatsAndExpansions());
        isSplat = (splats != null ? splats.length : void 0) > 0;
        isExpans = (expans != null ? expans.length : void 0) > 0;
        vvar = value.compileToFragments(o, LEVEL_LIST);
        vvarText = fragmentsToText(vvar);
        assigns = [];
        pushAssign = (variable, val) => {
          return assigns.push(new Assign(variable, val, null, {
            param: this.param,
            subpattern: true
          }).compileToFragments(o, LEVEL_LIST));
        };
        if (isSplat) {
          splatVar = objects[splats[0]].name.unwrap();
          if (splatVar instanceof Arr || splatVar instanceof Obj) {
            splatVarRef = new IdentifierLiteral(o.scope.freeVariable('ref'));
            objects[splats[0]].name = splatVarRef;
            splatVarAssign = function() {
              return pushAssign(new Value(splatVar), splatVarRef);
            };
          }
        }
        // At this point, there are several things to destructure. So the `fn()` in
        // `{a, b} = fn()` must be cached, for example. Make vvar into a simple
        // variable if it isn’t already.
        if (!(value.unwrap() instanceof IdentifierLiteral) || this.variable.assigns(vvarText)) {
          ref = o.scope.freeVariable('ref');
          assigns.push([this.makeCode(ref + ' = '), ...vvar]);
          vvar = [this.makeCode(ref)];
          vvarText = ref;
        }
        slicer = function(type) {
          return function(vvar, start, end = false) {
            var args, slice;
            if (!(vvar instanceof Value)) {
              vvar = new IdentifierLiteral(vvar);
            }
            args = [vvar, new NumberLiteral(start)];
            if (end) {
              args.push(new NumberLiteral(end));
            }
            slice = new Value(new IdentifierLiteral(utility(type, o)), [new Access(new PropertyName('call'))]);
            return new Value(new Call(slice, args));
          };
        };
        // Helper which outputs `[].slice` code.
        compSlice = slicer("slice");
        // Helper which outputs `[].splice` code.
        compSplice = slicer("splice");
        // Check if `objects` array contains any instance of `Assign`, e.g. {a:1}.
        hasObjAssigns = function(objs) {
          var i, j, len1, results1;
          results1 = [];
          for (i = j = 0, len1 = objs.length; j < len1; i = ++j) {
            obj = objs[i];
            if (obj instanceof Assign && obj.context === 'object') {
              results1.push(i);
            }
          }
          return results1;
        };
        // Check if `objects` array contains any unassignable object.
        objIsUnassignable = function(objs) {
          var j, len1;
          for (j = 0, len1 = objs.length; j < len1; j++) {
            obj = objs[j];
            if (!obj.isAssignable()) {
              return true;
            }
          }
          return false;
        };
        // `objects` are complex when there is object assign ({a:1}),
        // unassignable object, or just a single node.
        complexObjects = function(objs) {
          return hasObjAssigns(objs).length || objIsUnassignable(objs) || olen === 1;
        };
        // "Complex" `objects` are processed in a loop.
        // Examples: [a, b, {c, r...}, d], [a, ..., {b, r...}, c, d]
        loopObjects = (objs, vvar, vvarTxt) => {
          var acc, i, idx, j, len1, message, results1, vval;
          results1 = [];
          for (i = j = 0, len1 = objs.length; j < len1; i = ++j) {
            obj = objs[i];
            if (obj instanceof Elision) {
              // `Elision` can be skipped.
              continue;
            }
            // If `obj` is {a: 1}
            if (obj instanceof Assign && obj.context === 'object') {
              ({
                variable: {
                  base: idx
                },
                value: vvar
              } = obj);
              if (vvar instanceof Assign) {
                ({
                  variable: vvar
                } = vvar);
              }
              idx = vvar.this ? vvar.properties[0].name : new PropertyName(vvar.unwrap().value);
              acc = idx.unwrap() instanceof PropertyName;
              vval = new Value(value, [new (acc ? Access : Index)(idx)]);
            } else {
              // `obj` is [a...], {a...} or a
              vvar = (function() {
                switch (false) {
                  case !(obj instanceof Splat):
                    return new Value(obj.name);
                  default:
                    return obj;
                }
              })();
              vval = (function() {
                switch (false) {
                  case !(obj instanceof Splat):
                    return compSlice(vvarTxt, i);
                  default:
                    return new Value(new Literal(vvarTxt), [new Index(new NumberLiteral(i))]);
                }
              })();
            }
            message = isUnassignable(vvar.unwrap().value);
            if (message) {
              vvar.error(message);
            }
            results1.push(pushAssign(vvar, vval));
          }
          return results1;
        };
        // "Simple" `objects` can be split and compiled to arrays, [a, b, c] = arr, [a, b, c...] = arr
        assignObjects = (objs, vvar, vvarTxt) => {
          var vval;
          vvar = new Value(new Arr(objs, true));
          vval = vvarTxt instanceof Value ? vvarTxt : new Value(new Literal(vvarTxt));
          return pushAssign(vvar, vval);
        };
        processObjects = function(objs, vvar, vvarTxt) {
          if (complexObjects(objs)) {
            return loopObjects(objs, vvar, vvarTxt);
          } else {
            return assignObjects(objs, vvar, vvarTxt);
          }
        };
        // In case there is `Splat` or `Expansion` in `objects`,
        // we can split array in two simple subarrays.
        // `Splat` [a, b, c..., d, e] can be split into  [a, b, c...] and [d, e].
        // `Expansion` [a, b, ..., c, d] can be split into [a, b] and [c, d].
        // Examples:
        // a) `Splat`
        //   CS: [a, b, c..., d, e] = arr
        //   JS: [a, b, ...c] = arr, [d, e] = splice.call(c, -2)
        // b) `Expansion`
        //   CS: [a, b, ..., d, e] = arr
        //   JS: [a, b] = arr, [d, e] = slice.call(arr, -2)
        if (splatsAndExpans.length) {
          expIdx = splatsAndExpans[0];
          leftObjs = objects.slice(0, expIdx + (isSplat ? 1 : 0));
          rightObjs = objects.slice(expIdx + 1);
          if (leftObjs.length !== 0) {
            processObjects(leftObjs, vvar, vvarText);
          }
          if (rightObjs.length !== 0) {
            // Slice or splice `objects`.
            refExp = (function() {
              switch (false) {
                case !isSplat:
                  return compSplice(new Value(objects[expIdx].name), rightObjs.length * -1);
                case !isExpans:
                  return compSlice(vvarText, rightObjs.length * -1);
              }
            })();
            if (complexObjects(rightObjs)) {
              restVar = refExp;
              refExp = o.scope.freeVariable('ref');
              assigns.push([this.makeCode(refExp + ' = '), ...restVar.compileToFragments(o, LEVEL_LIST)]);
            }
            processObjects(rightObjs, vvar, refExp);
          }
        } else {
          // There is no `Splat` or `Expansion` in `objects`.
          processObjects(objects, vvar, vvarText);
        }
        if (typeof splatVarAssign === "function") {
          splatVarAssign();
        }
        if (!(top || this.subpattern)) {
          assigns.push(vvar);
        }
        fragments = this.joinFragmentArrays(assigns, ', ');
        if (o.level < LEVEL_LIST) {
          return fragments;
        } else {
          return this.wrapInParentheses(fragments);
        }
      }

      // Disallow `[...] = a` for some reason. (Could be equivalent to `[] = a`?)
      disallowLoneExpansion() {
        var loneObject, objects;
        if (!(this.variable.base instanceof Arr)) {
          return;
        }
        ({objects} = this.variable.base);
        if ((objects != null ? objects.length : void 0) !== 1) {
          return;
        }
        [loneObject] = objects;
        if (loneObject instanceof Expansion) {
          return loneObject.error('Destructuring assignment has no target');
        }
      }

      // Show error if there is more than one `Splat`, or `Expansion`.
      // Examples: [a, b, c..., d, e, f...], [a, b, ..., c, d, ...], [a, b, ..., c, d, e...]
      getAndCheckSplatsAndExpansions() {
        var expans, i, obj, objects, splats, splatsAndExpans;
        if (!(this.variable.base instanceof Arr)) {
          return {
            splats: [],
            expans: [],
            splatsAndExpans: []
          };
        }
        ({objects} = this.variable.base);
        // Count all `Splats`: [a, b, c..., d, e]
        splats = (function() {
          var j, len1, results1;
          results1 = [];
          for (i = j = 0, len1 = objects.length; j < len1; i = ++j) {
            obj = objects[i];
            if (obj instanceof Splat) {
              results1.push(i);
            }
          }
          return results1;
        })();
        // Count all `Expansions`: [a, b, ..., c, d]
        expans = (function() {
          var j, len1, results1;
          results1 = [];
          for (i = j = 0, len1 = objects.length; j < len1; i = ++j) {
            obj = objects[i];
            if (obj instanceof Expansion) {
              results1.push(i);
            }
          }
          return results1;
        })();
        // Combine splats and expansions.
        splatsAndExpans = [...splats, ...expans];
        if (splatsAndExpans.length > 1) {
          // Sort 'splatsAndExpans' so we can show error at first disallowed token.
          objects[splatsAndExpans.sort()[1]].error("multiple splats/expansions are disallowed in an assignment");
        }
        return {splats, expans, splatsAndExpans};
      }

      // When compiling a conditional assignment, take care to ensure that the
      // operands are only evaluated once, even though we have to reference them
      // more than once.
      compileConditional(o) {
        var fragments, left, right;
        [left, right] = this.variable.cacheReference(o);
        // Disallow conditional assignment of undefined variables.
        if (!left.properties.length && left.base instanceof Literal && !(left.base instanceof ThisLiteral) && !o.scope.check(left.base.value)) {
          this.throwUnassignableConditionalError(left.base.value);
        }
        if (indexOf.call(this.context, "?") >= 0) {
          o.isExistentialEquals = true;
          return new If(new Existence(left), right, {
            type: 'if'
          }).addElse(new Assign(right, this.value, '=')).compileToFragments(o);
        } else {
          fragments = new Op(this.context.slice(0, -1), left, new Assign(right, this.value, '=')).compileToFragments(o);
          if (o.level <= LEVEL_LIST) {
            return fragments;
          } else {
            return this.wrapInParentheses(fragments);
          }
        }
      }

      // Convert special math assignment operators like `a //= b` to the equivalent
      // extended form `a = a ** b` and then compiles that.
      compileSpecialMath(o) {
        var left, right;
        [left, right] = this.variable.cacheReference(o);
        return new Assign(left, new Op(this.context.slice(0, -1), right, this.value)).compileToFragments(o);
      }

      // Compile the assignment from an array splice literal, using JavaScript's
      // `Array#splice` method.
      compileSplice(o) {
        var answer, exclusive, from, fromDecl, fromRef, name, to, unwrappedVar, valDef, valRef;
        ({
          range: {from, to, exclusive}
        } = this.variable.properties.pop());
        unwrappedVar = this.variable.unwrapAll();
        if (unwrappedVar.comments) {
          moveComments(unwrappedVar, this);
          delete this.variable.comments;
        }
        name = this.variable.compile(o);
        if (from) {
          [fromDecl, fromRef] = this.cacheToCodeFragments(from.cache(o, LEVEL_OP));
        } else {
          fromDecl = fromRef = '0';
        }
        if (to) {
          if ((from != null ? from.isNumber() : void 0) && to.isNumber()) {
            to = to.compile(o) - fromRef;
            if (!exclusive) {
              to += 1;
            }
          } else {
            to = to.compile(o, LEVEL_ACCESS) + ' - ' + fromRef;
            if (!exclusive) {
              to += ' + 1';
            }
          }
        } else {
          to = "9e9";
        }
        [valDef, valRef] = this.value.cache(o, LEVEL_LIST);
        answer = [].concat(this.makeCode(`${utility('splice', o)}.apply(${name}, [${fromDecl}, ${to}].concat(`), valDef, this.makeCode(")), "), valRef);
        if (o.level > LEVEL_TOP) {
          return this.wrapInParentheses(answer);
        } else {
          return answer;
        }
      }

      eachName(iterator) {
        return this.variable.unwrapAll().eachName(iterator);
      }

      isDefaultAssignment() {
        return this.param || this.nestedLhs;
      }

      propagateLhs() {
        var ref1, ref2;
        if (!(((ref1 = this.variable) != null ? typeof ref1.isArray === "function" ? ref1.isArray() : void 0 : void 0) || ((ref2 = this.variable) != null ? typeof ref2.isObject === "function" ? ref2.isObject() : void 0 : void 0))) {
          return;
        }
        // This is the left-hand side of an assignment; let `Arr` and `Obj`
        // know that, so that those nodes know that they’re assignable as
        // destructured variables.
        return this.variable.base.propagateLhs(true);
      }

      throwUnassignableConditionalError(name) {
        return this.variable.error(`the variable \"${name}\" can't be assigned with ${this.context} because it has not been declared before`);
      }

      isConditional() {
        var ref1;
        return (ref1 = this.context) === '||=' || ref1 === '&&=' || ref1 === '?=';
      }

      astNode(o) {
        var variable;
        this.disallowLoneExpansion();
        this.getAndCheckSplatsAndExpansions();
        if (this.isConditional()) {
          variable = this.variable.unwrap();
          if (variable instanceof IdentifierLiteral && !o.scope.check(variable.value)) {
            this.throwUnassignableConditionalError(variable.value);
          }
        }
        this.addScopeVariables(o, {
          allowAssignmentToExpansion: true,
          allowAssignmentToNontrailingSplat: true,
          allowAssignmentToEmptyArray: true,
          allowAssignmentToComplexSplat: true
        });
        return super.astNode(o);
      }

      astType() {
        if (this.isDefaultAssignment()) {
          return 'AssignmentPattern';
        } else {
          return 'AssignmentExpression';
        }
      }

      astProperties(o) {
        var ref1, ret;
        ret = {
          right: this.value.ast(o, LEVEL_LIST),
          left: this.variable.ast(o, LEVEL_LIST)
        };
        if (!this.isDefaultAssignment()) {
          ret.operator = (ref1 = this.originalContext) != null ? ref1 : '=';
        }
        return ret;
      }

    };

    Assign.prototype.children = ['variable', 'value'];

    Assign.prototype.isAssignable = YES;

    Assign.prototype.isStatementAst = NO;

    return Assign;

  }).call(this);

  //### FuncGlyph
  exports.FuncGlyph = FuncGlyph = class FuncGlyph extends Base {
    constructor(glyph) {
      super();
      this.glyph = glyph;
    }

  };

  //### Code

  // A function definition. This is the only node that creates a new Scope.
  // When for the purposes of walking the contents of a function body, the Code
  // has no *children* -- they're within the inner scope.
  exports.Code = Code = (function() {
    class Code extends Base {
      constructor(params, body, funcGlyph, paramStart) {
        var ref1;
        super();
        this.funcGlyph = funcGlyph;
        this.paramStart = paramStart;
        this.params = params || [];
        this.body = body || new Block();
        this.bound = ((ref1 = this.funcGlyph) != null ? ref1.glyph : void 0) === '=>';
        this.isGenerator = false;
        this.isAsync = false;
        this.isMethod = false;
        this.body.traverseChildren(false, (node) => {
          if ((node instanceof Op && node.isYield()) || node instanceof YieldReturn) {
            this.isGenerator = true;
          }
          if ((node instanceof Op && node.isAwait()) || node instanceof AwaitReturn) {
            this.isAsync = true;
          }
          if (node instanceof For && node.isAwait()) {
            return this.isAsync = true;
          }
        });
        this.propagateLhs();
      }

      isStatement() {
        return this.isMethod;
      }

      makeScope(parentScope) {
        return new Scope(parentScope, this.body, this);
      }

      // Compilation creates a new scope unless explicitly asked to share with the
      // outer scope. Handles splat parameters in the parameter list by setting
      // such parameters to be the final parameter in the function definition, as
      // required per the ES2015 spec. If the CoffeeScript function definition had
      // parameters after the splat, they are declared via expressions in the
      // function body.
      compileNode(o) {
        var answer, body, boundMethodCheck, comment, condition, exprs, generatedVariables, haveBodyParam, haveSplatParam, i, ifTrue, j, k, l, len1, len2, len3, m, methodScope, modifiers, name, param, paramToAddToScope, params, paramsAfterSplat, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, scopeVariablesCount, signature, splatParamName, thisAssignments, wasEmpty, yieldNode;
        this.checkForAsyncOrGeneratorConstructor();
        if (this.bound) {
          if ((ref1 = o.scope.method) != null ? ref1.bound : void 0) {
            this.context = o.scope.method.context;
          }
          if (!this.context) {
            this.context = 'this';
          }
        }
        this.updateOptions(o);
        params = [];
        exprs = [];
        thisAssignments = (ref2 = (ref3 = this.thisAssignments) != null ? ref3.slice() : void 0) != null ? ref2 : [];
        paramsAfterSplat = [];
        haveSplatParam = false;
        haveBodyParam = false;
        this.checkForDuplicateParams();
        this.disallowLoneExpansionAndMultipleSplats();
        // Separate `this` assignments.
        this.eachParamName(function(name, node, param, obj) {
          var replacement, target;
          if (node.this) {
            name = node.properties[0].name.value;
            if (indexOf.call(JS_FORBIDDEN, name) >= 0) {
              name = `_${name}`;
            }
            target = new IdentifierLiteral(o.scope.freeVariable(name, {
              reserve: false
            }));
            // `Param` is object destructuring with a default value: ({@prop = 1}) ->
            // In a case when the variable name is already reserved, we have to assign
            // a new variable name to the destructured variable: ({prop:prop1 = 1}) ->
            replacement = param.name instanceof Obj && obj instanceof Assign && obj.operatorToken.value === '=' ? new Assign(new IdentifierLiteral(name), target, 'object') : target; //, operatorToken: new Literal ':'
            param.renameParam(node, replacement);
            return thisAssignments.push(new Assign(node, target));
          }
        });
        ref4 = this.params;
        // Parse the parameters, adding them to the list of parameters to put in the
        // function definition; and dealing with splats or expansions, including
        // adding expressions to the function body to declare all parameter
        // variables that would have been after the splat/expansion parameter.
        // If we encounter a parameter that needs to be declared in the function
        // body for any reason, for example it’s destructured with `this`, also
        // declare and assign all subsequent parameters in the function body so that
        // any non-idempotent parameters are evaluated in the correct order.
        for (i = j = 0, len1 = ref4.length; j < len1; i = ++j) {
          param = ref4[i];
          // Was `...` used with this parameter? Splat/expansion parameters cannot
          // have default values, so we need not worry about that.
          if (param.splat || param instanceof Expansion) {
            haveSplatParam = true;
            if (param.splat) {
              if (param.name instanceof Arr || param.name instanceof Obj) {
                // Splat arrays are treated oddly by ES; deal with them the legacy
                // way in the function body. TODO: Should this be handled in the
                // function parameter list, and if so, how?
                splatParamName = o.scope.freeVariable('arg');
                params.push(ref = new Value(new IdentifierLiteral(splatParamName)));
                exprs.push(new Assign(new Value(param.name), ref));
              } else {
                params.push(ref = param.asReference(o));
                splatParamName = fragmentsToText(ref.compileNodeWithoutComments(o));
              }
              if (param.shouldCache()) {
                exprs.push(new Assign(new Value(param.name), ref)); // `param` is an Expansion
              }
            } else {
              splatParamName = o.scope.freeVariable('args');
              params.push(new Value(new IdentifierLiteral(splatParamName)));
            }
            o.scope.parameter(splatParamName);
          } else {
            // Parse all other parameters; if a splat paramater has not yet been
            // encountered, add these other parameters to the list to be output in
            // the function definition.
            if (param.shouldCache() || haveBodyParam) {
              param.assignedInBody = true;
              haveBodyParam = true;
              // This parameter cannot be declared or assigned in the parameter
              // list. So put a reference in the parameter list and add a statement
              // to the function body assigning it, e.g.
              // `(arg) => { var a = arg.a; }`, with a default value if it has one.
              if (param.value != null) {
                condition = new Op('===', param, new UndefinedLiteral());
                ifTrue = new Assign(new Value(param.name), param.value);
                exprs.push(new If(condition, ifTrue));
              } else {
                exprs.push(new Assign(new Value(param.name), param.asReference(o), null, {
                  param: 'alwaysDeclare'
                }));
              }
            }
            // If this parameter comes before the splat or expansion, it will go
            // in the function definition parameter list.
            if (!haveSplatParam) {
              // If this parameter has a default value, and it hasn’t already been
              // set by the `shouldCache()` block above, define it as a statement in
              // the function body. This parameter comes after the splat parameter,
              // so we can’t define its default value in the parameter list.
              if (param.shouldCache()) {
                ref = param.asReference(o);
              } else {
                if ((param.value != null) && !param.assignedInBody) {
                  ref = new Assign(new Value(param.name), param.value, null, {
                    param: true
                  });
                } else {
                  ref = param;
                }
              }
              // Add this parameter’s reference(s) to the function scope.
              if (param.name instanceof Arr || param.name instanceof Obj) {
                // This parameter is destructured.
                param.name.lhs = true;
                if (!param.shouldCache()) {
                  param.name.eachName(function(prop) {
                    return o.scope.parameter(prop.value);
                  });
                }
              } else {
                // This compilation of the parameter is only to get its name to add
                // to the scope name tracking; since the compilation output here
                // isn’t kept for eventual output, don’t include comments in this
                // compilation, so that they get output the “real” time this param
                // is compiled.
                paramToAddToScope = param.value != null ? param : ref;
                o.scope.parameter(fragmentsToText(paramToAddToScope.compileToFragmentsWithoutComments(o)));
              }
              params.push(ref);
            } else {
              paramsAfterSplat.push(param);
              // If this parameter had a default value, since it’s no longer in the
              // function parameter list we need to assign its default value
              // (if necessary) as an expression in the body.
              if ((param.value != null) && !param.shouldCache()) {
                condition = new Op('===', param, new UndefinedLiteral());
                ifTrue = new Assign(new Value(param.name), param.value);
                exprs.push(new If(condition, ifTrue));
              }
              if (((ref5 = param.name) != null ? ref5.value : void 0) != null) {
                // Add this parameter to the scope, since it wouldn’t have been added
                // yet since it was skipped earlier.
                o.scope.add(param.name.value, 'var', true);
              }
            }
          }
        }
        // If there were parameters after the splat or expansion parameter, those
        // parameters need to be assigned in the body of the function.
        if (paramsAfterSplat.length !== 0) {
          // Create a destructured assignment, e.g. `[a, b, c] = [args..., b, c]`
          exprs.unshift(new Assign(new Value(new Arr([
            new Splat(new IdentifierLiteral(splatParamName)),
            ...((function() {
              var k,
            len2,
            results1;
              results1 = [];
              for (k = 0, len2 = paramsAfterSplat.length; k < len2; k++) {
                param = paramsAfterSplat[k];
                results1.push(param.asReference(o));
              }
              return results1;
            })())
          ])), new Value(new IdentifierLiteral(splatParamName))));
        }
        // Add new expressions to the function body
        wasEmpty = this.body.isEmpty();
        this.disallowSuperInParamDefaults();
        this.checkSuperCallsInConstructorBody();
        if (!this.expandCtorSuper(thisAssignments)) {
          this.body.expressions.unshift(...thisAssignments);
        }
        this.body.expressions.unshift(...exprs);
        if (this.isMethod && this.bound && !this.isStatic && this.classVariable) {
          boundMethodCheck = new Value(new Literal(utility('boundMethodCheck', o)));
          this.body.expressions.unshift(new Call(boundMethodCheck, [new Value(new ThisLiteral()), this.classVariable]));
        }
        if (!(wasEmpty || this.noReturn)) {
          this.body.makeReturn();
        }
        // JavaScript doesn’t allow bound (`=>`) functions to also be generators.
        // This is usually caught via `Op::compileContinuation`, but double-check:
        if (this.bound && this.isGenerator) {
          yieldNode = this.body.contains(function(node) {
            return node instanceof Op && node.operator === 'yield';
          });
          (yieldNode || this).error('yield cannot occur inside bound (fat arrow) functions');
        }
        // Assemble the output
        modifiers = [];
        if (this.isMethod && this.isStatic) {
          modifiers.push('static');
        }
        if (this.isAsync) {
          modifiers.push('async');
        }
        if (!(this.isMethod || this.bound)) {
          modifiers.push(`function${this.isGenerator ? '*' : ''}`);
        } else if (this.isGenerator) {
          modifiers.push('*');
        }
        signature = [this.makeCode('(')];
        // Block comments between a function name and `(` get output between
        // `function` and `(`.
        if (((ref6 = this.paramStart) != null ? ref6.comments : void 0) != null) {
          this.compileCommentFragments(o, this.paramStart, signature);
        }
        for (i = k = 0, len2 = params.length; k < len2; i = ++k) {
          param = params[i];
          if (i !== 0) {
            signature.push(this.makeCode(', '));
          }
          if (haveSplatParam && i === params.length - 1) {
            signature.push(this.makeCode('...'));
          }
          // Compile this parameter, but if any generated variables get created
          // (e.g. `ref`), shift those into the parent scope since we can’t put a
          // `var` line inside a function parameter list.
          scopeVariablesCount = o.scope.variables.length;
          signature.push(...param.compileToFragments(o, LEVEL_PAREN));
          if (scopeVariablesCount !== o.scope.variables.length) {
            generatedVariables = o.scope.variables.splice(scopeVariablesCount);
            o.scope.parent.variables.push(...generatedVariables);
          }
        }
        signature.push(this.makeCode(')'));
        // Block comments between `)` and `->`/`=>` get output between `)` and `{`.
        if (((ref7 = this.funcGlyph) != null ? ref7.comments : void 0) != null) {
          ref8 = this.funcGlyph.comments;
          for (l = 0, len3 = ref8.length; l < len3; l++) {
            comment = ref8[l];
            comment.unshift = false;
          }
          this.compileCommentFragments(o, this.funcGlyph, signature);
        }
        if (!this.body.isEmpty()) {
          body = this.body.compileWithDeclarations(o);
        }
        // We need to compile the body before method names to ensure `super`
        // references are handled.
        if (this.isMethod) {
          [methodScope, o.scope] = [o.scope, o.scope.parent];
          name = this.name.compileToFragments(o);
          if (name[0].code === '.') {
            name.shift();
          }
          o.scope = methodScope;
        }
        answer = this.joinFragmentArrays((function() {
          var len4, p, results1;
          results1 = [];
          for (p = 0, len4 = modifiers.length; p < len4; p++) {
            m = modifiers[p];
            results1.push(this.makeCode(m));
          }
          return results1;
        }).call(this), ' ');
        if (modifiers.length && name) {
          answer.push(this.makeCode(' '));
        }
        if (name) {
          answer.push(...name);
        }
        answer.push(...signature);
        if (this.bound && !this.isMethod) {
          answer.push(this.makeCode(' =>'));
        }
        answer.push(this.makeCode(' {'));
        if (body != null ? body.length : void 0) {
          answer.push(this.makeCode('\n'), ...body, this.makeCode(`\n${this.tab}`));
        }
        answer.push(this.makeCode('}'));
        if (this.isMethod) {
          return indentInitial(answer, this);
        }
        if (this.front || (o.level >= LEVEL_ACCESS)) {
          return this.wrapInParentheses(answer);
        } else {
          return answer;
        }
      }

      updateOptions(o) {
        o.scope = del(o, 'classScope') || this.makeScope(o.scope);
        o.scope.shared = del(o, 'sharedScope');
        o.indent += TAB;
        delete o.bare;
        return delete o.isExistentialEquals;
      }

      checkForDuplicateParams() {
        var paramNames;
        paramNames = [];
        return this.eachParamName(function(name, node, param) {
          if (indexOf.call(paramNames, name) >= 0) {
            node.error(`multiple parameters named '${name}'`);
          }
          return paramNames.push(name);
        });
      }

      eachParamName(iterator) {
        var j, len1, param, ref1, results1;
        ref1 = this.params;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          param = ref1[j];
          results1.push(param.eachName(iterator));
        }
        return results1;
      }

      // Short-circuit `traverseChildren` method to prevent it from crossing scope
      // boundaries unless `crossScope` is `true`.
      traverseChildren(crossScope, func) {
        if (crossScope) {
          return super.traverseChildren(crossScope, func);
        }
      }

      // Short-circuit `replaceInContext` method to prevent it from crossing context boundaries. Bound
      // functions have the same context.
      replaceInContext(child, replacement) {
        if (this.bound) {
          return super.replaceInContext(child, replacement);
        } else {
          return false;
        }
      }

      disallowSuperInParamDefaults({forAst} = {}) {
        if (!this.ctor) {
          return false;
        }
        return this.eachSuperCall(Block.wrap(this.params), function(superCall) {
          return superCall.error("'super' is not allowed in constructor parameter defaults");
        }, {
          checkForThisBeforeSuper: !forAst
        });
      }

      checkSuperCallsInConstructorBody() {
        var seenSuper;
        if (!this.ctor) {
          return false;
        }
        seenSuper = this.eachSuperCall(this.body, (superCall) => {
          if (this.ctor === 'base') {
            return superCall.error("'super' is only allowed in derived class constructors");
          }
        });
        return seenSuper;
      }

      flagThisParamInDerivedClassConstructorWithoutCallingSuper(param) {
        return param.error("Can't use @params in derived class constructors without calling super");
      }

      checkForAsyncOrGeneratorConstructor() {
        if (this.ctor) {
          if (this.isAsync) {
            this.name.error('Class constructor may not be async');
          }
          if (this.isGenerator) {
            return this.name.error('Class constructor may not be a generator');
          }
        }
      }

      disallowLoneExpansionAndMultipleSplats() {
        var j, len1, param, ref1, results1, seenSplatParam;
        seenSplatParam = false;
        ref1 = this.params;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          param = ref1[j];
          // Was `...` used with this parameter? (Only one such parameter is allowed
          // per function.)
          if (param.splat || param instanceof Expansion) {
            if (seenSplatParam) {
              param.error('only one splat or expansion parameter is allowed per function definition');
            } else if (param instanceof Expansion && this.params.length === 1) {
              param.error('an expansion parameter cannot be the only parameter in a function definition');
            }
            results1.push(seenSplatParam = true);
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }

      expandCtorSuper(thisAssignments) {
        var haveThisParam, param, ref1, seenSuper;
        if (!this.ctor) {
          return false;
        }
        seenSuper = this.eachSuperCall(this.body, (superCall) => {
          return superCall.expressions = thisAssignments;
        });
        haveThisParam = thisAssignments.length && thisAssignments.length !== ((ref1 = this.thisAssignments) != null ? ref1.length : void 0);
        if (this.ctor === 'derived' && !seenSuper && haveThisParam) {
          param = thisAssignments[0].variable;
          this.flagThisParamInDerivedClassConstructorWithoutCallingSuper(param);
        }
        return seenSuper;
      }

      // Find all super calls in the given context node;
      // returns `true` if `iterator` is called.
      eachSuperCall(context, iterator, {checkForThisBeforeSuper = true} = {}) {
        var seenSuper;
        seenSuper = false;
        context.traverseChildren(true, (child) => {
          var childArgs;
          if (child instanceof SuperCall) {
            // `super` in a constructor (the only `super` without an accessor)
            // cannot be given an argument with a reference to `this`, as that would
            // be referencing `this` before calling `super`.
            if (!child.variable.accessor) {
              childArgs = child.args.filter(function(arg) {
                return !(arg instanceof Class) && (!(arg instanceof Code) || arg.bound);
              });
              Block.wrap(childArgs).traverseChildren(true, (node) => {
                if (node.this) {
                  return node.error("Can't call super with @params in derived class constructors");
                }
              });
            }
            seenSuper = true;
            iterator(child);
          } else if (checkForThisBeforeSuper && child instanceof ThisLiteral && this.ctor === 'derived' && !seenSuper) {
            child.error("Can't reference 'this' before calling super in derived class constructors");
          }
          // `super` has the same target in bound (arrow) functions, so check them too
          return !(child instanceof SuperCall) && (!(child instanceof Code) || child.bound);
        });
        return seenSuper;
      }

      propagateLhs() {
        var j, len1, name, param, ref1, results1;
        ref1 = this.params;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          param = ref1[j];
          ({name} = param);
          if (name instanceof Arr || name instanceof Obj) {
            results1.push(name.propagateLhs(true));
          } else if (param instanceof Expansion) {
            results1.push(param.lhs = true);
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }

      astAddParamsToScope(o) {
        return this.eachParamName(function(name) {
          return o.scope.add(name, 'param');
        });
      }

      astNode(o) {
        var seenSuper;
        this.updateOptions(o);
        this.checkForAsyncOrGeneratorConstructor();
        this.checkForDuplicateParams();
        this.disallowSuperInParamDefaults({
          forAst: true
        });
        this.disallowLoneExpansionAndMultipleSplats();
        seenSuper = this.checkSuperCallsInConstructorBody();
        if (this.ctor === 'derived' && !seenSuper) {
          this.eachParamName((name, node) => {
            if (node.this) {
              return this.flagThisParamInDerivedClassConstructorWithoutCallingSuper(node);
            }
          });
        }
        this.astAddParamsToScope(o);
        if (!(this.body.isEmpty() || this.noReturn)) {
          this.body.makeReturn(null, true);
        }
        return super.astNode(o);
      }

      astType() {
        if (this.isMethod) {
          return 'ClassMethod';
        } else if (this.bound) {
          return 'ArrowFunctionExpression';
        } else {
          return 'FunctionExpression';
        }
      }

      paramForAst(param) {
        var name, splat, value;
        if (param instanceof Expansion) {
          return param;
        }
        ({name, value, splat} = param);
        if (splat) {
          return new Splat(name, {
            lhs: true,
            postfix: splat.postfix
          }).withLocationDataFrom(param);
        } else if (value != null) {
          return new Assign(name, value, null, {
            param: true
          }).withLocationDataFrom({
            locationData: mergeLocationData(name.locationData, value.locationData)
          });
        } else {
          return name;
        }
      }

      methodAstProperties(o) {
        var getIsComputed, ref1, ref2, ref3, ref4;
        getIsComputed = () => {
          if (this.name instanceof Index) {
            return true;
          }
          if (this.name instanceof ComputedPropertyName) {
            return true;
          }
          if (this.name.name instanceof ComputedPropertyName) {
            return true;
          }
          return false;
        };
        return {
          static: !!this.isStatic,
          key: this.name.ast(o),
          computed: getIsComputed(),
          kind: this.ctor ? 'constructor' : 'method',
          operator: (ref1 = (ref2 = this.operatorToken) != null ? ref2.value : void 0) != null ? ref1 : '=',
          staticClassName: (ref3 = (ref4 = this.isStatic.staticClassName) != null ? ref4.ast(o) : void 0) != null ? ref3 : null,
          bound: !!this.bound
        };
      }

      astProperties(o) {
        var param, ref1;
        return Object.assign({
          params: (function() {
            var j, len1, ref1, results1;
            ref1 = this.params;
            results1 = [];
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              param = ref1[j];
              results1.push(this.paramForAst(param).ast(o));
            }
            return results1;
          }).call(this),
          body: this.body.ast(Object.assign({}, o, {
            checkForDirectives: true
          }), LEVEL_TOP),
          generator: !!this.isGenerator,
          async: !!this.isAsync,
          // We never generate named functions, so specify `id` as `null`, which
          // matches the Babel AST for anonymous function expressions/arrow functions
          id: null,
          hasIndentedBody: this.body.locationData.first_line > ((ref1 = this.funcGlyph) != null ? ref1.locationData.first_line : void 0)
        }, this.isMethod ? this.methodAstProperties(o) : {});
      }

      astLocationData() {
        var astLocationData, functionLocationData;
        functionLocationData = super.astLocationData();
        if (!this.isMethod) {
          return functionLocationData;
        }
        astLocationData = mergeAstLocationData(this.name.astLocationData(), functionLocationData);
        if (this.isStatic.staticClassName != null) {
          astLocationData = mergeAstLocationData(this.isStatic.staticClassName.astLocationData(), astLocationData);
        }
        return astLocationData;
      }

    };

    Code.prototype.children = ['params', 'body'];

    Code.prototype.jumps = NO;

    return Code;

  }).call(this);

  //### Param

  // A parameter in a function definition. Beyond a typical JavaScript parameter,
  // these parameters can also attach themselves to the context of the function,
  // as well as be a splat, gathering up a group of parameters into an array.
  exports.Param = Param = (function() {
    class Param extends Base {
      constructor(name1, value1, splat1) {
        var message, token;
        super();
        this.name = name1;
        this.value = value1;
        this.splat = splat1;
        message = isUnassignable(this.name.unwrapAll().value);
        if (message) {
          this.name.error(message);
        }
        if (this.name instanceof Obj && this.name.generated) {
          token = this.name.objects[0].operatorToken;
          token.error(`unexpected ${token.value}`);
        }
      }

      compileToFragments(o) {
        return this.name.compileToFragments(o, LEVEL_LIST);
      }

      compileToFragmentsWithoutComments(o) {
        return this.name.compileToFragmentsWithoutComments(o, LEVEL_LIST);
      }

      asReference(o) {
        var name, node;
        if (this.reference) {
          return this.reference;
        }
        node = this.name;
        if (node.this) {
          name = node.properties[0].name.value;
          if (indexOf.call(JS_FORBIDDEN, name) >= 0) {
            name = `_${name}`;
          }
          node = new IdentifierLiteral(o.scope.freeVariable(name));
        } else if (node.shouldCache()) {
          node = new IdentifierLiteral(o.scope.freeVariable('arg'));
        }
        node = new Value(node);
        node.updateLocationDataIfMissing(this.locationData);
        return this.reference = node;
      }

      shouldCache() {
        return this.name.shouldCache();
      }

      // Iterates the name or names of a `Param`.
      // In a sense, a destructured parameter represents multiple JS parameters. This
      // method allows to iterate them all.
      // The `iterator` function will be called as `iterator(name, node)` where
      // `name` is the name of the parameter and `node` is the AST node corresponding
      // to that name.
      eachName(iterator, name = this.name) {
        var atParam, checkAssignabilityOfLiteral, j, len1, nObj, node, obj, ref1, ref2;
        checkAssignabilityOfLiteral = function(literal) {
          var message;
          message = isUnassignable(literal.value);
          if (message) {
            literal.error(message);
          }
          if (!literal.isAssignable()) {
            return literal.error(`'${literal.value}' can't be assigned`);
          }
        };
        atParam = (obj, originalObj = null) => {
          return iterator(`@${obj.properties[0].name.value}`, obj, this, originalObj);
        };
        if (name instanceof Call) {
          name.error("Function invocation can't be assigned");
        }
        // * simple literals `foo`
        if (name instanceof Literal) {
          checkAssignabilityOfLiteral(name);
          return iterator(name.value, name, this);
        }
        if (name instanceof Value) {
          // * at-params `@foo`
          return atParam(name);
        }
        ref2 = (ref1 = name.objects) != null ? ref1 : [];
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          obj = ref2[j];
          // Save original obj.
          nObj = obj;
          // * destructured parameter with default value
          if (obj instanceof Assign && (obj.context == null)) {
            obj = obj.variable;
          }
          // * assignments within destructured parameters `{foo:bar}`
          if (obj instanceof Assign) {
            // ... possibly with a default value
            if (obj.value instanceof Assign) {
              obj = obj.value.variable;
            } else {
              obj = obj.value;
            }
            this.eachName(iterator, obj.unwrap());
          // * splats within destructured parameters `[xs...]`
          } else if (obj instanceof Splat) {
            node = obj.name.unwrap();
            iterator(node.value, node, this);
          } else if (obj instanceof Value) {
            // * destructured parameters within destructured parameters `[{a}]`
            if (obj.isArray() || obj.isObject()) {
              this.eachName(iterator, obj.base);
            // * at-params within destructured parameters `{@foo}`
            } else if (obj.this) {
              atParam(obj, nObj);
            } else {
              // * simple destructured parameters {foo}
              checkAssignabilityOfLiteral(obj.base);
              iterator(obj.base.value, obj.base, this);
            }
          } else if (obj instanceof Elision) {
            obj;
          } else if (!(obj instanceof Expansion)) {
            obj.error(`illegal parameter ${obj.compile()}`);
          }
        }
      }

      // Rename a param by replacing the given AST node for a name with a new node.
      // This needs to ensure that the the source for object destructuring does not change.
      renameParam(node, newNode) {
        var isNode, replacement;
        isNode = function(candidate) {
          return candidate === node;
        };
        replacement = (node, parent) => {
          var key;
          if (parent instanceof Obj) {
            key = node;
            if (node.this) {
              key = node.properties[0].name;
            }
            // No need to assign a new variable for the destructured variable if the variable isn't reserved.
            // Examples:
            // `({@foo}) ->`  should compile to `({foo}) { this.foo = foo}`
            // `foo = 1; ({@foo}) ->` should compile to `foo = 1; ({foo:foo1}) { this.foo = foo1 }`
            if (node.this && key.value === newNode.value) {
              return new Value(newNode);
            } else {
              return new Assign(new Value(key), newNode, 'object');
            }
          } else {
            return newNode;
          }
        };
        return this.replaceInContext(isNode, replacement);
      }

    };

    Param.prototype.children = ['name', 'value'];

    return Param;

  }).call(this);

  //### Splat

  // A splat, either as a parameter to a function, an argument to a call,
  // or as part of a destructuring assignment.
  exports.Splat = Splat = (function() {
    class Splat extends Base {
      constructor(name, {
          lhs: lhs1,
          postfix: postfix = true
        } = {}) {
        super();
        this.lhs = lhs1;
        this.postfix = postfix;
        this.name = name.compile ? name : new Literal(name);
      }

      shouldCache() {
        return false;
      }

      isAssignable({allowComplexSplat = false} = {}) {
        if (this.name instanceof Obj || this.name instanceof Parens) {
          return allowComplexSplat;
        }
        return this.name.isAssignable() && (!this.name.isAtomic || this.name.isAtomic());
      }

      assigns(name) {
        return this.name.assigns(name);
      }

      compileNode(o) {
        var compiledSplat;
        compiledSplat = [this.makeCode('...'), ...this.name.compileToFragments(o, LEVEL_OP)];
        if (!this.jsx) {
          return compiledSplat;
        }
        return [this.makeCode('{'), ...compiledSplat, this.makeCode('}')];
      }

      unwrap() {
        return this.name;
      }

      propagateLhs(setLhs) {
        var base1;
        if (setLhs) {
          this.lhs = true;
        }
        if (!this.lhs) {
          return;
        }
        return typeof (base1 = this.name).propagateLhs === "function" ? base1.propagateLhs(true) : void 0;
      }

      astType() {
        if (this.jsx) {
          return 'JSXSpreadAttribute';
        } else if (this.lhs) {
          return 'RestElement';
        } else {
          return 'SpreadElement';
        }
      }

      astProperties(o) {
        return {
          argument: this.name.ast(o, LEVEL_OP),
          postfix: this.postfix
        };
      }

    };

    Splat.prototype.children = ['name'];

    return Splat;

  }).call(this);

  //### Expansion

  // Used to skip values inside an array destructuring (pattern matching) or
  // parameter list.
  exports.Expansion = Expansion = (function() {
    class Expansion extends Base {
      compileNode(o) {
        return this.throwLhsError();
      }

      asReference(o) {
        return this;
      }

      eachName(iterator) {}

      throwLhsError() {
        return this.error('Expansion must be used inside a destructuring assignment or parameter list');
      }

      astNode(o) {
        if (!this.lhs) {
          this.throwLhsError();
        }
        return super.astNode(o);
      }

      astType() {
        return 'RestElement';
      }

      astProperties() {
        return {
          argument: null
        };
      }

    };

    Expansion.prototype.shouldCache = NO;

    return Expansion;

  }).call(this);

  //### Elision

  // Array elision element (for example, [,a, , , b, , c, ,]).
  exports.Elision = Elision = (function() {
    class Elision extends Base {
      compileToFragments(o, level) {
        var fragment;
        fragment = super.compileToFragments(o, level);
        fragment.isElision = true;
        return fragment;
      }

      compileNode(o) {
        return [this.makeCode(', ')];
      }

      asReference(o) {
        return this;
      }

      eachName(iterator) {}

      astNode() {
        return null;
      }

    };

    Elision.prototype.isAssignable = YES;

    Elision.prototype.shouldCache = NO;

    return Elision;

  }).call(this);

  //### While

  // A while loop, the only sort of low-level loop exposed by CoffeeScript. From
  // it, all other loops can be manufactured. Useful in cases where you need more
  // flexibility or more speed than a comprehension can provide.
  exports.While = While = (function() {
    class While extends Base {
      constructor(condition1, {
          invert: inverted,
          guard,
          isLoop
        } = {}) {
        super();
        this.condition = condition1;
        this.inverted = inverted;
        this.guard = guard;
        this.isLoop = isLoop;
      }

      makeReturn(results, mark) {
        if (results) {
          return super.makeReturn(results, mark);
        }
        this.returns = !this.jumps();
        if (mark) {
          if (this.returns) {
            this.body.makeReturn(results, mark);
          }
          return;
        }
        return this;
      }

      addBody(body1) {
        this.body = body1;
        return this;
      }

      jumps() {
        var expressions, j, jumpNode, len1, node;
        ({expressions} = this.body);
        if (!expressions.length) {
          return false;
        }
        for (j = 0, len1 = expressions.length; j < len1; j++) {
          node = expressions[j];
          if (jumpNode = node.jumps({
            loop: true
          })) {
            return jumpNode;
          }
        }
        return false;
      }

      // The main difference from a JavaScript *while* is that the CoffeeScript
      // *while* can be used as a part of a larger expression -- while loops may
      // return an array containing the computed result of each iteration.
      compileNode(o) {
        var answer, body, rvar, set;
        o.indent += TAB;
        set = '';
        ({body} = this);
        if (body.isEmpty()) {
          body = this.makeCode('');
        } else {
          if (this.returns) {
            body.makeReturn(rvar = o.scope.freeVariable('results'));
            set = `${this.tab}${rvar} = [];\n`;
          }
          if (this.guard) {
            if (body.expressions.length > 1) {
              body.expressions.unshift(new If((new Parens(this.guard)).invert(), new StatementLiteral("continue")));
            } else {
              if (this.guard) {
                body = Block.wrap([new If(this.guard, body)]);
              }
            }
          }
          body = [].concat(this.makeCode("\n"), body.compileToFragments(o, LEVEL_TOP), this.makeCode(`\n${this.tab}`));
        }
        answer = [].concat(this.makeCode(set + this.tab + "while ("), this.processedCondition().compileToFragments(o, LEVEL_PAREN), this.makeCode(") {"), body, this.makeCode("}"));
        if (this.returns) {
          answer.push(this.makeCode(`\n${this.tab}return ${rvar};`));
        }
        return answer;
      }

      processedCondition() {
        return this.processedConditionCache != null ? this.processedConditionCache : this.processedConditionCache = this.inverted ? this.condition.invert() : this.condition;
      }

      astType() {
        return 'WhileStatement';
      }

      astProperties(o) {
        var ref1, ref2;
        return {
          test: this.condition.ast(o, LEVEL_PAREN),
          body: this.body.ast(o, LEVEL_TOP),
          guard: (ref1 = (ref2 = this.guard) != null ? ref2.ast(o) : void 0) != null ? ref1 : null,
          inverted: !!this.inverted,
          postfix: !!this.postfix,
          loop: !!this.isLoop
        };
      }

    };

    While.prototype.children = ['condition', 'guard', 'body'];

    While.prototype.isStatement = YES;

    return While;

  }).call(this);

  //### Op

  // Simple Arithmetic and logical operations. Performs some conversion from
  // CoffeeScript operations into their JavaScript equivalents.
  exports.Op = Op = (function() {
    var CONVERSIONS, INVERSIONS;

    class Op extends Base {
      constructor(op, first, second, flip, {invertOperator, originalOperator: originalOperator = op} = {}) {
        var call, firstCall, message, ref1, unwrapped;
        super();
        this.invertOperator = invertOperator;
        this.originalOperator = originalOperator;
        if (op === 'new') {
          if (((firstCall = unwrapped = first.unwrap()) instanceof Call || (firstCall = unwrapped.base) instanceof Call) && !firstCall.do && !firstCall.isNew) {
            return new Value(firstCall.newInstance(), firstCall === unwrapped ? [] : unwrapped.properties);
          }
          if (!(first instanceof Parens || first.unwrap() instanceof IdentifierLiteral || (typeof first.hasProperties === "function" ? first.hasProperties() : void 0))) {
            first = new Parens(first);
          }
          call = new Call(first, []);
          call.locationData = this.locationData;
          call.isNew = true;
          return call;
        }
        this.operator = CONVERSIONS[op] || op;
        this.first = first;
        this.second = second;
        this.flip = !!flip;
        if ((ref1 = this.operator) === '--' || ref1 === '++') {
          message = isUnassignable(this.first.unwrapAll().value);
          if (message) {
            this.first.error(message);
          }
        }
        return this;
      }

      isNumber() {
        var ref1;
        return this.isUnary() && ((ref1 = this.operator) === '+' || ref1 === '-') && this.first instanceof Value && this.first.isNumber();
      }

      isAwait() {
        return this.operator === 'await';
      }

      isYield() {
        var ref1;
        return (ref1 = this.operator) === 'yield' || ref1 === 'yield*';
      }

      isUnary() {
        return !this.second;
      }

      shouldCache() {
        return !this.isNumber();
      }

      // Am I capable of
      // [Python-style comparison chaining](https://docs.python.org/3/reference/expressions.html#not-in)?
      isChainable() {
        var ref1;
        return (ref1 = this.operator) === '<' || ref1 === '>' || ref1 === '>=' || ref1 === '<=' || ref1 === '===' || ref1 === '!==';
      }

      isChain() {
        return this.isChainable() && this.first.isChainable();
      }

      invert() {
        var allInvertable, curr, fst, op, ref1;
        if (this.isInOperator()) {
          this.invertOperator = '!';
          return this;
        }
        if (this.isChain()) {
          allInvertable = true;
          curr = this;
          while (curr && curr.operator) {
            allInvertable && (allInvertable = curr.operator in INVERSIONS);
            curr = curr.first;
          }
          if (!allInvertable) {
            return new Parens(this).invert();
          }
          curr = this;
          while (curr && curr.operator) {
            curr.invert = !curr.invert;
            curr.operator = INVERSIONS[curr.operator];
            curr = curr.first;
          }
          return this;
        } else if (op = INVERSIONS[this.operator]) {
          this.operator = op;
          if (this.first.unwrap() instanceof Op) {
            this.first.invert();
          }
          return this;
        } else if (this.second) {
          return new Parens(this).invert();
        } else if (this.operator === '!' && (fst = this.first.unwrap()) instanceof Op && ((ref1 = fst.operator) === '!' || ref1 === 'in' || ref1 === 'instanceof')) {
          return fst;
        } else {
          return new Op('!', this);
        }
      }

      unfoldSoak(o) {
        var ref1;
        return ((ref1 = this.operator) === '++' || ref1 === '--' || ref1 === 'delete') && unfoldSoak(o, this, 'first');
      }

      generateDo(exp) {
        var call, func, j, len1, param, passedParams, ref, ref1;
        passedParams = [];
        func = exp instanceof Assign && (ref = exp.value.unwrap()) instanceof Code ? ref : exp;
        ref1 = func.params || [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          param = ref1[j];
          if (param.value) {
            passedParams.push(param.value);
            delete param.value;
          } else {
            passedParams.push(param);
          }
        }
        call = new Call(exp, passedParams);
        call.do = true;
        return call;
      }

      isInOperator() {
        return this.originalOperator === 'in';
      }

      compileNode(o) {
        var answer, inNode, isChain, lhs, rhs;
        if (this.isInOperator()) {
          inNode = new In(this.first, this.second);
          return (this.invertOperator ? inNode.invert() : inNode).compileNode(o);
        }
        if (this.invertOperator) {
          this.invertOperator = null;
          return this.invert().compileNode(o);
        }
        if (this.operator === 'do') {
          return Op.prototype.generateDo(this.first).compileNode(o);
        }
        isChain = this.isChain();
        if (!isChain) {
          // In chains, there's no need to wrap bare obj literals in parens,
          // as the chained expression is wrapped.
          this.first.front = this.front;
        }
        this.checkDeleteOperand(o);
        if (this.isYield() || this.isAwait()) {
          return this.compileContinuation(o);
        }
        if (this.isUnary()) {
          return this.compileUnary(o);
        }
        if (isChain) {
          return this.compileChain(o);
        }
        switch (this.operator) {
          case '?':
            return this.compileExistence(o, this.second.isDefaultValue);
          case '//':
            return this.compileFloorDivision(o);
          case '%%':
            return this.compileModulo(o);
          default:
            lhs = this.first.compileToFragments(o, LEVEL_OP);
            rhs = this.second.compileToFragments(o, LEVEL_OP);
            answer = [].concat(lhs, this.makeCode(` ${this.operator} `), rhs);
            if (o.level <= LEVEL_OP) {
              return answer;
            } else {
              return this.wrapInParentheses(answer);
            }
        }
      }

      // Mimic Python's chained comparisons when multiple comparison operators are
      // used sequentially. For example:

      //     bin/coffee -e 'console.log 50 < 65 > 10'
      //     true
      compileChain(o) {
        var fragments, fst, shared;
        [this.first.second, shared] = this.first.second.cache(o);
        fst = this.first.compileToFragments(o, LEVEL_OP);
        fragments = fst.concat(this.makeCode(` ${this.invert ? '&&' : '||'} `), shared.compileToFragments(o), this.makeCode(` ${this.operator} `), this.second.compileToFragments(o, LEVEL_OP));
        return this.wrapInParentheses(fragments);
      }

      // Keep reference to the left expression, unless this an existential assignment
      compileExistence(o, checkOnlyUndefined) {
        var fst, ref;
        if (this.first.shouldCache()) {
          ref = new IdentifierLiteral(o.scope.freeVariable('ref'));
          fst = new Parens(new Assign(ref, this.first));
        } else {
          fst = this.first;
          ref = fst;
        }
        return new If(new Existence(fst, checkOnlyUndefined), ref, {
          type: 'if'
        }).addElse(this.second).compileToFragments(o);
      }

      // Compile a unary **Op**.
      compileUnary(o) {
        var op, parts, plusMinus;
        parts = [];
        op = this.operator;
        parts.push([this.makeCode(op)]);
        if (op === '!' && this.first instanceof Existence) {
          this.first.negated = !this.first.negated;
          return this.first.compileToFragments(o);
        }
        if (o.level >= LEVEL_ACCESS) {
          return (new Parens(this)).compileToFragments(o);
        }
        plusMinus = op === '+' || op === '-';
        if ((op === 'typeof' || op === 'delete') || plusMinus && this.first instanceof Op && this.first.operator === op) {
          parts.push([this.makeCode(' ')]);
        }
        if (plusMinus && this.first instanceof Op) {
          this.first = new Parens(this.first);
        }
        parts.push(this.first.compileToFragments(o, LEVEL_OP));
        if (this.flip) {
          parts.reverse();
        }
        return this.joinFragmentArrays(parts, '');
      }

      compileContinuation(o) {
        var op, parts, ref1;
        parts = [];
        op = this.operator;
        if (!this.isAwait()) {
          this.checkContinuation(o);
        }
        if (indexOf.call(Object.keys(this.first), 'expression') >= 0 && !(this.first instanceof Throw)) {
          if (this.first.expression != null) {
            parts.push(this.first.expression.compileToFragments(o, LEVEL_OP));
          }
        } else {
          if (o.level >= LEVEL_PAREN) {
            parts.push([this.makeCode("(")]);
          }
          parts.push([this.makeCode(op)]);
          if (((ref1 = this.first.base) != null ? ref1.value : void 0) !== '') {
            parts.push([this.makeCode(" ")]);
          }
          parts.push(this.first.compileToFragments(o, LEVEL_OP));
          if (o.level >= LEVEL_PAREN) {
            parts.push([this.makeCode(")")]);
          }
        }
        return this.joinFragmentArrays(parts, '');
      }

      checkContinuation(o) {
        var ref1;
        if (o.scope.parent == null) {
          this.error(`${this.operator} can only occur inside functions`);
        }
        if (((ref1 = o.scope.method) != null ? ref1.bound : void 0) && o.scope.method.isGenerator) {
          return this.error('yield cannot occur inside bound (fat arrow) functions');
        }
      }

      compileFloorDivision(o) {
        var div, floor, second;
        floor = new Value(new IdentifierLiteral('Math'), [new Access(new PropertyName('floor'))]);
        second = this.second.shouldCache() ? new Parens(this.second) : this.second;
        div = new Op('/', this.first, second);
        return new Call(floor, [div]).compileToFragments(o);
      }

      compileModulo(o) {
        var mod;
        mod = new Value(new Literal(utility('modulo', o)));
        return new Call(mod, [this.first, this.second]).compileToFragments(o);
      }

      toString(idt) {
        return super.toString(idt, this.constructor.name + ' ' + this.operator);
      }

      checkDeleteOperand(o) {
        if (this.operator === 'delete' && o.scope.check(this.first.unwrapAll().value)) {
          return this.error('delete operand may not be argument or var');
        }
      }

      astNode(o) {
        if (this.isYield()) {
          this.checkContinuation(o);
        }
        this.checkDeleteOperand(o);
        return super.astNode(o);
      }

      astType() {
        if (this.isAwait()) {
          return 'AwaitExpression';
        }
        if (this.isYield()) {
          return 'YieldExpression';
        }
        if (this.isChain()) {
          return 'ChainedComparison';
        }
        switch (this.operator) {
          case '||':
          case '&&':
          case '?':
            return 'LogicalExpression';
          case '++':
          case '--':
            return 'UpdateExpression';
          default:
            if (this.isUnary()) {
              return 'UnaryExpression';
            } else {
              return 'BinaryExpression';
            }
        }
      }

      operatorAst() {
        return `${this.invertOperator ? `${this.invertOperator} ` : ''}${this.originalOperator}`;
      }

      chainAstProperties(o) {
        var currentOp, operand, operands, operators;
        operators = [this.operatorAst()];
        operands = [this.second];
        currentOp = this.first;
        while (true) {
          operators.unshift(currentOp.operatorAst());
          operands.unshift(currentOp.second);
          currentOp = currentOp.first;
          if (!currentOp.isChainable()) {
            operands.unshift(currentOp);
            break;
          }
        }
        return {
          operators,
          operands: (function() {
            var j, len1, results1;
            results1 = [];
            for (j = 0, len1 = operands.length; j < len1; j++) {
              operand = operands[j];
              results1.push(operand.ast(o, LEVEL_OP));
            }
            return results1;
          })()
        };
      }

      astProperties(o) {
        var argument, firstAst, operatorAst, ref1, secondAst;
        if (this.isChain()) {
          return this.chainAstProperties(o);
        }
        firstAst = this.first.ast(o, LEVEL_OP);
        secondAst = (ref1 = this.second) != null ? ref1.ast(o, LEVEL_OP) : void 0;
        operatorAst = this.operatorAst();
        switch (false) {
          case !this.isUnary():
            argument = this.isYield() && this.first.unwrap().value === '' ? null : firstAst;
            if (this.isAwait()) {
              return {argument};
            }
            if (this.isYield()) {
              return {
                argument,
                delegate: this.operator === 'yield*'
              };
            }
            return {
              argument,
              operator: operatorAst,
              prefix: !this.flip
            };
          default:
            return {
              left: firstAst,
              right: secondAst,
              operator: operatorAst
            };
        }
      }

    };

    // The map of conversions from CoffeeScript to JavaScript symbols.
    CONVERSIONS = {
      '==': '===',
      '!=': '!==',
      'of': 'in',
      'yieldfrom': 'yield*'
    };

    // The map of invertible operators.
    INVERSIONS = {
      '!==': '===',
      '===': '!=='
    };

    Op.prototype.children = ['first', 'second'];

    return Op;

  }).call(this);

  //### In
  exports.In = In = (function() {
    class In extends Base {
      constructor(object1, array) {
        super();
        this.object = object1;
        this.array = array;
      }

      compileNode(o) {
        var hasSplat, j, len1, obj, ref1;
        if (this.array instanceof Value && this.array.isArray() && this.array.base.objects.length) {
          ref1 = this.array.base.objects;
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            obj = ref1[j];
            if (!(obj instanceof Splat)) {
              continue;
            }
            hasSplat = true;
            break;
          }
          if (!hasSplat) {
            // `compileOrTest` only if we have an array literal with no splats
            return this.compileOrTest(o);
          }
        }
        return this.compileLoopTest(o);
      }

      compileOrTest(o) {
        var cmp, cnj, i, item, j, len1, ref, ref1, sub, tests;
        [sub, ref] = this.object.cache(o, LEVEL_OP);
        [cmp, cnj] = this.negated ? [' !== ', ' && '] : [' === ', ' || '];
        tests = [];
        ref1 = this.array.base.objects;
        for (i = j = 0, len1 = ref1.length; j < len1; i = ++j) {
          item = ref1[i];
          if (i) {
            tests.push(this.makeCode(cnj));
          }
          tests = tests.concat((i ? ref : sub), this.makeCode(cmp), item.compileToFragments(o, LEVEL_ACCESS));
        }
        if (o.level < LEVEL_OP) {
          return tests;
        } else {
          return this.wrapInParentheses(tests);
        }
      }

      compileLoopTest(o) {
        var fragments, ref, sub;
        [sub, ref] = this.object.cache(o, LEVEL_LIST);
        fragments = [].concat(this.makeCode(utility('indexOf', o) + ".call("), this.array.compileToFragments(o, LEVEL_LIST), this.makeCode(", "), ref, this.makeCode(") " + (this.negated ? '< 0' : '>= 0')));
        if (fragmentsToText(sub) === fragmentsToText(ref)) {
          return fragments;
        }
        fragments = sub.concat(this.makeCode(', '), fragments);
        if (o.level < LEVEL_LIST) {
          return fragments;
        } else {
          return this.wrapInParentheses(fragments);
        }
      }

      toString(idt) {
        return super.toString(idt, this.constructor.name + (this.negated ? '!' : ''));
      }

    };

    In.prototype.children = ['object', 'array'];

    In.prototype.invert = NEGATE;

    return In;

  }).call(this);

  //### Try

  // A classic *try/catch/finally* block.
  exports.Try = Try = (function() {
    class Try extends Base {
      constructor(attempt, _catch, ensure, finallyTag) {
        super();
        this.attempt = attempt;
        this.catch = _catch;
        this.ensure = ensure;
        this.finallyTag = finallyTag;
      }

      jumps(o) {
        var ref1;
        return this.attempt.jumps(o) || ((ref1 = this.catch) != null ? ref1.jumps(o) : void 0);
      }

      makeReturn(results, mark) {
        var ref1, ref2;
        if (mark) {
          if ((ref1 = this.attempt) != null) {
            ref1.makeReturn(results, mark);
          }
          if ((ref2 = this.catch) != null) {
            ref2.makeReturn(results, mark);
          }
          return;
        }
        if (this.attempt) {
          this.attempt = this.attempt.makeReturn(results);
        }
        if (this.catch) {
          this.catch = this.catch.makeReturn(results);
        }
        return this;
      }

      // Compilation is more or less as you would expect -- the *finally* clause
      // is optional, the *catch* is not.
      compileNode(o) {
        var catchPart, ensurePart, generatedErrorVariableName, originalIndent, tryPart;
        originalIndent = o.indent;
        o.indent += TAB;
        tryPart = this.attempt.compileToFragments(o, LEVEL_TOP);
        catchPart = this.catch ? this.catch.compileToFragments(merge(o, {
          indent: originalIndent
        }), LEVEL_TOP) : !(this.ensure || this.catch) ? (generatedErrorVariableName = o.scope.freeVariable('error', {
          reserve: false
        }), [this.makeCode(` catch (${generatedErrorVariableName}) {}`)]) : [];
        ensurePart = this.ensure ? [].concat(this.makeCode(" finally {\n"), this.ensure.compileToFragments(o, LEVEL_TOP), this.makeCode(`\n${this.tab}}`)) : [];
        return [].concat(this.makeCode(`${this.tab}try {\n`), tryPart, this.makeCode(`\n${this.tab}}`), catchPart, ensurePart);
      }

      astType() {
        return 'TryStatement';
      }

      astProperties(o) {
        var ref1, ref2;
        return {
          block: this.attempt.ast(o, LEVEL_TOP),
          handler: (ref1 = (ref2 = this.catch) != null ? ref2.ast(o) : void 0) != null ? ref1 : null,
          // Include `finally` keyword in location data.
          finalizer: this.ensure != null ? Object.assign(this.ensure.ast(o, LEVEL_TOP), mergeAstLocationData(jisonLocationDataToAstLocationData(this.finallyTag.locationData), this.ensure.astLocationData())) : null
        };
      }

    };

    Try.prototype.children = ['attempt', 'catch', 'ensure'];

    Try.prototype.isStatement = YES;

    return Try;

  }).call(this);

  exports.Catch = Catch = (function() {
    class Catch extends Base {
      constructor(recovery, errorVariable) {
        var base1, ref1;
        super();
        this.recovery = recovery;
        this.errorVariable = errorVariable;
        if ((ref1 = this.errorVariable) != null) {
          if (typeof (base1 = ref1.unwrap()).propagateLhs === "function") {
            base1.propagateLhs(true);
          }
        }
      }

      jumps(o) {
        return this.recovery.jumps(o);
      }

      makeReturn(results, mark) {
        var ret;
        ret = this.recovery.makeReturn(results, mark);
        if (mark) {
          return;
        }
        this.recovery = ret;
        return this;
      }

      compileNode(o) {
        var generatedErrorVariableName, placeholder;
        o.indent += TAB;
        generatedErrorVariableName = o.scope.freeVariable('error', {
          reserve: false
        });
        placeholder = new IdentifierLiteral(generatedErrorVariableName);
        this.checkUnassignable();
        if (this.errorVariable) {
          this.recovery.unshift(new Assign(this.errorVariable, placeholder));
        }
        return [].concat(this.makeCode(" catch ("), placeholder.compileToFragments(o), this.makeCode(") {\n"), this.recovery.compileToFragments(o, LEVEL_TOP), this.makeCode(`\n${this.tab}}`));
      }

      checkUnassignable() {
        var message;
        if (this.errorVariable) {
          message = isUnassignable(this.errorVariable.unwrapAll().value);
          if (message) {
            return this.errorVariable.error(message);
          }
        }
      }

      astNode(o) {
        var ref1;
        this.checkUnassignable();
        if ((ref1 = this.errorVariable) != null) {
          ref1.eachName(function(name) {
            var alreadyDeclared;
            alreadyDeclared = o.scope.find(name.value);
            return name.isDeclaration = !alreadyDeclared;
          });
        }
        return super.astNode(o);
      }

      astType() {
        return 'CatchClause';
      }

      astProperties(o) {
        var ref1, ref2;
        return {
          param: (ref1 = (ref2 = this.errorVariable) != null ? ref2.ast(o) : void 0) != null ? ref1 : null,
          body: this.recovery.ast(o, LEVEL_TOP)
        };
      }

    };

    Catch.prototype.children = ['recovery', 'errorVariable'];

    Catch.prototype.isStatement = YES;

    return Catch;

  }).call(this);

  //### Throw

  // Simple node to throw an exception.
  exports.Throw = Throw = (function() {
    class Throw extends Base {
      constructor(expression1) {
        super();
        this.expression = expression1;
      }

      compileNode(o) {
        var fragments;
        fragments = this.expression.compileToFragments(o, LEVEL_LIST);
        unshiftAfterComments(fragments, this.makeCode('throw '));
        fragments.unshift(this.makeCode(this.tab));
        fragments.push(this.makeCode(';'));
        return fragments;
      }

      astType() {
        return 'ThrowStatement';
      }

      astProperties(o) {
        return {
          argument: this.expression.ast(o, LEVEL_LIST)
        };
      }

    };

    Throw.prototype.children = ['expression'];

    Throw.prototype.isStatement = YES;

    Throw.prototype.jumps = NO;

    // A **Throw** is already a return, of sorts...
    Throw.prototype.makeReturn = THIS;

    return Throw;

  }).call(this);

  //### Existence

  // Checks a variable for existence -- not `null` and not `undefined`. This is
  // similar to `.nil?` in Ruby, and avoids having to consult a JavaScript truth
  // table. Optionally only check if a variable is not `undefined`.
  exports.Existence = Existence = (function() {
    class Existence extends Base {
      constructor(expression1, onlyNotUndefined = false) {
        var salvagedComments;
        super();
        this.expression = expression1;
        this.comparisonTarget = onlyNotUndefined ? 'undefined' : 'null';
        salvagedComments = [];
        this.expression.traverseChildren(true, function(child) {
          var comment, j, len1, ref1;
          if (child.comments) {
            ref1 = child.comments;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              comment = ref1[j];
              if (indexOf.call(salvagedComments, comment) < 0) {
                salvagedComments.push(comment);
              }
            }
            return delete child.comments;
          }
        });
        attachCommentsToNode(salvagedComments, this);
        moveComments(this.expression, this);
      }

      compileNode(o) {
        var cmp, cnj, code;
        this.expression.front = this.front;
        code = this.expression.compile(o, LEVEL_OP);
        if (this.expression.unwrap() instanceof IdentifierLiteral && !o.scope.check(code)) {
          [cmp, cnj] = this.negated ? ['===', '||'] : ['!==', '&&'];
          code = `typeof ${code} ${cmp} \"undefined\"` + (this.comparisonTarget !== 'undefined' ? ` ${cnj} ${code} ${cmp} ${this.comparisonTarget}` : '');
        } else {
          // We explicity want to use loose equality (`==`) when comparing against `null`,
          // so that an existence check roughly corresponds to a check for truthiness.
          // Do *not* change this to `===` for `null`, as this will break mountains of
          // existing code. When comparing only against `undefined`, however, we want to
          // use `===` because this use case is for parity with ES2015+ default values,
          // which only get assigned when the variable is `undefined` (but not `null`).
          cmp = this.comparisonTarget === 'null' ? this.negated ? '==' : '!=' : this.negated ? '===' : '!=='; // `undefined`
          code = `${code} ${cmp} ${this.comparisonTarget}`;
        }
        return [this.makeCode(o.level <= LEVEL_COND ? code : `(${code})`)];
      }

      astType() {
        return 'UnaryExpression';
      }

      astProperties(o) {
        return {
          argument: this.expression.ast(o),
          operator: '?',
          prefix: false
        };
      }

    };

    Existence.prototype.children = ['expression'];

    Existence.prototype.invert = NEGATE;

    return Existence;

  }).call(this);

  //### Parens

  // An extra set of parentheses, specified explicitly in the source. At one time
  // we tried to clean up the results by detecting and removing redundant
  // parentheses, but no longer -- you can put in as many as you please.

  // Parentheses are a good way to force any statement to become an expression.
  exports.Parens = Parens = (function() {
    class Parens extends Base {
      constructor(body1) {
        super();
        this.body = body1;
      }

      unwrap() {
        return this.body;
      }

      shouldCache() {
        return this.body.shouldCache();
      }

      compileNode(o) {
        var bare, expr, fragments, ref1, shouldWrapComment;
        expr = this.body.unwrap();
        // If these parentheses are wrapping an `IdentifierLiteral` followed by a
        // block comment, output the parentheses (or put another way, don’t optimize
        // away these redundant parentheses). This is because Flow requires
        // parentheses in certain circumstances to distinguish identifiers followed
        // by comment-based type annotations from JavaScript labels.
        shouldWrapComment = (ref1 = expr.comments) != null ? ref1.some(function(comment) {
          return comment.here && !comment.unshift && !comment.newLine;
        }) : void 0;
        if (expr instanceof Value && expr.isAtomic() && !this.jsxAttribute && !shouldWrapComment) {
          expr.front = this.front;
          return expr.compileToFragments(o);
        }
        fragments = expr.compileToFragments(o, LEVEL_PAREN);
        bare = o.level < LEVEL_OP && !shouldWrapComment && (expr instanceof Op && !expr.isInOperator() || expr.unwrap() instanceof Call || (expr instanceof For && expr.returns)) && (o.level < LEVEL_COND || fragments.length <= 3);
        if (this.jsxAttribute) {
          return this.wrapInBraces(fragments);
        }
        if (bare) {
          return fragments;
        } else {
          return this.wrapInParentheses(fragments);
        }
      }

      astNode(o) {
        return this.body.unwrap().ast(o, LEVEL_PAREN);
      }

    };

    Parens.prototype.children = ['body'];

    return Parens;

  }).call(this);

  //### StringWithInterpolations
  exports.StringWithInterpolations = StringWithInterpolations = (function() {
    class StringWithInterpolations extends Base {
      constructor(body1, {quote, startQuote, jsxAttribute} = {}) {
        super();
        this.body = body1;
        this.quote = quote;
        this.startQuote = startQuote;
        this.jsxAttribute = jsxAttribute;
      }

      static fromStringLiteral(stringLiteral) {
        var updatedString, updatedStringValue;
        updatedString = stringLiteral.withoutQuotesInLocationData();
        updatedStringValue = new Value(updatedString).withLocationDataFrom(updatedString);
        return new StringWithInterpolations(Block.wrap([updatedStringValue]), {
          quote: stringLiteral.quote,
          jsxAttribute: stringLiteral.jsxAttribute
        }).withLocationDataFrom(stringLiteral);
      }

      // `unwrap` returns `this` to stop ancestor nodes reaching in to grab @body,
      // and using @body.compileNode. `StringWithInterpolations.compileNode` is
      // _the_ custom logic to output interpolated strings as code.
      unwrap() {
        return this;
      }

      shouldCache() {
        return this.body.shouldCache();
      }

      extractElements(o, {includeInterpolationWrappers, isJsx} = {}) {
        var elements, expr, salvagedComments;
        // Assumes that `expr` is `Block`
        expr = this.body.unwrap();
        elements = [];
        salvagedComments = [];
        expr.traverseChildren(false, (node) => {
          var comment, commentPlaceholder, empty, j, k, len1, len2, ref1, ref2, ref3, unwrapped;
          if (node instanceof StringLiteral) {
            if (node.comments) {
              salvagedComments.push(...node.comments);
              delete node.comments;
            }
            elements.push(node);
            return true;
          } else if (node instanceof Interpolation) {
            if (salvagedComments.length !== 0) {
              for (j = 0, len1 = salvagedComments.length; j < len1; j++) {
                comment = salvagedComments[j];
                comment.unshift = true;
                comment.newLine = true;
              }
              attachCommentsToNode(salvagedComments, node);
            }
            if ((unwrapped = (ref1 = node.expression) != null ? ref1.unwrapAll() : void 0) instanceof PassthroughLiteral && unwrapped.generated && !(isJsx && o.compiling)) {
              if (o.compiling) {
                commentPlaceholder = new StringLiteral('').withLocationDataFrom(node);
                commentPlaceholder.comments = unwrapped.comments;
                if (node.comments) {
                  (commentPlaceholder.comments != null ? commentPlaceholder.comments : commentPlaceholder.comments = []).push(...node.comments);
                }
                elements.push(new Value(commentPlaceholder));
              } else {
                empty = new Interpolation().withLocationDataFrom(node);
                empty.comments = node.comments;
                elements.push(empty);
              }
            } else if (node.expression || includeInterpolationWrappers) {
              if (node.comments) {
                ((ref2 = node.expression) != null ? ref2.comments != null ? ref2.comments : ref2.comments = [] : void 0).push(...node.comments);
              }
              elements.push(includeInterpolationWrappers ? node : node.expression);
            }
            return false;
          } else if (node.comments) {
            // This node is getting discarded, but salvage its comments.
            if (elements.length !== 0 && !(elements[elements.length - 1] instanceof StringLiteral)) {
              ref3 = node.comments;
              for (k = 0, len2 = ref3.length; k < len2; k++) {
                comment = ref3[k];
                comment.unshift = false;
                comment.newLine = true;
              }
              attachCommentsToNode(node.comments, elements[elements.length - 1]);
            } else {
              salvagedComments.push(...node.comments);
            }
            delete node.comments;
          }
          return true;
        });
        return elements;
      }

      compileNode(o) {
        var code, element, elements, fragments, j, len1, ref1, unquotedElementValue, wrapped;
        if (this.comments == null) {
          this.comments = (ref1 = this.startQuote) != null ? ref1.comments : void 0;
        }
        if (this.jsxAttribute) {
          wrapped = new Parens(new StringWithInterpolations(this.body));
          wrapped.jsxAttribute = true;
          return wrapped.compileNode(o);
        }
        elements = this.extractElements(o, {
          isJsx: this.jsx
        });
        fragments = [];
        if (!this.jsx) {
          fragments.push(this.makeCode('`'));
        }
        for (j = 0, len1 = elements.length; j < len1; j++) {
          element = elements[j];
          if (element instanceof StringLiteral) {
            unquotedElementValue = this.jsx ? element.unquotedValueForJSX : element.unquotedValueForTemplateLiteral;
            fragments.push(this.makeCode(unquotedElementValue));
          } else {
            if (!this.jsx) {
              fragments.push(this.makeCode('$'));
            }
            code = element.compileToFragments(o, LEVEL_PAREN);
            if (!this.isNestedTag(element) || code.some(function(fragment) {
              var ref2;
              return (ref2 = fragment.comments) != null ? ref2.some(function(comment) {
                return comment.here === false;
              }) : void 0;
            })) {
              code = this.wrapInBraces(code);
              // Flag the `{` and `}` fragments as having been generated by this
              // `StringWithInterpolations` node, so that `compileComments` knows
              // to treat them as bounds. But the braces are unnecessary if all of
              // the enclosed comments are `/* */` comments. Don’t trust
              // `fragment.type`, which can report minified variable names when
              // this compiler is minified.
              code[0].isStringWithInterpolations = true;
              code[code.length - 1].isStringWithInterpolations = true;
            }
            fragments.push(...code);
          }
        }
        if (!this.jsx) {
          fragments.push(this.makeCode('`'));
        }
        return fragments;
      }

      isNestedTag(element) {
        var call;
        call = typeof element.unwrapAll === "function" ? element.unwrapAll() : void 0;
        return this.jsx && call instanceof JSXElement;
      }

      astType() {
        return 'TemplateLiteral';
      }

      astProperties(o) {
        var element, elements, emptyInterpolation, expression, expressions, index, j, last, len1, node, quasis;
        elements = this.extractElements(o, {
          includeInterpolationWrappers: true
        });
        [last] = slice1.call(elements, -1);
        quasis = [];
        expressions = [];
        for (index = j = 0, len1 = elements.length; j < len1; index = ++j) {
          element = elements[index];
          if (element instanceof StringLiteral) {
            quasis.push(new TemplateElement(element.originalValue, {
              tail: element === last
            }).withLocationDataFrom(element).ast(o)); // Interpolation
          } else {
            ({expression} = element);
            node = expression == null ? (emptyInterpolation = new EmptyInterpolation(), emptyInterpolation.locationData = emptyExpressionLocationData({
              interpolationNode: element,
              openingBrace: '#{',
              closingBrace: '}'
            }), emptyInterpolation) : expression.unwrapAll();
            expressions.push(astAsBlockIfNeeded(node, o));
          }
        }
        return {expressions, quasis, quote: this.quote};
      }

    };

    StringWithInterpolations.prototype.children = ['body'];

    return StringWithInterpolations;

  }).call(this);

  exports.TemplateElement = TemplateElement = class TemplateElement extends Base {
    constructor(value1, {
        tail: tail1
      } = {}) {
      super();
      this.value = value1;
      this.tail = tail1;
    }

    astProperties() {
      return {
        value: {
          raw: this.value
        },
        tail: !!this.tail
      };
    }

  };

  exports.Interpolation = Interpolation = (function() {
    class Interpolation extends Base {
      constructor(expression1) {
        super();
        this.expression = expression1;
      }

    };

    Interpolation.prototype.children = ['expression'];

    return Interpolation;

  }).call(this);

  // Represents the contents of an empty interpolation (e.g. `#{}`).
  // Only used during AST generation.
  exports.EmptyInterpolation = EmptyInterpolation = class EmptyInterpolation extends Base {
    constructor() {
      super();
    }

  };

  //### For

  // CoffeeScript's replacement for the *for* loop is our array and object
  // comprehensions, that compile into *for* loops here. They also act as an
  // expression, able to return the result of each filtered iteration.

  // Unlike Python array comprehensions, they can be multi-line, and you can pass
  // the current index of the loop as a second parameter. Unlike Ruby blocks,
  // you can map and filter in a single pass.
  exports.For = For = (function() {
    class For extends While {
      constructor(body, source) {
        super();
        this.addBody(body);
        this.addSource(source);
      }

      isAwait() {
        var ref1;
        return (ref1 = this.await) != null ? ref1 : false;
      }

      addBody(body) {
        var base1, expressions;
        this.body = Block.wrap([body]);
        ({expressions} = this.body);
        if (expressions.length) {
          if ((base1 = this.body).locationData == null) {
            base1.locationData = mergeLocationData(expressions[0].locationData, expressions[expressions.length - 1].locationData);
          }
        }
        return this;
      }

      addSource(source) {
        var attr, attribs, attribute, base1, j, k, len1, len2, ref1, ref2, ref3, ref4;
        ({source: this.source = false} = source);
        attribs = ["name", "index", "guard", "step", "own", "ownTag", "await", "awaitTag", "object", "from"];
        for (j = 0, len1 = attribs.length; j < len1; j++) {
          attr = attribs[j];
          this[attr] = (ref1 = source[attr]) != null ? ref1 : this[attr];
        }
        if (!this.source) {
          return this;
        }
        if (this.from && this.index) {
          this.index.error('cannot use index with for-from');
        }
        if (this.own && !this.object) {
          this.ownTag.error(`cannot use own with for-${this.from ? 'from' : 'in'}`);
        }
        if (this.object) {
          [this.name, this.index] = [this.index, this.name];
        }
        if (((ref2 = this.index) != null ? typeof ref2.isArray === "function" ? ref2.isArray() : void 0 : void 0) || ((ref3 = this.index) != null ? typeof ref3.isObject === "function" ? ref3.isObject() : void 0 : void 0)) {
          this.index.error('index cannot be a pattern matching expression');
        }
        if (this.await && !this.from) {
          this.awaitTag.error('await must be used with for-from');
        }
        this.range = this.source instanceof Value && this.source.base instanceof Range && !this.source.properties.length && !this.from;
        this.pattern = this.name instanceof Value;
        if (this.pattern) {
          if (typeof (base1 = this.name.unwrap()).propagateLhs === "function") {
            base1.propagateLhs(true);
          }
        }
        if (this.range && this.index) {
          this.index.error('indexes do not apply to range loops');
        }
        if (this.range && this.pattern) {
          this.name.error('cannot pattern match over range loops');
        }
        this.returns = false;
        ref4 = ['source', 'guard', 'step', 'name', 'index'];
        // Move up any comments in the “`for` line”, i.e. the line of code with `for`,
        // from any child nodes of that line up to the `for` node itself so that these
        // comments get output, and get output above the `for` loop.
        for (k = 0, len2 = ref4.length; k < len2; k++) {
          attribute = ref4[k];
          if (!this[attribute]) {
            continue;
          }
          this[attribute].traverseChildren(true, (node) => {
            var comment, l, len3, ref5;
            if (node.comments) {
              ref5 = node.comments;
              for (l = 0, len3 = ref5.length; l < len3; l++) {
                comment = ref5[l];
                // These comments are buried pretty deeply, so if they happen to be
                // trailing comments the line they trail will be unrecognizable when
                // we’re done compiling this `for` loop; so just shift them up to
                // output above the `for` line.
                comment.newLine = comment.unshift = true;
              }
              return moveComments(node, this[attribute]);
            }
          });
          moveComments(this[attribute], this);
        }
        return this;
      }

      // Welcome to the hairiest method in all of CoffeeScript. Handles the inner
      // loop, filtering, stepping, and result saving for array, object, and range
      // comprehensions. Some of the generated code can be shared in common, and
      // some cannot.
      compileNode(o) {
        var body, bodyFragments, compare, compareDown, declare, declareDown, defPart, down, forClose, forCode, forPartFragments, fragments, guardPart, idt1, increment, index, ivar, kvar, kvarAssign, last, lvar, name, namePart, ref, ref1, resultPart, returnResult, rvar, scope, source, step, stepNum, stepVar, svar, varPart;
        body = Block.wrap([this.body]);
        ref1 = body.expressions, [last] = slice1.call(ref1, -1);
        if ((last != null ? last.jumps() : void 0) instanceof Return) {
          this.returns = false;
        }
        source = this.range ? this.source.base : this.source;
        scope = o.scope;
        if (!this.pattern) {
          name = this.name && (this.name.compile(o, LEVEL_LIST));
        }
        index = this.index && (this.index.compile(o, LEVEL_LIST));
        if (name && !this.pattern) {
          scope.find(name);
        }
        if (index && !(this.index instanceof Value)) {
          scope.find(index);
        }
        if (this.returns) {
          rvar = scope.freeVariable('results');
        }
        if (this.from) {
          if (this.pattern) {
            ivar = scope.freeVariable('x', {
              single: true
            });
          }
        } else {
          ivar = (this.object && index) || scope.freeVariable('i', {
            single: true
          });
        }
        kvar = ((this.range || this.from) && name) || index || ivar;
        kvarAssign = kvar !== ivar ? `${kvar} = ` : "";
        if (this.step && !this.range) {
          [step, stepVar] = this.cacheToCodeFragments(this.step.cache(o, LEVEL_LIST, shouldCacheOrIsAssignable));
          if (this.step.isNumber()) {
            stepNum = parseNumber(stepVar);
          }
        }
        if (this.pattern) {
          name = ivar;
        }
        varPart = '';
        guardPart = '';
        defPart = '';
        idt1 = this.tab + TAB;
        if (this.range) {
          forPartFragments = source.compileToFragments(merge(o, {
            index: ivar,
            name,
            step: this.step,
            shouldCache: shouldCacheOrIsAssignable
          }));
        } else {
          svar = this.source.compile(o, LEVEL_LIST);
          if ((name || this.own) && !this.from && !(this.source.unwrap() instanceof IdentifierLiteral)) {
            defPart += `${this.tab}${ref = scope.freeVariable('ref')} = ${svar};\n`;
            svar = ref;
          }
          if (name && !this.pattern && !this.from) {
            namePart = `${name} = ${svar}[${kvar}]`;
          }
          if (!this.object && !this.from) {
            if (step !== stepVar) {
              defPart += `${this.tab}${step};\n`;
            }
            down = stepNum < 0;
            if (!(this.step && (stepNum != null) && down)) {
              lvar = scope.freeVariable('len');
            }
            declare = `${kvarAssign}${ivar} = 0, ${lvar} = ${svar}.length`;
            declareDown = `${kvarAssign}${ivar} = ${svar}.length - 1`;
            compare = `${ivar} < ${lvar}`;
            compareDown = `${ivar} >= 0`;
            if (this.step) {
              if (stepNum != null) {
                if (down) {
                  compare = compareDown;
                  declare = declareDown;
                }
              } else {
                compare = `${stepVar} > 0 ? ${compare} : ${compareDown}`;
                declare = `(${stepVar} > 0 ? (${declare}) : ${declareDown})`;
              }
              increment = `${ivar} += ${stepVar}`;
            } else {
              increment = `${kvar !== ivar ? `++${ivar}` : `${ivar}++`}`;
            }
            forPartFragments = [this.makeCode(`${declare}; ${compare}; ${kvarAssign}${increment}`)];
          }
        }
        if (this.returns) {
          resultPart = `${this.tab}${rvar} = [];\n`;
          returnResult = `\n${this.tab}return ${rvar};`;
          body.makeReturn(rvar);
        }
        if (this.guard) {
          if (body.expressions.length > 1) {
            body.expressions.unshift(new If((new Parens(this.guard)).invert(), new StatementLiteral("continue")));
          } else {
            if (this.guard) {
              body = Block.wrap([new If(this.guard, body)]);
            }
          }
        }
        if (this.pattern) {
          body.expressions.unshift(new Assign(this.name, this.from ? new IdentifierLiteral(kvar) : new Literal(`${svar}[${kvar}]`)));
        }
        if (namePart) {
          varPart = `\n${idt1}${namePart};`;
        }
        if (this.object) {
          forPartFragments = [this.makeCode(`${kvar} in ${svar}`)];
          if (this.own) {
            guardPart = `\n${idt1}if (!${utility('hasProp', o)}.call(${svar}, ${kvar})) continue;`;
          }
        } else if (this.from) {
          if (this.await) {
            forPartFragments = new Op('await', new Parens(new Literal(`${kvar} of ${svar}`)));
            forPartFragments = forPartFragments.compileToFragments(o, LEVEL_TOP);
          } else {
            forPartFragments = [this.makeCode(`${kvar} of ${svar}`)];
          }
        }
        bodyFragments = body.compileToFragments(merge(o, {
          indent: idt1
        }), LEVEL_TOP);
        if (bodyFragments && bodyFragments.length > 0) {
          bodyFragments = [].concat(this.makeCode('\n'), bodyFragments, this.makeCode('\n'));
        }
        fragments = [this.makeCode(defPart)];
        if (resultPart) {
          fragments.push(this.makeCode(resultPart));
        }
        forCode = this.await ? 'for ' : 'for (';
        forClose = this.await ? '' : ')';
        fragments = fragments.concat(this.makeCode(this.tab), this.makeCode(forCode), forPartFragments, this.makeCode(`${forClose} {${guardPart}${varPart}`), bodyFragments, this.makeCode(this.tab), this.makeCode('}'));
        if (returnResult) {
          fragments.push(this.makeCode(returnResult));
        }
        return fragments;
      }

      astNode(o) {
        var addToScope, ref1, ref2;
        addToScope = function(name) {
          var alreadyDeclared;
          alreadyDeclared = o.scope.find(name.value);
          return name.isDeclaration = !alreadyDeclared;
        };
        if ((ref1 = this.name) != null) {
          ref1.eachName(addToScope, {
            checkAssignability: false
          });
        }
        if ((ref2 = this.index) != null) {
          ref2.eachName(addToScope, {
            checkAssignability: false
          });
        }
        return super.astNode(o);
      }

      astType() {
        return 'For';
      }

      astProperties(o) {
        var ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9;
        return {
          source: (ref1 = this.source) != null ? ref1.ast(o) : void 0,
          body: this.body.ast(o, LEVEL_TOP),
          guard: (ref2 = (ref3 = this.guard) != null ? ref3.ast(o) : void 0) != null ? ref2 : null,
          name: (ref4 = (ref5 = this.name) != null ? ref5.ast(o) : void 0) != null ? ref4 : null,
          index: (ref6 = (ref7 = this.index) != null ? ref7.ast(o) : void 0) != null ? ref6 : null,
          step: (ref8 = (ref9 = this.step) != null ? ref9.ast(o) : void 0) != null ? ref8 : null,
          postfix: !!this.postfix,
          own: !!this.own,
          await: !!this.await,
          style: (function() {
            switch (false) {
              case !this.from:
                return 'from';
              case !this.object:
                return 'of';
              case !this.name:
                return 'in';
              default:
                return 'range';
            }
          }).call(this)
        };
      }

    };

    For.prototype.children = ['body', 'source', 'guard', 'step'];

    return For;

  }).call(this);

  //### Switch

  // A JavaScript *switch* statement. Converts into a returnable expression on-demand.
  exports.Switch = Switch = (function() {
    class Switch extends Base {
      constructor(subject, cases1, otherwise) {
        super();
        this.subject = subject;
        this.cases = cases1;
        this.otherwise = otherwise;
      }

      jumps(o = {
          block: true
        }) {
        var block, j, jumpNode, len1, ref1, ref2;
        ref1 = this.cases;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          ({block} = ref1[j]);
          if (jumpNode = block.jumps(o)) {
            return jumpNode;
          }
        }
        return (ref2 = this.otherwise) != null ? ref2.jumps(o) : void 0;
      }

      makeReturn(results, mark) {
        var block, j, len1, ref1, ref2;
        ref1 = this.cases;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          ({block} = ref1[j]);
          block.makeReturn(results, mark);
        }
        if (results) {
          this.otherwise || (this.otherwise = new Block([new Literal('void 0')]));
        }
        if ((ref2 = this.otherwise) != null) {
          ref2.makeReturn(results, mark);
        }
        return this;
      }

      compileNode(o) {
        var block, body, cond, conditions, expr, fragments, i, idt1, idt2, j, k, len1, len2, ref1, ref2;
        idt1 = o.indent + TAB;
        idt2 = o.indent = idt1 + TAB;
        fragments = [].concat(this.makeCode(this.tab + "switch ("), (this.subject ? this.subject.compileToFragments(o, LEVEL_PAREN) : this.makeCode("false")), this.makeCode(") {\n"));
        ref1 = this.cases;
        for (i = j = 0, len1 = ref1.length; j < len1; i = ++j) {
          ({conditions, block} = ref1[i]);
          ref2 = flatten([conditions]);
          for (k = 0, len2 = ref2.length; k < len2; k++) {
            cond = ref2[k];
            if (!this.subject) {
              cond = cond.invert();
            }
            fragments = fragments.concat(this.makeCode(idt1 + "case "), cond.compileToFragments(o, LEVEL_PAREN), this.makeCode(":\n"));
          }
          if ((body = block.compileToFragments(o, LEVEL_TOP)).length > 0) {
            fragments = fragments.concat(body, this.makeCode('\n'));
          }
          if (i === this.cases.length - 1 && !this.otherwise) {
            break;
          }
          expr = this.lastNode(block.expressions);
          if (expr instanceof Return || expr instanceof Throw || (expr instanceof Literal && expr.jumps() && expr.value !== 'debugger')) {
            continue;
          }
          fragments.push(cond.makeCode(idt2 + 'break;\n'));
        }
        if (this.otherwise && this.otherwise.expressions.length) {
          fragments.push(this.makeCode(idt1 + "default:\n"), ...(this.otherwise.compileToFragments(o, LEVEL_TOP)), this.makeCode("\n"));
        }
        fragments.push(this.makeCode(this.tab + '}'));
        return fragments;
      }

      astType() {
        return 'SwitchStatement';
      }

      casesAst(o) {
        var caseIndex, caseLocationData, cases, consequent, j, k, kase, l, lastTestIndex, len1, len2, len3, ref1, ref2, results1, test, testConsequent, testIndex, tests;
        cases = [];
        ref1 = this.cases;
        for (caseIndex = j = 0, len1 = ref1.length; j < len1; caseIndex = ++j) {
          kase = ref1[caseIndex];
          ({
            conditions: tests,
            block: consequent
          } = kase);
          tests = flatten([tests]);
          lastTestIndex = tests.length - 1;
          for (testIndex = k = 0, len2 = tests.length; k < len2; testIndex = ++k) {
            test = tests[testIndex];
            testConsequent = testIndex === lastTestIndex ? consequent : null;
            caseLocationData = test.locationData;
            if (testConsequent != null ? testConsequent.expressions.length : void 0) {
              caseLocationData = mergeLocationData(caseLocationData, testConsequent.expressions[testConsequent.expressions.length - 1].locationData);
            }
            if (testIndex === 0) {
              caseLocationData = mergeLocationData(caseLocationData, kase.locationData, {
                justLeading: true
              });
            }
            if (testIndex === lastTestIndex) {
              caseLocationData = mergeLocationData(caseLocationData, kase.locationData, {
                justEnding: true
              });
            }
            cases.push(new SwitchCase(test, testConsequent, {
              trailing: testIndex === lastTestIndex
            }).withLocationDataFrom({
              locationData: caseLocationData
            }));
          }
        }
        if ((ref2 = this.otherwise) != null ? ref2.expressions.length : void 0) {
          cases.push(new SwitchCase(null, this.otherwise).withLocationDataFrom(this.otherwise));
        }
        results1 = [];
        for (l = 0, len3 = cases.length; l < len3; l++) {
          kase = cases[l];
          results1.push(kase.ast(o));
        }
        return results1;
      }

      astProperties(o) {
        var ref1, ref2;
        return {
          discriminant: (ref1 = (ref2 = this.subject) != null ? ref2.ast(o, LEVEL_PAREN) : void 0) != null ? ref1 : null,
          cases: this.casesAst(o)
        };
      }

    };

    Switch.prototype.children = ['subject', 'cases', 'otherwise'];

    Switch.prototype.isStatement = YES;

    return Switch;

  }).call(this);

  SwitchCase = (function() {
    class SwitchCase extends Base {
      constructor(test1, block1, {trailing} = {}) {
        super();
        this.test = test1;
        this.block = block1;
        this.trailing = trailing;
      }

      astProperties(o) {
        var ref1, ref2, ref3, ref4;
        return {
          test: (ref1 = (ref2 = this.test) != null ? ref2.ast(o, LEVEL_PAREN) : void 0) != null ? ref1 : null,
          consequent: (ref3 = (ref4 = this.block) != null ? ref4.ast(o, LEVEL_TOP).body : void 0) != null ? ref3 : [],
          trailing: !!this.trailing
        };
      }

    };

    SwitchCase.prototype.children = ['test', 'block'];

    return SwitchCase;

  }).call(this);

  exports.SwitchWhen = SwitchWhen = (function() {
    class SwitchWhen extends Base {
      constructor(conditions1, block1) {
        super();
        this.conditions = conditions1;
        this.block = block1;
      }

    };

    SwitchWhen.prototype.children = ['conditions', 'block'];

    return SwitchWhen;

  }).call(this);

  //### If

  // *If/else* statements. Acts as an expression by pushing down requested returns
  // to the last line of each clause.

  // Single-expression **Ifs** are compiled into conditional operators if possible,
  // because ternaries are already proper expressions, and don’t need conversion.
  exports.If = If = (function() {
    class If extends Base {
      constructor(condition1, body1, options = {}) {
        super();
        this.condition = condition1;
        this.body = body1;
        this.elseBody = null;
        this.isChain = false;
        ({soak: this.soak, postfix: this.postfix, type: this.type} = options);
        if (this.condition.comments) {
          moveComments(this.condition, this);
        }
      }

      bodyNode() {
        var ref1;
        return (ref1 = this.body) != null ? ref1.unwrap() : void 0;
      }

      elseBodyNode() {
        var ref1;
        return (ref1 = this.elseBody) != null ? ref1.unwrap() : void 0;
      }

      // Rewrite a chain of **Ifs** to add a default case as the final *else*.
      addElse(elseBody) {
        if (this.isChain) {
          this.elseBodyNode().addElse(elseBody);
          this.locationData = mergeLocationData(this.locationData, this.elseBodyNode().locationData);
        } else {
          this.isChain = elseBody instanceof If;
          this.elseBody = this.ensureBlock(elseBody);
          this.elseBody.updateLocationDataIfMissing(elseBody.locationData);
          if ((this.locationData != null) && (this.elseBody.locationData != null)) {
            this.locationData = mergeLocationData(this.locationData, this.elseBody.locationData);
          }
        }
        return this;
      }

      // The **If** only compiles into a statement if either of its bodies needs
      // to be a statement. Otherwise a conditional operator is safe.
      isStatement(o) {
        var ref1;
        return (o != null ? o.level : void 0) === LEVEL_TOP || this.bodyNode().isStatement(o) || ((ref1 = this.elseBodyNode()) != null ? ref1.isStatement(o) : void 0);
      }

      jumps(o) {
        var ref1;
        return this.body.jumps(o) || ((ref1 = this.elseBody) != null ? ref1.jumps(o) : void 0);
      }

      compileNode(o) {
        if (this.isStatement(o)) {
          return this.compileStatement(o);
        } else {
          return this.compileExpression(o);
        }
      }

      makeReturn(results, mark) {
        var ref1, ref2;
        if (mark) {
          if ((ref1 = this.body) != null) {
            ref1.makeReturn(results, mark);
          }
          if ((ref2 = this.elseBody) != null) {
            ref2.makeReturn(results, mark);
          }
          return;
        }
        if (results) {
          this.elseBody || (this.elseBody = new Block([new Literal('void 0')]));
        }
        this.body && (this.body = new Block([this.body.makeReturn(results)]));
        this.elseBody && (this.elseBody = new Block([this.elseBody.makeReturn(results)]));
        return this;
      }

      ensureBlock(node) {
        if (node instanceof Block) {
          return node;
        } else {
          return new Block([node]);
        }
      }

      // Compile the `If` as a regular *if-else* statement. Flattened chains
      // force inner *else* bodies into statement form.
      compileStatement(o) {
        var answer, body, child, cond, exeq, ifPart, indent;
        child = del(o, 'chainChild');
        exeq = del(o, 'isExistentialEquals');
        if (exeq) {
          return new If(this.processedCondition().invert(), this.elseBodyNode(), {
            type: 'if'
          }).compileToFragments(o);
        }
        indent = o.indent + TAB;
        cond = this.processedCondition().compileToFragments(o, LEVEL_PAREN);
        body = this.ensureBlock(this.body).compileToFragments(merge(o, {indent}));
        ifPart = [].concat(this.makeCode("if ("), cond, this.makeCode(") {\n"), body, this.makeCode(`\n${this.tab}}`));
        if (!child) {
          ifPart.unshift(this.makeCode(this.tab));
        }
        if (!this.elseBody) {
          return ifPart;
        }
        answer = ifPart.concat(this.makeCode(' else '));
        if (this.isChain) {
          o.chainChild = true;
          answer = answer.concat(this.elseBody.unwrap().compileToFragments(o, LEVEL_TOP));
        } else {
          answer = answer.concat(this.makeCode("{\n"), this.elseBody.compileToFragments(merge(o, {indent}), LEVEL_TOP), this.makeCode(`\n${this.tab}}`));
        }
        return answer;
      }

      // Compile the `If` as a conditional operator.
      compileExpression(o) {
        var alt, body, cond, fragments;
        cond = this.processedCondition().compileToFragments(o, LEVEL_COND);
        body = this.bodyNode().compileToFragments(o, LEVEL_LIST);
        alt = this.elseBodyNode() ? this.elseBodyNode().compileToFragments(o, LEVEL_LIST) : [this.makeCode('void 0')];
        fragments = cond.concat(this.makeCode(" ? "), body, this.makeCode(" : "), alt);
        if (o.level >= LEVEL_COND) {
          return this.wrapInParentheses(fragments);
        } else {
          return fragments;
        }
      }

      unfoldSoak() {
        return this.soak && this;
      }

      processedCondition() {
        return this.processedConditionCache != null ? this.processedConditionCache : this.processedConditionCache = this.type === 'unless' ? this.condition.invert() : this.condition;
      }

      isStatementAst(o) {
        return o.level === LEVEL_TOP;
      }

      astType(o) {
        if (this.isStatementAst(o)) {
          return 'IfStatement';
        } else {
          return 'ConditionalExpression';
        }
      }

      astProperties(o) {
        var isStatement, ref1, ref2, ref3, ref4;
        isStatement = this.isStatementAst(o);
        return {
          test: this.condition.ast(o, isStatement ? LEVEL_PAREN : LEVEL_COND),
          consequent: isStatement ? this.body.ast(o, LEVEL_TOP) : this.bodyNode().ast(o, LEVEL_TOP),
          alternate: this.isChain ? this.elseBody.unwrap().ast(o, isStatement ? LEVEL_TOP : LEVEL_COND) : !isStatement && ((ref1 = this.elseBody) != null ? (ref2 = ref1.expressions) != null ? ref2.length : void 0 : void 0) === 1 ? this.elseBody.expressions[0].ast(o, LEVEL_TOP) : (ref3 = (ref4 = this.elseBody) != null ? ref4.ast(o, LEVEL_TOP) : void 0) != null ? ref3 : null,
          postfix: !!this.postfix,
          inverted: this.type === 'unless'
        };
      }

    };

    If.prototype.children = ['condition', 'body', 'elseBody'];

    return If;

  }).call(this);

  // A sequence expression e.g. `(a; b)`.
  // Currently only used during AST generation.
  exports.Sequence = Sequence = (function() {
    class Sequence extends Base {
      constructor(expressions1) {
        super();
        this.expressions = expressions1;
      }

      astNode(o) {
        if (this.expressions.length === 1) {
          return this.expressions[0].ast(o);
        }
        return super.astNode(o);
      }

      astType() {
        return 'SequenceExpression';
      }

      astProperties(o) {
        var expression;
        return {
          expressions: (function() {
            var j, len1, ref1, results1;
            ref1 = this.expressions;
            results1 = [];
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              expression = ref1[j];
              results1.push(expression.ast(o));
            }
            return results1;
          }).call(this)
        };
      }

    };

    Sequence.prototype.children = ['expressions'];

    return Sequence;

  }).call(this);

  // Constants
  // ---------
  UTILITIES = {
    modulo: function() {
      return 'function(a, b) { return (+a % (b = +b) + b) % b; }';
    },
    boundMethodCheck: function() {
      return "function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } }";
    },
    // Shortcuts to speed up the lookup time for native functions.
    hasProp: function() {
      return '{}.hasOwnProperty';
    },
    indexOf: function() {
      return '[].indexOf';
    },
    slice: function() {
      return '[].slice';
    },
    splice: function() {
      return '[].splice';
    }
  };

  // Levels indicate a node's position in the AST. Useful for knowing if
  // parens are necessary or superfluous.
  LEVEL_TOP = 1; // ...;

  LEVEL_PAREN = 2; // (...)

  LEVEL_LIST = 3; // [...]

  LEVEL_COND = 4; // ... ? x : y

  LEVEL_OP = 5; // !...

  LEVEL_ACCESS = 6; // ...[0]

  
  // Tabs are two spaces for pretty printing.
  TAB = '  ';

  SIMPLENUM = /^[+-]?\d+(?:_\d+)*$/;

  SIMPLE_STRING_OMIT = /\s*\n\s*/g;

  LEADING_BLANK_LINE = /^[^\n\S]*\n/;

  TRAILING_BLANK_LINE = /\n[^\n\S]*$/;

  STRING_OMIT = /((?:\\\\)+)|\\[^\S\n]*\n\s*/g; // Consume (and preserve) an even number of backslashes.
  // Remove escaped newlines.

  HEREGEX_OMIT = /((?:\\\\)+)|\\(\s)|\s+(?:#.*)?/g; // Consume (and preserve) an even number of backslashes.
  // Preserve escaped whitespace.
  // Remove whitespace and comments.

  // Helper Functions
  // ----------------

  // Helper for ensuring that utility functions are assigned at the top level.
  utility = function(name, o) {
    var ref, root;
    ({root} = o.scope);
    if (name in root.utilities) {
      return root.utilities[name];
    } else {
      ref = root.freeVariable(name);
      root.assign(ref, UTILITIES[name](o));
      return root.utilities[name] = ref;
    }
  };

  multident = function(code, tab, includingFirstLine = true) {
    var endsWithNewLine;
    endsWithNewLine = code[code.length - 1] === '\n';
    code = (includingFirstLine ? tab : '') + code.replace(/\n/g, `$&${tab}`);
    code = code.replace(/\s+$/, '');
    if (endsWithNewLine) {
      code = code + '\n';
    }
    return code;
  };

  // Wherever in CoffeeScript 1 we might’ve inserted a `makeCode "#{@tab}"` to
  // indent a line of code, now we must account for the possibility of comments
  // preceding that line of code. If there are such comments, indent each line of
  // such comments, and _then_ indent the first following line of code.
  indentInitial = function(fragments, node) {
    var fragment, fragmentIndex, j, len1;
    for (fragmentIndex = j = 0, len1 = fragments.length; j < len1; fragmentIndex = ++j) {
      fragment = fragments[fragmentIndex];
      if (fragment.isHereComment) {
        fragment.code = multident(fragment.code, node.tab);
      } else {
        fragments.splice(fragmentIndex, 0, node.makeCode(`${node.tab}`));
        break;
      }
    }
    return fragments;
  };

  hasLineComments = function(node) {
    var comment, j, len1, ref1;
    if (!node.comments) {
      return false;
    }
    ref1 = node.comments;
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      comment = ref1[j];
      if (comment.here === false) {
        return true;
      }
    }
    return false;
  };

  // Move the `comments` property from one object to another, deleting it from
  // the first object.
  moveComments = function(from, to) {
    if (!(from != null ? from.comments : void 0)) {
      return;
    }
    attachCommentsToNode(from.comments, to);
    return delete from.comments;
  };

  // Sometimes when compiling a node, we want to insert a fragment at the start
  // of an array of fragments; but if the start has one or more comment fragments,
  // we want to insert this fragment after those but before any non-comments.
  unshiftAfterComments = function(fragments, fragmentToInsert) {
    var fragment, fragmentIndex, inserted, j, len1;
    inserted = false;
    for (fragmentIndex = j = 0, len1 = fragments.length; j < len1; fragmentIndex = ++j) {
      fragment = fragments[fragmentIndex];
      if (!(!fragment.isComment)) {
        continue;
      }
      fragments.splice(fragmentIndex, 0, fragmentToInsert);
      inserted = true;
      break;
    }
    if (!inserted) {
      fragments.push(fragmentToInsert);
    }
    return fragments;
  };

  isLiteralArguments = function(node) {
    return node instanceof IdentifierLiteral && node.value === 'arguments';
  };

  isLiteralThis = function(node) {
    return node instanceof ThisLiteral || (node instanceof Code && node.bound);
  };

  shouldCacheOrIsAssignable = function(node) {
    return node.shouldCache() || (typeof node.isAssignable === "function" ? node.isAssignable() : void 0);
  };

  // Unfold a node's child if soak, then tuck the node under created `If`
  unfoldSoak = function(o, parent, name) {
    var ifn;
    if (!(ifn = parent[name].unfoldSoak(o))) {
      return;
    }
    parent[name] = ifn.body;
    ifn.body = new Value(parent);
    return ifn;
  };

  // Constructs a string or regex by escaping certain characters.
  makeDelimitedLiteral = function(body, {
      delimiter: delimiterOption,
      escapeNewlines,
      double,
      includeDelimiters = true,
      escapeDelimiter = true,
      convertTrailingNullEscapes
    } = {}) {
    var escapeTemplateLiteralCurlies, printedDelimiter, regex;
    if (body === '' && delimiterOption === '/') {
      body = '(?:)';
    }
    escapeTemplateLiteralCurlies = delimiterOption === '`';
    regex = RegExp(`(\\\\\\\\)|(\\\\0(?=\\d))${convertTrailingNullEscapes ? /|(\\0)$/.source : '' // Escaped backslash. // Trailing null character that could be mistaken as octal escape.
    // Null character mistaken as octal escape.
    // Trailing null character that could be mistaken as octal escape.
    // (Possibly escaped) delimiter.
    // `${` inside template literals must be escaped.
    // (Possibly escaped) newlines.
    // Other escapes.
}${escapeDelimiter ? RegExp(`|\\\\?(${delimiterOption})`).source : '' // (Possibly escaped) delimiter.
}${escapeTemplateLiteralCurlies ? /|\\?(\$\{)/.source : '' // `${` inside template literals must be escaped.
}|\\\\?(?:${escapeNewlines ? '(\n)|' : ''}(\\r)|(\\u2028)|(\\u2029))|(\\\\.)`, "g");
    body = body.replace(regex, function(match, backslash, nul, ...args) {
      var cr, delimiter, lf, ls, other, ps, templateLiteralCurly, trailingNullEscape;
      trailingNullEscape = convertTrailingNullEscapes ? args.shift() : void 0;
      delimiter = escapeDelimiter ? args.shift() : void 0;
      templateLiteralCurly = escapeTemplateLiteralCurlies ? args.shift() : void 0;
      lf = escapeNewlines ? args.shift() : void 0;
      [cr, ls, ps, other] = args;
      switch (false) {
        // Ignore escaped backslashes.
        case !backslash:
          if (double) {
            return backslash + backslash;
          } else {
            return backslash;
          }
        case !nul:
          return '\\x00';
        case !trailingNullEscape:
          return "\\x00";
        case !delimiter:
          return `\\${delimiter}`;
        case !templateLiteralCurly:
          return "\\${";
        case !lf:
          return '\\n';
        case !cr:
          return '\\r';
        case !ls:
          return '\\u2028';
        case !ps:
          return '\\u2029';
        case !other:
          if (double) {
            return `\\${other}`;
          } else {
            return other;
          }
      }
    });
    printedDelimiter = includeDelimiters ? delimiterOption : '';
    return `${printedDelimiter}${body}${printedDelimiter}`;
  };

  sniffDirectives = function(expressions, {notFinalExpression} = {}) {
    var expression, index, lastIndex, results1, unwrapped;
    index = 0;
    lastIndex = expressions.length - 1;
    results1 = [];
    while (index <= lastIndex) {
      if (index === lastIndex && notFinalExpression) {
        break;
      }
      expression = expressions[index];
      if ((unwrapped = expression != null ? typeof expression.unwrap === "function" ? expression.unwrap() : void 0 : void 0) instanceof PassthroughLiteral && unwrapped.generated) {
        index++;
        continue;
      }
      if (!(expression instanceof Value && expression.isString() && !expression.unwrap().shouldGenerateTemplateLiteral())) {
        break;
      }
      expressions[index] = new Directive(expression).withLocationDataFrom(expression);
      results1.push(index++);
    }
    return results1;
  };

  astAsBlockIfNeeded = function(node, o) {
    var unwrapped;
    unwrapped = node.unwrap();
    if (unwrapped instanceof Block && unwrapped.expressions.length > 1) {
      unwrapped.makeReturn(null, true);
      return unwrapped.ast(o, LEVEL_TOP);
    } else {
      return node.ast(o, LEVEL_PAREN);
    }
  };

  // Helpers for `mergeLocationData` and `mergeAstLocationData` below.
  lesser = function(a, b) {
    if (a < b) {
      return a;
    } else {
      return b;
    }
  };

  greater = function(a, b) {
    if (a > b) {
      return a;
    } else {
      return b;
    }
  };

  isAstLocGreater = function(a, b) {
    if (a.line > b.line) {
      return true;
    }
    if (a.line !== b.line) {
      return false;
    }
    return a.column > b.column;
  };

  isLocationDataStartGreater = function(a, b) {
    if (a.first_line > b.first_line) {
      return true;
    }
    if (a.first_line !== b.first_line) {
      return false;
    }
    return a.first_column > b.first_column;
  };

  isLocationDataEndGreater = function(a, b) {
    if (a.last_line > b.last_line) {
      return true;
    }
    if (a.last_line !== b.last_line) {
      return false;
    }
    return a.last_column > b.last_column;
  };

  // Take two nodes’ location data and return a new `locationData` object that
  // encompasses the location data of both nodes. So the new `first_line` value
  // will be the earlier of the two nodes’ `first_line` values, the new
  // `last_column` the later of the two nodes’ `last_column` values, etc.

  // If you only want to extend the first node’s location data with the start or
  // end location data of the second node, pass the `justLeading` or `justEnding`
  // options. So e.g. if `first`’s range is [4, 5] and `second`’s range is [1, 10],
  // you’d get:
  // ```
  // mergeLocationData(first, second).range                   # [1, 10]
  // mergeLocationData(first, second, justLeading: yes).range # [1, 5]
  // mergeLocationData(first, second, justEnding:  yes).range # [4, 10]
  // ```
  exports.mergeLocationData = mergeLocationData = function(locationDataA, locationDataB, {justLeading, justEnding} = {}) {
    return Object.assign(justEnding ? {
      first_line: locationDataA.first_line,
      first_column: locationDataA.first_column
    } : isLocationDataStartGreater(locationDataA, locationDataB) ? {
      first_line: locationDataB.first_line,
      first_column: locationDataB.first_column
    } : {
      first_line: locationDataA.first_line,
      first_column: locationDataA.first_column
    }, justLeading ? {
      last_line: locationDataA.last_line,
      last_column: locationDataA.last_column,
      last_line_exclusive: locationDataA.last_line_exclusive,
      last_column_exclusive: locationDataA.last_column_exclusive
    } : isLocationDataEndGreater(locationDataA, locationDataB) ? {
      last_line: locationDataA.last_line,
      last_column: locationDataA.last_column,
      last_line_exclusive: locationDataA.last_line_exclusive,
      last_column_exclusive: locationDataA.last_column_exclusive
    } : {
      last_line: locationDataB.last_line,
      last_column: locationDataB.last_column,
      last_line_exclusive: locationDataB.last_line_exclusive,
      last_column_exclusive: locationDataB.last_column_exclusive
    }, {
      range: [justEnding ? locationDataA.range[0] : lesser(locationDataA.range[0], locationDataB.range[0]), justLeading ? locationDataA.range[1] : greater(locationDataA.range[1], locationDataB.range[1])]
    });
  };

  // Take two AST nodes, or two AST nodes’ location data objects, and return a new
  // location data object that encompasses the location data of both nodes. So the
  // new `start` value will be the earlier of the two nodes’ `start` values, the
  // new `end` value will be the later of the two nodes’ `end` values, etc.

  // If you only want to extend the first node’s location data with the start or
  // end location data of the second node, pass the `justLeading` or `justEnding`
  // options. So e.g. if `first`’s range is [4, 5] and `second`’s range is [1, 10],
  // you’d get:
  // ```
  // mergeAstLocationData(first, second).range                   # [1, 10]
  // mergeAstLocationData(first, second, justLeading: yes).range # [1, 5]
  // mergeAstLocationData(first, second, justEnding:  yes).range # [4, 10]
  // ```
  exports.mergeAstLocationData = mergeAstLocationData = function(nodeA, nodeB, {justLeading, justEnding} = {}) {
    return {
      loc: {
        start: justEnding ? nodeA.loc.start : isAstLocGreater(nodeA.loc.start, nodeB.loc.start) ? nodeB.loc.start : nodeA.loc.start,
        end: justLeading ? nodeA.loc.end : isAstLocGreater(nodeA.loc.end, nodeB.loc.end) ? nodeA.loc.end : nodeB.loc.end
      },
      range: [justEnding ? nodeA.range[0] : lesser(nodeA.range[0], nodeB.range[0]), justLeading ? nodeA.range[1] : greater(nodeA.range[1], nodeB.range[1])],
      start: justEnding ? nodeA.start : lesser(nodeA.start, nodeB.start),
      end: justLeading ? nodeA.end : greater(nodeA.end, nodeB.end)
    };
  };

  // Convert Jison-style node class location data to Babel-style location data
  exports.jisonLocationDataToAstLocationData = jisonLocationDataToAstLocationData = function({first_line, first_column, last_line_exclusive, last_column_exclusive, range}) {
    return {
      loc: {
        start: {
          line: first_line + 1,
          column: first_column
        },
        end: {
          line: last_line_exclusive + 1,
          column: last_column_exclusive
        }
      },
      range: [range[0], range[1]],
      start: range[0],
      end: range[1]
    };
  };

  // Generate a zero-width location data that corresponds to the end of another node’s location.
  zeroWidthLocationDataFromEndLocation = function({
      range: [, endRange],
      last_line_exclusive,
      last_column_exclusive
    }) {
    return {
      first_line: last_line_exclusive,
      first_column: last_column_exclusive,
      last_line: last_line_exclusive,
      last_column: last_column_exclusive,
      last_line_exclusive,
      last_column_exclusive,
      range: [endRange, endRange]
    };
  };

  extractSameLineLocationDataFirst = function(numChars) {
    return function({
        range: [startRange],
        first_line,
        first_column
      }) {
      return {
        first_line,
        first_column,
        last_line: first_line,
        last_column: first_column + numChars - 1,
        last_line_exclusive: first_line,
        last_column_exclusive: first_column + numChars,
        range: [startRange, startRange + numChars]
      };
    };
  };

  extractSameLineLocationDataLast = function(numChars) {
    return function({
        range: [, endRange],
        last_line,
        last_column,
        last_line_exclusive,
        last_column_exclusive
      }) {
      return {
        first_line: last_line,
        first_column: last_column - (numChars - 1),
        last_line: last_line,
        last_column: last_column,
        last_line_exclusive,
        last_column_exclusive,
        range: [endRange - numChars, endRange]
      };
    };
  };

  // We don’t currently have a token corresponding to the empty space
  // between interpolation/JSX expression braces, so piece together the location
  // data by trimming the braces from the Interpolation’s location data.
  // Technically the last_line/last_column calculation here could be
  // incorrect if the ending brace is preceded by a newline, but
  // last_line/last_column aren’t used for AST generation anyway.
  emptyExpressionLocationData = function({
      interpolationNode: element,
      openingBrace,
      closingBrace
    }) {
    return {
      first_line: element.locationData.first_line,
      first_column: element.locationData.first_column + openingBrace.length,
      last_line: element.locationData.last_line,
      last_column: element.locationData.last_column - closingBrace.length,
      last_line_exclusive: element.locationData.last_line,
      last_column_exclusive: element.locationData.last_column,
      range: [element.locationData.range[0] + openingBrace.length, element.locationData.range[1] - closingBrace.length]
    };
  };

}).call(this);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZXMuanMiLCJzb3VyY2VSb290IjoiLi4vLi4vIiwic291cmNlcyI6WyJzcmMvbm9kZXMuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFHaUY7RUFBQTs7OztBQUFBLE1BQUEsTUFBQSxFQUFBLEdBQUEsRUFBQSxNQUFBLEVBQUEsV0FBQSxFQUFBLElBQUEsRUFBQSxLQUFBLEVBQUEsY0FBQSxFQUFBLElBQUEsRUFBQSxLQUFBLEVBQUEsS0FBQSxFQUFBLGFBQUEsRUFBQSxzQkFBQSxFQUFBLElBQUEsRUFBQSxZQUFBLEVBQUEsb0JBQUEsRUFBQSxjQUFBLEVBQUEsU0FBQSxFQUFBLGFBQUEsRUFBQSxpQkFBQSxFQUFBLE9BQUEsRUFBQSxrQkFBQSxFQUFBLG1CQUFBLEVBQUEsU0FBQSxFQUFBLFNBQUEsRUFBQSxvQkFBQSxFQUFBLGlCQUFBLEVBQUEsd0JBQUEsRUFBQSxzQkFBQSxFQUFBLGVBQUEsRUFBQSxtQkFBQSxFQUFBLE9BQUEsRUFBQSxHQUFBLEVBQUEsbUJBQUEsRUFBQSxTQUFBLEVBQUEsWUFBQSxFQUFBLFdBQUEsRUFBQSxXQUFBLEVBQUEsaUJBQUEsRUFBQSxFQUFBLEVBQUEsWUFBQSxFQUFBLGlCQUFBLEVBQUEsc0JBQUEsRUFBQSx3QkFBQSxFQUFBLGVBQUEsRUFBQSxtQkFBQSxFQUFBLEVBQUEsRUFBQSxLQUFBLEVBQUEsZUFBQSxFQUFBLGFBQUEsRUFBQSxZQUFBLEVBQUEsYUFBQSxFQUFBLFVBQUEsRUFBQSxrQkFBQSxFQUFBLHNCQUFBLEVBQUEsYUFBQSxFQUFBLGlCQUFBLEVBQUEsTUFBQSxFQUFBLE9BQUEsRUFBQSxZQUFBLEVBQUEsa0JBQUEsRUFBQSxZQUFBLEVBQUEsVUFBQSxFQUFBLFVBQUEsRUFBQSxRQUFBLEVBQUEsV0FBQSxFQUFBLFNBQUEsRUFBQSxXQUFBLEVBQUEsT0FBQSxFQUFBLFlBQUEsRUFBQSxpQkFBQSxFQUFBLGVBQUEsRUFBQSxtQkFBQSxFQUFBLE1BQUEsRUFBQSxFQUFBLEVBQUEsVUFBQSxF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aUJBQUEsRUFBbUIsT0FBcEI7TUFBNkIsWUFBN0I7TUFBMkM7SUFBM0MsQ0FBRCxDQUFBO1dBQzVCO01BQUEsVUFBQSxFQUF1QixPQUFPLENBQUMsWUFBWSxDQUFDLFVBQTVDO01BQ0EsWUFBQSxFQUF1QixPQUFPLENBQUMsWUFBWSxDQUFDLFlBQXJCLEdBQW9DLFlBQVksQ0FBQyxNQUR4RTtNQUVBLFNBQUEsRUFBdUIsT0FBTyxDQUFDLFlBQVksQ0FBQyxTQUY1QztNQUdBLFdBQUEsRUFBdUIsT0FBTyxDQUFDLFlBQVksQ0FBQyxXQUFyQixHQUFtQyxZQUFZLENBQUMsTUFIdkU7TUFJQSxtQkFBQSxFQUF1QixPQUFPLENBQUMsWUFBWSxDQUFDLFNBSjVDO01BS0EscUJBQUEsRUFBdUIsT0FBTyxDQUFDLFlBQVksQ0FBQyxXQUw1QztNQU1BLEtBQUEsRUFBTyxDQUNMLE9BQU8sQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUQsQ0FBMUIsR0FBZ0MsWUFBWSxDQUFDLE1BRHhDLEVBRUwsT0FBTyxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBRCxDQUExQixHQUFnQyxZQUFZLENBQUMsTUFGeEM7SUFOUDtFQUQ0QjtBQTUrTG1EIiwic291cmNlc0NvbnRlbnQiOlsiIyBgbm9kZXMuY29mZmVlYCBjb250YWlucyBhbGwgb2YgdGhlIG5vZGUgY2xhc3NlcyBmb3IgdGhlIHN5bnRheCB0cmVlLiBNb3N0XG4jIG5vZGVzIGFyZSBjcmVhdGVkIGFzIHRoZSByZXN1bHQgb2YgYWN0aW9ucyBpbiB0aGUgW2dyYW1tYXJdKGdyYW1tYXIuaHRtbCksXG4jIGJ1dCBzb21lIGFyZSBjcmVhdGVkIGJ5IG90aGVyIG5vZGVzIGFzIGEgbWV0aG9kIG9mIGNvZGUgZ2VuZXJhdGlvbi4gVG8gY29udmVydFxuIyB0aGUgc3ludGF4IHRyZWUgaW50byBhIHN0cmluZyBvZiBKYXZhU2NyaXB0IGNvZGUsIGNhbGwgYGNvbXBpbGUoKWAgb24gdGhlIHJvb3QuXG5cbkVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IEluZmluaXR5XG5cbntTY29wZX0gPSByZXF1aXJlICcuL3Njb3BlJ1xue2lzVW5hc3NpZ25hYmxlLCBKU19GT1JCSURERU59ID0gcmVxdWlyZSAnLi9sZXhlcidcblxuIyBJbXBvcnQgdGhlIGhlbHBlcnMgd2UgcGxhbiB0byB1c2UuXG57Y29tcGFjdCwgZmxhdHRlbiwgZXh0ZW5kLCBtZXJnZSwgZGVsLCBzdGFydHMsIGVuZHMsIHNvbWUsXG5hZGREYXRhVG9Ob2RlLCBhdHRhY2hDb21tZW50c1RvTm9kZSwgbG9jYXRpb25EYXRhVG9TdHJpbmcsXG50aHJvd1N5bnRheEVycm9yLCByZXBsYWNlVW5pY29kZUNvZGVQb2ludEVzY2FwZXMsXG5pc0Z1bmN0aW9uLCBpc1BsYWluT2JqZWN0LCBpc051bWJlciwgcGFyc2VOdW1iZXJ9ID0gcmVxdWlyZSAnLi9oZWxwZXJzJ1xuXG4jIEZ1bmN0aW9ucyByZXF1aXJlZCBieSBwYXJzZXIuXG5leHBvcnRzLmV4dGVuZCA9IGV4dGVuZFxuZXhwb3J0cy5hZGREYXRhVG9Ob2RlID0gYWRkRGF0YVRvTm9kZVxuXG4jIENvbnN0YW50IGZ1bmN0aW9ucyBmb3Igbm9kZXMgdGhhdCBkb27igJl0IG5lZWQgY3VzdG9taXphdGlvbi5cbllFUyAgICAgPSAtPiB5ZXNcbk5PICAgICAgPSAtPiBub1xuVEhJUyAgICA9IC0+IHRoaXNcbk5FR0FURSAgPSAtPiBAbmVnYXRlZCA9IG5vdCBAbmVnYXRlZDsgdGhpc1xuXG4jIyMjIENvZGVGcmFnbWVudFxuXG4jIFRoZSB2YXJpb3VzIG5vZGVzIGRlZmluZWQgYmVsb3cgYWxsIGNvbXBpbGUgdG8gYSBjb2xsZWN0aW9uIG9mICoqQ29kZUZyYWdtZW50Kiogb2JqZWN0cy5cbiMgQSBDb2RlRnJhZ21lbnRzIGlzIGEgYmxvY2sgb2YgZ2VuZXJhdGVkIGNvZGUsIGFuZCB0aGUgbG9jYXRpb24gaW4gdGhlIHNvdXJjZSBmaWxlIHdoZXJlIHRoZSBjb2RlXG4jIGNhbWUgZnJvbS4gQ29kZUZyYWdtZW50cyBjYW4gYmUgYXNzZW1ibGVkIHRvZ2V0aGVyIGludG8gd29ya2luZyBjb2RlIGp1c3QgYnkgY2F0dGluZyB0b2dldGhlclxuIyBhbGwgdGhlIENvZGVGcmFnbWVudHMnIGBjb2RlYCBzbmlwcGV0cywgaW4gb3JkZXIuXG5leHBvcnRzLkNvZGVGcmFnbWVudCA9IGNsYXNzIENvZGVGcmFnbWVudFxuICBjb25zdHJ1Y3RvcjogKHBhcmVudCwgY29kZSkgLT5cbiAgICBAY29kZSA9IFwiI3tjb2RlfVwiXG4gICAgQHR5cGUgPSBwYXJlbnQ/LmNvbnN0cnVjdG9yPy5uYW1lIG9yICd1bmtub3duJ1xuICAgIEBsb2NhdGlvbkRhdGEgPSBwYXJlbnQ/LmxvY2F0aW9uRGF0YVxuICAgIEBjb21tZW50cyA9IHBhcmVudD8uY29tbWVudHNcblxuICB0b1N0cmluZzogLT5cbiAgICAjIFRoaXMgaXMgb25seSBpbnRlbmRlZCBmb3IgZGVidWdnaW5nLlxuICAgIFwiI3tAY29kZX0je2lmIEBsb2NhdGlvbkRhdGEgdGhlbiBcIjogXCIgKyBsb2NhdGlvbkRhdGFUb1N0cmluZyhAbG9jYXRpb25EYXRhKSBlbHNlICcnfVwiXG5cbiMgQ29udmVydCBhbiBhcnJheSBvZiBDb2RlRnJhZ21lbnRzIGludG8gYSBzdHJpbmcuXG5mcmFnbWVudHNUb1RleHQgPSAoZnJhZ21lbnRzKSAtPlxuICAoZnJhZ21lbnQuY29kZSBmb3IgZnJhZ21lbnQgaW4gZnJhZ21lbnRzKS5qb2luKCcnKVxuXG4jIyMjIEJhc2VcblxuIyBUaGUgKipCYXNlKiogaXMgdGhlIGFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGFsbCBub2RlcyBpbiB0aGUgc3ludGF4IHRyZWUuXG4jIEVhY2ggc3ViY2xhc3MgaW1wbGVtZW50cyB0aGUgYGNvbXBpbGVOb2RlYCBtZXRob2QsIHdoaWNoIHBlcmZvcm1zIHRoZVxuIyBjb2RlIGdlbmVyYXRpb24gZm9yIHRoYXQgbm9kZS4gVG8gY29tcGlsZSBhIG5vZGUgdG8gSmF2YVNjcmlwdCxcbiMgY2FsbCBgY29tcGlsZWAgb24gaXQsIHdoaWNoIHdyYXBzIGBjb21waWxlTm9kZWAgaW4gc29tZSBnZW5lcmljIGV4dHJhIHNtYXJ0cyxcbiMgdG8ga25vdyB3aGVuIHRoZSBnZW5lcmF0ZWQgY29kZSBuZWVkcyB0byBiZSB3cmFwcGVkIHVwIGluIGEgY2xvc3VyZS5cbiMgQW4gb3B0aW9ucyBoYXNoIGlzIHBhc3NlZCBhbmQgY2xvbmVkIHRocm91Z2hvdXQsIGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXRcbiMgdGhlIGVudmlyb25tZW50IGZyb20gaGlnaGVyIGluIHRoZSB0cmVlIChzdWNoIGFzIGlmIGEgcmV0dXJuZWQgdmFsdWUgaXNcbiMgYmVpbmcgcmVxdWVzdGVkIGJ5IHRoZSBzdXJyb3VuZGluZyBmdW5jdGlvbiksIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50XG4jIHNjb3BlLCBhbmQgaW5kZW50YXRpb24gbGV2ZWwuXG5leHBvcnRzLkJhc2UgPSBjbGFzcyBCYXNlXG5cbiAgY29tcGlsZTogKG8sIGx2bCkgLT5cbiAgICBmcmFnbWVudHNUb1RleHQgQGNvbXBpbGVUb0ZyYWdtZW50cyBvLCBsdmxcblxuICAjIE9jY2FzaW9uYWxseSBhIG5vZGUgaXMgY29tcGlsZWQgbXVsdGlwbGUgdGltZXMsIGZvciBleGFtcGxlIHRvIGdldCB0aGUgbmFtZVxuICAjIG9mIGEgdmFyaWFibGUgdG8gYWRkIHRvIHNjb3BlIHRyYWNraW5nLiBXaGVuIHdlIGtub3cgdGhhdCBhIOKAnHByZW1hdHVyZeKAnVxuICAjIGNvbXBpbGF0aW9uIHdvbuKAmXQgcmVzdWx0IGluIGNvbW1lbnRzIGJlaW5nIG91dHB1dCwgc2V0IHRob3NlIGNvbW1lbnRzIGFzaWRlXG4gICMgc28gdGhhdCB0aGV54oCZcmUgcHJlc2VydmVkIGZvciBhIGxhdGVyIGBjb21waWxlYCBjYWxsIHRoYXQgd2lsbCByZXN1bHQgaW5cbiAgIyB0aGUgY29tbWVudHMgYmVpbmcgaW5jbHVkZWQgaW4gdGhlIG91dHB1dC5cbiAgY29tcGlsZVdpdGhvdXRDb21tZW50czogKG8sIGx2bCwgbWV0aG9kID0gJ2NvbXBpbGUnKSAtPlxuICAgIGlmIEBjb21tZW50c1xuICAgICAgQGlnbm9yZVRoZXNlQ29tbWVudHNUZW1wb3JhcmlseSA9IEBjb21tZW50c1xuICAgICAgZGVsZXRlIEBjb21tZW50c1xuICAgIHVud3JhcHBlZCA9IEB1bndyYXBBbGwoKVxuICAgIGlmIHVud3JhcHBlZC5jb21tZW50c1xuICAgICAgdW53cmFwcGVkLmlnbm9yZVRoZXNlQ29tbWVudHNUZW1wb3JhcmlseSA9IHVud3JhcHBlZC5jb21tZW50c1xuICAgICAgZGVsZXRlIHVud3JhcHBlZC5jb21tZW50c1xuXG4gICAgZnJhZ21lbnRzID0gQFttZXRob2RdIG8sIGx2bFxuXG4gICAgaWYgQGlnbm9yZVRoZXNlQ29tbWVudHNUZW1wb3JhcmlseVxuICAgICAgQGNvbW1lbnRzID0gQGlnbm9yZVRoZXNlQ29tbWVudHNUZW1wb3JhcmlseVxuICAgICAgZGVsZXRlIEBpZ25vcmVUaGVzZUNvbW1lbnRzVGVtcG9yYXJpbHlcbiAgICBpZiB1bndyYXBwZWQuaWdub3JlVGhlc2VDb21tZW50c1RlbXBvcmFyaWx5XG4gICAgICB1bndyYXBwZWQuY29tbWVudHMgPSB1bndyYXBwZWQuaWdub3JlVGhlc2VDb21tZW50c1RlbXBvcmFyaWx5XG4gICAgICBkZWxldGUgdW53cmFwcGVkLmlnbm9yZVRoZXNlQ29tbWVudHNUZW1wb3JhcmlseVxuXG4gICAgZnJhZ21lbnRzXG5cbiAgY29tcGlsZU5vZGVXaXRob3V0Q29tbWVudHM6IChvLCBsdmwpIC0+XG4gICAgQGNvbXBpbGVXaXRob3V0Q29tbWVudHMgbywgbHZsLCAnY29tcGlsZU5vZGUnXG5cbiAgIyBDb21tb24gbG9naWMgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdG8gd3JhcCB0aGlzIG5vZGUgaW4gYSBjbG9zdXJlIGJlZm9yZVxuICAjIGNvbXBpbGluZyBpdCwgb3IgdG8gY29tcGlsZSBkaXJlY3RseS4gV2UgbmVlZCB0byB3cmFwIGlmIHRoaXMgbm9kZSBpcyBhXG4gICMgKnN0YXRlbWVudCosIGFuZCBpdCdzIG5vdCBhICpwdXJlU3RhdGVtZW50KiwgYW5kIHdlJ3JlIG5vdCBhdFxuICAjIHRoZSB0b3AgbGV2ZWwgb2YgYSBibG9jayAod2hpY2ggd291bGQgYmUgdW5uZWNlc3NhcnkpLCBhbmQgd2UgaGF2ZW4ndFxuICAjIGFscmVhZHkgYmVlbiBhc2tlZCB0byByZXR1cm4gdGhlIHJlc3VsdCAoYmVjYXVzZSBzdGF0ZW1lbnRzIGtub3cgaG93IHRvXG4gICMgcmV0dXJuIHJlc3VsdHMpLlxuICBjb21waWxlVG9GcmFnbWVudHM6IChvLCBsdmwpIC0+XG4gICAgbyAgICAgICAgPSBleHRlbmQge30sIG9cbiAgICBvLmxldmVsICA9IGx2bCBpZiBsdmxcbiAgICBub2RlICAgICA9IEB1bmZvbGRTb2FrKG8pIG9yIHRoaXNcbiAgICBub2RlLnRhYiA9IG8uaW5kZW50XG5cbiAgICBmcmFnbWVudHMgPSBpZiBvLmxldmVsIGlzIExFVkVMX1RPUCBvciBub3Qgbm9kZS5pc1N0YXRlbWVudChvKVxuICAgICAgbm9kZS5jb21waWxlTm9kZSBvXG4gICAgZWxzZVxuICAgICAgbm9kZS5jb21waWxlQ2xvc3VyZSBvXG4gICAgQGNvbXBpbGVDb21tZW50RnJhZ21lbnRzIG8sIG5vZGUsIGZyYWdtZW50c1xuICAgIGZyYWdtZW50c1xuXG4gIGNvbXBpbGVUb0ZyYWdtZW50c1dpdGhvdXRDb21tZW50czogKG8sIGx2bCkgLT5cbiAgICBAY29tcGlsZVdpdGhvdXRDb21tZW50cyBvLCBsdmwsICdjb21waWxlVG9GcmFnbWVudHMnXG5cbiAgIyBTdGF0ZW1lbnRzIGNvbnZlcnRlZCBpbnRvIGV4cHJlc3Npb25zIHZpYSBjbG9zdXJlLXdyYXBwaW5nIHNoYXJlIGEgc2NvcGVcbiAgIyBvYmplY3Qgd2l0aCB0aGVpciBwYXJlbnQgY2xvc3VyZSwgdG8gcHJlc2VydmUgdGhlIGV4cGVjdGVkIGxleGljYWwgc2NvcGUuXG4gIGNvbXBpbGVDbG9zdXJlOiAobykgLT5cbiAgICBAY2hlY2tGb3JQdXJlU3RhdGVtZW50SW5FeHByZXNzaW9uKClcbiAgICBvLnNoYXJlZFNjb3BlID0geWVzXG4gICAgZnVuYyA9IG5ldyBDb2RlIFtdLCBCbG9jay53cmFwIFt0aGlzXVxuICAgIGFyZ3MgPSBbXVxuICAgIGlmIEBjb250YWlucyAoKG5vZGUpIC0+IG5vZGUgaW5zdGFuY2VvZiBTdXBlckNhbGwpXG4gICAgICBmdW5jLmJvdW5kID0geWVzXG4gICAgZWxzZSBpZiAoYXJndW1lbnRzTm9kZSA9IEBjb250YWlucyBpc0xpdGVyYWxBcmd1bWVudHMpIG9yIEBjb250YWlucyBpc0xpdGVyYWxUaGlzXG4gICAgICBhcmdzID0gW25ldyBUaGlzTGl0ZXJhbF1cbiAgICAgIGlmIGFyZ3VtZW50c05vZGVcbiAgICAgICAgbWV0aCA9ICdhcHBseSdcbiAgICAgICAgYXJncy5wdXNoIG5ldyBJZGVudGlmaWVyTGl0ZXJhbCAnYXJndW1lbnRzJ1xuICAgICAgZWxzZVxuICAgICAgICBtZXRoID0gJ2NhbGwnXG4gICAgICBmdW5jID0gbmV3IFZhbHVlIGZ1bmMsIFtuZXcgQWNjZXNzIG5ldyBQcm9wZXJ0eU5hbWUgbWV0aF1cbiAgICBwYXJ0cyA9IChuZXcgQ2FsbCBmdW5jLCBhcmdzKS5jb21waWxlTm9kZSBvXG5cbiAgICBzd2l0Y2hcbiAgICAgIHdoZW4gZnVuYy5pc0dlbmVyYXRvciBvciBmdW5jLmJhc2U/LmlzR2VuZXJhdG9yXG4gICAgICAgIHBhcnRzLnVuc2hpZnQgQG1ha2VDb2RlIFwiKHlpZWxkKiBcIlxuICAgICAgICBwYXJ0cy5wdXNoICAgIEBtYWtlQ29kZSBcIilcIlxuICAgICAgd2hlbiBmdW5jLmlzQXN5bmMgb3IgZnVuYy5iYXNlPy5pc0FzeW5jXG4gICAgICAgIHBhcnRzLnVuc2hpZnQgQG1ha2VDb2RlIFwiKGF3YWl0IFwiXG4gICAgICAgIHBhcnRzLnB1c2ggICAgQG1ha2VDb2RlIFwiKVwiXG4gICAgcGFydHNcblxuICBjb21waWxlQ29tbWVudEZyYWdtZW50czogKG8sIG5vZGUsIGZyYWdtZW50cykgLT5cbiAgICByZXR1cm4gZnJhZ21lbnRzIHVubGVzcyBub2RlLmNvbW1lbnRzXG4gICAgIyBUaGlzIGlzIHdoZXJlIGNvbW1lbnRzLCB0aGF0IGFyZSBhdHRhY2hlZCB0byBub2RlcyBhcyBhIGBjb21tZW50c2BcbiAgICAjIHByb3BlcnR5LCBiZWNvbWUgYENvZGVGcmFnbWVudGBzLiDigJxJbmxpbmUgYmxvY2sgY29tbWVudHMs4oCdIGUuZy5cbiAgICAjIGAvKiAqL2AtZGVsaW1pdGVkIGNvbW1lbnRzIHRoYXQgYXJlIGludGVyc3BlcnNlZCB3aXRoaW4gY29kZSBvbiBhIGxpbmUsXG4gICAgIyBhcmUgYWRkZWQgdG8gdGhlIGN1cnJlbnQgYGZyYWdtZW50c2Agc3RyZWFtLiBBbGwgb3RoZXIgZnJhZ21lbnRzIGFyZVxuICAgICMgYXR0YWNoZWQgYXMgcHJvcGVydGllcyB0byB0aGUgbmVhcmVzdCBwcmVjZWRpbmcgb3IgZm9sbG93aW5nIGZyYWdtZW50LFxuICAgICMgdG8gcmVtYWluIHN0b3dhd2F5cyB1bnRpbCB0aGV5IGdldCBwcm9wZXJseSBvdXRwdXQgaW4gYGNvbXBpbGVDb21tZW50c2BcbiAgICAjIGxhdGVyIG9uLlxuICAgIHVuc2hpZnRDb21tZW50RnJhZ21lbnQgPSAoY29tbWVudEZyYWdtZW50KSAtPlxuICAgICAgaWYgY29tbWVudEZyYWdtZW50LnVuc2hpZnRcbiAgICAgICAgIyBGaW5kIHRoZSBmaXJzdCBub24tY29tbWVudCBmcmFnbWVudCBhbmQgaW5zZXJ0IGBjb21tZW50RnJhZ21lbnRgXG4gICAgICAgICMgYmVmb3JlIGl0LlxuICAgICAgICB1bnNoaWZ0QWZ0ZXJDb21tZW50cyBmcmFnbWVudHMsIGNvbW1lbnRGcmFnbWVudFxuICAgICAgZWxzZVxuICAgICAgICBpZiBmcmFnbWVudHMubGVuZ3RoIGlzbnQgMFxuICAgICAgICAgIHByZWNlZGluZ0ZyYWdtZW50ID0gZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXVxuICAgICAgICAgIGlmIGNvbW1lbnRGcmFnbWVudC5uZXdMaW5lIGFuZCBwcmVjZWRpbmdGcmFnbWVudC5jb2RlIGlzbnQgJycgYW5kXG4gICAgICAgICAgICAgbm90IC9cXG5cXHMqJC8udGVzdCBwcmVjZWRpbmdGcmFnbWVudC5jb2RlXG4gICAgICAgICAgICBjb21tZW50RnJhZ21lbnQuY29kZSA9IFwiXFxuI3tjb21tZW50RnJhZ21lbnQuY29kZX1cIlxuICAgICAgICBmcmFnbWVudHMucHVzaCBjb21tZW50RnJhZ21lbnRcblxuICAgIGZvciBjb21tZW50IGluIG5vZGUuY29tbWVudHMgd2hlbiBjb21tZW50IG5vdCBpbiBAY29tcGlsZWRDb21tZW50c1xuICAgICAgQGNvbXBpbGVkQ29tbWVudHMucHVzaCBjb21tZW50ICMgRG9u4oCZdCBvdXRwdXQgdGhpcyBjb21tZW50IHR3aWNlLlxuICAgICAgIyBGb3IgYmxvY2svaGVyZSBjb21tZW50cywgZGVub3RlZCBieSBgIyMjYCwgdGhhdCBhcmUgaW5saW5lIGNvbW1lbnRzXG4gICAgICAjIGxpa2UgYDEgKyAjIyMgY29tbWVudCAjIyMgMmAsIGNyZWF0ZSBmcmFnbWVudHMgYW5kIGluc2VydCB0aGVtIGludG9cbiAgICAgICMgdGhlIGZyYWdtZW50cyBhcnJheS5cbiAgICAgICMgT3RoZXJ3aXNlIGF0dGFjaCBjb21tZW50IGZyYWdtZW50cyB0byB0aGVpciBjbG9zZXN0IGZyYWdtZW50IGZvciBub3csXG4gICAgICAjIHNvIHRoZXkgY2FuIGJlIGluc2VydGVkIGludG8gdGhlIG91dHB1dCBsYXRlciBhZnRlciBhbGwgdGhlIG5ld2xpbmVzXG4gICAgICAjIGhhdmUgYmVlbiBhZGRlZC5cbiAgICAgIGlmIGNvbW1lbnQuaGVyZSAjIEJsb2NrIGNvbW1lbnQsIGRlbGltaXRlZCBieSBgIyMjYC5cbiAgICAgICAgY29tbWVudEZyYWdtZW50ID0gbmV3IEhlcmVDb21tZW50KGNvbW1lbnQpLmNvbXBpbGVOb2RlIG9cbiAgICAgIGVsc2UgIyBMaW5lIGNvbW1lbnQsIGRlbGltaXRlZCBieSBgI2AuXG4gICAgICAgIGNvbW1lbnRGcmFnbWVudCA9IG5ldyBMaW5lQ29tbWVudChjb21tZW50KS5jb21waWxlTm9kZSBvXG4gICAgICBpZiAoY29tbWVudEZyYWdtZW50LmlzSGVyZUNvbW1lbnQgYW5kIG5vdCBjb21tZW50RnJhZ21lbnQubmV3TGluZSkgb3JcbiAgICAgICAgIG5vZGUuaW5jbHVkZUNvbW1lbnRGcmFnbWVudHMoKVxuICAgICAgICAjIElubGluZSBibG9jayBjb21tZW50cywgbGlrZSBgMSArIC8qIGNvbW1lbnQgKi8gMmAsIG9yIGEgbm9kZSB3aG9zZVxuICAgICAgICAjIGBjb21waWxlVG9GcmFnbWVudHNgIG1ldGhvZCBoYXMgbG9naWMgZm9yIG91dHB1dHRpbmcgY29tbWVudHMuXG4gICAgICAgIHVuc2hpZnRDb21tZW50RnJhZ21lbnQgY29tbWVudEZyYWdtZW50XG4gICAgICBlbHNlXG4gICAgICAgIGZyYWdtZW50cy5wdXNoIEBtYWtlQ29kZSAnJyBpZiBmcmFnbWVudHMubGVuZ3RoIGlzIDBcbiAgICAgICAgaWYgY29tbWVudEZyYWdtZW50LnVuc2hpZnRcbiAgICAgICAgICBmcmFnbWVudHNbMF0ucHJlY2VkaW5nQ29tbWVudHMgPz0gW11cbiAgICAgICAgICBmcmFnbWVudHNbMF0ucHJlY2VkaW5nQ29tbWVudHMucHVzaCBjb21tZW50RnJhZ21lbnRcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0uZm9sbG93aW5nQ29tbWVudHMgPz0gW11cbiAgICAgICAgICBmcmFnbWVudHNbZnJhZ21lbnRzLmxlbmd0aCAtIDFdLmZvbGxvd2luZ0NvbW1lbnRzLnB1c2ggY29tbWVudEZyYWdtZW50XG4gICAgZnJhZ21lbnRzXG5cbiAgIyBJZiB0aGUgY29kZSBnZW5lcmF0aW9uIHdpc2hlcyB0byB1c2UgdGhlIHJlc3VsdCBvZiBhIGNvbXBsZXggZXhwcmVzc2lvblxuICAjIGluIG11bHRpcGxlIHBsYWNlcywgZW5zdXJlIHRoYXQgdGhlIGV4cHJlc3Npb24gaXMgb25seSBldmVyIGV2YWx1YXRlZCBvbmNlLFxuICAjIGJ5IGFzc2lnbmluZyBpdCB0byBhIHRlbXBvcmFyeSB2YXJpYWJsZS4gUGFzcyBhIGxldmVsIHRvIHByZWNvbXBpbGUuXG4gICNcbiAgIyBJZiBgbGV2ZWxgIGlzIHBhc3NlZCwgdGhlbiByZXR1cm5zIGBbdmFsLCByZWZdYCwgd2hlcmUgYHZhbGAgaXMgdGhlIGNvbXBpbGVkIHZhbHVlLCBhbmQgYHJlZmBcbiAgIyBpcyB0aGUgY29tcGlsZWQgcmVmZXJlbmNlLiBJZiBgbGV2ZWxgIGlzIG5vdCBwYXNzZWQsIHRoaXMgcmV0dXJucyBgW3ZhbCwgcmVmXWAgd2hlcmVcbiAgIyB0aGUgdHdvIHZhbHVlcyBhcmUgcmF3IG5vZGVzIHdoaWNoIGhhdmUgbm90IGJlZW4gY29tcGlsZWQuXG4gIGNhY2hlOiAobywgbGV2ZWwsIHNob3VsZENhY2hlKSAtPlxuICAgIGNvbXBsZXggPSBpZiBzaG91bGRDYWNoZT8gdGhlbiBzaG91bGRDYWNoZSB0aGlzIGVsc2UgQHNob3VsZENhY2hlKClcbiAgICBpZiBjb21wbGV4XG4gICAgICByZWYgPSBuZXcgSWRlbnRpZmllckxpdGVyYWwgby5zY29wZS5mcmVlVmFyaWFibGUgJ3JlZidcbiAgICAgIHN1YiA9IG5ldyBBc3NpZ24gcmVmLCB0aGlzXG4gICAgICBpZiBsZXZlbCB0aGVuIFtzdWIuY29tcGlsZVRvRnJhZ21lbnRzKG8sIGxldmVsKSwgW0BtYWtlQ29kZShyZWYudmFsdWUpXV0gZWxzZSBbc3ViLCByZWZdXG4gICAgZWxzZVxuICAgICAgcmVmID0gaWYgbGV2ZWwgdGhlbiBAY29tcGlsZVRvRnJhZ21lbnRzIG8sIGxldmVsIGVsc2UgdGhpc1xuICAgICAgW3JlZiwgcmVmXVxuXG4gICMgT2NjYXNpb25hbGx5IGl0IG1heSBiZSB1c2VmdWwgdG8gbWFrZSBhbiBleHByZXNzaW9uIGJlaGF2ZSBhcyBpZiBpdCB3YXMgJ2hvaXN0ZWQnLCB3aGVyZWJ5IHRoZVxuICAjIHJlc3VsdCBvZiB0aGUgZXhwcmVzc2lvbiBpcyBhdmFpbGFibGUgYmVmb3JlIGl0cyBsb2NhdGlvbiBpbiB0aGUgc291cmNlLCBidXQgdGhlIGV4cHJlc3Npb24nc1xuICAjIHZhcmlhYmxlIHNjb3BlIGNvcnJlc3BvbmRzIHRvIHRoZSBzb3VyY2UgcG9zaXRpb24uIFRoaXMgaXMgdXNlZCBleHRlbnNpdmVseSB0byBkZWFsIHdpdGggZXhlY3V0YWJsZVxuICAjIGNsYXNzIGJvZGllcyBpbiBjbGFzc2VzLlxuICAjXG4gICMgQ2FsbGluZyB0aGlzIG1ldGhvZCBtdXRhdGVzIHRoZSBub2RlLCBwcm94eWluZyB0aGUgYGNvbXBpbGVOb2RlYCBhbmQgYGNvbXBpbGVUb0ZyYWdtZW50c2BcbiAgIyBtZXRob2RzIHRvIHN0b3JlIHRoZWlyIHJlc3VsdCBmb3IgbGF0ZXIgcmVwbGFjaW5nIHRoZSBgdGFyZ2V0YCBub2RlLCB3aGljaCBpcyByZXR1cm5lZCBieSB0aGVcbiAgIyBjYWxsLlxuICBob2lzdDogLT5cbiAgICBAaG9pc3RlZCA9IHllc1xuICAgIHRhcmdldCAgID0gbmV3IEhvaXN0VGFyZ2V0IEBcblxuICAgIGNvbXBpbGVOb2RlICAgICAgICA9IEBjb21waWxlTm9kZVxuICAgIGNvbXBpbGVUb0ZyYWdtZW50cyA9IEBjb21waWxlVG9GcmFnbWVudHNcblxuICAgIEBjb21waWxlTm9kZSA9IChvKSAtPlxuICAgICAgdGFyZ2V0LnVwZGF0ZSBjb21waWxlTm9kZSwgb1xuXG4gICAgQGNvbXBpbGVUb0ZyYWdtZW50cyA9IChvKSAtPlxuICAgICAgdGFyZ2V0LnVwZGF0ZSBjb21waWxlVG9GcmFnbWVudHMsIG9cblxuICAgIHRhcmdldFxuXG4gIGNhY2hlVG9Db2RlRnJhZ21lbnRzOiAoY2FjaGVWYWx1ZXMpIC0+XG4gICAgW2ZyYWdtZW50c1RvVGV4dChjYWNoZVZhbHVlc1swXSksIGZyYWdtZW50c1RvVGV4dChjYWNoZVZhbHVlc1sxXSldXG5cbiAgIyBDb25zdHJ1Y3QgYSBub2RlIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCBub2Rl4oCZcyByZXN1bHQuXG4gICMgTm90ZSB0aGF0IHRoaXMgaXMgb3ZlcnJpZGRlbiBmb3Igc21hcnRlciBiZWhhdmlvciBmb3JcbiAgIyBtYW55IHN0YXRlbWVudCBub2RlcyAoZS5nLiBgSWZgLCBgRm9yYCkuXG4gIG1ha2VSZXR1cm46IChyZXN1bHRzLCBtYXJrKSAtPlxuICAgIGlmIG1hcmtcbiAgICAgICMgTWFyayB0aGlzIG5vZGUgYXMgaW1wbGljaXRseSByZXR1cm5lZCwgc28gdGhhdCBpdCBjYW4gYmUgcGFydCBvZiB0aGVcbiAgICAgICMgbm9kZSBtZXRhZGF0YSByZXR1cm5lZCBpbiB0aGUgQVNULlxuICAgICAgQGNhbkJlUmV0dXJuZWQgPSB5ZXNcbiAgICAgIHJldHVyblxuICAgIG5vZGUgPSBAdW53cmFwQWxsKClcbiAgICBpZiByZXN1bHRzXG4gICAgICBuZXcgQ2FsbCBuZXcgTGl0ZXJhbChcIiN7cmVzdWx0c30ucHVzaFwiKSwgW25vZGVdXG4gICAgZWxzZVxuICAgICAgbmV3IFJldHVybiBub2RlXG5cbiAgIyBEb2VzIHRoaXMgbm9kZSwgb3IgYW55IG9mIGl0cyBjaGlsZHJlbiwgY29udGFpbiBhIG5vZGUgb2YgYSBjZXJ0YWluIGtpbmQ/XG4gICMgUmVjdXJzaXZlbHkgdHJhdmVyc2VzIGRvd24gdGhlICpjaGlsZHJlbiogbm9kZXMgYW5kIHJldHVybnMgdGhlIGZpcnN0IG9uZVxuICAjIHRoYXQgdmVyaWZpZXMgYHByZWRgLiBPdGhlcndpc2UgcmV0dXJuIHVuZGVmaW5lZC4gYGNvbnRhaW5zYCBkb2VzIG5vdCBjcm9zc1xuICAjIHNjb3BlIGJvdW5kYXJpZXMuXG4gIGNvbnRhaW5zOiAocHJlZCkgLT5cbiAgICBub2RlID0gdW5kZWZpbmVkXG4gICAgQHRyYXZlcnNlQ2hpbGRyZW4gbm8sIChuKSAtPlxuICAgICAgaWYgcHJlZCBuXG4gICAgICAgIG5vZGUgPSBuXG4gICAgICAgIHJldHVybiBub1xuICAgIG5vZGVcblxuICAjIFB1bGwgb3V0IHRoZSBsYXN0IG5vZGUgb2YgYSBub2RlIGxpc3QuXG4gIGxhc3ROb2RlOiAobGlzdCkgLT5cbiAgICBpZiBsaXN0Lmxlbmd0aCBpcyAwIHRoZW4gbnVsbCBlbHNlIGxpc3RbbGlzdC5sZW5ndGggLSAxXVxuXG4gICMgRGVidWdnaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBub2RlLCBmb3IgaW5zcGVjdGluZyB0aGUgcGFyc2UgdHJlZS5cbiAgIyBUaGlzIGlzIHdoYXQgYGNvZmZlZSAtLW5vZGVzYCBwcmludHMgb3V0LlxuICB0b1N0cmluZzogKGlkdCA9ICcnLCBuYW1lID0gQGNvbnN0cnVjdG9yLm5hbWUpIC0+XG4gICAgdHJlZSA9ICdcXG4nICsgaWR0ICsgbmFtZVxuICAgIHRyZWUgKz0gJz8nIGlmIEBzb2FrXG4gICAgQGVhY2hDaGlsZCAobm9kZSkgLT4gdHJlZSArPSBub2RlLnRvU3RyaW5nIGlkdCArIFRBQlxuICAgIHRyZWVcblxuICBjaGVja0ZvclB1cmVTdGF0ZW1lbnRJbkV4cHJlc3Npb246IC0+XG4gICAgaWYganVtcE5vZGUgPSBAanVtcHMoKVxuICAgICAganVtcE5vZGUuZXJyb3IgJ2Nhbm5vdCB1c2UgYSBwdXJlIHN0YXRlbWVudCBpbiBhbiBleHByZXNzaW9uJ1xuXG4gICMgUGxhaW4gSmF2YVNjcmlwdCBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhlIG5vZGUsIHRoYXQgY2FuIGJlIHNlcmlhbGl6ZWRcbiAgIyBhcyBKU09OLiBUaGlzIGlzIHdoYXQgdGhlIGBhc3RgIG9wdGlvbiBpbiB0aGUgTm9kZSBBUEkgcmV0dXJucy5cbiAgIyBXZSB0cnkgdG8gZm9sbG93IHRoZSBbQmFiZWwgQVNUIHNwZWNdKGh0dHBzOi8vZ2l0aHViLmNvbS9iYWJlbC9iYWJlbC9ibG9iL21hc3Rlci9wYWNrYWdlcy9iYWJlbC1wYXJzZXIvYXN0L3NwZWMubWQpXG4gICMgYXMgY2xvc2VseSBhcyBwb3NzaWJsZSwgZm9yIGltcHJvdmVkIGludGVyb3BlcmFiaWxpdHkgd2l0aCBvdGhlciB0b29scy5cbiAgIyAqKldBUk5JTkc6IERPIE5PVCBPVkVSUklERSBUSElTIE1FVEhPRCBJTiBDSElMRCBDTEFTU0VTLioqXG4gICMgT25seSBvdmVycmlkZSB0aGUgY29tcG9uZW50IGBhc3QqYCBtZXRob2RzIGFzIG5lZWRlZC5cbiAgYXN0OiAobywgbGV2ZWwpIC0+XG4gICAgIyBNZXJnZSBgbGV2ZWxgIGludG8gYG9gIGFuZCBwZXJmb3JtIG90aGVyIHVuaXZlcnNhbCBjaGVja3MuXG4gICAgbyA9IEBhc3RJbml0aWFsaXplIG8sIGxldmVsXG4gICAgIyBDcmVhdGUgc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbm9kZS5cbiAgICBhc3ROb2RlID0gQGFzdE5vZGUgb1xuICAgICMgTWFyayBBU1Qgbm9kZXMgdGhhdCBjb3JyZXNwb25kIHRvIGV4cHJlc3Npb25zIHRoYXQgKGltcGxpY2l0bHkpIHJldHVybi5cbiAgICAjIFdlIGNhbuKAmXQgZG8gdGhpcyBhcyBwYXJ0IG9mIGBhc3ROb2RlYCBiZWNhdXNlIHdlIG5lZWQgdG8gYXNzZW1ibGUgY2hpbGRcbiAgICAjIG5vZGVzIGZpcnN0IGJlZm9yZSBtYXJraW5nIHRoZSBwYXJlbnQgYmVpbmcgcmV0dXJuZWQuXG4gICAgaWYgQGFzdE5vZGU/IGFuZCBAY2FuQmVSZXR1cm5lZFxuICAgICAgT2JqZWN0LmFzc2lnbiBhc3ROb2RlLCB7cmV0dXJuczogeWVzfVxuICAgIGFzdE5vZGVcblxuICBhc3RJbml0aWFsaXplOiAobywgbGV2ZWwpIC0+XG4gICAgbyA9IE9iamVjdC5hc3NpZ24ge30sIG9cbiAgICBvLmxldmVsID0gbGV2ZWwgaWYgbGV2ZWw/XG4gICAgaWYgby5sZXZlbCA+IExFVkVMX1RPUFxuICAgICAgQGNoZWNrRm9yUHVyZVN0YXRlbWVudEluRXhwcmVzc2lvbigpXG4gICAgIyBgQG1ha2VSZXR1cm5gIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBgYXN0UHJvcGVydGllc2AsIGJlY2F1c2UgdGhlIGxhdHRlciBtYXkgY2FsbFxuICAgICMgYC5hc3QoKWAgZm9yIGNoaWxkIG5vZGVzIGFuZCB0aG9zZSBub2RlcyB3b3VsZCBuZWVkIHRoZSByZXR1cm4gbG9naWMgZnJvbSBgbWFrZVJldHVybmBcbiAgICAjIGFscmVhZHkgZXhlY3V0ZWQgYnkgdGhlbi5cbiAgICBAbWFrZVJldHVybiBudWxsLCB5ZXMgaWYgQGlzU3RhdGVtZW50KG8pIGFuZCBvLmxldmVsIGlzbnQgTEVWRUxfVE9QIGFuZCBvLnNjb3BlP1xuICAgIG9cblxuICBhc3ROb2RlOiAobykgLT5cbiAgICAjIEV2ZXJ5IGFic3RyYWN0IHN5bnRheCB0cmVlIG5vZGUgb2JqZWN0IGhhcyBmb3VyIGNhdGVnb3JpZXMgb2YgcHJvcGVydGllczpcbiAgICAjIC0gdHlwZSwgc3RvcmVkIGluIHRoZSBgdHlwZWAgZmllbGQgYW5kIGEgc3RyaW5nIGxpa2UgYE51bWJlckxpdGVyYWxgLlxuICAgICMgLSBsb2NhdGlvbiBkYXRhLCBzdG9yZWQgaW4gdGhlIGBsb2NgLCBgc3RhcnRgLCBgZW5kYCBhbmQgYHJhbmdlYCBmaWVsZHMuXG4gICAgIyAtIHByb3BlcnRpZXMgc3BlY2lmaWMgdG8gdGhpcyBub2RlLCBsaWtlIGBwYXJzZWRWYWx1ZWAuXG4gICAgIyAtIHByb3BlcnRpZXMgdGhhdCBhcmUgdGhlbXNlbHZlcyBjaGlsZCBub2RlcywgbGlrZSBgYm9keWAuXG4gICAgIyBUaGVzZSBmaWVsZHMgYXJlIGFsbCBpbnRlcm1peGVkIGluIHRoZSBCYWJlbCBzcGVjOyBgdHlwZWAgYW5kIGBzdGFydGAgYW5kXG4gICAgIyBgcGFyc2VkVmFsdWVgIGFyZSBhbGwgdG9wIGxldmVsIGZpZWxkcyBpbiB0aGUgQVNUIG5vZGUgb2JqZWN0LiBXZSBoYXZlXG4gICAgIyBzZXBhcmF0ZSBtZXRob2RzIGZvciByZXR1cm5pbmcgZWFjaCBjYXRlZ29yeSwgdGhhdCB3ZSBtZXJnZSB0b2dldGhlciBoZXJlLlxuICAgIE9iamVjdC5hc3NpZ24ge30sIHt0eXBlOiBAYXN0VHlwZShvKX0sIEBhc3RQcm9wZXJ0aWVzKG8pLCBAYXN0TG9jYXRpb25EYXRhKClcblxuICAjIEJ5IGRlZmF1bHQsIGEgbm9kZSBjbGFzcyBoYXMgbm8gc3BlY2lmaWMgcHJvcGVydGllcy5cbiAgYXN0UHJvcGVydGllczogLT4ge31cblxuICAjIEJ5IGRlZmF1bHQsIGEgbm9kZSBjbGFzc+KAmXMgQVNUIGB0eXBlYCBpcyBpdHMgY2xhc3MgbmFtZS5cbiAgYXN0VHlwZTogLT4gQGNvbnN0cnVjdG9yLm5hbWVcblxuICAjIFRoZSBBU1QgbG9jYXRpb24gZGF0YSBpcyBhIHJlYXJyYW5nZWQgdmVyc2lvbiBvZiBvdXIgSmlzb24gbG9jYXRpb24gZGF0YSxcbiAgIyBtdXRhdGVkIGludG8gdGhlIHN0cnVjdHVyZSB0aGF0IHRoZSBCYWJlbCBzcGVjIHVzZXMuXG4gIGFzdExvY2F0aW9uRGF0YTogLT5cbiAgICBqaXNvbkxvY2F0aW9uRGF0YVRvQXN0TG9jYXRpb25EYXRhIEBsb2NhdGlvbkRhdGFcblxuICAjIERldGVybWluZXMgd2hldGhlciBhbiBBU1Qgbm9kZSBuZWVkcyBhbiBgRXhwcmVzc2lvblN0YXRlbWVudGAgd3JhcHBlci5cbiAgIyBUeXBpY2FsbHkgbWF0Y2hlcyBvdXIgYGlzU3RhdGVtZW50KClgIGxvZ2ljIGJ1dCB0aGlzIGFsbG93cyBvdmVycmlkaW5nLlxuICBpc1N0YXRlbWVudEFzdDogKG8pIC0+XG4gICAgQGlzU3RhdGVtZW50IG9cblxuICAjIFBhc3NlcyBlYWNoIGNoaWxkIHRvIGEgZnVuY3Rpb24sIGJyZWFraW5nIHdoZW4gdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYC5cbiAgZWFjaENoaWxkOiAoZnVuYykgLT5cbiAgICByZXR1cm4gdGhpcyB1bmxlc3MgQGNoaWxkcmVuXG4gICAgZm9yIGF0dHIgaW4gQGNoaWxkcmVuIHdoZW4gQFthdHRyXVxuICAgICAgZm9yIGNoaWxkIGluIGZsYXR0ZW4gW0BbYXR0cl1dXG4gICAgICAgIHJldHVybiB0aGlzIGlmIGZ1bmMoY2hpbGQpIGlzIGZhbHNlXG4gICAgdGhpc1xuXG4gIHRyYXZlcnNlQ2hpbGRyZW46IChjcm9zc1Njb3BlLCBmdW5jKSAtPlxuICAgIEBlYWNoQ2hpbGQgKGNoaWxkKSAtPlxuICAgICAgcmVjdXIgPSBmdW5jKGNoaWxkKVxuICAgICAgY2hpbGQudHJhdmVyc2VDaGlsZHJlbihjcm9zc1Njb3BlLCBmdW5jKSB1bmxlc3MgcmVjdXIgaXMgbm9cblxuICAjIGByZXBsYWNlSW5Db250ZXh0YCB3aWxsIHRyYXZlcnNlIGNoaWxkcmVuIGxvb2tpbmcgZm9yIGEgbm9kZSBmb3Igd2hpY2ggYG1hdGNoYCByZXR1cm5zXG4gICMgdHJ1ZS4gT25jZSBmb3VuZCwgdGhlIG1hdGNoaW5nIG5vZGUgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYHJlcGxhY2VtZW50YC5cbiAgcmVwbGFjZUluQ29udGV4dDogKG1hdGNoLCByZXBsYWNlbWVudCkgLT5cbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIEBjaGlsZHJlblxuICAgIGZvciBhdHRyIGluIEBjaGlsZHJlbiB3aGVuIGNoaWxkcmVuID0gQFthdHRyXVxuICAgICAgaWYgQXJyYXkuaXNBcnJheSBjaGlsZHJlblxuICAgICAgICBmb3IgY2hpbGQsIGkgaW4gY2hpbGRyZW5cbiAgICAgICAgICBpZiBtYXRjaCBjaGlsZFxuICAgICAgICAgICAgY2hpbGRyZW5baS4uaV0gPSByZXBsYWNlbWVudCBjaGlsZCwgQFxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZSBpZiBjaGlsZC5yZXBsYWNlSW5Db250ZXh0IG1hdGNoLCByZXBsYWNlbWVudFxuICAgICAgZWxzZSBpZiBtYXRjaCBjaGlsZHJlblxuICAgICAgICBAW2F0dHJdID0gcmVwbGFjZW1lbnQgY2hpbGRyZW4sIEBcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHRydWUgaWYgY2hpbGRyZW4ucmVwbGFjZUluQ29udGV4dCBtYXRjaCwgcmVwbGFjZW1lbnRcblxuICBpbnZlcnQ6IC0+XG4gICAgbmV3IE9wICchJywgdGhpc1xuXG4gIHVud3JhcEFsbDogLT5cbiAgICBub2RlID0gdGhpc1xuICAgIGNvbnRpbnVlIHVudGlsIG5vZGUgaXMgbm9kZSA9IG5vZGUudW53cmFwKClcbiAgICBub2RlXG5cbiAgIyBEZWZhdWx0IGltcGxlbWVudGF0aW9ucyBvZiB0aGUgY29tbW9uIG5vZGUgcHJvcGVydGllcyBhbmQgbWV0aG9kcy4gTm9kZXNcbiAgIyB3aWxsIG92ZXJyaWRlIHRoZXNlIHdpdGggY3VzdG9tIGxvZ2ljLCBpZiBuZWVkZWQuXG5cbiAgIyBgY2hpbGRyZW5gIGFyZSB0aGUgcHJvcGVydGllcyB0byByZWN1cnNlIGludG8gd2hlbiB0cmVlIHdhbGtpbmcuIFRoZVxuICAjIGBjaGlsZHJlbmAgbGlzdCAqaXMqIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIEFTVC4gVGhlIGBwYXJlbnRgIHBvaW50ZXIsIGFuZFxuICAjIHRoZSBwb2ludGVyIHRvIHRoZSBgY2hpbGRyZW5gIGFyZSBob3cgeW91IGNhbiB0cmF2ZXJzZSB0aGUgdHJlZS5cbiAgY2hpbGRyZW46IFtdXG5cbiAgIyBgaXNTdGF0ZW1lbnRgIGhhcyB0byBkbyB3aXRoIOKAnGV2ZXJ5dGhpbmcgaXMgYW4gZXhwcmVzc2lvbuKAnS4gQSBmZXcgdGhpbmdzXG4gICMgY2Fu4oCZdCBiZSBleHByZXNzaW9ucywgc3VjaCBhcyBgYnJlYWtgLiBUaGluZ3MgdGhhdCBgaXNTdGF0ZW1lbnRgIHJldHVybnNcbiAgIyBgdHJ1ZWAgZm9yIGFyZSB0aGluZ3MgdGhhdCBjYW7igJl0IGJlIHVzZWQgYXMgZXhwcmVzc2lvbnMuIFRoZXJlIGFyZSBzb21lXG4gICMgZXJyb3IgbWVzc2FnZXMgdGhhdCBjb21lIGZyb20gYG5vZGVzLmNvZmZlZWAgZHVlIHRvIHN0YXRlbWVudHMgZW5kaW5nIHVwXG4gICMgaW4gZXhwcmVzc2lvbiBwb3NpdGlvbi5cbiAgaXNTdGF0ZW1lbnQ6IE5PXG5cbiAgIyBUcmFjayBjb21tZW50cyB0aGF0IGhhdmUgYmVlbiBjb21waWxlZCBpbnRvIGZyYWdtZW50cywgdG8gYXZvaWQgb3V0cHV0dGluZ1xuICAjIHRoZW0gdHdpY2UuXG4gIGNvbXBpbGVkQ29tbWVudHM6IFtdXG5cbiAgIyBgaW5jbHVkZUNvbW1lbnRGcmFnbWVudHNgIGxldHMgYGNvbXBpbGVDb21tZW50RnJhZ21lbnRzYCBrbm93IHdoZXRoZXIgdGhpcyBub2RlXG4gICMgaGFzIHNwZWNpYWwgYXdhcmVuZXNzIG9mIGhvdyB0byBoYW5kbGUgY29tbWVudHMgd2l0aGluIGl0cyBvdXRwdXQuXG4gIGluY2x1ZGVDb21tZW50RnJhZ21lbnRzOiBOT1xuXG4gICMgYGp1bXBzYCB0ZWxscyB5b3UgaWYgYW4gZXhwcmVzc2lvbiwgb3IgYW4gaW50ZXJuYWwgcGFydCBvZiBhbiBleHByZXNzaW9uLFxuICAjIGhhcyBhIGZsb3cgY29udHJvbCBjb25zdHJ1Y3QgKGxpa2UgYGJyZWFrYCwgYGNvbnRpbnVlYCwgb3IgYHJldHVybmApXG4gICMgdGhhdCBqdW1wcyBvdXQgb2YgdGhlIG5vcm1hbCBmbG93IG9mIGNvbnRyb2wgYW5kIGNhbuKAmXQgYmUgdXNlZCBhcyBhIHZhbHVlLlxuICAjIChOb3RlIHRoYXQgYHRocm93YCBpcyBub3QgY29uc2lkZXJlZCBhIGZsb3cgY29udHJvbCBjb25zdHJ1Y3QuKVxuICAjIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgZmxvdyBjb250cm9sIGluIHRoZSBtaWRkbGUgb2YgYW4gZXhwcmVzc2lvblxuICAjIG1ha2VzIG5vIHNlbnNlOyB3ZSBoYXZlIHRvIGRpc2FsbG93IGl0LlxuICBqdW1wczogTk9cblxuICAjIElmIGBub2RlLnNob3VsZENhY2hlKCkgaXMgZmFsc2VgLCBpdCBpcyBzYWZlIHRvIHVzZSBgbm9kZWAgbW9yZSB0aGFuIG9uY2UuXG4gICMgT3RoZXJ3aXNlIHlvdSBuZWVkIHRvIHN0b3JlIHRoZSB2YWx1ZSBvZiBgbm9kZWAgaW4gYSB2YXJpYWJsZSBhbmQgb3V0cHV0XG4gICMgdGhhdCB2YXJpYWJsZSBzZXZlcmFsIHRpbWVzIGluc3RlYWQuIEtpbmQgb2YgbGlrZSB0aGlzOiBgNWAgbmVlZCBub3QgYmVcbiAgIyBjYWNoZWQuIGByZXR1cm5GaXZlKClgLCBob3dldmVyLCBjb3VsZCBoYXZlIHNpZGUgZWZmZWN0cyBhcyBhIHJlc3VsdCBvZlxuICAjIGV2YWx1YXRpbmcgaXQgbW9yZSB0aGFuIG9uY2UsIGFuZCB0aGVyZWZvcmUgd2UgbmVlZCB0byBjYWNoZSBpdC4gVGhlXG4gICMgcGFyYW1ldGVyIGlzIG5hbWVkIGBzaG91bGRDYWNoZWAgcmF0aGVyIHRoYW4gYG11c3RDYWNoZWAgYmVjYXVzZSB0aGVyZSBhcmVcbiAgIyBhbHNvIGNhc2VzIHdoZXJlIHdlIG1pZ2h0IG5vdCBuZWVkIHRvIGNhY2hlIGJ1dCB3aGVyZSB3ZSB3YW50IHRvLCBmb3JcbiAgIyBleGFtcGxlIGEgbG9uZyBleHByZXNzaW9uIHRoYXQgbWF5IHdlbGwgYmUgaWRlbXBvdGVudCBidXQgd2Ugd2FudCB0byBjYWNoZVxuICAjIGZvciBicmV2aXR5LlxuICBzaG91bGRDYWNoZTogWUVTXG5cbiAgaXNDaGFpbmFibGU6IE5PXG4gIGlzQXNzaWduYWJsZTogTk9cbiAgaXNOdW1iZXI6IE5PXG5cbiAgdW53cmFwOiBUSElTXG4gIHVuZm9sZFNvYWs6IE5PXG5cbiAgIyBJcyB0aGlzIG5vZGUgdXNlZCB0byBhc3NpZ24gYSBjZXJ0YWluIHZhcmlhYmxlP1xuICBhc3NpZ25zOiBOT1xuXG4gICMgRm9yIHRoaXMgbm9kZSBhbmQgYWxsIGRlc2NlbmRlbnRzLCBzZXQgdGhlIGxvY2F0aW9uIGRhdGEgdG8gYGxvY2F0aW9uRGF0YWBcbiAgIyBpZiB0aGUgbG9jYXRpb24gZGF0YSBpcyBub3QgYWxyZWFkeSBzZXQuXG4gIHVwZGF0ZUxvY2F0aW9uRGF0YUlmTWlzc2luZzogKGxvY2F0aW9uRGF0YSwgZm9yY2UpIC0+XG4gICAgQGZvcmNlVXBkYXRlTG9jYXRpb24gPSB5ZXMgaWYgZm9yY2VcbiAgICByZXR1cm4gdGhpcyBpZiBAbG9jYXRpb25EYXRhIGFuZCBub3QgQGZvcmNlVXBkYXRlTG9jYXRpb25cbiAgICBkZWxldGUgQGZvcmNlVXBkYXRlTG9jYXRpb25cbiAgICBAbG9jYXRpb25EYXRhID0gbG9jYXRpb25EYXRhXG5cbiAgICBAZWFjaENoaWxkIChjaGlsZCkgLT5cbiAgICAgIGNoaWxkLnVwZGF0ZUxvY2F0aW9uRGF0YUlmTWlzc2luZyBsb2NhdGlvbkRhdGFcblxuICAjIEFkZCBsb2NhdGlvbiBkYXRhIGZyb20gYW5vdGhlciBub2RlXG4gIHdpdGhMb2NhdGlvbkRhdGFGcm9tOiAoe2xvY2F0aW9uRGF0YX0pIC0+XG4gICAgQHVwZGF0ZUxvY2F0aW9uRGF0YUlmTWlzc2luZyBsb2NhdGlvbkRhdGFcblxuICAjIEFkZCBsb2NhdGlvbiBkYXRhIGFuZCBjb21tZW50cyBmcm9tIGFub3RoZXIgbm9kZVxuICB3aXRoTG9jYXRpb25EYXRhQW5kQ29tbWVudHNGcm9tOiAobm9kZSkgLT5cbiAgICBAd2l0aExvY2F0aW9uRGF0YUZyb20gbm9kZVxuICAgIHtjb21tZW50c30gPSBub2RlXG4gICAgQGNvbW1lbnRzID0gY29tbWVudHMgaWYgY29tbWVudHM/Lmxlbmd0aFxuICAgIHRoaXNcblxuICAjIFRocm93IGEgU3ludGF4RXJyb3IgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZeKAmXMgbG9jYXRpb24uXG4gIGVycm9yOiAobWVzc2FnZSkgLT5cbiAgICB0aHJvd1N5bnRheEVycm9yIG1lc3NhZ2UsIEBsb2NhdGlvbkRhdGFcblxuICBtYWtlQ29kZTogKGNvZGUpIC0+XG4gICAgbmV3IENvZGVGcmFnbWVudCB0aGlzLCBjb2RlXG5cbiAgd3JhcEluUGFyZW50aGVzZXM6IChmcmFnbWVudHMpIC0+XG4gICAgW0BtYWtlQ29kZSgnKCcpLCBmcmFnbWVudHMuLi4sIEBtYWtlQ29kZSgnKScpXVxuXG4gIHdyYXBJbkJyYWNlczogKGZyYWdtZW50cykgLT5cbiAgICBbQG1ha2VDb2RlKCd7JyksIGZyYWdtZW50cy4uLiwgQG1ha2VDb2RlKCd9JyldXG5cbiAgIyBgZnJhZ21lbnRzTGlzdGAgaXMgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIGZyYWdtZW50cy4gRWFjaCBhcnJheSBpbiBmcmFnbWVudHNMaXN0IHdpbGwgYmVcbiAgIyBjb25jYXRlbmF0ZWQgdG9nZXRoZXIsIHdpdGggYGpvaW5TdHJgIGFkZGVkIGluIGJldHdlZW4gZWFjaCwgdG8gcHJvZHVjZSBhIGZpbmFsIGZsYXQgYXJyYXlcbiAgIyBvZiBmcmFnbWVudHMuXG4gIGpvaW5GcmFnbWVudEFycmF5czogKGZyYWdtZW50c0xpc3QsIGpvaW5TdHIpIC0+XG4gICAgYW5zd2VyID0gW11cbiAgICBmb3IgZnJhZ21lbnRzLCBpIGluIGZyYWdtZW50c0xpc3RcbiAgICAgIGlmIGkgdGhlbiBhbnN3ZXIucHVzaCBAbWFrZUNvZGUgam9pblN0clxuICAgICAgYW5zd2VyID0gYW5zd2VyLmNvbmNhdCBmcmFnbWVudHNcbiAgICBhbnN3ZXJcblxuIyMjIyBIb2lzdFRhcmdldFxuXG4jIEEgKipIb2lzdFRhcmdldE5vZGUqKiByZXByZXNlbnRzIHRoZSBvdXRwdXQgbG9jYXRpb24gaW4gdGhlIG5vZGUgdHJlZSBmb3IgYSBob2lzdGVkIG5vZGUuXG4jIFNlZSBCYXNlI2hvaXN0LlxuZXhwb3J0cy5Ib2lzdFRhcmdldCA9IGNsYXNzIEhvaXN0VGFyZ2V0IGV4dGVuZHMgQmFzZVxuICAjIEV4cGFuZHMgaG9pc3RlZCBmcmFnbWVudHMgaW4gdGhlIGdpdmVuIGFycmF5XG4gIEBleHBhbmQgPSAoZnJhZ21lbnRzKSAtPlxuICAgIGZvciBmcmFnbWVudCwgaSBpbiBmcmFnbWVudHMgYnkgLTEgd2hlbiBmcmFnbWVudC5mcmFnbWVudHNcbiAgICAgIGZyYWdtZW50c1tpLi5pXSA9IEBleHBhbmQgZnJhZ21lbnQuZnJhZ21lbnRzXG4gICAgZnJhZ21lbnRzXG5cbiAgY29uc3RydWN0b3I6IChAc291cmNlKSAtPlxuICAgIHN1cGVyKClcblxuICAgICMgSG9sZHMgcHJlc2VudGF0aW9uYWwgb3B0aW9ucyB0byBhcHBseSB3aGVuIHRoZSBzb3VyY2Ugbm9kZSBpcyBjb21waWxlZC5cbiAgICBAb3B0aW9ucyA9IHt9XG5cbiAgICAjIFBsYWNlaG9sZGVyIGZyYWdtZW50cyB0byBiZSByZXBsYWNlZCBieSB0aGUgc291cmNlIG5vZGXigJlzIGNvbXBpbGF0aW9uLlxuICAgIEB0YXJnZXRGcmFnbWVudHMgPSB7IGZyYWdtZW50czogW10gfVxuXG4gIGlzU3RhdGVtZW50OiAobykgLT5cbiAgICBAc291cmNlLmlzU3RhdGVtZW50IG9cblxuICAjIFVwZGF0ZSB0aGUgdGFyZ2V0IGZyYWdtZW50cyB3aXRoIHRoZSByZXN1bHQgb2YgY29tcGlsaW5nIHRoZSBzb3VyY2UuXG4gICMgQ2FsbHMgdGhlIGdpdmVuIGNvbXBpbGUgZnVuY3Rpb24gd2l0aCB0aGUgbm9kZSBhbmQgb3B0aW9ucyAob3ZlcnJpZGVuIHdpdGggdGhlIHRhcmdldFxuICAjIHByZXNlbnRhdGlvbmFsIG9wdGlvbnMpLlxuICB1cGRhdGU6IChjb21waWxlLCBvKSAtPlxuICAgIEB0YXJnZXRGcmFnbWVudHMuZnJhZ21lbnRzID0gY29tcGlsZS5jYWxsIEBzb3VyY2UsIG1lcmdlIG8sIEBvcHRpb25zXG5cbiAgIyBDb3BpZXMgdGhlIHRhcmdldCBpbmRlbnQgYW5kIGxldmVsLCBhbmQgcmV0dXJucyB0aGUgcGxhY2Vob2xkZXIgZnJhZ21lbnRzXG4gIGNvbXBpbGVUb0ZyYWdtZW50czogKG8sIGxldmVsKSAtPlxuICAgIEBvcHRpb25zLmluZGVudCA9IG8uaW5kZW50XG4gICAgQG9wdGlvbnMubGV2ZWwgID0gbGV2ZWwgPyBvLmxldmVsXG4gICAgWyBAdGFyZ2V0RnJhZ21lbnRzIF1cblxuICBjb21waWxlTm9kZTogKG8pIC0+XG4gICAgQGNvbXBpbGVUb0ZyYWdtZW50cyBvXG5cbiAgY29tcGlsZUNsb3N1cmU6IChvKSAtPlxuICAgIEBjb21waWxlVG9GcmFnbWVudHMgb1xuXG4jIyMjIFJvb3RcblxuIyBUaGUgcm9vdCBub2RlIG9mIHRoZSBub2RlIHRyZWVcbmV4cG9ydHMuUm9vdCA9IGNsYXNzIFJvb3QgZXh0ZW5kcyBCYXNlXG4gIGNvbnN0cnVjdG9yOiAoQGJvZHkpIC0+XG4gICAgc3VwZXIoKVxuXG4gICAgQGlzQXN5bmMgPSAobmV3IENvZGUgW10sIEBib2R5KS5pc0FzeW5jXG5cbiAgY2hpbGRyZW46IFsnYm9keSddXG5cbiAgIyBXcmFwIGV2ZXJ5dGhpbmcgaW4gYSBzYWZldHkgY2xvc3VyZSwgdW5sZXNzIHJlcXVlc3RlZCBub3QgdG8uIEl0IHdvdWxkIGJlXG4gICMgYmV0dGVyIG5vdCB0byBnZW5lcmF0ZSB0aGVtIGluIHRoZSBmaXJzdCBwbGFjZSwgYnV0IGZvciBub3csIGNsZWFuIHVwXG4gICMgb2J2aW91cyBkb3VibGUtcGFyZW50aGVzZXMuXG4gIGNvbXBpbGVOb2RlOiAobykgLT5cbiAgICBvLmluZGVudCAgICA9IGlmIG8uYmFyZSB0aGVuICcnIGVsc2UgVEFCXG4gICAgby5sZXZlbCAgICAgPSBMRVZFTF9UT1BcbiAgICBvLmNvbXBpbGluZyA9IHllc1xuICAgIEBpbml0aWFsaXplU2NvcGUgb1xuICAgIGZyYWdtZW50cyA9IEBib2R5LmNvbXBpbGVSb290IG9cbiAgICByZXR1cm4gZnJhZ21lbnRzIGlmIG8uYmFyZVxuICAgIGZ1bmN0aW9uS2V5d29yZCA9IFwiI3tpZiBAaXNBc3luYyB0aGVuICdhc3luYyAnIGVsc2UgJyd9ZnVuY3Rpb25cIlxuICAgIFtdLmNvbmNhdCBAbWFrZUNvZGUoXCIoI3tmdW5jdGlvbktleXdvcmR9KCkge1xcblwiKSwgZnJhZ21lbnRzLCBAbWFrZUNvZGUoXCJcXG59KS5jYWxsKHRoaXMpO1xcblwiKVxuXG4gIGluaXRpYWxpemVTY29wZTogKG8pIC0+XG4gICAgby5zY29wZSA9IG5ldyBTY29wZSBudWxsLCBAYm9keSwgbnVsbCwgby5yZWZlcmVuY2VkVmFycyA/IFtdXG4gICAgIyBNYXJrIGdpdmVuIGxvY2FsIHZhcmlhYmxlcyBpbiB0aGUgcm9vdCBzY29wZSBhcyBwYXJhbWV0ZXJzIHNvIHRoZXkgZG9u4oCZdFxuICAgICMgZW5kIHVwIGJlaW5nIGRlY2xhcmVkIG9uIHRoZSByb290IGJsb2NrLlxuICAgIG8uc2NvcGUucGFyYW1ldGVyIG5hbWUgZm9yIG5hbWUgaW4gby5sb2NhbHMgb3IgW11cblxuICBjb21tZW50c0FzdDogLT5cbiAgICBAYWxsQ29tbWVudHMgPz1cbiAgICAgIGZvciBjb21tZW50VG9rZW4gaW4gKEBhbGxDb21tZW50VG9rZW5zID8gW10pIHdoZW4gbm90IGNvbW1lbnRUb2tlbi5oZXJlZ2V4XG4gICAgICAgIGlmIGNvbW1lbnRUb2tlbi5oZXJlXG4gICAgICAgICAgbmV3IEhlcmVDb21tZW50IGNvbW1lbnRUb2tlblxuICAgICAgICBlbHNlXG4gICAgICAgICAgbmV3IExpbmVDb21tZW50IGNvbW1lbnRUb2tlblxuICAgIGNvbW1lbnQuYXN0KCkgZm9yIGNvbW1lbnQgaW4gQGFsbENvbW1lbnRzXG5cbiAgYXN0Tm9kZTogKG8pIC0+XG4gICAgby5sZXZlbCA9IExFVkVMX1RPUFxuICAgIEBpbml0aWFsaXplU2NvcGUgb1xuICAgIHN1cGVyIG9cblxuICBhc3RUeXBlOiAtPiAnRmlsZSdcblxuICBhc3RQcm9wZXJ0aWVzOiAobykgLT5cbiAgICBAYm9keS5pc1Jvb3RCbG9jayA9IHllc1xuICAgIHJldHVyblxuICAgICAgcHJvZ3JhbTogT2JqZWN0LmFzc2lnbiBAYm9keS5hc3QobyksIEBhc3RMb2NhdGlvbkRhdGEoKVxuICAgICAgY29tbWVudHM6IEBjb21tZW50c0FzdCgpXG5cbiMjIyMgQmxvY2tcblxuIyBUaGUgYmxvY2sgaXMgdGhlIGxpc3Qgb2YgZXhwcmVzc2lvbnMgdGhhdCBmb3JtcyB0aGUgYm9keSBvZiBhblxuIyBpbmRlbnRlZCBibG9jayBvZiBjb2RlIC0tIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBhIGZ1bmN0aW9uLCBhIGNsYXVzZSBpbiBhblxuIyBgaWZgLCBgc3dpdGNoYCwgb3IgYHRyeWAsIGFuZCBzbyBvbi4uLlxuZXhwb3J0cy5CbG9jayA9IGNsYXNzIEJsb2NrIGV4dGVuZHMgQmFzZVxuICBjb25zdHJ1Y3RvcjogKG5vZGVzKSAtPlxuICAgIHN1cGVyKClcblxuICAgIEBleHByZXNzaW9ucyA9IGNvbXBhY3QgZmxhdHRlbiBub2RlcyBvciBbXVxuXG4gIGNoaWxkcmVuOiBbJ2V4cHJlc3Npb25zJ11cblxuICAjIFRhY2sgYW4gZXhwcmVzc2lvbiBvbiB0byB0aGUgZW5kIG9mIHRoaXMgZXhwcmVzc2lvbiBsaXN0LlxuICBwdXNoOiAobm9kZSkgLT5cbiAgICBAZXhwcmVzc2lvbnMucHVzaCBub2RlXG4gICAgdGhpc1xuXG4gICMgUmVtb3ZlIGFuZCByZXR1cm4gdGhlIGxhc3QgZXhwcmVzc2lvbiBvZiB0aGlzIGV4cHJlc3Npb24gbGlzdC5cbiAgcG9wOiAtPlxuICAgIEBleHByZXNzaW9ucy5wb3AoKVxuXG4gICMgQWRkIGFuIGV4cHJlc3Npb24gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGlzIGV4cHJlc3Npb24gbGlzdC5cbiAgdW5zaGlmdDogKG5vZGUpIC0+XG4gICAgQGV4cHJlc3Npb25zLnVuc2hpZnQgbm9kZVxuICAgIHRoaXNcblxuICAjIElmIHRoaXMgQmxvY2sgY29uc2lzdHMgb2YganVzdCBhIHNpbmdsZSBub2RlLCB1bndyYXAgaXQgYnkgcHVsbGluZ1xuICAjIGl0IGJhY2sgb3V0LlxuICB1bndyYXA6IC0+XG4gICAgaWYgQGV4cHJlc3Npb25zLmxlbmd0aCBpcyAxIHRoZW4gQGV4cHJlc3Npb25zWzBdIGVsc2UgdGhpc1xuXG4gICMgSXMgdGhpcyBhbiBlbXB0eSBibG9jayBvZiBjb2RlP1xuICBpc0VtcHR5OiAtPlxuICAgIG5vdCBAZXhwcmVzc2lvbnMubGVuZ3RoXG5cbiAgaXNTdGF0ZW1lbnQ6IChvKSAtPlxuICAgIGZvciBleHAgaW4gQGV4cHJlc3Npb25zIHdoZW4gZXhwLmlzU3RhdGVtZW50IG9cbiAgICAgIHJldHVybiB5ZXNcbiAgICBub1xuXG4gIGp1bXBzOiAobykgLT5cbiAgICBmb3IgZXhwIGluIEBleHByZXNzaW9uc1xuICAgICAgcmV0dXJuIGp1bXBOb2RlIGlmIGp1bXBOb2RlID0gZXhwLmp1bXBzIG9cblxuICAjIEEgQmxvY2sgbm9kZSBkb2VzIG5vdCByZXR1cm4gaXRzIGVudGlyZSBib2R5LCByYXRoZXIgaXRcbiAgIyBlbnN1cmVzIHRoYXQgdGhlIGZpbmFsIGV4cHJlc3Npb24gaXMgcmV0dXJuZWQuXG4gIG1ha2VSZXR1cm46IChyZXN1bHRzLCBtYXJrKSAtPlxuICAgIGxlbiA9IEBleHByZXNzaW9ucy5sZW5ndGhcbiAgICBbLi4uLCBsYXN0RXhwXSA9IEBleHByZXNzaW9uc1xuICAgIGxhc3RFeHAgPSBsYXN0RXhwPy51bndyYXAoKSBvciBub1xuICAgICMgV2UgYWxzbyBuZWVkIHRvIGNoZWNrIHRoYXQgd2XigJlyZSBub3QgcmV0dXJuaW5nIGEgSlNYIHRhZyBpZiB0aGVyZeKAmXMgYW5cbiAgICAjIGFkamFjZW50IG9uZSBhdCB0aGUgc2FtZSBsZXZlbDsgSlNYIGRvZXNu4oCZdCBhbGxvdyB0aGF0LlxuICAgIGlmIGxhc3RFeHAgYW5kIGxhc3RFeHAgaW5zdGFuY2VvZiBQYXJlbnMgYW5kIGxhc3RFeHAuYm9keS5leHByZXNzaW9ucy5sZW5ndGggPiAxXG4gICAgICB7Ym9keTp7ZXhwcmVzc2lvbnN9fSA9IGxhc3RFeHBcbiAgICAgIFsuLi4sIHBlbnVsdCwgbGFzdF0gPSBleHByZXNzaW9uc1xuICAgICAgcGVudWx0ID0gcGVudWx0LnVud3JhcCgpXG4gICAgICBsYXN0ID0gbGFzdC51bndyYXAoKVxuICAgICAgaWYgcGVudWx0IGluc3RhbmNlb2YgSlNYRWxlbWVudCBhbmQgbGFzdCBpbnN0YW5jZW9mIEpTWEVsZW1lbnRcbiAgICAgICAgZXhwcmVzc2lvbnNbZXhwcmVzc2lvbnMubGVuZ3RoIC0gMV0uZXJyb3IgJ0FkamFjZW50IEpTWCBlbGVtZW50cyBtdXN0IGJlIHdyYXBwZWQgaW4gYW4gZW5jbG9zaW5nIHRhZydcbiAgICBpZiBtYXJrXG4gICAgICBAZXhwcmVzc2lvbnNbbGVuIC0gMV0/Lm1ha2VSZXR1cm4gcmVzdWx0cywgbWFya1xuICAgICAgcmV0dXJuXG4gICAgd2hpbGUgbGVuLS1cbiAgICAgIGV4cHIgPSBAZXhwcmVzc2lvbnNbbGVuXVxuICAgICAgQGV4cHJlc3Npb25zW2xlbl0gPSBleHByLm1ha2VSZXR1cm4gcmVzdWx0c1xuICAgICAgQGV4cHJlc3Npb25zLnNwbGljZShsZW4sIDEpIGlmIGV4cHIgaW5zdGFuY2VvZiBSZXR1cm4gYW5kIG5vdCBleHByLmV4cHJlc3Npb25cbiAgICAgIGJyZWFrXG4gICAgdGhpc1xuXG4gIGNvbXBpbGU6IChvLCBsdmwpIC0+XG4gICAgcmV0dXJuIG5ldyBSb290KHRoaXMpLndpdGhMb2NhdGlvbkRhdGFGcm9tKHRoaXMpLmNvbXBpbGUgbywgbHZsIHVubGVzcyBvLnNjb3BlXG5cbiAgICBzdXBlciBvLCBsdmxcblxuICAjIENvbXBpbGUgYWxsIGV4cHJlc3Npb25zIHdpdGhpbiB0aGUgKipCbG9jayoqIGJvZHkuIElmIHdlIG5lZWQgdG8gcmV0dXJuXG4gICMgdGhlIHJlc3VsdCwgYW5kIGl04oCZcyBhbiBleHByZXNzaW9uLCBzaW1wbHkgcmV0dXJuIGl0LiBJZiBpdOKAmXMgYSBzdGF0ZW1lbnQsXG4gICMgYXNrIHRoZSBzdGF0ZW1lbnQgdG8gZG8gc28uXG4gIGNvbXBpbGVOb2RlOiAobykgLT5cbiAgICBAdGFiICA9IG8uaW5kZW50XG4gICAgdG9wICAgPSBvLmxldmVsIGlzIExFVkVMX1RPUFxuICAgIGNvbXBpbGVkTm9kZXMgPSBbXVxuXG4gICAgZm9yIG5vZGUsIGluZGV4IGluIEBleHByZXNzaW9uc1xuICAgICAgaWYgbm9kZS5ob2lzdGVkXG4gICAgICAgICMgVGhpcyBpcyBhIGhvaXN0ZWQgZXhwcmVzc2lvbi5cbiAgICAgICAgIyBXZSB3YW50IHRvIGNvbXBpbGUgdGhpcyBhbmQgaWdub3JlIHRoZSByZXN1bHQuXG4gICAgICAgIG5vZGUuY29tcGlsZVRvRnJhZ21lbnRzIG9cbiAgICAgICAgY29udGludWVcbiAgICAgIG5vZGUgPSAobm9kZS51bmZvbGRTb2FrKG8pIG9yIG5vZGUpXG4gICAgICBpZiBub2RlIGluc3RhbmNlb2YgQmxvY2tcbiAgICAgICAgIyBUaGlzIGlzIGEgbmVzdGVkIGJsb2NrLiBXZSBkb27igJl0IGRvIGFueXRoaW5nIHNwZWNpYWwgaGVyZSBsaWtlXG4gICAgICAgICMgZW5jbG9zZSBpdCBpbiBhIG5ldyBzY29wZTsgd2UganVzdCBjb21waWxlIHRoZSBzdGF0ZW1lbnRzIGluIHRoaXNcbiAgICAgICAgIyBibG9jayBhbG9uZyB3aXRoIG91ciBvd24uXG4gICAgICAgIGNvbXBpbGVkTm9kZXMucHVzaCBub2RlLmNvbXBpbGVOb2RlIG9cbiAgICAgIGVsc2UgaWYgdG9wXG4gICAgICAgIG5vZGUuZnJvbnQgPSB5ZXNcbiAgICAgICAgZnJhZ21lbnRzID0gbm9kZS5jb21waWxlVG9GcmFnbWVudHMgb1xuICAgICAgICB1bmxlc3Mgbm9kZS5pc1N0YXRlbWVudCBvXG4gICAgICAgICAgZnJhZ21lbnRzID0gaW5kZW50SW5pdGlhbCBmcmFnbWVudHMsIEBcbiAgICAgICAgICBbLi4uLCBsYXN0RnJhZ21lbnRdID0gZnJhZ21lbnRzXG4gICAgICAgICAgdW5sZXNzIGxhc3RGcmFnbWVudC5jb2RlIGlzICcnIG9yIGxhc3RGcmFnbWVudC5pc0NvbW1lbnRcbiAgICAgICAgICAgIGZyYWdtZW50cy5wdXNoIEBtYWtlQ29kZSAnOydcbiAgICAgICAgY29tcGlsZWROb2Rlcy5wdXNoIGZyYWdtZW50c1xuICAgICAgZWxzZVxuICAgICAgICBjb21waWxlZE5vZGVzLnB1c2ggbm9kZS5jb21waWxlVG9GcmFnbWVudHMgbywgTEVWRUxfTElTVFxuICAgIGlmIHRvcFxuICAgICAgaWYgQHNwYWNlZFxuICAgICAgICByZXR1cm4gW10uY29uY2F0IEBqb2luRnJhZ21lbnRBcnJheXMoY29tcGlsZWROb2RlcywgJ1xcblxcbicpLCBAbWFrZUNvZGUoJ1xcbicpXG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBAam9pbkZyYWdtZW50QXJyYXlzKGNvbXBpbGVkTm9kZXMsICdcXG4nKVxuICAgIGlmIGNvbXBpbGVkTm9kZXMubGVuZ3RoXG4gICAgICBhbnN3ZXIgPSBAam9pbkZyYWdtZW50QXJyYXlzKGNvbXBpbGVkTm9kZXMsICcsICcpXG4gICAgZWxzZVxuICAgICAgYW5zd2VyID0gW0BtYWtlQ29kZSAndm9pZCAwJ11cbiAgICBpZiBjb21waWxlZE5vZGVzLmxlbmd0aCA+IDEgYW5kIG8ubGV2ZWwgPj0gTEVWRUxfTElTVCB0aGVuIEB3cmFwSW5QYXJlbnRoZXNlcyBhbnN3ZXIgZWxzZSBhbnN3ZXJcblxuICBjb21waWxlUm9vdDogKG8pIC0+XG4gICAgQHNwYWNlZCA9IHllc1xuICAgIGZyYWdtZW50cyA9IEBjb21waWxlV2l0aERlY2xhcmF0aW9ucyBvXG4gICAgSG9pc3RUYXJnZXQuZXhwYW5kIGZyYWdtZW50c1xuICAgIEBjb21waWxlQ29tbWVudHMgZnJhZ21lbnRzXG5cbiAgIyBDb21waWxlIHRoZSBleHByZXNzaW9ucyBib2R5IGZvciB0aGUgY29udGVudHMgb2YgYSBmdW5jdGlvbiwgd2l0aFxuICAjIGRlY2xhcmF0aW9ucyBvZiBhbGwgaW5uZXIgdmFyaWFibGVzIHB1c2hlZCB1cCB0byB0aGUgdG9wLlxuICBjb21waWxlV2l0aERlY2xhcmF0aW9uczogKG8pIC0+XG4gICAgZnJhZ21lbnRzID0gW11cbiAgICBwb3N0ID0gW11cbiAgICBmb3IgZXhwLCBpIGluIEBleHByZXNzaW9uc1xuICAgICAgZXhwID0gZXhwLnVud3JhcCgpXG4gICAgICBicmVhayB1bmxlc3MgZXhwIGluc3RhbmNlb2YgTGl0ZXJhbFxuICAgIG8gPSBtZXJnZShvLCBsZXZlbDogTEVWRUxfVE9QKVxuICAgIGlmIGlcbiAgICAgIHJlc3QgPSBAZXhwcmVzc2lvbnMuc3BsaWNlIGksIDllOVxuICAgICAgW3NwYWNlZCwgICAgQHNwYWNlZF0gPSBbQHNwYWNlZCwgbm9dXG4gICAgICBbZnJhZ21lbnRzLCBAc3BhY2VkXSA9IFtAY29tcGlsZU5vZGUobyksIHNwYWNlZF1cbiAgICAgIEBleHByZXNzaW9ucyA9IHJlc3RcbiAgICBwb3N0ID0gQGNvbXBpbGVOb2RlIG9cbiAgICB7c2NvcGV9ID0gb1xuICAgIGlmIHNjb3BlLmV4cHJlc3Npb25zIGlzIHRoaXNcbiAgICAgIGRlY2xhcnMgPSBvLnNjb3BlLmhhc0RlY2xhcmF0aW9ucygpXG4gICAgICBhc3NpZ25zID0gc2NvcGUuaGFzQXNzaWdubWVudHNcbiAgICAgIGlmIGRlY2xhcnMgb3IgYXNzaWduc1xuICAgICAgICBmcmFnbWVudHMucHVzaCBAbWFrZUNvZGUgJ1xcbicgaWYgaVxuICAgICAgICBmcmFnbWVudHMucHVzaCBAbWFrZUNvZGUgXCIje0B0YWJ9dmFyIFwiXG4gICAgICAgIGlmIGRlY2xhcnNcbiAgICAgICAgICBkZWNsYXJlZFZhcmlhYmxlcyA9IHNjb3BlLmRlY2xhcmVkVmFyaWFibGVzKClcbiAgICAgICAgICBmb3IgZGVjbGFyZWRWYXJpYWJsZSwgZGVjbGFyZWRWYXJpYWJsZXNJbmRleCBpbiBkZWNsYXJlZFZhcmlhYmxlc1xuICAgICAgICAgICAgZnJhZ21lbnRzLnB1c2ggQG1ha2VDb2RlIGRlY2xhcmVkVmFyaWFibGVcbiAgICAgICAgICAgIGlmIE9iamVjdDo6aGFzT3duUHJvcGVydHkuY2FsbCBvLnNjb3BlLmNvbW1lbnRzLCBkZWNsYXJlZFZhcmlhYmxlXG4gICAgICAgICAgICAgIGZyYWdtZW50cy5wdXNoIG8uc2NvcGUuY29tbWVudHNbZGVjbGFyZWRWYXJpYWJsZV0uLi5cbiAgICAgICAgICAgIGlmIGRlY2xhcmVkVmFyaWFibGVzSW5kZXggaXNudCBkZWNsYXJlZFZhcmlhYmxlcy5sZW5ndGggLSAxXG4gICAgICAgICAgICAgIGZyYWdtZW50cy5wdXNoIEBtYWtlQ29kZSAnLCAnXG4gICAgICAgIGlmIGFzc2lnbnNcbiAgICAgICAgICBmcmFnbWVudHMucHVzaCBAbWFrZUNvZGUgXCIsXFxuI3tAdGFiICsgVEFCfVwiIGlmIGRlY2xhcnNcbiAgICAgICAgICBmcmFnbWVudHMucHVzaCBAbWFrZUNvZGUgc2NvcGUuYXNzaWduZWRWYXJpYWJsZXMoKS5qb2luKFwiLFxcbiN7QHRhYiArIFRBQn1cIilcbiAgICAgICAgZnJhZ21lbnRzLnB1c2ggQG1ha2VDb2RlIFwiO1xcbiN7aWYgQHNwYWNlZCB0aGVuICdcXG4nIGVsc2UgJyd9XCJcbiAgICAgIGVsc2UgaWYgZnJhZ21lbnRzLmxlbmd0aCBhbmQgcG9zdC5sZW5ndGhcbiAgICAgICAgZnJhZ21lbnRzLnB1c2ggQG1ha2VDb2RlIFwiXFxuXCJcbiAgICBmcmFnbWVudHMuY29uY2F0IHBvc3RcblxuICBjb21waWxlQ29tbWVudHM6IChmcmFnbWVudHMpIC0+XG4gICAgZm9yIGZyYWdtZW50LCBmcmFnbWVudEluZGV4IGluIGZyYWdtZW50c1xuICAgICAgIyBJbnNlcnQgY29tbWVudHMgaW50byB0aGUgb3V0cHV0IGF0IHRoZSBuZXh0IG9yIHByZXZpb3VzIG5ld2xpbmUuXG4gICAgICAjIElmIHRoZXJlIGFyZSBubyBuZXdsaW5lcyBhdCB3aGljaCB0byBwbGFjZSBjb21tZW50cywgY3JlYXRlIHRoZW0uXG4gICAgICBpZiBmcmFnbWVudC5wcmVjZWRpbmdDb21tZW50c1xuICAgICAgICAjIERldGVybWluZSB0aGUgaW5kZW50YXRpb24gbGV2ZWwgb2YgdGhlIGZyYWdtZW50IHRoYXQgd2UgYXJlIGFib3V0XG4gICAgICAgICMgdG8gaW5zZXJ0IGNvbW1lbnRzIGJlZm9yZSwgYW5kIHVzZSB0aGF0IGluZGVudGF0aW9uIGxldmVsIGZvciBvdXJcbiAgICAgICAgIyBpbnNlcnRlZCBjb21tZW50cy4gQXQgdGhpcyBwb2ludCwgdGhlIGZyYWdtZW50c+KAmSBgY29kZWAgcHJvcGVydHlcbiAgICAgICAgIyBpcyB0aGUgZ2VuZXJhdGVkIG91dHB1dCBKYXZhU2NyaXB0LCBhbmQgQ29mZmVlU2NyaXB0IGFsd2F5c1xuICAgICAgICAjIGdlbmVyYXRlcyBvdXRwdXQgaW5kZW50ZWQgYnkgdHdvIHNwYWNlczsgc28gYWxsIHdlIG5lZWQgdG8gZG8gaXNcbiAgICAgICAgIyBzZWFyY2ggZm9yIGEgYGNvZGVgIHByb3BlcnR5IHRoYXQgYmVnaW5zIHdpdGggYXQgbGVhc3QgdHdvIHNwYWNlcy5cbiAgICAgICAgZnJhZ21lbnRJbmRlbnQgPSAnJ1xuICAgICAgICBmb3IgcGFzdEZyYWdtZW50IGluIGZyYWdtZW50c1swLi4uKGZyYWdtZW50SW5kZXggKyAxKV0gYnkgLTFcbiAgICAgICAgICBpbmRlbnQgPSAvXiB7Mix9L20uZXhlYyBwYXN0RnJhZ21lbnQuY29kZVxuICAgICAgICAgIGlmIGluZGVudFxuICAgICAgICAgICAgZnJhZ21lbnRJbmRlbnQgPSBpbmRlbnRbMF1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgZWxzZSBpZiAnXFxuJyBpbiBwYXN0RnJhZ21lbnQuY29kZVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgY29kZSA9IFwiXFxuI3tmcmFnbWVudEluZGVudH1cIiArIChcbiAgICAgICAgICAgIGZvciBjb21tZW50RnJhZ21lbnQgaW4gZnJhZ21lbnQucHJlY2VkaW5nQ29tbWVudHNcbiAgICAgICAgICAgICAgaWYgY29tbWVudEZyYWdtZW50LmlzSGVyZUNvbW1lbnQgYW5kIGNvbW1lbnRGcmFnbWVudC5tdWx0aWxpbmVcbiAgICAgICAgICAgICAgICBtdWx0aWRlbnQgY29tbWVudEZyYWdtZW50LmNvZGUsIGZyYWdtZW50SW5kZW50LCBub1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY29tbWVudEZyYWdtZW50LmNvZGVcbiAgICAgICAgICApLmpvaW4oXCJcXG4je2ZyYWdtZW50SW5kZW50fVwiKS5yZXBsYWNlIC9eKFxccyopJC9nbSwgJydcbiAgICAgICAgZm9yIHBhc3RGcmFnbWVudCwgcGFzdEZyYWdtZW50SW5kZXggaW4gZnJhZ21lbnRzWzAuLi4oZnJhZ21lbnRJbmRleCArIDEpXSBieSAtMVxuICAgICAgICAgIG5ld0xpbmVJbmRleCA9IHBhc3RGcmFnbWVudC5jb2RlLmxhc3RJbmRleE9mICdcXG4nXG4gICAgICAgICAgaWYgbmV3TGluZUluZGV4IGlzIC0xXG4gICAgICAgICAgICAjIEtlZXAgc2VhcmNoaW5nIHByZXZpb3VzIGZyYWdtZW50cyB1bnRpbCB3ZSBjYW7igJl0IGdvIGJhY2sgYW55XG4gICAgICAgICAgICAjIGZ1cnRoZXIsIGVpdGhlciBiZWNhdXNlIHRoZXJlIGFyZSBubyBmcmFnbWVudHMgbGVmdCBvciB3ZeKAmXZlXG4gICAgICAgICAgICAjIGRpc2NvdmVyZWQgdGhhdCB3ZeKAmXJlIGluIGEgY29kZSBibG9jayB0aGF0IGlzIGludGVycG9sYXRlZFxuICAgICAgICAgICAgIyBpbnNpZGUgYSBzdHJpbmcuXG4gICAgICAgICAgICBpZiBwYXN0RnJhZ21lbnRJbmRleCBpcyAwXG4gICAgICAgICAgICAgIHBhc3RGcmFnbWVudC5jb2RlID0gJ1xcbicgKyBwYXN0RnJhZ21lbnQuY29kZVxuICAgICAgICAgICAgICBuZXdMaW5lSW5kZXggPSAwXG4gICAgICAgICAgICBlbHNlIGlmIHBhc3RGcmFnbWVudC5pc1N0cmluZ1dpdGhJbnRlcnBvbGF0aW9ucyBhbmQgcGFzdEZyYWdtZW50LmNvZGUgaXMgJ3snXG4gICAgICAgICAgICAgIGNvZGUgPSBjb2RlWzEuLl0gKyAnXFxuJyAjIE1vdmUgbmV3bGluZSB0byBlbmQuXG4gICAgICAgICAgICAgIG5ld0xpbmVJbmRleCA9IDFcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICBkZWxldGUgZnJhZ21lbnQucHJlY2VkaW5nQ29tbWVudHNcbiAgICAgICAgICBwYXN0RnJhZ21lbnQuY29kZSA9IHBhc3RGcmFnbWVudC5jb2RlWzAuLi5uZXdMaW5lSW5kZXhdICtcbiAgICAgICAgICAgIGNvZGUgKyBwYXN0RnJhZ21lbnQuY29kZVtuZXdMaW5lSW5kZXguLl1cbiAgICAgICAgICBicmVha1xuXG4gICAgICAjIFllcywgdGhpcyBpcyBhd2Z1bGx5IHNpbWlsYXIgdG8gdGhlIHByZXZpb3VzIGBpZmAgYmxvY2ssIGJ1dCBpZiB5b3VcbiAgICAgICMgbG9vayBjbG9zZWx5IHlvdeKAmWxsIGZpbmQgbG90cyBvZiB0aW55IGRpZmZlcmVuY2VzIHRoYXQgbWFrZSB0aGlzXG4gICAgICAjIGNvbmZ1c2luZyBpZiBpdCB3ZXJlIGFic3RyYWN0ZWQgaW50byBhIGZ1bmN0aW9uIHRoYXQgYm90aCBibG9ja3Mgc2hhcmUuXG4gICAgICBpZiBmcmFnbWVudC5mb2xsb3dpbmdDb21tZW50c1xuICAgICAgICAjIERvZXMgdGhlIGZpcnN0IHRyYWlsaW5nIGNvbW1lbnQgZm9sbG93IGF0IHRoZSBlbmQgb2YgYSBsaW5lIG9mIGNvZGUsXG4gICAgICAgICMgbGlrZSBgOyAvLyBDb21tZW50YCwgb3IgZG9lcyBpdCBzdGFydCBhIG5ldyBsaW5lIGFmdGVyIGEgbGluZSBvZiBjb2RlP1xuICAgICAgICB0cmFpbCA9IGZyYWdtZW50LmZvbGxvd2luZ0NvbW1lbnRzWzBdLnRyYWlsXG4gICAgICAgIGZyYWdtZW50SW5kZW50ID0gJydcbiAgICAgICAgIyBGaW5kIHRoZSBpbmRlbnQgb2YgdGhlIG5leHQgbGluZSBvZiBjb2RlLCBpZiB3ZSBoYXZlIGFueSBub24tdHJhaWxpbmdcbiAgICAgICAgIyBjb21tZW50cyB0byBvdXRwdXQuIFdlIG5lZWQgdG8gZmlyc3QgZmluZCB0aGUgbmV4dCBuZXdsaW5lLCBhcyB0aGVzZVxuICAgICAgICAjIGNvbW1lbnRzIHdpbGwgYmUgb3V0cHV0IGFmdGVyIHRoYXQ7IGFuZCB0aGVuIHRoZSBpbmRlbnQgb2YgdGhlIGxpbmVcbiAgICAgICAgIyB0aGF0IGZvbGxvd3MgdGhlIG5leHQgbmV3bGluZS5cbiAgICAgICAgdW5sZXNzIHRyYWlsIGFuZCBmcmFnbWVudC5mb2xsb3dpbmdDb21tZW50cy5sZW5ndGggaXMgMVxuICAgICAgICAgIG9uTmV4dExpbmUgPSBub1xuICAgICAgICAgIGZvciB1cGNvbWluZ0ZyYWdtZW50IGluIGZyYWdtZW50c1tmcmFnbWVudEluZGV4Li4uXVxuICAgICAgICAgICAgdW5sZXNzIG9uTmV4dExpbmVcbiAgICAgICAgICAgICAgaWYgJ1xcbicgaW4gdXBjb21pbmdGcmFnbWVudC5jb2RlXG4gICAgICAgICAgICAgICAgb25OZXh0TGluZSA9IHllc1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgaW5kZW50ID0gL14gezIsfS9tLmV4ZWMgdXBjb21pbmdGcmFnbWVudC5jb2RlXG4gICAgICAgICAgICAgIGlmIGluZGVudFxuICAgICAgICAgICAgICAgIGZyYWdtZW50SW5kZW50ID0gaW5kZW50WzBdXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgZWxzZSBpZiAnXFxuJyBpbiB1cGNvbWluZ0ZyYWdtZW50LmNvZGVcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAjIElzIHRoaXMgY29tbWVudCBmb2xsb3dpbmcgdGhlIGluZGVudCBpbnNlcnRlZCBieSBiYXJlIG1vZGU/XG4gICAgICAgICMgSWYgc28sIHRoZXJl4oCZcyBubyBuZWVkIHRvIGluZGVudCB0aGlzIGZ1cnRoZXIuXG4gICAgICAgIGNvZGUgPSBpZiBmcmFnbWVudEluZGV4IGlzIDEgYW5kIC9eXFxzKyQvLnRlc3QgZnJhZ21lbnRzWzBdLmNvZGVcbiAgICAgICAgICAnJ1xuICAgICAgICBlbHNlIGlmIHRyYWlsXG4gICAgICAgICAgJyAnXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBcIlxcbiN7ZnJhZ21lbnRJbmRlbnR9XCJcbiAgICAgICAgIyBBc3NlbWJsZSBwcm9wZXJseSBpbmRlbnRlZCBjb21tZW50cy5cbiAgICAgICAgY29kZSArPSAoXG4gICAgICAgICAgICBmb3IgY29tbWVudEZyYWdtZW50IGluIGZyYWdtZW50LmZvbGxvd2luZ0NvbW1lbnRzXG4gICAgICAgICAgICAgIGlmIGNvbW1lbnRGcmFnbWVudC5pc0hlcmVDb21tZW50IGFuZCBjb21tZW50RnJhZ21lbnQubXVsdGlsaW5lXG4gICAgICAgICAgICAgICAgbXVsdGlkZW50IGNvbW1lbnRGcmFnbWVudC5jb2RlLCBmcmFnbWVudEluZGVudCwgbm9cbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvbW1lbnRGcmFnbWVudC5jb2RlXG4gICAgICAgICAgKS5qb2luKFwiXFxuI3tmcmFnbWVudEluZGVudH1cIikucmVwbGFjZSAvXihcXHMqKSQvZ20sICcnXG4gICAgICAgIGZvciB1cGNvbWluZ0ZyYWdtZW50LCB1cGNvbWluZ0ZyYWdtZW50SW5kZXggaW4gZnJhZ21lbnRzW2ZyYWdtZW50SW5kZXguLi5dXG4gICAgICAgICAgbmV3TGluZUluZGV4ID0gdXBjb21pbmdGcmFnbWVudC5jb2RlLmluZGV4T2YgJ1xcbidcbiAgICAgICAgICBpZiBuZXdMaW5lSW5kZXggaXMgLTFcbiAgICAgICAgICAgICMgS2VlcCBzZWFyY2hpbmcgdXBjb21pbmcgZnJhZ21lbnRzIHVudGlsIHdlIGNhbuKAmXQgZ28gYW55XG4gICAgICAgICAgICAjIGZ1cnRoZXIsIGVpdGhlciBiZWNhdXNlIHRoZXJlIGFyZSBubyBmcmFnbWVudHMgbGVmdCBvciB3ZeKAmXZlXG4gICAgICAgICAgICAjIGRpc2NvdmVyZWQgdGhhdCB3ZeKAmXJlIGluIGEgY29kZSBibG9jayB0aGF0IGlzIGludGVycG9sYXRlZFxuICAgICAgICAgICAgIyBpbnNpZGUgYSBzdHJpbmcuXG4gICAgICAgICAgICBpZiB1cGNvbWluZ0ZyYWdtZW50SW5kZXggaXMgZnJhZ21lbnRzLmxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgdXBjb21pbmdGcmFnbWVudC5jb2RlID0gdXBjb21pbmdGcmFnbWVudC5jb2RlICsgJ1xcbidcbiAgICAgICAgICAgICAgbmV3TGluZUluZGV4ID0gdXBjb21pbmdGcmFnbWVudC5jb2RlLmxlbmd0aFxuICAgICAgICAgICAgZWxzZSBpZiB1cGNvbWluZ0ZyYWdtZW50LmlzU3RyaW5nV2l0aEludGVycG9sYXRpb25zIGFuZCB1cGNvbWluZ0ZyYWdtZW50LmNvZGUgaXMgJ30nXG4gICAgICAgICAgICAgIGNvZGUgPSBcIiN7Y29kZX1cXG5cIlxuICAgICAgICAgICAgICBuZXdMaW5lSW5kZXggPSAwXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgZGVsZXRlIGZyYWdtZW50LmZvbGxvd2luZ0NvbW1lbnRzXG4gICAgICAgICAgIyBBdm9pZCBpbnNlcnRpbmcgZXh0cmEgYmxhbmsgbGluZXMuXG4gICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZSAvXlxcbi8sICcnIGlmIHVwY29taW5nRnJhZ21lbnQuY29kZSBpcyAnXFxuJ1xuICAgICAgICAgIHVwY29taW5nRnJhZ21lbnQuY29kZSA9IHVwY29taW5nRnJhZ21lbnQuY29kZVswLi4ubmV3TGluZUluZGV4XSArXG4gICAgICAgICAgICBjb2RlICsgdXBjb21pbmdGcmFnbWVudC5jb2RlW25ld0xpbmVJbmRleC4uXVxuICAgICAgICAgIGJyZWFrXG5cbiAgICBmcmFnbWVudHNcblxuICAjIFdyYXAgdXAgdGhlIGdpdmVuIG5vZGVzIGFzIGEgKipCbG9jayoqLCB1bmxlc3MgaXQgYWxyZWFkeSBoYXBwZW5zXG4gICMgdG8gYmUgb25lLlxuICBAd3JhcDogKG5vZGVzKSAtPlxuICAgIHJldHVybiBub2Rlc1swXSBpZiBub2Rlcy5sZW5ndGggaXMgMSBhbmQgbm9kZXNbMF0gaW5zdGFuY2VvZiBCbG9ja1xuICAgIG5ldyBCbG9jayBub2Rlc1xuXG4gIGFzdE5vZGU6IChvKSAtPlxuICAgIGlmIChvLmxldmVsPyBhbmQgby5sZXZlbCBpc250IExFVkVMX1RPUCkgYW5kIEBleHByZXNzaW9ucy5sZW5ndGhcbiAgICAgIHJldHVybiAobmV3IFNlcXVlbmNlKEBleHByZXNzaW9ucykud2l0aExvY2F0aW9uRGF0YUZyb20gQCkuYXN0IG9cblxuICAgIHN1cGVyIG9cblxuICBhc3RUeXBlOiAtPlxuICAgIGlmIEBpc1Jvb3RCbG9ja1xuICAgICAgJ1Byb2dyYW0nXG4gICAgZWxzZSBpZiBAaXNDbGFzc0JvZHlcbiAgICAgICdDbGFzc0JvZHknXG4gICAgZWxzZVxuICAgICAgJ0Jsb2NrU3RhdGVtZW50J1xuXG4gIGFzdFByb3BlcnRpZXM6IChvKSAtPlxuICAgIGNoZWNrRm9yRGlyZWN0aXZlcyA9IGRlbCBvLCAnY2hlY2tGb3JEaXJlY3RpdmVzJ1xuXG4gICAgc25pZmZEaXJlY3RpdmVzIEBleHByZXNzaW9ucywgbm90RmluYWxFeHByZXNzaW9uOiBjaGVja0ZvckRpcmVjdGl2ZXMgaWYgQGlzUm9vdEJsb2NrIG9yIGNoZWNrRm9yRGlyZWN0aXZlc1xuICAgIGRpcmVjdGl2ZXMgPSBbXVxuICAgIGJvZHkgPSBbXVxuICAgIGZvciBleHByZXNzaW9uIGluIEBleHByZXNzaW9uc1xuICAgICAgZXhwcmVzc2lvbkFzdCA9IGV4cHJlc3Npb24uYXN0IG9cbiAgICAgICMgSWdub3JlIGdlbmVyYXRlZCBQYXNzdGhyb3VnaExpdGVyYWxcbiAgICAgIGlmIG5vdCBleHByZXNzaW9uQXN0P1xuICAgICAgICBjb250aW51ZVxuICAgICAgZWxzZSBpZiBleHByZXNzaW9uIGluc3RhbmNlb2YgRGlyZWN0aXZlXG4gICAgICAgIGRpcmVjdGl2ZXMucHVzaCBleHByZXNzaW9uQXN0XG4gICAgICAjIElmIGFuIGV4cHJlc3Npb24gaXMgYSBzdGF0ZW1lbnQsIGl0IGNhbiBiZSBhZGRlZCB0byB0aGUgYm9keSBhcyBpcy5cbiAgICAgIGVsc2UgaWYgZXhwcmVzc2lvbi5pc1N0YXRlbWVudEFzdCBvXG4gICAgICAgIGJvZHkucHVzaCBleHByZXNzaW9uQXN0XG4gICAgICAjIE90aGVyd2lzZSwgd2UgbmVlZCB0byB3cmFwIGl0IGluIGFuIGBFeHByZXNzaW9uU3RhdGVtZW50YCBBU1Qgbm9kZS5cbiAgICAgIGVsc2VcbiAgICAgICAgYm9keS5wdXNoIE9iamVjdC5hc3NpZ25cbiAgICAgICAgICAgIHR5cGU6ICdFeHByZXNzaW9uU3RhdGVtZW50J1xuICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbkFzdFxuICAgICAgICAgICxcbiAgICAgICAgICAgIGV4cHJlc3Npb24uYXN0TG9jYXRpb25EYXRhKClcblxuICAgIHJldHVybiB7XG4gICAgICAjIEZvciBub3csIHdl4oCZcmUgbm90IGluY2x1ZGluZyBgc291cmNlVHlwZWAgb24gdGhlIGBQcm9ncmFtYCBBU1Qgbm9kZS5cbiAgICAgICMgSXRzIHZhbHVlIGNvdWxkIGJlIGVpdGhlciBgJ3NjcmlwdCdgIG9yIGAnbW9kdWxlJ2AsIGFuZCB0aGVyZeKAmXMgbm8gd2F5XG4gICAgICAjIGZvciBDb2ZmZWVTY3JpcHQgdG8gYWx3YXlzIGtub3cgd2hpY2ggaXQgc2hvdWxkIGJlLiBUaGUgcHJlc2VuY2Ugb2YgYW5cbiAgICAgICMgYGltcG9ydGAgb3IgYGV4cG9ydGAgc3RhdGVtZW50IGluIHNvdXJjZSBjb2RlIHdvdWxkIGltcGx5IHRoYXQgaXQgc2hvdWxkXG4gICAgICAjIGJlIGEgYG1vZHVsZWAsIGJ1dCBhIHByb2plY3QgbWF5IGNvbnNpc3Qgb2YgbW9zdGx5IHN1Y2ggZmlsZXMgYW5kIGFsc29cbiAgICAgICMgYW4gb3V0bGllciBmaWxlIHRoYXQgbGFja3MgYGltcG9ydGAgb3IgYGV4cG9ydGAgYnV0IGlzIHN0aWxsIGltcG9ydGVkXG4gICAgICAjIGludG8gdGhlIHByb2plY3QgYW5kIHRoZXJlZm9yZSBleHBlY3RzIHRvIGJlIHRyZWF0ZWQgYXMgYSBgbW9kdWxlYC5cbiAgICAgICMgRGV0ZXJtaW5pbmcgdGhlIHZhbHVlIG9mIGBzb3VyY2VUeXBlYCBpcyBlc3NlbnRpYWxseSB0aGUgc2FtZSBjaGFsbGVuZ2VcbiAgICAgICMgcG9zZWQgYnkgZGV0ZXJtaW5pbmcgdGhlIHBhcnNlIGdvYWwgb2YgYSBKYXZhU2NyaXB0IGZpbGUsIGFsc28gYG1vZHVsZWBcbiAgICAgICMgb3IgYHNjcmlwdGAsIGFuZCBzbyBpZiBOb2RlIGZpZ3VyZXMgb3V0IGEgd2F5IHRvIGRvIHNvIGZvciBgLmpzYCBmaWxlc1xuICAgICAgIyB0aGVuIENvZmZlZVNjcmlwdCBjYW4gY29weSBOb2Rl4oCZcyBhbGdvcml0aG0uXG5cbiAgICAgICMgc291cmNlVHlwZTogJ21vZHVsZSdcbiAgICAgIGJvZHksIGRpcmVjdGl2ZXNcbiAgICB9XG5cbiAgYXN0TG9jYXRpb25EYXRhOiAtPlxuICAgIHJldHVybiBpZiBAaXNSb290QmxvY2sgYW5kIG5vdCBAbG9jYXRpb25EYXRhP1xuICAgIHN1cGVyKClcblxuIyBBIGRpcmVjdGl2ZSBlLmcuICd1c2Ugc3RyaWN0Jy5cbiMgQ3VycmVudGx5IG9ubHkgdXNlZCBkdXJpbmcgQVNUIGdlbmVyYXRpb24uXG5leHBvcnRzLkRpcmVjdGl2ZSA9IGNsYXNzIERpcmVjdGl2ZSBleHRlbmRzIEJhc2VcbiAgY29uc3RydWN0b3I6IChAdmFsdWUpIC0+XG4gICAgc3VwZXIoKVxuXG4gIGFzdFByb3BlcnRpZXM6IChvKSAtPlxuICAgIHJldHVyblxuICAgICAgdmFsdWU6IE9iamVjdC5hc3NpZ24ge30sXG4gICAgICAgIEB2YWx1ZS5hc3Qgb1xuICAgICAgICB0eXBlOiAnRGlyZWN0aXZlTGl0ZXJhbCdcblxuIyMjIyBMaXRlcmFsXG5cbiMgYExpdGVyYWxgIGlzIGEgYmFzZSBjbGFzcyBmb3Igc3RhdGljIHZhbHVlcyB0aGF0IGNhbiBiZSBwYXNzZWQgdGhyb3VnaFxuIyBkaXJlY3RseSBpbnRvIEphdmFTY3JpcHQgd2l0aG91dCB0cmFuc2xhdGlvbiwgc3VjaCBhczogc3RyaW5ncywgbnVtYmVycyxcbiMgYHRydWVgLCBgZmFsc2VgLCBgbnVsbGAuLi5cbmV4cG9ydHMuTGl0ZXJhbCA9IGNsYXNzIExpdGVyYWwgZXh0ZW5kcyBCYXNlXG4gIGNvbnN0cnVjdG9yOiAoQHZhbHVlKSAtPlxuICAgIHN1cGVyKClcblxuICBzaG91bGRDYWNoZTogTk9cblxuICBhc3NpZ25zOiAobmFtZSkgLT5cbiAgICBuYW1lIGlzIEB2YWx1ZVxuXG4gIGNvbXBpbGVOb2RlOiAobykgLT5cbiAgICBbQG1ha2VDb2RlIEB2YWx1ZV1cblxuICBhc3RQcm9wZXJ0aWVzOiAtPlxuICAgIHJldHVyblxuICAgICAgdmFsdWU6IEB2YWx1ZVxuXG4gIHRvU3RyaW5nOiAtPlxuICAgICMgVGhpcyBpcyBvbmx5IGludGVuZGVkIGZvciBkZWJ1Z2dpbmcuXG4gICAgXCIgI3tpZiBAaXNTdGF0ZW1lbnQoKSB0aGVuIHN1cGVyKCkgZWxzZSBAY29uc3RydWN0b3IubmFtZX06ICN7QHZhbHVlfVwiXG5cbmV4cG9ydHMuTnVtYmVyTGl0ZXJhbCA9IGNsYXNzIE51bWJlckxpdGVyYWwgZXh0ZW5kcyBMaXRlcmFsXG4gIGNvbnN0cnVjdG9yOiAoQHZhbHVlLCB7QHBhcnNlZFZhbHVlfSA9IHt9KSAtPlxuICAgIHN1cGVyKClcbiAgICB1bmxlc3MgQHBhcnNlZFZhbHVlP1xuICAgICAgaWYgaXNOdW1iZXIgQHZhbHVlXG4gICAgICAgIEBwYXJzZWRWYWx1ZSA9IEB2YWx1ZVxuICAgICAgICBAdmFsdWUgPSBcIiN7QHZhbHVlfVwiXG4gICAgICBlbHNlXG4gICAgICAgIEBwYXJzZWRWYWx1ZSA9IHBhcnNlTnVtYmVyIEB2YWx1ZVxuXG4gIGlzQmlnSW50OiAtPlxuICAgIC9uJC8udGVzdCBAdmFsdWVcblxuICBhc3RUeXBlOiAtPlxuICAgIGlmIEBpc0JpZ0ludCgpXG4gICAgICAnQmlnSW50TGl0ZXJhbCdcbiAgICBlbHNlXG4gICAgICAnTnVtZXJpY0xpdGVyYWwnXG5cbiAgYXN0UHJvcGVydGllczogLT5cbiAgICByZXR1cm5cbiAgICAgIHZhbHVlOlxuICAgICAgICBpZiBAaXNCaWdJbnQoKVxuICAgICAgICAgIEBwYXJzZWRWYWx1ZS50b1N0cmluZygpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBAcGFyc2VkVmFsdWVcbiAgICAgIGV4dHJhOlxuICAgICAgICByYXdWYWx1ZTpcbiAgICAgICAgICBpZiBAaXNCaWdJbnQoKVxuICAgICAgICAgICAgQHBhcnNlZFZhbHVlLnRvU3RyaW5nKClcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBAcGFyc2VkVmFsdWVcbiAgICAgICAgcmF3OiBAdmFsdWVcblxuZXhwb3J0cy5JbmZpbml0eUxpdGVyYWwgPSBjbGFzcyBJbmZpbml0eUxpdGVyYWwgZXh0ZW5kcyBOdW1iZXJMaXRlcmFsXG4gIGNvbnN0cnVjdG9yOiAoQHZhbHVlLCB7QG9yaWdpbmFsVmFsdWUgPSAnSW5maW5pdHknfSA9IHt9KSAtPlxuICAgIHN1cGVyKClcblxuICBjb21waWxlTm9kZTogLT5cbiAgICBbQG1ha2VDb2RlICcyZTMwOCddXG5cbiAgYXN0Tm9kZTogKG8pIC0+XG4gICAgdW5sZXNzIEBvcmlnaW5hbFZhbHVlIGlzICdJbmZpbml0eSdcbiAgICAgIHJldHVybiBuZXcgTnVtYmVyTGl0ZXJhbChAdmFsdWUpLndpdGhMb2NhdGlvbkRhdGFGcm9tKEApLmFzdCBvXG4gICAgc3VwZXIgb1xuXG4gIGFzdFR5cGU6IC0+ICdJZGVudGlmaWVyJ1xuXG4gIGFzdFByb3BlcnRpZXM6IC0+XG4gICAgcmV0dXJuXG4gICAgICBuYW1lOiAnSW5maW5pdHknXG4gICAgICBkZWNsYXJhdGlvbjogbm9cblxuZXhwb3J0cy5OYU5MaXRlcmFsID0gY2xhc3MgTmFOTGl0ZXJhbCBleHRlbmRzIE51bWJlckxpdGVyYWxcbiAgY29uc3RydWN0b3I6IC0+XG4gICAgc3VwZXIgJ05hTidcblxuICBjb21waWxlTm9kZTogKG8pIC0+XG4gICAgY29kZSA9IFtAbWFrZUNvZGUgJzAvMCddXG4gICAgaWYgby5sZXZlbCA+PSBMRVZFTF9PUCB0aGVuIEB3cmFwSW5QYXJlbnRoZXNlcyBjb2RlIGVsc2UgY29kZVxuXG4gIGFzdFR5cGU6IC0+ICdJZGVudGlmaWVyJ1xuXG4gIGFzdFByb3BlcnRpZXM6IC0+XG4gICAgcmV0dXJuXG4gICAgICBuYW1lOiAnTmFOJ1xuICAgICAgZGVjbGFyYXRpb246IG5vXG5cbmV4cG9ydHMuU3RyaW5nTGl0ZXJhbCA9IGNsYXNzIFN0cmluZ0xpdGVyYWwgZXh0ZW5kcyBMaXRlcmFsXG4gIGNvbnN0cnVjdG9yOiAoQG9yaWdpbmFsVmFsdWUsIHtAcXVvdGUsIEBpbml0aWFsQ2h1bmssIEBmaW5hbENodW5rLCBAaW5kZW50LCBAZG91YmxlLCBAaGVyZWdleH0gPSB7fSkgLT5cbiAgICBzdXBlciAnJ1xuICAgIEBxdW90ZSA9IG51bGwgaWYgQHF1b3RlIGlzICcvLy8nXG4gICAgQGZyb21Tb3VyY2VTdHJpbmcgPSBAcXVvdGU/XG4gICAgQHF1b3RlID89ICdcIidcbiAgICBoZXJlZG9jID0gQGlzRnJvbUhlcmVkb2MoKVxuXG4gICAgdmFsID0gQG9yaWdpbmFsVmFsdWVcbiAgICBpZiBAaGVyZWdleFxuICAgICAgdmFsID0gdmFsLnJlcGxhY2UgSEVSRUdFWF9PTUlULCAnJDEkMidcbiAgICAgIHZhbCA9IHJlcGxhY2VVbmljb2RlQ29kZVBvaW50RXNjYXBlcyB2YWwsIGZsYWdzOiBAaGVyZWdleC5mbGFnc1xuICAgIGVsc2VcbiAgICAgIHZhbCA9IHZhbC5yZXBsYWNlIFNUUklOR19PTUlULCAnJDEnXG4gICAgICB2YWwgPVxuICAgICAgICB1bmxlc3MgQGZyb21Tb3VyY2VTdHJpbmdcbiAgICAgICAgICB2YWxcbiAgICAgICAgZWxzZSBpZiBoZXJlZG9jXG4gICAgICAgICAgaW5kZW50UmVnZXggPSAvLy8gXFxuI3tAaW5kZW50fSAvLy9nIGlmIEBpbmRlbnRcblxuICAgICAgICAgIHZhbCA9IHZhbC5yZXBsYWNlIGluZGVudFJlZ2V4LCAnXFxuJyBpZiBpbmRlbnRSZWdleFxuICAgICAgICAgIHZhbCA9IHZhbC5yZXBsYWNlIExFQURJTkdfQkxBTktfTElORSwgICcnIGlmIEBpbml0aWFsQ2h1bmtcbiAgICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSBUUkFJTElOR19CTEFOS19MSU5FLCAnJyBpZiBAZmluYWxDaHVua1xuICAgICAgICAgIHZhbFxuICAgICAgICBlbHNlXG4gICAgICAgICAgdmFsLnJlcGxhY2UgU0lNUExFX1NUUklOR19PTUlULCAobWF0Y2gsIG9mZnNldCkgPT5cbiAgICAgICAgICAgIGlmIChAaW5pdGlhbENodW5rIGFuZCBvZmZzZXQgaXMgMCkgb3JcbiAgICAgICAgICAgICAgIChAZmluYWxDaHVuayBhbmQgb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoIGlzIHZhbC5sZW5ndGgpXG4gICAgICAgICAgICAgICcnXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICcgJ1xuICAgIEBkZWxpbWl0ZXIgPSBAcXVvdGUuY2hhckF0IDBcbiAgICBAdmFsdWUgPSBtYWtlRGVsaW1pdGVkTGl0ZXJhbCB2YWwsIHtcbiAgICAgIEBkZWxpbWl0ZXJcbiAgICAgIEBkb3VibGVcbiAgICB9XG5cbiAgICBAdW5xdW90ZWRWYWx1ZUZvclRlbXBsYXRlTGl0ZXJhbCA9IG1ha2VEZWxpbWl0ZWRMaXRlcmFsIHZhbCwge1xuICAgICAgZGVsaW1pdGVyOiAnYCdcbiAgICAgIEBkb3VibGVcbiAgICAgIGVzY2FwZU5ld2xpbmVzOiBub1xuICAgICAgaW5jbHVkZURlbGltaXRlcnM6IG5vXG4gICAgICBjb252ZXJ0VHJhaWxpbmdOdWxsRXNjYXBlczogeWVzXG4gICAgfVxuXG4gICAgQHVucXVvdGVkVmFsdWVGb3JKU1ggPSBtYWtlRGVsaW1pdGVkTGl0ZXJhbCB2YWwsIHtcbiAgICAgIEBkb3VibGVcbiAgICAgIGVzY2FwZU5ld2xpbmVzOiBub1xuICAgICAgaW5jbHVkZURlbGltaXRlcnM6IG5vXG4gICAgICBlc2NhcGVEZWxpbWl0ZXI6IG5vXG4gICAgfVxuXG4gIGNvbXBpbGVOb2RlOiAobykgLT5cbiAgICByZXR1cm4gU3RyaW5nV2l0aEludGVycG9sYXRpb25zLmZyb21TdHJpbmdMaXRlcmFsKEApLmNvbXBpbGVOb2RlIG8gaWYgQHNob3VsZEdlbmVyYXRlVGVtcGxhdGVMaXRlcmFsKClcbiAgICByZXR1cm4gW0BtYWtlQ29kZSBAdW5xdW90ZWRWYWx1ZUZvckpTWF0gaWYgQGpzeFxuICAgIHN1cGVyIG9cblxuICAjIGBTdHJpbmdMaXRlcmFsYHMgY2FuIHJlcHJlc2VudCBlaXRoZXIgZW50aXJlIGxpdGVyYWwgc3RyaW5nc1xuICAjIG9yIHBpZWNlcyBvZiB0ZXh0IGluc2lkZSBvZiBlLmcuIGFuIGludGVycG9sYXRlZCBzdHJpbmcuXG4gICMgV2hlbiBwYXJzZWQgYXMgdGhlIGZvcm1lciBidXQgbmVlZGluZyB0byBiZSB0cmVhdGVkIGFzIHRoZSBsYXR0ZXJcbiAgIyAoZS5nLiB0aGUgc3RyaW5nIHBhcnQgb2YgYSB0YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbCksIHRoaXMgd2lsbCByZXR1cm5cbiAgIyBhIGNvcHkgb2YgdGhlIGBTdHJpbmdMaXRlcmFsYCB3aXRoIHRoZSBxdW90ZXMgdHJpbW1lZCBmcm9tIGl0cyBsb2NhdGlvblxuICAjIGRhdGEgKGxpa2UgaXQgd291bGQgaGF2ZSBpZiBwYXJzZWQgYXMgcGFydCBvZiBhbiBpbnRlcnBvbGF0ZWQgc3RyaW5nKS5cbiAgd2l0aG91dFF1b3Rlc0luTG9jYXRpb25EYXRhOiAtPlxuICAgIGVuZHNXaXRoTmV3bGluZSA9IEBvcmlnaW5hbFZhbHVlWy0xLi5dIGlzICdcXG4nXG4gICAgbG9jYXRpb25EYXRhID0gT2JqZWN0LmFzc2lnbiB7fSwgQGxvY2F0aW9uRGF0YVxuICAgIGxvY2F0aW9uRGF0YS5maXJzdF9jb2x1bW4gICAgICAgICAgKz0gQHF1b3RlLmxlbmd0aFxuICAgIGlmIGVuZHNXaXRoTmV3bGluZVxuICAgICAgbG9jYXRpb25EYXRhLmxhc3RfbGluZSAtPSAxXG4gICAgICBsb2NhdGlvbkRhdGEubGFzdF9jb2x1bW4gPVxuICAgICAgICBpZiBsb2NhdGlvbkRhdGEubGFzdF9saW5lIGlzIGxvY2F0aW9uRGF0YS5maXJzdF9saW5lXG4gICAgICAgICAgbG9jYXRpb25EYXRhLmZpcnN0X2NvbHVtbiArIEBvcmlnaW5hbFZhbHVlLmxlbmd0aCAtICdcXG4nLmxlbmd0aFxuICAgICAgICBlbHNlXG4gICAgICAgICAgQG9yaWdpbmFsVmFsdWVbLi4uLTFdLmxlbmd0aCAtICdcXG4nLmxlbmd0aCAtIEBvcmlnaW5hbFZhbHVlWy4uLi0xXS5sYXN0SW5kZXhPZignXFxuJylcbiAgICBlbHNlXG4gICAgICBsb2NhdGlvbkRhdGEubGFzdF9jb2x1bW4gICAgICAgICAtPSBAcXVvdGUubGVuZ3RoXG4gICAgbG9jYXRpb25EYXRhLmxhc3RfY29sdW1uX2V4Y2x1c2l2ZSAtPSBAcXVvdGUubGVuZ3RoXG4gICAgbG9jYXRpb25EYXRhLnJhbmdlID0gW1xuICAgICAgbG9jYXRpb25EYXRhLnJhbmdlWzBdICsgQHF1b3RlLmxlbmd0aFxuICAgICAgbG9jYXRpb25EYXRhLnJhbmdlWzFdIC0gQHF1b3RlLmxlbmd0aFxuICAgIF1cbiAgICBjb3B5ID0gbmV3IFN0cmluZ0xpdGVyYWwgQG9yaWdpbmFsVmFsdWUsIHtAcXVvdGUsIEBpbml0aWFsQ2h1bmssIEBmaW5hbENodW5rLCBAaW5kZW50LCBAZG91YmxlLCBAaGVyZWdleH1cbiAgICBjb3B5LmxvY2F0aW9uRGF0YSA9IGxvY2F0aW9uRGF0YVxuICAgIGNvcHlcblxuICBpc0Zyb21IZXJlZG9jOiAtPlxuICAgIEBxdW90ZS5sZW5ndGggaXMgM1xuXG4gIHNob3VsZEdlbmVyYXRlVGVtcGxhdGVMaXRlcmFsOiAtPlxuICAgIEBpc0Zyb21IZXJlZG9jKClcblxuICBhc3ROb2RlOiAobykgLT5cbiAgICByZXR1cm4gU3RyaW5nV2l0aEludGVycG9sYXRpb25zLmZyb21TdHJpbmdMaXRlcmFsKEApLmFzdCBvIGlmIEBzaG91bGRHZW5lcmF0ZVRlbXBsYXRlTGl0ZXJhbCgpXG4gICAgc3VwZXIgb1xuXG4gIGFzdFByb3BlcnRpZXM6IC0+XG4gICAgcmV0dXJuXG4gICAgICB2YWx1ZTogQG9yaWdpbmFsVmFsdWVcbiAgICAgIGV4dHJhOlxuICAgICAgICByYXc6IFwiI3tAZGVsaW1pdGVyfSN7QG9yaWdpbmFsVmFsdWV9I3tAZGVsaW1pdGVyfVwiXG5cbmV4cG9ydHMuUmVnZXhMaXRlcmFsID0gY2xhc3MgUmVnZXhMaXRlcmFsIGV4dGVuZHMgTGl0ZXJhbFxuICBjb25zdHJ1Y3RvcjogKHZhbHVlLCB7QGRlbGltaXRlciA9ICcvJywgQGhlcmVnZXhDb21tZW50VG9rZW5zID0gW119ID0ge30pIC0+XG4gICAgc3VwZXIgJydcbiAgICBoZXJlZ2V4ID0gQGRlbGltaXRlciBpcyAnLy8vJ1xuICAgIGVuZERlbGltaXRlckluZGV4ID0gdmFsdWUubGFzdEluZGV4T2YgJy8nXG4gICAgQGZsYWdzID0gdmFsdWVbZW5kRGVsaW1pdGVySW5kZXggKyAxLi5dXG4gICAgdmFsID0gQG9yaWdpbmFsVmFsdWUgPSB2YWx1ZVsxLi4uZW5kRGVsaW1pdGVySW5kZXhdXG4gICAgdmFsID0gdmFsLnJlcGxhY2UgSEVSRUdFWF9PTUlULCAnJDEkMicgaWYgaGVyZWdleFxuICAgIHZhbCA9IHJlcGxhY2VVbmljb2RlQ29kZVBvaW50RXNjYXBlcyB2YWwsIHtAZmxhZ3N9XG4gICAgQHZhbHVlID0gXCIje21ha2VEZWxpbWl0ZWRMaXRlcmFsIHZhbCwgZGVsaW1pdGVyOiAnLyd9I3tAZmxhZ3N9XCJcblxuICBSRUdFWF9SRUdFWDogLy8vIF4gLyAoLiopIC8gXFx3KiAkIC8vL1xuXG4gIGFzdFR5cGU6IC0+ICdSZWdFeHBMaXRlcmFsJ1xuXG4gIGFzdFByb3BlcnRpZXM6IChvKSAtPlxuICAgIFssIHBhdHRlcm5dID0gQFJFR0VYX1JFR0VYLmV4ZWMgQHZhbHVlXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgIHBhdHRlcm4sIEBmbGFncywgQGRlbGltaXRlclxuICAgICAgb3JpZ2luYWxQYXR0ZXJuOiBAb3JpZ2luYWxWYWx1ZVxuICAgICAgZXh0cmE6XG4gICAgICAgIHJhdzogQHZhbHVlXG4gICAgICAgIG9yaWdpbmFsUmF3OiBcIiN7QGRlbGltaXRlcn0je0BvcmlnaW5hbFZhbHVlfSN7QGRlbGltaXRlcn0je0BmbGFnc31cIlxuICAgICAgICByYXdWYWx1ZTogdW5kZWZpbmVkXG4gICAgICBjb21tZW50czpcbiAgICAgICAgZm9yIGhlcmVnZXhDb21tZW50VG9rZW4gaW4gQGhlcmVnZXhDb21tZW50VG9rZW5zXG4gICAgICAgICAgaWYgaGVyZWdleENvbW1lbnRUb2tlbi5oZXJlXG4gICAgICAgICAgICBuZXcgSGVyZUNvbW1lbnQoaGVyZWdleENvbW1lbnRUb2tlbikuYXN0IG9cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBuZXcgTGluZUNvbW1lbnQoaGVyZWdleENvbW1lbnRUb2tlbikuYXN0IG9cbiAgICB9XG5cbmV4cG9ydHMuUGFzc3Rocm91Z2hMaXRlcmFsID0gY2xhc3MgUGFzc3Rocm91Z2hMaXRlcmFsIGV4dGVuZHMgTGl0ZXJhbFxuICBjb25zdHJ1Y3RvcjogKEBvcmlnaW5hbFZhbHVlLCB7QGhlcmUsIEBnZW5lcmF0ZWR9ID0ge30pIC0+XG4gICAgc3VwZXIgJydcbiAgICBAdmFsdWUgPSBAb3JpZ2luYWxWYWx1ZS5yZXBsYWNlIC9cXFxcKyhgfCQpL2csIChzdHJpbmcpIC0+XG4gICAgICAjIGBzdHJpbmdgIGlzIGFsd2F5cyBhIHZhbHVlIGxpa2UgJ1xcYCcsICdcXFxcXFxgJywgJ1xcXFxcXFxcXFxgJywgZXRjLlxuICAgICAgIyBCeSByZWR1Y2luZyBpdCB0byBpdHMgbGF0dGVyIGhhbGYsIHdlIHR1cm4gJ1xcYCcgdG8gJ2AnLCAnXFxcXFxcYCcgdG8gJ1xcYCcsIGV0Yy5cbiAgICAgIHN0cmluZ1stTWF0aC5jZWlsKHN0cmluZy5sZW5ndGggLyAyKS4uXVxuXG4gIGFzdE5vZGU6IChvKSAtPlxuICAgIHJldHVybiBudWxsIGlmIEBnZW5lcmF0ZWRcbiAgICBzdXBlciBvXG5cbiAgYXN0UHJvcGVydGllczogLT5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IEBvcmlnaW5hbFZhbHVlXG4gICAgICBoZXJlOiAhIUBoZXJlXG4gICAgfVxuXG5leHBvcnRzLklkZW50aWZpZXJMaXRlcmFsID0gY2xhc3MgSWRlbnRpZmllckxpdGVyYWwgZXh0ZW5kcyBMaXRlcmFsXG4gIGlzQXNzaWduYWJsZTogWUVTXG5cbiAgZWFjaE5hbWU6IChpdGVyYXRvcikgLT5cbiAgICBpdGVyYXRvciBAXG5cbiAgYXN0VHlwZTogLT5cbiAgICBpZiBAanN4XG4gICAgICAnSlNYSWRlbnRpZmllcidcbiAgICBlbHNlXG4gICAgICAnSWRlbnRpZmllcidcblxuICBhc3RQcm9wZXJ0aWVzOiAtPlxuICAgIHJldHVyblxuICAgICAgbmFtZTogQHZhbHVlXG4gICAgICBkZWNsYXJhdGlvbjogISFAaXNEZWNsYXJhdGlvblxuXG5leHBvcnRzLlByb3BlcnR5TmFtZSA9IGNsYXNzIFByb3BlcnR5TmFtZSBleHRlbmRzIExpdGVyYWxcbiAgaXNBc3NpZ25hYmxlOiBZRVNcblxuICBhc3RUeXBlOiAtPlxuICAgIGlmIEBqc3hcbiAgICAgICdKU1hJZGVudGlmaWVyJ1xuICAgIGVsc2VcbiAgICAgICdJZGVudGlmaWVyJ1xuXG4gIGFzdFByb3BlcnRpZXM6IC0+XG4gICAgcmV0dXJuXG4gICAgICBuYW1lOiBAdmFsdWVcbiAgICAgIGRlY2xhcmF0aW9uOiBub1xuXG5leHBvcnRzLkNvbXB1dGVkUHJvcGVydHlOYW1lID0gY2xhc3MgQ29tcHV0ZWRQcm9wZXJ0eU5hbWUgZXh0ZW5kcyBQcm9wZXJ0eU5hbWVcbiAgY29tcGlsZU5vZGU6IChvKSAtPlxuICAgIFtAbWFrZUNvZGUoJ1snKSwgQHZhbHVlLmNvbXBpbGVUb0ZyYWdtZW50cyhvLCBMRVZFTF9MSVNUKS4uLiwgQG1ha2VDb2RlKCddJyldXG5cbiAgYXN0Tm9kZTogKG8pIC0+XG4gICAgQHZhbHVlLmFzdCBvXG5cbmV4cG9ydHMuU3RhdGVtZW50TGl0ZXJhbCA9IGNsYXNzIFN0YXRlbWVudExpdGVyYWwgZXh0ZW5kcyBMaXRlcmFsXG4gIGlzU3RhdGVtZW50OiBZRVNcblxuICBtYWtlUmV0dXJuOiBUSElTXG5cbiAganVtcHM6IChvKSAtPlxuICAgIHJldHVybiB0aGlzIGlmIEB2YWx1ZSBpcyAnYnJlYWsnIGFuZCBub3QgKG8/Lmxvb3Agb3Igbz8uYmxvY2spXG4gICAgcmV0dXJuIHRoaXMgaWYgQHZhbHVlIGlzICdjb250aW51ZScgYW5kIG5vdCBvPy5sb29wXG5cbiAgY29tcGlsZU5vZGU6IChvKSAtPlxuICAgIFtAbWFrZUNvZGUgXCIje0B0YWJ9I3tAdmFsdWV9O1wiXVxuXG4gIGFzdFR5cGU6IC0+XG4gICAgc3dpdGNoIEB2YWx1ZVxuICAgICAgd2hlbiAnY29udGludWUnIHRoZW4gJ0NvbnRpbnVlU3RhdGVtZW50J1xuICAgICAgd2hlbiAnYnJlYWsnICAgIHRoZW4gJ0JyZWFrU3RhdGVtZW50J1xuICAgICAgd2hlbiAnZGVidWdnZXInIHRoZW4gJ0RlYnVnZ2VyU3RhdGVtZW50J1xuXG5leHBvcnRzLlRoaXNMaXRlcmFsID0gY2xhc3MgVGhpc0xpdGVyYWwgZXh0ZW5kcyBMaXRlcmFsXG4gIGNvbnN0cnVjdG9yOiAodmFsdWUpIC0+XG4gICAgc3VwZXIgJ3RoaXMnXG4gICAgQHNob3J0aGFuZCA9IHZhbHVlIGlzICdAJ1xuXG4gIGNvbXBpbGVOb2RlOiAobykgLT5cbiAgICBjb2RlID0gaWYgby5zY29wZS5tZXRob2Q/LmJvdW5kIHRoZW4gby5zY29wZS5tZXRob2QuY29udGV4dCBlbHNlIEB2YWx1ZVxuICAgIFtAbWFrZUNvZGUgY29kZV1cblxuICBhc3RUeXBlOiAtPiAnVGhpc0V4cHJlc3Npb24nXG5cbiAgYXN0UHJvcGVydGllczogLT5cbiAgICByZXR1cm5cbiAgICAgIHNob3J0aGFuZDogQHNob3J0aGFuZFxuXG5leHBvcnRzLlVuZGVmaW5lZExpdGVyYWwgPSBjbGFzcyBVbmRlZmluZWRMaXRlcmFsIGV4dGVuZHMgTGl0ZXJhbFxuICBjb25zdHJ1Y3RvcjogLT5cbiAgICBzdXBlciAndW5kZWZpbmVkJ1xuXG4gIGNvbXBpbGVOb2RlOiAobykgLT5cbiAgICBbQG1ha2VDb2RlIGlmIG8ubGV2ZWwgPj0gTEVWRUxfQUNDRVNTIHRoZW4gJyh2b2lkIDApJyBlbHNlICd2b2lkIDAnXVxuXG4gIGFzdFR5cGU6IC0+ICdJZGVudGlmaWVyJ1xuXG4gIGFzdFByb3BlcnRpZXM6IC0+XG4gICAgcmV0dXJuXG4gICAgICBuYW1lOiBAdmFsdWVcbiAgICAgIGRlY2xhcmF0aW9uOiBub1xuXG5leHBvcnRzLk51bGxMaXRlcmFsID0gY2xhc3MgTnVsbExpdGVyYWwgZXh0ZW5kcyBMaXRlcmFsXG4gIGNvbnN0cnVjdG9yOiAtPlxuICAgIHN1cGVyICdudWxsJ1xuXG5leHBvcnRzLkJvb2xlYW5MaXRlcmFsID0gY2xhc3MgQm9vbGVhbkxpdGVyYWwgZXh0ZW5kcyBMaXRlcmFsXG4gIGNvbnN0cnVjdG9yOiAodmFsdWUsIHtAb3JpZ2luYWxWYWx1ZX0gPSB7fSkgLT5cbiAgICBzdXBlciB2YWx1ZVxuICAgIEBvcmlnaW5hbFZhbHVlID89IEB2YWx1ZVxuXG4gIGFzdFByb3BlcnRpZXM6IC0+XG4gICAgdmFsdWU6IGlmIEB2YWx1ZSBpcyAndHJ1ZScgdGhlbiB5ZXMgZWxzZSBub1xuICAgIG5hbWU6IEBvcmlnaW5hbFZhbHVlXG5cbmV4cG9ydHMuRGVmYXVsdExpdGVyYWwgPSBjbGFzcyBEZWZhdWx0TGl0ZXJhbCBleHRlbmRzIExpdGVyYWxcbiAgYXN0VHlwZTogLT4gJ0lkZW50aWZpZXInXG5cbiAgYXN0UHJvcGVydGllczogLT5cbiAgICByZXR1cm5cbiAgICAgIG5hbWU6ICdkZWZhdWx0J1xuICAgICAgZGVjbGFyYXRpb246IG5vXG5cbiMjIyMgUmV0dXJuXG5cbiMgQSBgcmV0dXJuYCBpcyBhICpwdXJlU3RhdGVtZW50KuKAlHdyYXBwaW5nIGl0IGluIGEgY2xvc3VyZSB3b3VsZG7igJl0IG1ha2Ugc2Vuc2UuXG5leHBvcnRzLlJldHVybiA9IGNsYXNzIFJldHVybiBleHRlbmRzIEJhc2VcbiAgY29uc3RydWN0b3I6IChAZXhwcmVzc2lvbiwge0BiZWxvbmdzVG9GdW5jRGlyZWN0aXZlUmV0dXJufSA9IHt9KSAtPlxuICAgIHN1cGVyKClcblxuICBjaGlsZHJlbjogWydleHByZXNzaW9uJ11cblxuICBpc1N0YXRlbWVudDogICAgIFlFU1xuICBtYWtlUmV0dXJuOiAgICAgIFRISVNcbiAganVtcHM6ICAgICAgICAgICBUSElTXG5cbiAgY29tcGlsZVRvRnJhZ21lbnRzOiAobywgbGV2ZWwpIC0+XG4gICAgZXhwciA9IEBleHByZXNzaW9uPy5tYWtlUmV0dXJuKClcbiAgICBpZiBleHByIGFuZCBleHByIG5vdCBpbnN0YW5jZW9mIFJldHVybiB0aGVuIGV4cHIuY29tcGlsZVRvRnJhZ21lbnRzIG8sIGxldmVsIGVsc2Ugc3VwZXIgbywgbGV2ZWxcblxuICBjb21waWxlTm9kZTogKG8pIC0+XG4gICAgYW5zd2VyID0gW11cbiAgICAjIFRPRE86IElmIHdlIGNhbGwgYGV4cHJlc3Npb24uY29tcGlsZSgpYCBoZXJlIHR3aWNlLCB3ZeKAmWxsIHNvbWV0aW1lc1xuICAgICMgZ2V0IGJhY2sgZGlmZmVyZW50IHJlc3VsdHMhXG4gICAgaWYgQGV4cHJlc3Npb25cbiAgICAgIGFuc3dlciA9IEBleHByZXNzaW9uLmNvbXBpbGVUb0ZyYWdtZW50cyBvLCBMRVZFTF9QQVJFTlxuICAgICAgdW5zaGlmdEFmdGVyQ29tbWVudHMgYW5zd2VyLCBAbWFrZUNvZGUgXCIje0B0YWJ9cmV0dXJuIFwiXG4gICAgICAjIFNpbmNlIHRoZSBgcmV0dXJuYCBnb3QgaW5kZW50ZWQgYnkgYEB0YWJgLCBwcmVjZWRpbmcgY29tbWVudHMgdGhhdCBhcmVcbiAgICAgICMgbXVsdGlsaW5lIG5lZWQgdG8gYmUgaW5kZW50ZWQuXG4gICAgICBmb3IgZnJhZ21lbnQgaW4gYW5zd2VyXG4gICAgICAgIGlmIGZyYWdtZW50LmlzSGVyZUNvbW1lbnQgYW5kICdcXG4nIGluIGZyYWdtZW50LmNvZGVcbiAgICAgICAgICBmcmFnbWVudC5jb2RlID0gbXVsdGlkZW50IGZyYWdtZW50LmNvZGUsIEB0YWJcbiAgICAgICAgZWxzZSBpZiBmcmFnbWVudC5pc0xpbmVDb21tZW50XG4gICAgICAgICAgZnJhZ21lbnQuY29kZSA9IFwiI3tAdGFifSN7ZnJhZ21lbnQuY29kZX1cIlxuICAgICAgICBlbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICBlbHNlXG4gICAgICBhbnN3ZXIucHVzaCBAbWFrZUNvZGUgXCIje0B0YWJ9cmV0dXJuXCJcbiAgICBhbnN3ZXIucHVzaCBAbWFrZUNvZGUgJzsnXG4gICAgYW5zd2VyXG5cbiAgY2hlY2tGb3JQdXJlU3RhdGVtZW50SW5FeHByZXNzaW9uOiAtPlxuICAgICMgZG9u4oCZdCBmbGFnIGByZXR1cm5gIGZyb20gYGF3YWl0IHJldHVybmAvYHlpZWxkIHJldHVybmAgYXMgaW52YWxpZC5cbiAgICByZXR1cm4gaWYgQGJlbG9uZ3NUb0Z1bmNEaXJlY3RpdmVSZXR1cm5cbiAgICBzdXBlcigpXG5cbiAgYXN0VHlwZTogLT4gJ1JldHVyblN0YXRlbWVudCdcblxuICBhc3RQcm9wZXJ0aWVzOiAobykgLT5cbiAgICBhcmd1bWVudDogQGV4cHJlc3Npb24/LmFzdChvLCBMRVZFTF9QQVJFTikgPyBudWxsXG5cbiMgUGFyZW50IGNsYXNzIGZvciBgWWllbGRSZXR1cm5gL2BBd2FpdFJldHVybmAuXG5leHBvcnRzLkZ1bmNEaXJlY3RpdmVSZXR1cm4gPSBjbGFzcyBGdW5jRGlyZWN0aXZlUmV0dXJuIGV4dGVuZHMgUmV0dXJuXG4gIGNvbnN0cnVjdG9yOiAoZXhwcmVzc2lvbiwge0ByZXR1cm5LZXl3b3JkfSkgLT5cbiAgICBzdXBlciBleHByZXNzaW9uXG5cbiAgY29tcGlsZU5vZGU6IChvKSAtPlxuICAgIEBjaGVja1Njb3BlIG9cbiAgICBzdXBlciBvXG5cbiAgY2hlY2tTY29wZTogKG8pIC0+XG4gICAgdW5sZXNzIG8uc2NvcGUucGFyZW50P1xuICAgICAgQGVycm9yIFwiI3tAa2V5d29yZH0gY2FuIG9ubHkgb2NjdXIgaW5zaWRlIGZ1bmN0aW9uc1wiXG5cbiAgaXNTdGF0ZW1lbnRBc3Q6IE5PXG5cbiAgYXN0Tm9kZTogKG8pIC0+XG4gICAgQGNoZWNrU2NvcGUgb1xuXG4gICAgbmV3IE9wIEBrZXl3b3JkLFxuICAgICAgbmV3IFJldHVybiBAZXhwcmVzc2lvbiwgYmVsb25nc1RvRnVuY0RpcmVjdGl2ZVJldHVybjogeWVzXG4gICAgICAud2l0aExvY2F0aW9uRGF0YUZyb20oXG4gICAgICAgIGlmIEBleHByZXNzaW9uP1xuICAgICAgICAgIGxvY2F0aW9uRGF0YTogbWVyZ2VMb2NhdGlvbkRhdGEgQHJldHVybktleXdvcmQubG9jYXRpb25EYXRhLCBAZXhwcmVzc2lvbi5sb2NhdGlvbkRhdGFcbiAgICAgICAgZWxzZVxuICAgICAgICAgIEByZXR1cm5LZXl3b3JkXG4gICAgICApXG4gICAgLndpdGhMb2NhdGlvbkRhdGFGcm9tIEBcbiAgICAuYXN0IG9cblxuIyBgeWllbGQgcmV0dXJuYCB3b3JrcyBleGFjdGx5IGxpa2UgYHJldHVybmAsIGV4Y2VwdCB0aGF0IGl0IHR1cm5zIHRoZSBmdW5jdGlvblxuIyBpbnRvIGEgZ2VuZXJhdG9yLlxuZXhwb3J0cy5ZaWVsZFJldHVybiA9IGNsYXNzIFlpZWxkUmV0dXJuIGV4dGVuZHMgRnVuY0RpcmVjdGl2ZVJldHVyblxuICBrZXl3b3JkOiAneWllbGQnXG5cbmV4cG9ydHMuQXdhaXRSZXR1cm4gPSBjbGFzcyBBd2FpdFJldHVybiBleHRlbmRzIEZ1bmNEaXJlY3RpdmVSZXR1cm5cbiAga2V5d29yZDogJ2F3YWl0J1xuXG4jIyMjIFZhbHVlXG5cbiMgQSB2YWx1ZSwgdmFyaWFibGUgb3IgbGl0ZXJhbCBvciBwYXJlbnRoZXNpemVkLCBpbmRleGVkIG9yIGRvdHRlZCBpbnRvLFxuIyBvciB2YW5pbGxhLlxuZXhwb3J0cy5WYWx1ZSA9IGNsYXNzIFZhbHVlIGV4dGVuZHMgQmFzZVxuICBjb25zdHJ1Y3RvcjogKGJhc2UsIHByb3BzLCB0YWcsIGlzRGVmYXVsdFZhbHVlID0gbm8pIC0+XG4gICAgc3VwZXIoKVxuICAgIHJldHVybiBiYXNlIGlmIG5vdCBwcm9wcyBhbmQgYmFzZSBpbnN0YW5jZW9mIFZhbHVlXG4gICAgQGJhc2UgICAgICAgICAgID0gYmFzZVxuICAgIEBwcm9wZXJ0aWVzICAgICA9IHByb3BzIG9yIFtdXG4gICAgQHRhZyAgICAgICAgICAgID0gdGFnXG4gICAgQFt0YWddICAgICAgICAgID0geWVzIGlmIHRhZ1xuICAgIEBpc0RlZmF1bHRWYWx1ZSA9IGlzRGVmYXVsdFZhbHVlXG4gICAgIyBJZiB0aGlzIGlzIGEgYEBmb28gPWAgYXNzaWdubWVudCwgaWYgdGhlcmUgYXJlIGNvbW1lbnRzIG9uIGBAYCBtb3ZlIHRoZW1cbiAgICAjIHRvIGJlIG9uIGBmb29gLlxuICAgIGlmIEBiYXNlPy5jb21tZW50cyBhbmQgQGJhc2UgaW5zdGFuY2VvZiBUaGlzTGl0ZXJhbCBhbmQgQHByb3BlcnRpZXNbMF0/Lm5hbWU/XG4gICAgICBtb3ZlQ29tbWVudHMgQGJhc2UsIEBwcm9wZXJ0aWVzWzBdLm5hbWVcblxuICBjaGlsZHJlbjogWydiYXNlJywgJ3Byb3BlcnRpZXMnXVxuXG4gICMgQWRkIGEgcHJvcGVydHkgKG9yICpwcm9wZXJ0aWVzKiApIGBBY2Nlc3NgIHRvIHRoZSBsaXN0LlxuICBhZGQ6IChwcm9wcykgLT5cbiAgICBAcHJvcGVydGllcyA9IEBwcm9wZXJ0aWVzLmNvbmNhdCBwcm9wc1xuICAgIEBmb3JjZVVwZGF0ZUxvY2F0aW9uID0geWVzXG4gICAgdGhpc1xuXG4gIGhhc1Byb3BlcnRpZXM6IC0+XG4gICAgQHByb3BlcnRpZXMubGVuZ3RoIGlzbnQgMFxuXG4gIGJhcmVMaXRlcmFsOiAodHlwZSkgLT5cbiAgICBub3QgQHByb3BlcnRpZXMubGVuZ3RoIGFuZCBAYmFzZSBpbnN0YW5jZW9mIHR5cGVcblxuICAjIFNvbWUgYm9vbGVhbiBjaGVja3MgZm9yIHRoZSBiZW5lZml0IG9mIG90aGVyIG5vZGVzLlxuICBpc0FycmF5ICAgICAgICA6IC0+IEBiYXJlTGl0ZXJhbChBcnIpXG4gIGlzUmFuZ2UgICAgICAgIDogLT4gQGJhcmVMaXRlcmFsKFJhbmdlKVxuICBzaG91bGRDYWNoZSAgICA6IC0+IEBoYXNQcm9wZXJ0aWVzKCkgb3IgQGJhc2Uuc2hvdWxkQ2FjaGUoKVxuICBpc0Fzc2lnbmFibGUgICA6IChvcHRzKSAtPiBAaGFzUHJvcGVydGllcygpIG9yIEBiYXNlLmlzQXNzaWduYWJsZSBvcHRzXG4gIGlzTnVtYmVyICAgICAgIDogLT4gQGJhcmVMaXRlcmFsKE51bWJlckxpdGVyYWwpXG4gIGlzU3RyaW5nICAgICAgIDogLT4gQGJhcmVMaXRlcmFsKFN0cmluZ0xpdGVyYWwpXG4gIGlzUmVnZXggICAgICAgIDogLT4gQGJhcmVMaXRlcmFsKFJlZ2V4TGl0ZXJhbClcbiAgaXNVbmRlZmluZWQgICAgOiAtPiBAYmFyZUxpdGVyYWwoVW5kZWZpbmVkTGl0ZXJhbClcbiAgaXNOdWxsICAgICAgICAgOiAtPiBAYmFyZUxpdGVyYWwoTnVsbExpdGVyYWwpXG4gIGlzQm9vbGVhbiAgICAgIDogLT4gQGJhcmVMaXRlcmFsKEJvb2xlYW5MaXRlcmFsKVxuICBpc0F0b21pYyAgICAgICA6IC0+XG4gICAgZm9yIG5vZGUgaW4gQHByb3BlcnRpZXMuY29uY2F0IEBiYXNlXG4gICAgICByZXR1cm4gbm8gaWYgbm9kZS5zb2FrIG9yIG5vZGUgaW5zdGFuY2VvZiBDYWxsIG9yIG5vZGUgaW5zdGFuY2VvZiBPcCBhbmQgbm9kZS5vcGVyYXRvciBpcyAnZG8nXG4gICAgeWVzXG5cbiAgaXNOb3RDYWxsYWJsZSAgOiAtPiBAaXNOdW1iZXIoKSBvciBAaXNTdHJpbmcoKSBvciBAaXNSZWdleCgpIG9yXG4gICAgICAgICAgICAgICAgICAgICAgQGlzQXJyYXkoKSBvciBAaXNSYW5nZSgpIG9yIEBpc1NwbGljZSgpIG9yIEBpc09iamVjdCgpIG9yXG4gICAgICAgICAgICAgICAgICAgICAgQGlzVW5kZWZpbmVkKCkgb3IgQGlzTnVsbCgpIG9yIEBpc0Jvb2xlYW4oKVxuXG4gIGlzU3RhdGVtZW50IDogKG8pICAgIC0+IG5vdCBAcHJvcGVydGllcy5sZW5ndGggYW5kIEBiYXNlLmlzU3RhdGVtZW50IG9cbiAgaXNKU1hUYWcgICAgOiAtPiBAYmFzZSBpbnN0YW5jZW9mIEpTWFRhZ1xuICBhc3NpZ25zICAgICA6IChuYW1lKSAtPiBub3QgQHByb3BlcnRpZXMubGVuZ3RoIGFuZCBAYmFzZS5hc3NpZ25zIG5hbWVcbiAganVtcHMgICAgICAgOiAobykgICAgLT4gbm90IEBwcm9wZXJ0aWVzLmxlbmd0aCBhbmQgQGJhc2UuanVtcHMgb1xuXG4gIGlzT2JqZWN0OiAob25seUdlbmVyYXRlZCkgLT5cbiAgICByZXR1cm4gbm8gaWYgQHByb3BlcnRpZXMubGVuZ3RoXG4gICAgKEBiYXNlIGluc3RhbmNlb2YgT2JqKSBhbmQgKG5vdCBvbmx5R2VuZXJhdGVkIG9yIEBiYXNlLmdlbmVyYXRlZClcblxuICBpc0VsaXNpb246IC0+XG4gICAgcmV0dXJuIG5vIHVubGVzcyBAYmFzZSBpbnN0YW5jZW9mIEFyclxuICAgIEBiYXNlLmhhc0VsaXNpb24oKVxuXG4gIGlzU3BsaWNlOiAtPlxuICAgIFsuLi4sIGxhc3RQcm9wZXJ0eV0gPSBAcHJvcGVydGllc1xuICAgIGxhc3RQcm9wZXJ0eSBpbnN0YW5jZW9mIFNsaWNlXG5cbiAgbG9va3NTdGF0aWM6IChjbGFzc05hbWUpIC0+XG4gICAgcmV0dXJuIG5vIHVubGVzcyAoKHRoaXNMaXRlcmFsID0gQGJhc2UpIGluc3RhbmNlb2YgVGhpc0xpdGVyYWwgb3IgKG5hbWUgPSBAYmFzZSkudmFsdWUgaXMgY2xhc3NOYW1lKSBhbmRcbiAgICAgIEBwcm9wZXJ0aWVzLmxlbmd0aCBpcyAxIGFuZCBAcHJvcGVydGllc1swXS5uYW1lPy52YWx1ZSBpc250ICdwcm90b3R5cGUnXG4gICAgcmV0dXJuXG4gICAgICBzdGF0aWNDbGFzc05hbWU6IHRoaXNMaXRlcmFsID8gbmFtZVxuXG4gICMgVGhlIHZhbHVlIGNhbiBiZSB1bndyYXBwZWQgYXMgaXRzIGlubmVyIG5vZGUsIGlmIHRoZXJlIGFyZSBubyBhdHRhY2hlZFxuICAjIHByb3BlcnRpZXMuXG4gIHVud3JhcDogLT5cbiAgICBpZiBAcHJvcGVydGllcy5sZW5ndGggdGhlbiB0aGlzIGVsc2UgQGJhc2VcblxuICAjIEEgcmVmZXJlbmNlIGhhcyBiYXNlIHBhcnQgKGB0aGlzYCB2YWx1ZSkgYW5kIG5hbWUgcGFydC5cbiAgIyBXZSBjYWNoZSB0aGVtIHNlcGFyYXRlbHkgZm9yIGNvbXBpbGluZyBjb21wbGV4IGV4cHJlc3Npb25zLlxuICAjIGBhKClbYigpXSA/PSBjYCAtPiBgKF9iYXNlID0gYSgpKVtfbmFtZSA9IGIoKV0gPyBfYmFzZVtfbmFtZV0gPSBjYFxuICBjYWNoZVJlZmVyZW5jZTogKG8pIC0+XG4gICAgWy4uLiwgbmFtZV0gPSBAcHJvcGVydGllc1xuICAgIGlmIEBwcm9wZXJ0aWVzLmxlbmd0aCA8IDIgYW5kIG5vdCBAYmFzZS5zaG91bGRDYWNoZSgpIGFuZCBub3QgbmFtZT8uc2hvdWxkQ2FjaGUoKVxuICAgICAgcmV0dXJuIFt0aGlzLCB0aGlzXSAgIyBgYWAgYGEuYmBcbiAgICBiYXNlID0gbmV3IFZhbHVlIEBiYXNlLCBAcHJvcGVydGllc1suLi4tMV1cbiAgICBpZiBiYXNlLnNob3VsZENhY2hlKCkgICMgYGEoKS5iYFxuICAgICAgYnJlZiA9IG5ldyBJZGVudGlmaWVyTGl0ZXJhbCBvLnNjb3BlLmZyZWVWYXJpYWJsZSAnYmFzZSdcbiAgICAgIGJhc2UgPSBuZXcgVmFsdWUgbmV3IFBhcmVucyBuZXcgQXNzaWduIGJyZWYsIGJhc2VcbiAgICByZXR1cm4gW2Jhc2UsIGJyZWZdIHVubGVzcyBuYW1lICAjIGBhKClgXG4gICAgaWYgbmFtZS5zaG91bGRDYWNoZSgpICAjIGBhW2IoKV1gXG4gICAgICBucmVmID0gbmV3IElkZW50aWZpZXJMaXRlcmFsIG8uc2NvcGUuZnJlZVZhcmlhYmxlICduYW1lJ1xuICAgICAgbmFtZSA9IG5ldyBJbmRleCBuZXcgQXNzaWduIG5yZWYsIG5hbWUuaW5kZXhcbiAgICAgIG5yZWYgPSBuZXcgSW5kZXggbnJlZlxuICAgIFtiYXNlLmFkZChuYW1lKSwgbmV3IFZhbHVlKGJyZWYgb3IgYmFzZS5iYXNlLCBbbnJlZiBvciBuYW1lXSldXG5cbiAgIyBXZSBjb21waWxlIGEgdmFsdWUgdG8gSmF2YVNjcmlwdCBieSBjb21waWxpbmcgYW5kIGpvaW5pbmcgZWFjaCBwcm9wZXJ0eS5cbiAgIyBUaGluZ3MgZ2V0IG11Y2ggbW9yZSBpbnRlcmVzdGluZyBpZiB0aGUgY2hhaW4gb2YgcHJvcGVydGllcyBoYXMgKnNvYWsqXG4gICMgb3BlcmF0b3JzIGA/LmAgaW50ZXJzcGVyc2VkLiBUaGVuIHdlIGhhdmUgdG8gdGFrZSBjYXJlIG5vdCB0byBhY2NpZGVudGFsbHlcbiAgIyBldmFsdWF0ZSBhbnl0aGluZyB0d2ljZSB3aGVuIGJ1aWxkaW5nIHRoZSBzb2FrIGNoYWluLlxuICBjb21waWxlTm9kZTogKG8pIC0+XG4gICAgQGJhc2UuZnJvbnQgPSBAZnJvbnRcbiAgICBwcm9wcyA9IEBwcm9wZXJ0aWVzXG4gICAgaWYgcHJvcHMubGVuZ3RoIGFuZCBAYmFzZS5jYWNoZWQ/XG4gICAgICAjIENhY2hlZCBmcmFnbWVudHMgZW5hYmxlIGNvcnJlY3Qgb3JkZXIgb2YgdGhlIGNvbXBpbGF0aW9uLFxuICAgICAgIyBhbmQgcmV1c2Ugb2YgdmFyaWFibGVzIGluIHRoZSBzY29wZS5cbiAgICAgICMgRXhhbXBsZTpcbiAgICAgICMgYGEoeCA9IDUpLmIoLT4geCA9IDYpYCBzaG91bGQgY29tcGlsZSBpbiB0aGUgc2FtZSBvcmRlciBhc1xuICAgICAgIyBgYSh4ID0gNSk7IGIoLT4geCA9IDYpYFxuICAgICAgIyAoc2VlIGlzc3VlICM0NDM3LCBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL2NvZmZlZXNjcmlwdC9pc3N1ZXMvNDQzNylcbiAgICAgIGZyYWdtZW50cyA9IEBiYXNlLmNhY2hlZFxuICAgIGVsc2VcbiAgICAgIGZyYWdtZW50cyA9IEBiYXNlLmNvbXBpbGVUb0ZyYWdtZW50cyBvLCAoaWYgcHJvcHMubGVuZ3RoIHRoZW4gTEVWRUxfQUNDRVNTIGVsc2UgbnVsbClcbiAgICBpZiBwcm9wcy5sZW5ndGggYW5kIFNJTVBMRU5VTS50ZXN0IGZyYWdtZW50c1RvVGV4dCBmcmFnbWVudHNcbiAgICAgIGZyYWdtZW50cy5wdXNoIEBtYWtlQ29kZSAnLidcbiAgICBmb3IgcHJvcCBpbiBwcm9wc1xuICAgICAgZnJhZ21lbnRzLnB1c2ggKHByb3AuY29tcGlsZVRvRnJhZ21lbnRzIG8pLi4uXG5cbiAgICBmcmFnbWVudHNcblxuICAjIFVuZm9sZCBhIHNvYWsgaW50byBhbiBgSWZgOiBgYT8uYmAgLT4gYGEuYiBpZiBhP2BcbiAgdW5mb2xkU29hazogKG8pIC0+XG4gICAgQHVuZm9sZGVkU29hayA/PSBkbyA9PlxuICAgICAgaWZuID0gQGJhc2UudW5mb2xkU29hayBvXG4gICAgICBpZiBpZm5cbiAgICAgICAgaWZuLmJvZHkucHJvcGVydGllcy5wdXNoIEBwcm9wZXJ0aWVzLi4uXG4gICAgICAgIHJldHVybiBpZm5cbiAgICAgIGZvciBwcm9wLCBpIGluIEBwcm9wZXJ0aWVzIHdoZW4gcHJvcC5zb2FrXG4gICAgICAgIHByb3Auc29hayA9IG9mZlxuICAgICAgICBmc3QgPSBuZXcgVmFsdWUgQGJhc2UsIEBwcm9wZXJ0aWVzWy4uLmldXG4gICAgICAgIHNuZCA9IG5ldyBWYWx1ZSBAYmFzZSwgQHByb3BlcnRpZXNbaS4uXVxuICAgICAgICBpZiBmc3Quc2hvdWxkQ2FjaGUoKVxuICAgICAgICAgIHJlZiA9IG5ldyBJZGVudGlmaWVyTGl0ZXJhbCBvLnNjb3BlLmZyZWVWYXJpYWJsZSAncmVmJ1xuICAgICAgICAgIGZzdCA9IG5ldyBQYXJlbnMgbmV3IEFzc2lnbiByZWYsIGZzdFxuICAgICAgICAgIHNuZC5iYXNlID0gcmVmXG4gICAgICAgIHJldHVybiBuZXcgSWYgbmV3IEV4aXN0ZW5jZShmc3QpLCBzbmQsIHNvYWs6IG9uXG4gICAgICBub1xuXG4gIGVhY2hOYW1lOiAoaXRlcmF0b3IsIHtjaGVja0Fzc2lnbmFiaWxpdHkgPSB5ZXN9ID0ge30pIC0+XG4gICAgaWYgQGhhc1Byb3BlcnRpZXMoKVxuICAgICAgaXRlcmF0b3IgQFxuICAgIGVsc2UgaWYgbm90IGNoZWNrQXNzaWduYWJpbGl0eSBvciBAYmFzZS5pc0Fzc2lnbmFibGUoKVxuICAgICAgQGJhc2UuZWFjaE5hbWUgaXRlcmF0b3JcbiAgICBlbHNlXG4gICAgICBAZXJyb3IgJ3RyaWVkIHRvIGFzc2lnbiB0byB1bmFzc2lnbmFibGUgdmFsdWUnXG5cbiAgIyBGb3IgQVNUIGdlbmVyYXRpb24sIHdlIG5lZWQgYW4gYG9iamVjdGAgdGhhdOKAmXMgdGhpcyBgVmFsdWVgIG1pbnVzIGl0cyBsYXN0XG4gICMgcHJvcGVydHksIGlmIGl0IGhhcyBwcm9wZXJ0aWVzLlxuICBvYmplY3Q6IC0+XG4gICAgcmV0dXJuIEAgdW5sZXNzIEBoYXNQcm9wZXJ0aWVzKClcbiAgICAjIEdldCBhbGwgcHJvcGVydGllcyBleGNlcHQgdGhlIGxhc3Qgb25lOyBmb3IgYSBgVmFsdWVgIHdpdGggb25seSBvbmVcbiAgICAjIHByb3BlcnR5LCBgaW5pdGlhbFByb3BlcnRpZXNgIGlzIGFuIGVtcHR5IGFycmF5LlxuICAgIGluaXRpYWxQcm9wZXJ0aWVzID0gQHByb3BlcnRpZXNbMC4uLkBwcm9wZXJ0aWVzLmxlbmd0aCAtIDFdXG4gICAgIyBDcmVhdGUgdGhlIGBvYmplY3RgIHRoYXQgYmVjb21lcyB0aGUgbmV3IOKAnGJhc2XigJ0gZm9yIHRoZSBzcGxpdC1vZmYgZmluYWxcbiAgICAjIHByb3BlcnR5LlxuICAgIG9iamVjdCA9IG5ldyBWYWx1ZSBAYmFzZSwgaW5pdGlhbFByb3BlcnRpZXMsIEB0YWcsIEBpc0RlZmF1bHRWYWx1ZVxuICAgICMgQWRkIGxvY2F0aW9uIGRhdGEgdG8gb3VyIG5ldyBub2RlLCBzbyB0aGF0IGl0IGhhcyBjb3JyZWN0IGxvY2F0aW9uIGRhdGFcbiAgICAjIGZvciBzb3VyY2UgbWFwcyBvciBsYXRlciBjb252ZXJzaW9uIGludG8gQVNUIGxvY2F0aW9uIGRhdGEuXG4gICAgb2JqZWN0LmxvY2F0aW9uRGF0YSA9XG4gICAgICBpZiBpbml0aWFsUHJvcGVydGllcy5sZW5ndGggaXMgMFxuICAgICAgICAjIFRoaXMgbmV3IGBWYWx1ZWAgaGFzIG9ubHkgb25lIHByb3BlcnR5LCBzbyB0aGUgbG9jYXRpb24gZGF0YSBpcyBqdXN0XG4gICAgICAgICMgdGhhdCBvZiB0aGUgcGFyZW50IGBWYWx1ZWDigJlzIGJhc2UuXG4gICAgICAgIEBiYXNlLmxvY2F0aW9uRGF0YVxuICAgICAgZWxzZVxuICAgICAgICAjIFRoaXMgbmV3IGBWYWx1ZWAgaGFzIG11bHRpcGxlIHByb3BlcnRpZXMsIHNvIHRoZSBsb2NhdGlvbiBkYXRhIHNwYW5zXG4gICAgICAgICMgZnJvbSB0aGUgcGFyZW50IGBWYWx1ZWDigJlzIGJhc2UgdG8gdGhlIGxhc3QgcHJvcGVydHkgdGhhdOKAmXMgaW5jbHVkZWRcbiAgICAgICAgIyBpbiB0aGlzIG5ldyBub2RlIChhLmsuYS4gdGhlIHNlY29uZC10by1sYXN0IHByb3BlcnR5IG9mIHRoZSBwYXJlbnQpLlxuICAgICAgICBtZXJnZUxvY2F0aW9uRGF0YSBAYmFzZS5sb2NhdGlvbkRhdGEsIGluaXRpYWxQcm9wZXJ0aWVzW2luaXRpYWxQcm9wZXJ0aWVzLmxlbmd0aCAtIDFdLmxvY2F0aW9uRGF0YVxuICAgIG9iamVjdFxuXG4gIGNvbnRhaW5zU29hazogLT5cbiAgICByZXR1cm4gbm8gdW5sZXNzIEBoYXNQcm9wZXJ0aWVzKClcblxuICAgIGZvciBwcm9wZXJ0eSBpbiBAcHJvcGVydGllcyB3aGVuIHByb3BlcnR5LnNvYWtcbiAgICAgIHJldHVybiB5ZXNcblxuICAgIHJldHVybiB5ZXMgaWYgQGJhc2UgaW5zdGFuY2VvZiBDYWxsIGFuZCBAYmFzZS5zb2FrXG5cbiAgICBub1xuXG4gIGFzdE5vZGU6IChvKSAtPlxuICAgICMgSWYgdGhlIGBWYWx1ZWAgaGFzIG5vIHByb3BlcnRpZXMsIHRoZSBBU1Qgbm9kZSBpcyBqdXN0IHdoYXRldmVyIHRoaXNcbiAgICAjIG5vZGXigJlzIGBiYXNlYCBpcy5cbiAgICByZXR1cm4gQGJhc2UuYXN0IG8gdW5sZXNzIEBoYXNQcm9wZXJ0aWVzKClcbiAgICAjIE90aGVyd2lzZSwgY2FsbCBgQmFzZTo6YXN0YCB3aGljaCBpbiB0dXJuIGNhbGxzIHRoZSBgYXN0VHlwZWAgYW5kXG4gICAgIyBgYXN0UHJvcGVydGllc2AgbWV0aG9kcyBiZWxvdy5cbiAgICBzdXBlciBvXG5cbiAgYXN0VHlwZTogLT5cbiAgICBpZiBAaXNKU1hUYWcoKVxuICAgICAgJ0pTWE1lbWJlckV4cHJlc3Npb24nXG4gICAgZWxzZSBpZiBAY29udGFpbnNTb2FrKClcbiAgICAgICdPcHRpb25hbE1lbWJlckV4cHJlc3Npb24nXG4gICAgZWxzZVxuICAgICAgJ01lbWJlckV4cHJlc3Npb24nXG5cbiAgIyBJZiB0aGlzIGBWYWx1ZWAgaGFzIHByb3BlcnRpZXMsIHRoZSAqbGFzdCogcHJvcGVydHkgKGUuZy4gYGNgIGluIGBhLmIuY2ApXG4gICMgYmVjb21lcyB0aGUgYHByb3BlcnR5YCwgYW5kIHRoZSBwcmVjZWRpbmcgcHJvcGVydGllcyAoZS5nLiBgYS5iYCkgYmVjb21lXG4gICMgYSBjaGlsZCBgVmFsdWVgIG5vZGUgYXNzaWduZWQgdG8gdGhlIGBvYmplY3RgIHByb3BlcnR5LlxuICBhc3RQcm9wZXJ0aWVzOiAobykgLT5cbiAgICBbLi4uLCBwcm9wZXJ0eV0gPSBAcHJvcGVydGllc1xuICAgIHByb3BlcnR5Lm5hbWUuanN4ID0geWVzIGlmIEBpc0pTWFRhZygpXG4gICAgY29tcHV0ZWQgPSBwcm9wZXJ0eSBpbnN0YW5jZW9mIEluZGV4IG9yIHByb3BlcnR5Lm5hbWU/LnVud3JhcCgpIG5vdCBpbnN0YW5jZW9mIFByb3BlcnR5TmFtZVxuICAgIHJldHVybiB7XG4gICAgICBvYmplY3Q6IEBvYmplY3QoKS5hc3QgbywgTEVWRUxfQUNDRVNTXG4gICAgICBwcm9wZXJ0eTogcHJvcGVydHkuYXN0IG8sIChMRVZFTF9QQVJFTiBpZiBjb21wdXRlZClcbiAgICAgIGNvbXB1dGVkXG4gICAgICBvcHRpb25hbDogISFwcm9wZXJ0eS5zb2FrXG4gICAgICBzaG9ydGhhbmQ6ICEhcHJvcGVydHkuc2hvcnRoYW5kXG4gICAgfVxuXG4gIGFzdExvY2F0aW9uRGF0YTogLT5cbiAgICByZXR1cm4gc3VwZXIoKSB1bmxlc3MgQGlzSlNYVGFnKClcbiAgICAjIGRvbid0IGluY2x1ZGUgbGVhZGluZyA8IG9mIEpTWCB0YWcgaW4gbG9jYXRpb24gZGF0YVxuICAgIG1lcmdlQXN0TG9jYXRpb25EYXRhKFxuICAgICAgamlzb25Mb2NhdGlvbkRhdGFUb0FzdExvY2F0aW9uRGF0YShAYmFzZS50YWdOYW1lTG9jYXRpb25EYXRhKSxcbiAgICAgIGppc29uTG9jYXRpb25EYXRhVG9Bc3RMb2NhdGlvbkRhdGEoQHByb3BlcnRpZXNbQHByb3BlcnRpZXMubGVuZ3RoIC0gMV0ubG9jYXRpb25EYXRhKVxuICAgIClcblxuZXhwb3J0cy5NZXRhUHJvcGVydHkgPSBjbGFzcyBNZXRhUHJvcGVydHkgZXh0ZW5kcyBCYXNlXG4gIGNvbnN0cnVjdG9yOiAoQG1ldGEsIEBwcm9wZXJ0eSkgLT5cbiAgICBzdXBlcigpXG5cbiAgY2hpbGRyZW46IFsnbWV0YScsICdwcm9wZXJ0eSddXG5cbiAgY2hlY2tWYWxpZDogKG8pIC0+XG4gICAgaWYgQG1ldGEudmFsdWUgaXMgJ25ldydcbiAgICAgIGlmIEBwcm9wZXJ0eSBpbnN0YW5jZW9mIEFjY2VzcyBhbmQgQHByb3BlcnR5Lm5hbWUudmFsdWUgaXMgJ3RhcmdldCdcbiAgICAgICAgdW5sZXNzIG8uc2NvcGUucGFyZW50P1xuICAgICAgICAgIEBlcnJvciBcIm5ldy50YXJnZXQgY2FuIG9ubHkgb2NjdXIgaW5zaWRlIGZ1bmN0aW9uc1wiXG4gICAgICBlbHNlXG4gICAgICAgIEBlcnJvciBcInRoZSBvbmx5IHZhbGlkIG1ldGEgcHJvcGVydHkgZm9yIG5ldyBpcyBuZXcudGFyZ2V0XCJcbiAgICBlbHNlIGlmIEBtZXRhLnZhbHVlIGlzICdpbXBvcnQnXG4gICAgICB1bmxlc3MgQHByb3BlcnR5IGluc3RhbmNlb2YgQWNjZXNzIGFuZCBAcHJvcGVydHkubmFtZS52YWx1ZSBpcyAnbWV0YSdcbiAgICAgICAgQGVycm9yIFwidGhlIG9ubHkgdmFsaWQgbWV0YSBwcm9wZXJ0eSBmb3IgaW1wb3J0IGlzIGltcG9ydC5tZXRhXCJcblxuICBjb21waWxlTm9kZTogKG8pIC0+XG4gICAgQGNoZWNrVmFsaWQgb1xuICAgIGZyYWdtZW50cyA9IFtdXG4gICAgZnJhZ21lbnRzLnB1c2ggQG1ldGEuY29tcGlsZVRvRnJhZ21lbnRzKG8sIExFVkVMX0FDQ0VTUykuLi5cbiAgICBmcmFnbWVudHMucHVzaCBAcHJvcGVydHkuY29tcGlsZVRvRnJhZ21lbnRzKG8pLi4uXG4gICAgZnJhZ21lbnRzXG5cbiAgYXN0UHJvcGVydGllczogKG8pIC0+XG4gICAgQGNoZWNrVmFsaWQgb1xuXG4gICAgcmV0dXJuXG4gICAgICBtZXRhOiBAbWV0YS5hc3QgbywgTEVWRUxfQUNDRVNTXG4gICAgICBwcm9wZXJ0eTogQHByb3BlcnR5LmFzdCBvXG5cbiMjIyMgSGVyZUNvbW1lbnRcblxuIyBDb21tZW50IGRlbGltaXRlZCBieSBgIyMjYCAoYmVjb21pbmcgYC8qICovYCkuXG5leHBvcnRzLkhlcmVDb21tZW50ID0gY2xhc3MgSGVyZUNvbW1lbnQgZXh0ZW5kcyBCYXNlXG4gIGNvbnN0cnVjdG9yOiAoeyBAY29udGVudCwgQG5ld0xpbmUsIEB1bnNoaWZ0LCBAbG9jYXRpb25EYXRhIH0pIC0+XG4gICAgc3VwZXIoKVxuXG4gIGNvbXBpbGVOb2RlOiAobykgLT5cbiAgICBtdWx0aWxpbmUgPSAnXFxuJyBpbiBAY29udGVudFxuXG4gICAgIyBVbmluZGVudCBtdWx0aWxpbmUgY29tbWVudHMuIFRoZXkgd2lsbCBiZSByZWluZGVudGVkIGxhdGVyLlxuICAgIGlmIG11bHRpbGluZVxuICAgICAgaW5kZW50ID0gbnVsbFxuICAgICAgZm9yIGxpbmUgaW4gQGNvbnRlbnQuc3BsaXQgJ1xcbidcbiAgICAgICAgbGVhZGluZ1doaXRlc3BhY2UgPSAvXlxccyovLmV4ZWMobGluZSlbMF1cbiAgICAgICAgaWYgbm90IGluZGVudCBvciBsZWFkaW5nV2hpdGVzcGFjZS5sZW5ndGggPCBpbmRlbnQubGVuZ3RoXG4gICAgICAgICAgaW5kZW50ID0gbGVhZGluZ1doaXRlc3BhY2VcbiAgICAgIEBjb250ZW50ID0gQGNvbnRlbnQucmVwbGFjZSAvLy8gXFxuICN7aW5kZW50fSAvLy9nLCAnXFxuJyBpZiBpbmRlbnRcblxuICAgIGhhc0xlYWRpbmdNYXJrcyA9IC9cXG5cXHMqWyN8XFwqXS8udGVzdCBAY29udGVudFxuICAgIEBjb250ZW50ID0gQGNvbnRlbnQucmVwbGFjZSAvXihbIFxcdF0qKSMoPz1cXHMpL2dtLCAnIConIGlmIGhhc0xlYWRpbmdNYXJrc1xuXG4gICAgQGNvbnRlbnQgPSBcIi8qI3tAY29udGVudH0je2lmIGhhc0xlYWRpbmdNYXJrcyB0aGVuICcgJyBlbHNlICcnfSovXCJcbiAgICBmcmFnbWVudCA9IEBtYWtlQ29kZSBAY29udGVudFxuICAgIGZyYWdtZW50Lm5ld0xpbmUgPSBAbmV3TGluZVxuICAgIGZyYWdtZW50LnVuc2hpZnQgPSBAdW5zaGlmdFxuICAgIGZyYWdtZW50Lm11bHRpbGluZSA9IG11bHRpbGluZVxuICAgICMgRG9u4oCZdCByZWx5IG9uIGBmcmFnbWVudC50eXBlYCwgd2hpY2ggY2FuIGJyZWFrIHdoZW4gdGhlIGNvbXBpbGVyIGlzIG1pbmlmaWVkLlxuICAgIGZyYWdtZW50LmlzQ29tbWVudCA9IGZyYWdtZW50LmlzSGVyZUNvbW1lbnQgPSB5ZXNcbiAgICBmcmFnbWVudFxuXG4gIGFzdFR5cGU6IC0+ICdDb21tZW50QmxvY2snXG5cbiAgYXN0UHJvcGVydGllczogLT5cbiAgICByZXR1cm5cbiAgICAgIHZhbHVlOiBAY29udGVudFxuXG4jIyMjIExpbmVDb21tZW50XG5cbiMgQ29tbWVudCBydW5uaW5nIGZyb20gYCNgIHRvIHRoZSBlbmQgb2YgYSBsaW5lIChiZWNvbWluZyBgLy9gKS5cbmV4cG9ydHMuTGluZUNvbW1lbnQgPSBjbGFzcyBMaW5lQ29tbWVudCBleHRlbmRzIEJhc2VcbiAgY29uc3RydWN0b3I6ICh7IEBjb250ZW50LCBAbmV3TGluZSwgQHVuc2hpZnQsIEBsb2NhdGlvbkRhdGEsIEBwcmVjZWRlZEJ5QmxhbmtMaW5lIH0pIC0+XG4gICAgc3VwZXIoKVxuXG4gIGNvbXBpbGVOb2RlOiAobykgLT5cbiAgICBmcmFnbWVudCA9IEBtYWtlQ29kZShpZiAvXlxccyokLy50ZXN0IEBjb250ZW50IHRoZW4gJycgZWxzZSBcIiN7aWYgQHByZWNlZGVkQnlCbGFua0xpbmUgdGhlbiBcIlxcbiN7by5pbmRlbnR9XCIgZWxzZSAnJ30vLyN7QGNvbnRlbnR9XCIpXG4gICAgZnJhZ21lbnQubmV3TGluZSA9IEBuZXdMaW5lXG4gICAgZnJhZ21lbnQudW5zaGlmdCA9IEB1bnNoaWZ0XG4gICAgZnJhZ21lbnQudHJhaWwgPSBub3QgQG5ld0xpbmUgYW5kIG5vdCBAdW5zaGlmdFxuICAgICMgRG9u4oCZdCByZWx5IG9uIGBmcmFnbWVudC50eXBlYCwgd2hpY2ggY2FuIGJyZWFrIHdoZW4gdGhlIGNvbXBpbGVyIGlzIG1pbmlmaWVkLlxuICAgIGZyYWdtZW50LmlzQ29tbWVudCA9IGZyYWdtZW50LmlzTGluZUNvbW1lbnQgPSB5ZXNcbiAgICBmcmFnbWVudFxuXG4gIGFzdFR5cGU6IC0+ICdDb21tZW50TGluZSdcblxuICBhc3RQcm9wZXJ0aWVzOiAtPlxuICAgIHJldHVyblxuICAgICAgdmFsdWU6IEBjb250ZW50XG5cbiMjIyMgSlNYXG5cbmV4cG9ydHMuSlNYSWRlbnRpZmllciA9IGNsYXNzIEpTWElkZW50aWZpZXIgZXh0ZW5kcyBJZGVudGlmaWVyTGl0ZXJhbFxuICBhc3RUeXBlOiAtPiAnSlNYSWRlbnRpZmllcidcblxuZXhwb3J0cy5KU1hUYWcgPSBjbGFzcyBKU1hUYWcgZXh0ZW5kcyBKU1hJZGVudGlmaWVyXG4gIGNvbnN0cnVjdG9yOiAodmFsdWUsIHtcbiAgICBAdGFnTmFtZUxvY2F0aW9uRGF0YVxuICAgIEBjbG9zaW5nVGFnT3BlbmluZ0JyYWNrZXRMb2NhdGlvbkRhdGFcbiAgICBAY2xvc2luZ1RhZ1NsYXNoTG9jYXRpb25EYXRhXG4gICAgQGNsb3NpbmdUYWdOYW1lTG9jYXRpb25EYXRhXG4gICAgQGNsb3NpbmdUYWdDbG9zaW5nQnJhY2tldExvY2F0aW9uRGF0YVxuICB9KSAtPlxuICAgIHN1cGVyIHZhbHVlXG5cbiAgYXN0UHJvcGVydGllczogLT5cbiAgICByZXR1cm5cbiAgICAgIG5hbWU6IEB2YWx1ZVxuXG5leHBvcnRzLkpTWEV4cHJlc3Npb25Db250YWluZXIgPSBjbGFzcyBKU1hFeHByZXNzaW9uQ29udGFpbmVyIGV4dGVuZHMgQmFzZVxuICBjb25zdHJ1Y3RvcjogKEBleHByZXNzaW9uLCB7bG9jYXRpb25EYXRhfSA9IHt9KSAtPlxuICAgIHN1cGVyKClcbiAgICBAZXhwcmVzc2lvbi5qc3hBdHRyaWJ1dGUgPSB5ZXNcbiAgICBAbG9jYXRpb25EYXRhID0gbG9jYXRpb25EYXRhID8gQGV4cHJlc3Npb24ubG9jYXRpb25EYXRhXG5cbiAgY2hpbGRyZW46IFsnZXhwcmVzc2lvbiddXG5cbiAgY29tcGlsZU5vZGU6IChvKSAtPlxuICAgIEBleHByZXNzaW9uLmNvbXBpbGVOb2RlKG8pXG5cbiAgYXN0UHJvcGVydGllczogKG8pIC0+XG4gICAgcmV0dXJuXG4gICAgICBleHByZXNzaW9uOiBhc3RBc0Jsb2NrSWZOZWVkZWQgQGV4cHJlc3Npb24sIG9cblxuZXhwb3J0cy5KU1hFbXB0eUV4cHJlc3Npb24gPSBjbGFzcyBKU1hFbXB0eUV4cHJlc3Npb24gZXh0ZW5kcyBCYXNlXG5cbmV4cG9ydHMuSlNYVGV4dCA9IGNsYXNzIEpTWFRleHQgZXh0ZW5kcyBCYXNlXG4gIGNvbnN0cnVjdG9yOiAoc3RyaW5nTGl0ZXJhbCkgLT5cbiAgICBzdXBlcigpXG4gICAgQHZhbHVlID0gc3RyaW5nTGl0ZXJhbC51bnF1b3RlZFZhbHVlRm9ySlNYXG4gICAgQGxvY2F0aW9uRGF0YSA9IHN0cmluZ0xpdGVyYWwubG9jYXRpb25EYXRhXG5cbiAgYXN0UHJvcGVydGllczogLT5cbiAgICByZXR1cm4ge1xuICAgICAgQHZhbHVlXG4gICAgICBleHRyYTpcbiAgICAgICAgcmF3OiBAdmFsdWVcbiAgICB9XG5cbmV4cG9ydHMuSlNYQXR0cmlidXRlID0gY2xhc3MgSlNYQXR0cmlidXRlIGV4dGVuZHMgQmFzZVxuICBjb25zdHJ1Y3RvcjogKHtAbmFtZSwgdmFsdWV9KSAtPlxuICAgIHN1cGVyKClcbiAgICBAdmFsdWUgPVxuICAgICAgaWYgdmFsdWU/XG4gICAgICAgIHZhbHVlID0gdmFsdWUuYmFzZVxuICAgICAgICBpZiB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZ0xpdGVyYWwgYW5kIG5vdCB2YWx1ZS5zaG91bGRHZW5lcmF0ZVRlbXBsYXRlTGl0ZXJhbCgpXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG5ldyBKU1hFeHByZXNzaW9uQ29udGFpbmVyIHZhbHVlXG4gICAgICBlbHNlXG4gICAgICAgIG51bGxcbiAgICBAdmFsdWU/LmNvbW1lbnRzID0gdmFsdWUuY29tbWVudHNcblxuICBjaGlsZHJlbjogWyduYW1lJywgJ3ZhbHVlJ11cblxuICBjb21waWxlTm9kZTogKG8pIC0+XG4gICAgY29tcGlsZWROYW1lID0gQG5hbWUuY29tcGlsZVRvRnJhZ21lbnRzIG8sIExFVkVMX0xJU1RcbiAgICByZXR1cm4gY29tcGlsZWROYW1lIHVubGVzcyBAdmFsdWU/XG4gICAgdmFsID0gQHZhbHVlLmNvbXBpbGVUb0ZyYWdtZW50cyBvLCBMRVZFTF9MSVNUXG4gICAgY29tcGlsZWROYW1lLmNvbmNhdCBAbWFrZUNvZGUoJz0nKSwgdmFsXG5cbiAgYXN0UHJvcGVydGllczogKG8pIC0+XG4gICAgbmFtZSA9IEBuYW1lXG4gICAgaWYgJzonIGluIG5hbWUudmFsdWVcbiAgICAgIG5hbWUgPSBuZXcgSlNYTmFtZXNwYWNlZE5hbWUgbmFtZVxuICAgIHJldHVyblxuICAgICAgbmFtZTogbmFtZS5hc3Qgb1xuICAgICAgdmFsdWU6IEB2YWx1ZT8uYXN0KG8pID8gbnVsbFxuXG5leHBvcnRzLkpTWEF0dHJpYnV0ZXMgPSBjbGFzcyBKU1hBdHRyaWJ1dGVzIGV4dGVuZHMgQmFzZVxuICBjb25zdHJ1Y3RvcjogKGFycikgLT5cbiAgICBzdXBlcigpXG4gICAgQGF0dHJpYnV0ZXMgPSBbXVxuICAgIGZvciBvYmplY3QgaW4gYXJyLm9iamVjdHNcbiAgICAgIEBjaGVja1ZhbGlkQXR0cmlidXRlIG9iamVjdFxuICAgICAge2Jhc2V9ID0gb2JqZWN0XG4gICAgICBpZiBiYXNlIGluc3RhbmNlb2YgSWRlbnRpZmllckxpdGVyYWxcbiAgICAgICAgIyBhdHRyaWJ1dGUgd2l0aCBubyB2YWx1ZSBlZyBkaXNhYmxlZFxuICAgICAgICBhdHRyaWJ1dGUgPSBuZXcgSlNYQXR0cmlidXRlIG5hbWU6IG5ldyBKU1hJZGVudGlmaWVyKGJhc2UudmFsdWUpLndpdGhMb2NhdGlvbkRhdGFBbmRDb21tZW50c0Zyb20gYmFzZVxuICAgICAgICBhdHRyaWJ1dGUubG9jYXRpb25EYXRhID0gYmFzZS5sb2NhdGlvbkRhdGFcbiAgICAgICAgQGF0dHJpYnV0ZXMucHVzaCBhdHRyaWJ1dGVcbiAgICAgIGVsc2UgaWYgbm90IGJhc2UuZ2VuZXJhdGVkXG4gICAgICAgICMgb2JqZWN0IHNwcmVhZCBhdHRyaWJ1dGUgZWcgey4uLnByb3BzfVxuICAgICAgICBhdHRyaWJ1dGUgPSBiYXNlLnByb3BlcnRpZXNbMF1cbiAgICAgICAgYXR0cmlidXRlLmpzeCA9IHllc1xuICAgICAgICBhdHRyaWJ1dGUubG9jYXRpb25EYXRhID0gYmFzZS5sb2NhdGlvbkRhdGFcbiAgICAgICAgQGF0dHJpYnV0ZXMucHVzaCBhdHRyaWJ1dGVcbiAgICAgIGVsc2VcbiAgICAgICAgIyBPYmogY29udGFpbmluZyBhdHRyaWJ1dGVzIHdpdGggdmFsdWVzIGVnIGE9XCJiXCIgYz17ZH1cbiAgICAgICAgZm9yIHByb3BlcnR5IGluIGJhc2UucHJvcGVydGllc1xuICAgICAgICAgIHt2YXJpYWJsZSwgdmFsdWV9ID0gcHJvcGVydHlcbiAgICAgICAgICBhdHRyaWJ1dGUgPSBuZXcgSlNYQXR0cmlidXRlIHtcbiAgICAgICAgICAgIG5hbWU6IG5ldyBKU1hJZGVudGlmaWVyKHZhcmlhYmxlLmJhc2UudmFsdWUpLndpdGhMb2NhdGlvbkRhdGFBbmRDb21tZW50c0Zyb20gdmFyaWFibGUuYmFzZVxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0cmlidXRlLmxvY2F0aW9uRGF0YSA9IHByb3BlcnR5LmxvY2F0aW9uRGF0YVxuICAgICAgICAgIEBhdHRyaWJ1dGVzLnB1c2ggYXR0cmlidXRlXG4gICAgQGxvY2F0aW9uRGF0YSA9IGFyci5sb2NhdGlvbkRhdGFcblxuICBjaGlsZHJlbjogWydhdHRyaWJ1dGVzJ11cblxuICAjIENhdGNoIGludmFsaWQgYXR0cmlidXRlczogPGRpdiB7YTpcImJcIiwgcHJvcHN9IHtwcm9wc30gXCJ2YWx1ZVwiIC8+XG4gIGNoZWNrVmFsaWRBdHRyaWJ1dGU6IChvYmplY3QpIC0+XG4gICAge2Jhc2U6IGF0dHJpYnV0ZX0gPSBvYmplY3RcbiAgICBwcm9wZXJ0aWVzID0gYXR0cmlidXRlPy5wcm9wZXJ0aWVzIG9yIFtdXG4gICAgaWYgbm90IChhdHRyaWJ1dGUgaW5zdGFuY2VvZiBPYmogb3IgYXR0cmlidXRlIGluc3RhbmNlb2YgSWRlbnRpZmllckxpdGVyYWwpIG9yIChhdHRyaWJ1dGUgaW5zdGFuY2VvZiBPYmogYW5kIG5vdCBhdHRyaWJ1dGUuZ2VuZXJhdGVkIGFuZCAocHJvcGVydGllcy5sZW5ndGggPiAxIG9yIG5vdCAocHJvcGVydGllc1swXSBpbnN0YW5jZW9mIFNwbGF0KSkpXG4gICAgICBvYmplY3QuZXJyb3IgXCJcIlwiXG4gICAgICAgIFVuZXhwZWN0ZWQgdG9rZW4uIEFsbG93ZWQgSlNYIGF0dHJpYnV0ZXMgYXJlOiBpZD1cInZhbFwiLCBzcmM9e3NvdXJjZX0sIHtwcm9wcy4uLn0gb3IgYXR0cmlidXRlLlxuICAgICAgXCJcIlwiXG5cbiAgY29tcGlsZU5vZGU6IChvKSAtPlxuICAgIGZyYWdtZW50cyA9IFtdXG4gICAgZm9yIGF0dHJpYnV0ZSBpbiBAYXR0cmlidXRlc1xuICAgICAgZnJhZ21lbnRzLnB1c2ggQG1ha2VDb2RlICcgJ1xuICAgICAgZnJhZ21lbnRzLnB1c2ggYXR0cmlidXRlLmNvbXBpbGVUb0ZyYWdtZW50cyhvLCBMRVZFTF9UT1ApLi4uXG4gICAgZnJhZ21lbnRzXG5cbiAgYXN0Tm9kZTogKG8pIC0+XG4gICAgYXR0cmlidXRlLmFzdChvKSBmb3IgYXR0cmlidXRlIGluIEBhdHRyaWJ1dGVzXG5cbmV4cG9ydHMuSlNYTmFtZXNwYWNlZE5hbWUgPSBjbGFzcyBKU1hOYW1lc3BhY2VkTmFtZSBleHRlbmRzIEJhc2VcbiAgY29uc3RydWN0b3I6ICh0YWcpIC0+XG4gICAgc3VwZXIoKVxuICAgIFtuYW1lc3BhY2UsIG5hbWVdID0gdGFnLnZhbHVlLnNwbGl0ICc6J1xuICAgIEBuYW1lc3BhY2UgPSBuZXcgSlNYSWRlbnRpZmllcihuYW1lc3BhY2UpLndpdGhMb2NhdGlvbkRhdGFGcm9tIGxvY2F0aW9uRGF0YTogZXh0cmFjdFNhbWVMaW5lTG9jYXRpb25EYXRhRmlyc3QobmFtZXNwYWNlLmxlbmd0aCkgdGFnLmxvY2F0aW9uRGF0YVxuICAgIEBuYW1lICAgICAgPSBuZXcgSlNYSWRlbnRpZmllcihuYW1lICAgICApLndpdGhMb2NhdGlvbkRhdGFGcm9tIGxvY2F0aW9uRGF0YTogZXh0cmFjdFNhbWVMaW5lTG9jYXRpb25EYXRhTGFzdChuYW1lLmxlbmd0aCAgICAgICkgdGFnLmxvY2F0aW9uRGF0YVxuICAgIEBsb2NhdGlvbkRhdGEgPSB0YWcubG9jYXRpb25EYXRhXG5cbiAgY2hpbGRyZW46IFsnbmFtZXNwYWNlJywgJ25hbWUnXVxuXG4gIGFzdFByb3BlcnRpZXM6IChvKSAtPlxuICAgIHJldHVyblxuICAgICAgbmFtZXNwYWNlOiBAbmFtZXNwYWNlLmFzdCBvXG4gICAgICBuYW1lOiBAbmFtZS5hc3Qgb1xuXG4jIE5vZGUgZm9yIGEgSlNYIGVsZW1lbnRcbmV4cG9ydHMuSlNYRWxlbWVudCA9IGNsYXNzIEpTWEVsZW1lbnQgZXh0ZW5kcyBCYXNlXG4gIGNvbnN0cnVjdG9yOiAoe0B0YWdOYW1lLCBAYXR0cmlidXRlcywgQGNvbnRlbnR9KSAtPlxuICAgIHN1cGVyKClcblxuICBjaGlsZHJlbjogWyd0YWdOYW1lJywgJ2F0dHJpYnV0ZXMnLCAnY29udGVudCddXG5cbiAgY29tcGlsZU5vZGU6IChvKSAtPlxuICAgIEBjb250ZW50Py5iYXNlLmpzeCA9IHllc1xuICAgIGZyYWdtZW50cyA9IFtAbWFrZUNvZGUoJzwnKV1cbiAgICBmcmFnbWVudHMucHVzaCAodGFnID0gQHRhZ05hbWUuY29tcGlsZVRvRnJhZ21lbnRzKG8sIExFVkVMX0FDQ0VTUykpLi4uXG4gICAgZnJhZ21lbnRzLnB1c2ggQGF0dHJpYnV0ZXMuY29tcGlsZVRvRnJhZ21lbnRzKG8pLi4uXG4gICAgaWYgQGNvbnRlbnRcbiAgICAgIGZyYWdtZW50cy5wdXNoIEBtYWtlQ29kZSgnPicpXG4gICAgICBmcmFnbWVudHMucHVzaCBAY29udGVudC5jb21waWxlTm9kZShvLCBMRVZFTF9MSVNUKS4uLlxuICAgICAgZnJhZ21lbnRzLnB1c2ggW0BtYWtlQ29kZSgnPC8nKSwgdGFnLi4uLCBAbWFrZUNvZGUoJz4nKV0uLi5cbiAgICBlbHNlXG4gICAgICBmcmFnbWVudHMucHVzaCBAbWFrZUNvZGUoJyAvPicpXG4gICAgZnJhZ21lbnRzXG5cbiAgaXNGcmFnbWVudDogLT5cbiAgICAhQHRhZ05hbWUuYmFzZS52YWx1ZS5sZW5ndGhcblxuICBhc3ROb2RlOiAobykgLT5cbiAgICAjIFRoZSBsb2NhdGlvbiBkYXRhIHNwYW5uaW5nIHRoZSBvcGVuaW5nIGVsZW1lbnQgPCAuLi4gPiBpcyBjYXB0dXJlZCBieVxuICAgICMgdGhlIGdlbmVyYXRlZCBBcnIgd2hpY2ggY29udGFpbnMgdGhlIGVsZW1lbnQncyBhdHRyaWJ1dGVzXG4gICAgQG9wZW5pbmdFbGVtZW50TG9jYXRpb25EYXRhID0gamlzb25Mb2NhdGlvbkRhdGFUb0FzdExvY2F0aW9uRGF0YSBAYXR0cmlidXRlcy5sb2NhdGlvbkRhdGFcblxuICAgIHRhZ05hbWUgPSBAdGFnTmFtZS5iYXNlXG4gICAgdGFnTmFtZS5sb2NhdGlvbkRhdGEgPSB0YWdOYW1lLnRhZ05hbWVMb2NhdGlvbkRhdGFcbiAgICBpZiBAY29udGVudD9cbiAgICAgIEBjbG9zaW5nRWxlbWVudExvY2F0aW9uRGF0YSA9IG1lcmdlQXN0TG9jYXRpb25EYXRhKFxuICAgICAgICBqaXNvbkxvY2F0aW9uRGF0YVRvQXN0TG9jYXRpb25EYXRhIHRhZ05hbWUuY2xvc2luZ1RhZ09wZW5pbmdCcmFja2V0TG9jYXRpb25EYXRhXG4gICAgICAgIGppc29uTG9jYXRpb25EYXRhVG9Bc3RMb2NhdGlvbkRhdGEgdGFnTmFtZS5jbG9zaW5nVGFnQ2xvc2luZ0JyYWNrZXRMb2NhdGlvbkRhdGFcbiAgICAgIClcblxuICAgIHN1cGVyIG9cblxuICBhc3RUeXBlOiAtPlxuICAgIGlmIEBpc0ZyYWdtZW50KClcbiAgICAgICdKU1hGcmFnbWVudCdcbiAgICBlbHNlXG4gICAgICAnSlNYRWxlbWVudCdcblxuICBlbGVtZW50QXN0UHJvcGVydGllczogKG8pIC0+XG4gICAgdGFnTmFtZUFzdCA9ID0+XG4gICAgICB0YWcgPSBAdGFnTmFtZS51bndyYXAoKVxuICAgICAgaWYgdGFnPy52YWx1ZSBhbmQgJzonIGluIHRhZy52YWx1ZVxuICAgICAgICB0YWcgPSBuZXcgSlNYTmFtZXNwYWNlZE5hbWUgdGFnXG4gICAgICB0YWcuYXN0IG9cblxuICAgIG9wZW5pbmdFbGVtZW50ID0gT2JqZWN0LmFzc2lnbiB7XG4gICAgICB0eXBlOiAnSlNYT3BlbmluZ0VsZW1lbnQnXG4gICAgICBuYW1lOiB0YWdOYW1lQXN0KClcbiAgICAgIHNlbGZDbG9zaW5nOiBub3QgQGNsb3NpbmdFbGVtZW50TG9jYXRpb25EYXRhP1xuICAgICAgYXR0cmlidXRlczogQGF0dHJpYnV0ZXMuYXN0IG9cbiAgICB9LCBAb3BlbmluZ0VsZW1lbnRMb2NhdGlvbkRhdGFcblxuICAgIGNsb3NpbmdFbGVtZW50ID0gbnVsbFxuICAgIGlmIEBjbG9zaW5nRWxlbWVudExvY2F0aW9uRGF0YT9cbiAgICAgIGNsb3NpbmdFbGVtZW50ID0gT2JqZWN0LmFzc2lnbiB7XG4gICAgICAgIHR5cGU6ICdKU1hDbG9zaW5nRWxlbWVudCdcbiAgICAgICAgbmFtZTogT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB0YWdOYW1lQXN0KCksXG4gICAgICAgICAgamlzb25Mb2NhdGlvbkRhdGFUb0FzdExvY2F0aW9uRGF0YSBAdGFnTmFtZS5iYXNlLmNsb3NpbmdUYWdOYW1lTG9jYXRpb25EYXRhXG4gICAgICAgIClcbiAgICAgIH0sIEBjbG9zaW5nRWxlbWVudExvY2F0aW9uRGF0YVxuICAgICAgaWYgY2xvc2luZ0VsZW1lbnQubmFtZS50eXBlIGluIFsnSlNYTWVtYmVyRXhwcmVzc2lvbicsICdKU1hOYW1lc3BhY2VkTmFtZSddXG4gICAgICAgIHJhbmdlRGlmZiA9IGNsb3NpbmdFbGVtZW50LnJhbmdlWzBdIC0gb3BlbmluZ0VsZW1lbnQucmFuZ2VbMF0gKyAnLycubGVuZ3RoXG4gICAgICAgIGNvbHVtbkRpZmYgPSBjbG9zaW5nRWxlbWVudC5sb2Muc3RhcnQuY29sdW1uIC0gb3BlbmluZ0VsZW1lbnQubG9jLnN0YXJ0LmNvbHVtbiArICcvJy5sZW5ndGhcbiAgICAgICAgc2hpZnRBc3RMb2NhdGlvbkRhdGEgPSAobm9kZSkgPT5cbiAgICAgICAgICBub2RlLnJhbmdlID0gW1xuICAgICAgICAgICAgbm9kZS5yYW5nZVswXSArIHJhbmdlRGlmZlxuICAgICAgICAgICAgbm9kZS5yYW5nZVsxXSArIHJhbmdlRGlmZlxuICAgICAgICAgIF1cbiAgICAgICAgICBub2RlLnN0YXJ0ICs9IHJhbmdlRGlmZlxuICAgICAgICAgIG5vZGUuZW5kICs9IHJhbmdlRGlmZlxuICAgICAgICAgIG5vZGUubG9jLnN0YXJ0ID1cbiAgICAgICAgICAgIGxpbmU6IEBjbG9zaW5nRWxlbWVudExvY2F0aW9uRGF0YS5sb2Muc3RhcnQubGluZVxuICAgICAgICAgICAgY29sdW1uOiBub2RlLmxvYy5zdGFydC5jb2x1bW4gKyBjb2x1bW5EaWZmXG4gICAgICAgICAgbm9kZS5sb2MuZW5kID1cbiAgICAgICAgICAgIGxpbmU6IEBjbG9zaW5nRWxlbWVudExvY2F0aW9uRGF0YS5sb2Muc3RhcnQubGluZVxuICAgICAgICAgICAgY29sdW1uOiBub2RlLmxvYy5lbmQuY29sdW1uICsgY29sdW1uRGlmZlxuICAgICAgICBpZiBjbG9zaW5nRWxlbWVudC5uYW1lLnR5cGUgaXMgJ0pTWE1lbWJlckV4cHJlc3Npb24nXG4gICAgICAgICAgY3VycmVudEV4cHIgPSBjbG9zaW5nRWxlbWVudC5uYW1lXG4gICAgICAgICAgd2hpbGUgY3VycmVudEV4cHIudHlwZSBpcyAnSlNYTWVtYmVyRXhwcmVzc2lvbidcbiAgICAgICAgICAgIHNoaWZ0QXN0TG9jYXRpb25EYXRhIGN1cnJlbnRFeHByIHVubGVzcyBjdXJyZW50RXhwciBpcyBjbG9zaW5nRWxlbWVudC5uYW1lXG4gICAgICAgICAgICBzaGlmdEFzdExvY2F0aW9uRGF0YSBjdXJyZW50RXhwci5wcm9wZXJ0eVxuICAgICAgICAgICAgY3VycmVudEV4cHIgPSBjdXJyZW50RXhwci5vYmplY3RcbiAgICAgICAgICBzaGlmdEFzdExvY2F0aW9uRGF0YSBjdXJyZW50RXhwclxuICAgICAgICBlbHNlICMgSlNYTmFtZXNwYWNlZE5hbWVcbiAgICAgICAgICBzaGlmdEFzdExvY2F0aW9uRGF0YSBjbG9zaW5nRWxlbWVudC5uYW1lLm5hbWVzcGFjZVxuICAgICAgICAgIHNoaWZ0QXN0TG9jYXRpb25EYXRhIGNsb3NpbmdFbGVtZW50Lm5hbWUubmFtZVxuXG4gICAge29wZW5pbmdFbGVtZW50LCBjbG9zaW5nRWxlbWVudH1cblxuICBmcmFnbWVudEFzdFByb3BlcnRpZXM6IChvKSAtPlxuICAgIG9wZW5pbmdGcmFnbWVudCA9IE9iamVjdC5hc3NpZ24ge1xuICAgICAgdHlwZTogJ0pTWE9wZW5pbmdGcmFnbWVudCdcbiAgICB9LCBAb3BlbmluZ0VsZW1lbnRMb2NhdGlvbkRhdGFcblxuICAgIGNsb3NpbmdGcmFnbWVudCA9IE9iamVjdC5hc3NpZ24ge1xuICAgICAgdHlwZTogJ0pTWENsb3NpbmdGcmFnbWVudCdcbiAgICB9LCBAY2xvc2luZ0VsZW1lbnRMb2NhdGlvbkRhdGFcblxuICAgIHtvcGVuaW5nRnJhZ21lbnQsIGNsb3NpbmdGcmFnbWVudH1cblxuICBjb250ZW50QXN0OiAobykgLT5cbiAgICByZXR1cm4gW10gdW5sZXNzIEBjb250ZW50IGFuZCBub3QgQGNvbnRlbnQuYmFzZS5pc0VtcHR5PygpXG5cbiAgICBjb250ZW50ID0gQGNvbnRlbnQudW53cmFwQWxsKClcbiAgICBjaGlsZHJlbiA9XG4gICAgICBpZiBjb250ZW50IGluc3RhbmNlb2YgU3RyaW5nTGl0ZXJhbFxuICAgICAgICBbbmV3IEpTWFRleHQgY29udGVudF1cbiAgICAgIGVsc2UgIyBTdHJpbmdXaXRoSW50ZXJwb2xhdGlvbnNcbiAgICAgICAgZm9yIGVsZW1lbnQgaW4gQGNvbnRlbnQudW53cmFwQWxsKCkuZXh0cmFjdEVsZW1lbnRzIG8sIGluY2x1ZGVJbnRlcnBvbGF0aW9uV3JhcHBlcnM6IHllcywgaXNKc3g6IHllc1xuICAgICAgICAgIGlmIGVsZW1lbnQgaW5zdGFuY2VvZiBTdHJpbmdMaXRlcmFsXG4gICAgICAgICAgICBuZXcgSlNYVGV4dCBlbGVtZW50XG4gICAgICAgICAgZWxzZSAjIEludGVycG9sYXRpb25cbiAgICAgICAgICAgIHtleHByZXNzaW9ufSA9IGVsZW1lbnRcbiAgICAgICAgICAgIHVubGVzcyBleHByZXNzaW9uP1xuICAgICAgICAgICAgICBlbXB0eUV4cHJlc3Npb24gPSBuZXcgSlNYRW1wdHlFeHByZXNzaW9uKClcbiAgICAgICAgICAgICAgZW1wdHlFeHByZXNzaW9uLmxvY2F0aW9uRGF0YSA9IGVtcHR5RXhwcmVzc2lvbkxvY2F0aW9uRGF0YSB7XG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbk5vZGU6IGVsZW1lbnRcbiAgICAgICAgICAgICAgICBvcGVuaW5nQnJhY2U6ICd7J1xuICAgICAgICAgICAgICAgIGNsb3NpbmdCcmFjZTogJ30nXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBuZXcgSlNYRXhwcmVzc2lvbkNvbnRhaW5lciBlbXB0eUV4cHJlc3Npb24sIGxvY2F0aW9uRGF0YTogZWxlbWVudC5sb2NhdGlvbkRhdGFcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgdW53cmFwcGVkID0gZXhwcmVzc2lvbi51bndyYXBBbGwoKVxuICAgICAgICAgICAgICBpZiB1bndyYXBwZWQgaW5zdGFuY2VvZiBKU1hFbGVtZW50IGFuZFxuICAgICAgICAgICAgICAgICAgIyBkaXN0aW5ndWlzaCBgPGE+PGIgLz48L2E+YCBmcm9tIGA8YT57PGIgLz59PC9hPmBcbiAgICAgICAgICAgICAgICAgIHVud3JhcHBlZC5sb2NhdGlvbkRhdGEucmFuZ2VbMF0gaXMgZWxlbWVudC5sb2NhdGlvbkRhdGEucmFuZ2VbMF1cbiAgICAgICAgICAgICAgICB1bndyYXBwZWRcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5ldyBKU1hFeHByZXNzaW9uQ29udGFpbmVyIHVud3JhcHBlZCwgbG9jYXRpb25EYXRhOiBlbGVtZW50LmxvY2F0aW9uRGF0YVxuXG4gICAgY2hpbGQuYXN0KG8pIGZvciBjaGlsZCBpbiBjaGlsZHJlbiB3aGVuIG5vdCAoY2hpbGQgaW5zdGFuY2VvZiBKU1hUZXh0IGFuZCBjaGlsZC52YWx1ZS5sZW5ndGggaXMgMClcblxuICBhc3RQcm9wZXJ0aWVzOiAobykgLT5cbiAgICBPYmplY3QuYXNzaWduKFxuICAgICAgaWYgQGlzRnJhZ21lbnQoKVxuICAgICAgICBAZnJhZ21lbnRBc3RQcm9wZXJ0aWVzIG9cbiAgICAgIGVsc2VcbiAgICAgICAgQGVsZW1lbnRBc3RQcm9wZXJ0aWVzIG9cbiAgICAsXG4gICAgICBjaGlsZHJlbjogQGNvbnRlbnRBc3Qgb1xuICAgIClcblxuICBhc3RMb2NhdGlvbkRhdGE6IC0+XG4gICAgaWYgQGNsb3NpbmdFbGVtZW50TG9jYXRpb25EYXRhP1xuICAgICAgbWVyZ2VBc3RMb2NhdGlvbkRhdGEgQG9wZW5pbmdFbGVtZW50TG9jYXRpb25EYXRhLCBAY2xvc2luZ0VsZW1lbnRMb2NhdGlvbkRhdGFcbiAgICBlbHNlXG4gICAgICBAb3BlbmluZ0VsZW1lbnRMb2NhdGlvbkRhdGFcblxuIyMjIyBDYWxsXG5cbiMgTm9kZSBmb3IgYSBmdW5jdGlvbiBpbnZvY2F0aW9uLlxuZXhwb3J0cy5DYWxsID0gY2xhc3MgQ2FsbCBleHRlbmRzIEJhc2VcbiAgY29uc3RydWN0b3I6IChAdmFyaWFibGUsIEBhcmdzID0gW10sIEBzb2FrLCBAdG9rZW4pIC0+XG4gICAgc3VwZXIoKVxuXG4gICAgQGltcGxpY2l0ID0gQGFyZ3MuaW1wbGljaXRcbiAgICBAaXNOZXcgPSBub1xuICAgIGlmIEB2YXJpYWJsZSBpbnN0YW5jZW9mIFZhbHVlIGFuZCBAdmFyaWFibGUuaXNOb3RDYWxsYWJsZSgpXG4gICAgICBAdmFyaWFibGUuZXJyb3IgXCJsaXRlcmFsIGlzIG5vdCBhIGZ1bmN0aW9uXCJcblxuICAgIGlmIEB2YXJpYWJsZS5iYXNlIGluc3RhbmNlb2YgSlNYVGFnXG4gICAgICByZXR1cm4gbmV3IEpTWEVsZW1lbnQoXG4gICAgICAgIHRhZ05hbWU6IEB2YXJpYWJsZVxuICAgICAgICBhdHRyaWJ1dGVzOiBuZXcgSlNYQXR0cmlidXRlcyBAYXJnc1swXS5iYXNlXG4gICAgICAgIGNvbnRlbnQ6IEBhcmdzWzFdXG4gICAgICApXG5cbiAgICAjIGBAdmFyaWFibGVgIG5ldmVyIGdldHMgb3V0cHV0IGFzIGEgcmVzdWx0IG9mIHRoaXMgbm9kZSBnZXR0aW5nIGNyZWF0ZWQgYXNcbiAgICAjIHBhcnQgb2YgYFJlZ2V4V2l0aEludGVycG9sYXRpb25zYCwgc28gZm9yIHRoYXQgY2FzZSBtb3ZlIGFueSBjb21tZW50cyB0b1xuICAgICMgdGhlIGBhcmdzYCBwcm9wZXJ0eSB0aGF0IGdldHMgcGFzc2VkIGludG8gYFJlZ2V4V2l0aEludGVycG9sYXRpb25zYCB2aWFcbiAgICAjIHRoZSBncmFtbWFyLlxuICAgIGlmIEB2YXJpYWJsZS5iYXNlPy52YWx1ZSBpcyAnUmVnRXhwJyBhbmQgQGFyZ3MubGVuZ3RoIGlzbnQgMFxuICAgICAgbW92ZUNvbW1lbnRzIEB2YXJpYWJsZSwgQGFyZ3NbMF1cblxuICBjaGlsZHJlbjogWyd2YXJpYWJsZScsICdhcmdzJ11cblxuICAjIFdoZW4gc2V0dGluZyB0aGUgbG9jYXRpb24sIHdlIHNvbWV0aW1lcyBuZWVkIHRvIHVwZGF0ZSB0aGUgc3RhcnQgbG9jYXRpb24gdG9cbiAgIyBhY2NvdW50IGZvciBhIG5ld2x5LWRpc2NvdmVyZWQgYG5ld2Agb3BlcmF0b3IgdG8gdGhlIGxlZnQgb2YgdXMuIFRoaXNcbiAgIyBleHBhbmRzIHRoZSByYW5nZSBvbiB0aGUgbGVmdCwgYnV0IG5vdCB0aGUgcmlnaHQuXG4gIHVwZGF0ZUxvY2F0aW9uRGF0YUlmTWlzc2luZzogKGxvY2F0aW9uRGF0YSkgLT5cbiAgICBpZiBAbG9jYXRpb25EYXRhIGFuZCBAbmVlZHNVcGRhdGVkU3RhcnRMb2NhdGlvblxuICAgICAgQGxvY2F0aW9uRGF0YSA9IE9iamVjdC5hc3NpZ24ge30sXG4gICAgICAgIEBsb2NhdGlvbkRhdGEsXG4gICAgICAgIGZpcnN0X2xpbmU6IGxvY2F0aW9uRGF0YS5maXJzdF9saW5lXG4gICAgICAgIGZpcnN0X2NvbHVtbjogbG9jYXRpb25EYXRhLmZpcnN0X2NvbHVtblxuICAgICAgICByYW5nZTogW1xuICAgICAgICAgIGxvY2F0aW9uRGF0YS5yYW5nZVswXVxuICAgICAgICAgIEBsb2NhdGlvbkRhdGEucmFuZ2VbMV1cbiAgICAgICAgXVxuICAgICAgYmFzZSA9IEB2YXJpYWJsZT8uYmFzZSBvciBAdmFyaWFibGVcbiAgICAgIGlmIGJhc2UubmVlZHNVcGRhdGVkU3RhcnRMb2NhdGlvblxuICAgICAgICBAdmFyaWFibGUubG9jYXRpb25EYXRhID0gT2JqZWN0LmFzc2lnbiB7fSxcbiAgICAgICAgICBAdmFyaWFibGUubG9jYXRpb25EYXRhLFxuICAgICAgICAgIGZpcnN0X2xpbmU6IGxvY2F0aW9uRGF0YS5maXJzdF9saW5lXG4gICAgICAgICAgZmlyc3RfY29sdW1uOiBsb2NhdGlvbkRhdGEuZmlyc3RfY29sdW1uXG4gICAgICAgICAgcmFuZ2U6IFtcbiAgICAgICAgICAgIGxvY2F0aW9uRGF0YS5yYW5nZVswXVxuICAgICAgICAgICAgQHZhcmlhYmxlLmxvY2F0aW9uRGF0YS5yYW5nZVsxXVxuICAgICAgICAgIF1cbiAgICAgICAgYmFzZS51cGRhdGVMb2NhdGlvbkRhdGFJZk1pc3NpbmcgbG9jYXRpb25EYXRhXG4gICAgICBkZWxldGUgQG5lZWRzVXBkYXRlZFN0YXJ0TG9jYXRpb25cbiAgICBzdXBlciBsb2NhdGlvbkRhdGFcblxuICAjIFRhZyB0aGlzIGludm9jYXRpb24gYXMgY3JlYXRpbmcgYSBuZXcgaW5zdGFuY2UuXG4gIG5ld0luc3RhbmNlOiAtPlxuICAgIGJhc2UgPSBAdmFyaWFibGU/LmJhc2Ugb3IgQHZhcmlhYmxlXG4gICAgaWYgYmFzZSBpbnN0YW5jZW9mIENhbGwgYW5kIG5vdCBiYXNlLmlzTmV3XG4gICAgICBiYXNlLm5ld0luc3RhbmNlKClcbiAgICBlbHNlXG4gICAgICBAaXNOZXcgPSB0cnVlXG4gICAgQG5lZWRzVXBkYXRlZFN0YXJ0TG9jYXRpb24gPSB0cnVlXG4gICAgdGhpc1xuXG4gICMgU29ha2VkIGNoYWluZWQgaW52b2NhdGlvbnMgdW5mb2xkIGludG8gaWYvZWxzZSB0ZXJuYXJ5IHN0cnVjdHVyZXMuXG4gIHVuZm9sZFNvYWs6IChvKSAtPlxuICAgIGlmIEBzb2FrXG4gICAgICBpZiBAdmFyaWFibGUgaW5zdGFuY2VvZiBTdXBlclxuICAgICAgICBsZWZ0ID0gbmV3IExpdGVyYWwgQHZhcmlhYmxlLmNvbXBpbGUgb1xuICAgICAgICByaXRlID0gbmV3IFZhbHVlIGxlZnRcbiAgICAgICAgQHZhcmlhYmxlLmVycm9yIFwiVW5zdXBwb3J0ZWQgcmVmZXJlbmNlIHRvICdzdXBlcidcIiB1bmxlc3MgQHZhcmlhYmxlLmFjY2Vzc29yP1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gaWZuIGlmIGlmbiA9IHVuZm9sZFNvYWsgbywgdGhpcywgJ3ZhcmlhYmxlJ1xuICAgICAgICBbbGVmdCwgcml0ZV0gPSBuZXcgVmFsdWUoQHZhcmlhYmxlKS5jYWNoZVJlZmVyZW5jZSBvXG4gICAgICByaXRlID0gbmV3IENhbGwgcml0ZSwgQGFyZ3NcbiAgICAgIHJpdGUuaXNOZXcgPSBAaXNOZXdcbiAgICAgIGxlZnQgPSBuZXcgTGl0ZXJhbCBcInR5cGVvZiAjeyBsZWZ0LmNvbXBpbGUgbyB9ID09PSBcXFwiZnVuY3Rpb25cXFwiXCJcbiAgICAgIHJldHVybiBuZXcgSWYgbGVmdCwgbmV3IFZhbHVlKHJpdGUpLCBzb2FrOiB5ZXNcbiAgICBjYWxsID0gdGhpc1xuICAgIGxpc3QgPSBbXVxuICAgIGxvb3BcbiAgICAgIGlmIGNhbGwudmFyaWFibGUgaW5zdGFuY2VvZiBDYWxsXG4gICAgICAgIGxpc3QucHVzaCBjYWxsXG4gICAgICAgIGNhbGwgPSBjYWxsLnZhcmlhYmxlXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICBicmVhayB1bmxlc3MgY2FsbC52YXJpYWJsZSBpbnN0YW5jZW9mIFZhbHVlXG4gICAgICBsaXN0LnB1c2ggY2FsbFxuICAgICAgYnJlYWsgdW5sZXNzIChjYWxsID0gY2FsbC52YXJpYWJsZS5iYXNlKSBpbnN0YW5jZW9mIENhbGxcbiAgICBmb3IgY2FsbCBpbiBsaXN0LnJldmVyc2UoKVxuICAgICAgaWYgaWZuXG4gICAgICAgIGlmIGNhbGwudmFyaWFibGUgaW5zdGFuY2VvZiBDYWxsXG4gICAgICAgICAgY2FsbC52YXJpYWJsZSA9IGlmblxuICAgICAgICBlbHNlXG4gICAgICAgICAgY2FsbC52YXJpYWJsZS5iYXNlID0gaWZuXG4gICAgICBpZm4gPSB1bmZvbGRTb2FrIG8sIGNhbGwsICd2YXJpYWJsZSdcbiAgICBpZm5cblxuICAjIENvbXBpbGUgYSB2YW5pbGxhIGZ1bmN0aW9uIGNhbGwuXG4gIGNvbXBpbGVOb2RlOiAobykgLT5cbiAgICBAY2hlY2tGb3JOZXdTdXBlcigpXG4gICAgQHZhcmlhYmxlPy5mcm9udCA9IEBmcm9udFxuICAgIGNvbXBpbGVkQXJncyA9IFtdXG4gICAgIyBJZiB2YXJpYWJsZSBpcyBgQWNjZXNzb3JgIGZyYWdtZW50cyBhcmUgY2FjaGVkIGFuZCB1c2VkIGxhdGVyXG4gICAgIyBpbiBgVmFsdWU6OmNvbXBpbGVOb2RlYCB0byBlbnN1cmUgY29ycmVjdCBvcmRlciBvZiB0aGUgY29tcGlsYXRpb24sXG4gICAgIyBhbmQgcmV1c2Ugb2YgdmFyaWFibGVzIGluIHRoZSBzY29wZS5cbiAgICAjIEV4YW1wbGU6XG4gICAgIyBgYSh4ID0gNSkuYigtPiB4ID0gNilgIHNob3VsZCBjb21waWxlIGluIHRoZSBzYW1lIG9yZGVyIGFzXG4gICAgIyBgYSh4ID0gNSk7IGIoLT4geCA9IDYpYFxuICAgICMgKHNlZSBpc3N1ZSAjNDQzNywgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy9jb2ZmZWVzY3JpcHQvaXNzdWVzLzQ0MzcpXG4gICAgdmFyQWNjZXNzID0gQHZhcmlhYmxlPy5wcm9wZXJ0aWVzP1swXSBpbnN0YW5jZW9mIEFjY2Vzc1xuICAgIGFyZ0NvZGUgPSAoYXJnIGZvciBhcmcgaW4gKEBhcmdzIHx8IFtdKSB3aGVuIGFyZyBpbnN0YW5jZW9mIENvZGUpXG4gICAgaWYgYXJnQ29kZS5sZW5ndGggPiAwIGFuZCB2YXJBY2Nlc3MgYW5kIG5vdCBAdmFyaWFibGUuYmFzZS5jYWNoZWRcbiAgICAgIFtjYWNoZV0gPSBAdmFyaWFibGUuYmFzZS5jYWNoZSBvLCBMRVZFTF9BQ0NFU1MsIC0+IG5vXG4gICAgICBAdmFyaWFibGUuYmFzZS5jYWNoZWQgPSBjYWNoZVxuXG4gICAgZm9yIGFyZywgYXJnSW5kZXggaW4gQGFyZ3NcbiAgICAgIGlmIGFyZ0luZGV4IHRoZW4gY29tcGlsZWRBcmdzLnB1c2ggQG1ha2VDb2RlIFwiLCBcIlxuICAgICAgY29tcGlsZWRBcmdzLnB1c2ggKGFyZy5jb21waWxlVG9GcmFnbWVudHMgbywgTEVWRUxfTElTVCkuLi5cblxuICAgIGZyYWdtZW50cyA9IFtdXG4gICAgaWYgQGlzTmV3XG4gICAgICBmcmFnbWVudHMucHVzaCBAbWFrZUNvZGUgJ25ldyAnXG4gICAgZnJhZ21lbnRzLnB1c2ggQHZhcmlhYmxlLmNvbXBpbGVUb0ZyYWdtZW50cyhvLCBMRVZFTF9BQ0NFU1MpLi4uXG4gICAgZnJhZ21lbnRzLnB1c2ggQG1ha2VDb2RlKCcoJyksIGNvbXBpbGVkQXJncy4uLiwgQG1ha2VDb2RlKCcpJylcbiAgICBmcmFnbWVudHNcblxuICBjaGVja0Zvck5ld1N1cGVyOiAtPlxuICAgIGlmIEBpc05ld1xuICAgICAgQHZhcmlhYmxlLmVycm9yIFwiVW5zdXBwb3J0ZWQgcmVmZXJlbmNlIHRvICdzdXBlcidcIiBpZiBAdmFyaWFibGUgaW5zdGFuY2VvZiBTdXBlclxuXG4gIGNvbnRhaW5zU29hazogLT5cbiAgICByZXR1cm4geWVzIGlmIEBzb2FrXG4gICAgcmV0dXJuIHllcyBpZiBAdmFyaWFibGU/LmNvbnRhaW5zU29haz8oKVxuICAgIG5vXG5cbiAgYXN0Tm9kZTogKG8pIC0+XG4gICAgaWYgQHNvYWsgYW5kIEB2YXJpYWJsZSBpbnN0YW5jZW9mIFN1cGVyIGFuZCBvLnNjb3BlLm5hbWVkTWV0aG9kKCk/LmN0b3JcbiAgICAgIEB2YXJpYWJsZS5lcnJvciBcIlVuc3VwcG9ydGVkIHJlZmVyZW5jZSB0byAnc3VwZXInXCJcbiAgICBAY2hlY2tGb3JOZXdTdXBlcigpXG4gICAgc3VwZXIgb1xuXG4gIGFzdFR5cGU6IC0+XG4gICAgaWYgQGlzTmV3XG4gICAgICAnTmV3RXhwcmVzc2lvbidcbiAgICBlbHNlIGlmIEBjb250YWluc1NvYWsoKVxuICAgICAgJ09wdGlvbmFsQ2FsbEV4cHJlc3Npb24nXG4gICAgZWxzZVxuICAgICAgJ0NhbGxFeHByZXNzaW9uJ1xuXG4gIGFzdFByb3BlcnRpZXM6IChvKSAtPlxuICAgIHJldHVyblxuICAgICAgY2FsbGVlOiBAdmFyaWFibGUuYXN0IG8sIExFVkVMX0FDQ0VTU1xuICAgICAgYXJndW1lbnRzOiBhcmcuYXN0KG8sIExFVkVMX0xJU1QpIGZvciBhcmcgaW4gQGFyZ3NcbiAgICAgIG9wdGlvbmFsOiAhIUBzb2FrXG4gICAgICBpbXBsaWNpdDogISFAaW1wbGljaXRcblxuIyMjIyBTdXBlclxuXG4jIFRha2VzIGNhcmUgb2YgY29udmVydGluZyBgc3VwZXIoKWAgY2FsbHMgaW50byBjYWxscyBhZ2FpbnN0IHRoZSBwcm90b3R5cGUnc1xuIyBmdW5jdGlvbiBvZiB0aGUgc2FtZSBuYW1lLlxuIyBXaGVuIGBleHByZXNzaW9uc2AgYXJlIHNldCB0aGUgY2FsbCB3aWxsIGJlIGNvbXBpbGVkIGluIHN1Y2ggYSB3YXkgdGhhdCB0aGVcbiMgZXhwcmVzc2lvbnMgYXJlIGV2YWx1YXRlZCB3aXRob3V0IGFsdGVyaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGBTdXBlckNhbGxgXG4jIGV4cHJlc3Npb24uXG5leHBvcnRzLlN1cGVyQ2FsbCA9IGNsYXNzIFN1cGVyQ2FsbCBleHRlbmRzIENhbGxcbiAgY2hpbGRyZW46IENhbGw6OmNoaWxkcmVuLmNvbmNhdCBbJ2V4cHJlc3Npb25zJ11cblxuICBpc1N0YXRlbWVudDogKG8pIC0+XG4gICAgQGV4cHJlc3Npb25zPy5sZW5ndGggYW5kIG8ubGV2ZWwgaXMgTEVWRUxfVE9QXG5cbiAgY29tcGlsZU5vZGU6IChvKSAtPlxuICAgIHJldHVybiBzdXBlciBvIHVubGVzcyBAZXhwcmVzc2lvbnM/Lmxlbmd0aFxuXG4gICAgc3VwZXJDYWxsICAgPSBuZXcgTGl0ZXJhbCBmcmFnbWVudHNUb1RleHQgc3VwZXIgb1xuICAgIHJlcGxhY2VtZW50ID0gbmV3IEJsb2NrIEBleHByZXNzaW9ucy5zbGljZSgpXG5cbiAgICBpZiBvLmxldmVsID4gTEVWRUxfVE9QXG4gICAgICAjIElmIHdlIG1pZ2h0IGJlIGluIGFuIGV4cHJlc3Npb24gd2UgbmVlZCB0byBjYWNoZSBhbmQgcmV0dXJuIHRoZSByZXN1bHRcbiAgICAgIFtzdXBlckNhbGwsIHJlZl0gPSBzdXBlckNhbGwuY2FjaGUgbywgbnVsbCwgWUVTXG4gICAgICByZXBsYWNlbWVudC5wdXNoIHJlZlxuXG4gICAgcmVwbGFjZW1lbnQudW5zaGlmdCBzdXBlckNhbGxcbiAgICByZXBsYWNlbWVudC5jb21waWxlVG9GcmFnbWVudHMgbywgaWYgby5sZXZlbCBpcyBMRVZFTF9UT1AgdGhlbiBvLmxldmVsIGVsc2UgTEVWRUxfTElTVFxuXG5leHBvcnRzLlN1cGVyID0gY2xhc3MgU3VwZXIgZXh0ZW5kcyBCYXNlXG4gIGNvbnN0cnVjdG9yOiAoQGFjY2Vzc29yLCBAc3VwZXJMaXRlcmFsKSAtPlxuICAgIHN1cGVyKClcblxuICBjaGlsZHJlbjogWydhY2Nlc3NvciddXG5cbiAgY29tcGlsZU5vZGU6IChvKSAtPlxuICAgIEBjaGVja0luSW5zdGFuY2VNZXRob2Qgb1xuXG4gICAgbWV0aG9kID0gby5zY29wZS5uYW1lZE1ldGhvZCgpXG4gICAgdW5sZXNzIG1ldGhvZC5jdG9yPyBvciBAYWNjZXNzb3I/XG4gICAgICB7bmFtZSwgdmFyaWFibGV9ID0gbWV0aG9kXG4gICAgICBpZiBuYW1lLnNob3VsZENhY2hlKCkgb3IgKG5hbWUgaW5zdGFuY2VvZiBJbmRleCBhbmQgbmFtZS5pbmRleC5pc0Fzc2lnbmFibGUoKSlcbiAgICAgICAgbnJlZiA9IG5ldyBJZGVudGlmaWVyTGl0ZXJhbCBvLnNjb3BlLnBhcmVudC5mcmVlVmFyaWFibGUgJ25hbWUnXG4gICAgICAgIG5hbWUuaW5kZXggPSBuZXcgQXNzaWduIG5yZWYsIG5hbWUuaW5kZXhcbiAgICAgIEBhY2Nlc3NvciA9IGlmIG5yZWY/IHRoZW4gbmV3IEluZGV4IG5yZWYgZWxzZSBuYW1lXG5cbiAgICBpZiBAYWNjZXNzb3I/Lm5hbWU/LmNvbW1lbnRzXG4gICAgICAjIEEgYHN1cGVyKClgIGNhbGwgZ2V0cyBjb21waWxlZCB0byBlLmcuIGBzdXBlci5tZXRob2QoKWAsIHdoaWNoIG1lYW5zXG4gICAgICAjIHRoZSBgbWV0aG9kYCBwcm9wZXJ0eSBuYW1lIGdldHMgY29tcGlsZWQgZm9yIHRoZSBmaXJzdCB0aW1lIGhlcmUsIGFuZFxuICAgICAgIyBhZ2FpbiB3aGVuIHRoZSBgbWV0aG9kOmAgcHJvcGVydHkgb2YgdGhlIGNsYXNzIGdldHMgY29tcGlsZWQuIFNpbmNlXG4gICAgICAjIHRoaXMgY29tcGlsYXRpb24gaGFwcGVucyBmaXJzdCwgY29tbWVudHMgYXR0YWNoZWQgdG8gYG1ldGhvZDpgIHdvdWxkXG4gICAgICAjIGdldCBpbmNvcnJlY3RseSBvdXRwdXQgbmVhciBgc3VwZXIubWV0aG9kKClgLCB3aGVuIHdlIHdhbnQgdGhlbSB0b1xuICAgICAgIyBnZXQgb3V0cHV0IG9uIHRoZSBzZWNvbmQgcGFzcyB3aGVuIGBtZXRob2Q6YCBpcyBvdXRwdXQuIFNvIHNldCB0aGVtXG4gICAgICAjIGFzaWRlIGR1cmluZyB0aGlzIGNvbXBpbGF0aW9uIHBhc3MsIGFuZCBwdXQgdGhlbSBiYWNrIG9uIHRoZSBvYmplY3Qgc29cbiAgICAgICMgdGhhdCB0aGV54oCZcmUgdGhlcmUgZm9yIHRoZSBsYXRlciBjb21waWxhdGlvbi5cbiAgICAgIHNhbHZhZ2VkQ29tbWVudHMgPSBAYWNjZXNzb3IubmFtZS5jb21tZW50c1xuICAgICAgZGVsZXRlIEBhY2Nlc3Nvci5uYW1lLmNvbW1lbnRzXG4gICAgZnJhZ21lbnRzID0gKG5ldyBWYWx1ZSAobmV3IExpdGVyYWwgJ3N1cGVyJyksIGlmIEBhY2Nlc3NvciB0aGVuIFsgQGFjY2Vzc29yIF0gZWxzZSBbXSlcbiAgICAuY29tcGlsZVRvRnJhZ21lbnRzIG9cbiAgICBhdHRhY2hDb21tZW50c1RvTm9kZSBzYWx2YWdlZENvbW1lbnRzLCBAYWNjZXNzb3IubmFtZSBpZiBzYWx2YWdlZENvbW1lbnRzXG4gICAgZnJhZ21lbnRzXG5cbiAgY2hlY2tJbkluc3RhbmNlTWV0aG9kOiAobykgLT5cbiAgICBtZXRob2QgPSBvLnNjb3BlLm5hbWVkTWV0aG9kKClcbiAgICBAZXJyb3IgJ2Nhbm5vdCB1c2Ugc3VwZXIgb3V0c2lkZSBvZiBhbiBpbnN0YW5jZSBtZXRob2QnIHVubGVzcyBtZXRob2Q/LmlzTWV0aG9kXG5cbiAgYXN0Tm9kZTogKG8pIC0+XG4gICAgQGNoZWNrSW5JbnN0YW5jZU1ldGhvZCBvXG5cbiAgICBpZiBAYWNjZXNzb3I/XG4gICAgICByZXR1cm4gKFxuICAgICAgICBuZXcgVmFsdWUoXG4gICAgICAgICAgbmV3IFN1cGVyKCkud2l0aExvY2F0aW9uRGF0YUZyb20gKEBzdXBlckxpdGVyYWwgPyBAKVxuICAgICAgICAgIFtAYWNjZXNzb3JdXG4gICAgICAgICkud2l0aExvY2F0aW9uRGF0YUZyb20gQFxuICAgICAgKS5hc3Qgb1xuXG4gICAgc3VwZXIgb1xuXG4jIyMjIFJlZ2V4V2l0aEludGVycG9sYXRpb25zXG5cbiMgUmVnZXhlcyB3aXRoIGludGVycG9sYXRpb25zIGFyZSBpbiBmYWN0IGp1c3QgYSB2YXJpYXRpb24gb2YgYSBgQ2FsbGAgKGFcbiMgYFJlZ0V4cCgpYCBjYWxsIHRvIGJlIHByZWNpc2UpIHdpdGggYSBgU3RyaW5nV2l0aEludGVycG9sYXRpb25zYCBpbnNpZGUuXG5leHBvcnRzLlJlZ2V4V2l0aEludGVycG9sYXRpb25zID0gY2xhc3MgUmVnZXhXaXRoSW50ZXJwb2xhdGlvbnMgZXh0ZW5kcyBCYXNlXG4gIGNvbnN0cnVjdG9yOiAoQGNhbGwsIHtAaGVyZWdleENvbW1lbnRUb2tlbnMgPSBbXX0gPSB7fSkgLT5cbiAgICBzdXBlcigpXG5cbiAgY2hpbGRyZW46IFsnY2FsbCddXG5cbiAgY29tcGlsZU5vZGU6IChvKSAtPlxuICAgIEBjYWxsLmNvbXBpbGVOb2RlIG9cblxuICBhc3RUeXBlOiAtPiAnSW50ZXJwb2xhdGVkUmVnRXhwTGl0ZXJhbCdcblxuICBhc3RQcm9wZXJ0aWVzOiAobykgLT5cbiAgICBpbnRlcnBvbGF0ZWRQYXR0ZXJuOiBAY2FsbC5hcmdzWzBdLmFzdCBvXG4gICAgZmxhZ3M6IEBjYWxsLmFyZ3NbMV0/LnVud3JhcCgpLm9yaWdpbmFsVmFsdWUgPyAnJ1xuICAgIGNvbW1lbnRzOlxuICAgICAgZm9yIGhlcmVnZXhDb21tZW50VG9rZW4gaW4gQGhlcmVnZXhDb21tZW50VG9rZW5zXG4gICAgICAgIGlmIGhlcmVnZXhDb21tZW50VG9rZW4uaGVyZVxuICAgICAgICAgIG5ldyBIZXJlQ29tbWVudChoZXJlZ2V4Q29tbWVudFRva2VuKS5hc3Qgb1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbmV3IExpbmVDb21tZW50KGhlcmVnZXhDb21tZW50VG9rZW4pLmFzdCBvXG5cbiMjIyMgVGFnZ2VkVGVtcGxhdGVDYWxsXG5cbmV4cG9ydHMuVGFnZ2VkVGVtcGxhdGVDYWxsID0gY2xhc3MgVGFnZ2VkVGVtcGxhdGVDYWxsIGV4dGVuZHMgQ2FsbFxuICBjb25zdHJ1Y3RvcjogKHZhcmlhYmxlLCBhcmcsIHNvYWspIC0+XG4gICAgYXJnID0gU3RyaW5nV2l0aEludGVycG9sYXRpb25zLmZyb21TdHJpbmdMaXRlcmFsIGFyZyBpZiBhcmcgaW5zdGFuY2VvZiBTdHJpbmdMaXRlcmFsXG4gICAgc3VwZXIgdmFyaWFibGUsIFsgYXJnIF0sIHNvYWtcblxuICBjb21waWxlTm9kZTogKG8pIC0+XG4gICAgQHZhcmlhYmxlLmNvbXBpbGVUb0ZyYWdtZW50cyhvLCBMRVZFTF9BQ0NFU1MpLmNvbmNhdCBAYXJnc1swXS5jb21waWxlVG9GcmFnbWVudHMobywgTEVWRUxfTElTVClcblxuICBhc3RUeXBlOiAtPiAnVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uJ1xuXG4gIGFzdFByb3BlcnRpZXM6IChvKSAtPlxuICAgIHJldHVyblxuICAgICAgdGFnOiBAdmFyaWFibGUuYXN0IG8sIExFVkVMX0FDQ0VTU1xuICAgICAgcXVhc2k6IEBhcmdzWzBdLmFzdCBvLCBMRVZFTF9MSVNUXG5cbiMjIyMgRXh0ZW5kc1xuXG4jIE5vZGUgdG8gZXh0ZW5kIGFuIG9iamVjdCdzIHByb3RvdHlwZSB3aXRoIGFuIGFuY2VzdG9yIG9iamVjdC5cbiMgQWZ0ZXIgYGdvb2cuaW5oZXJpdHNgIGZyb20gdGhlXG4jIFtDbG9zdXJlIExpYnJhcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1saWJyYXJ5L2Jsb2IvbWFzdGVyL2Nsb3N1cmUvZ29vZy9iYXNlLmpzKS5cbmV4cG9ydHMuRXh0ZW5kcyA9IGNsYXNzIEV4dGVuZHMgZXh0ZW5kcyBCYXNlXG4gIGNvbnN0cnVjdG9yOiAoQGNoaWxkLCBAcGFyZW50KSAtPlxuICAgIHN1cGVyKClcblxuICBjaGlsZHJlbjogWydjaGlsZCcsICdwYXJlbnQnXVxuXG4gICMgSG9va3Mgb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlcidzIHByb3RvdHlwZSBjaGFpbi5cbiAgY29tcGlsZVRvRnJhZ21lbnRzOiAobykgLT5cbiAgICBuZXcgQ2FsbChuZXcgVmFsdWUobmV3IExpdGVyYWwgdXRpbGl0eSAnZXh0ZW5kJywgbyksIFtAY2hpbGQsIEBwYXJlbnRdKS5jb21waWxlVG9GcmFnbWVudHMgb1xuXG4jIyMjIEFjY2Vzc1xuXG4jIEEgYC5gIGFjY2VzcyBpbnRvIGEgcHJvcGVydHkgb2YgYSB2YWx1ZSwgb3IgdGhlIGA6OmAgc2hvcnRoYW5kIGZvclxuIyBhbiBhY2Nlc3MgaW50byB0aGUgb2JqZWN0J3MgcHJvdG90eXBlLlxuZXhwb3J0cy5BY2Nlc3MgPSBjbGFzcyBBY2Nlc3MgZXh0ZW5kcyBCYXNlXG4gIGNvbnN0cnVjdG9yOiAoQG5hbWUsIHtAc29haywgQHNob3J0aGFuZH0gPSB7fSkgLT5cbiAgICBzdXBlcigpXG5cbiAgY2hpbGRyZW46IFsnbmFtZSddXG5cbiAgY29tcGlsZVRvRnJhZ21lbnRzOiAobykgLT5cbiAgICBuYW1lID0gQG5hbWUuY29tcGlsZVRvRnJhZ21lbnRzIG9cbiAgICBub2RlID0gQG5hbWUudW53cmFwKClcbiAgICBpZiBub2RlIGluc3RhbmNlb2YgUHJvcGVydHlOYW1lXG4gICAgICBbQG1ha2VDb2RlKCcuJyksIG5hbWUuLi5dXG4gICAgZWxzZVxuICAgICAgW0BtYWtlQ29kZSgnWycpLCBuYW1lLi4uLCBAbWFrZUNvZGUoJ10nKV1cblxuICBzaG91bGRDYWNoZTogTk9cblxuICBhc3ROb2RlOiAobykgLT5cbiAgICAjIEJhYmVsIGRvZXNu4oCZdCBoYXZlIGFuIEFTVCBub2RlIGZvciBgQWNjZXNzYCwgYnV0IHJhdGhlciBqdXN0IGluY2x1ZGVzXG4gICAgIyB0aGlzIEFjY2VzcyBub2Rl4oCZcyBjaGlsZCBgbmFtZWAgSWRlbnRpZmllciBub2RlIGFzIHRoZSBgcHJvcGVydHlgIG9mXG4gICAgIyB0aGUgYE1lbWJlckV4cHJlc3Npb25gIG5vZGUuXG4gICAgQG5hbWUuYXN0IG9cblxuIyMjIyBJbmRleFxuXG4jIEEgYFsgLi4uIF1gIGluZGV4ZWQgYWNjZXNzIGludG8gYW4gYXJyYXkgb3Igb2JqZWN0LlxuZXhwb3J0cy5JbmRleCA9IGNsYXNzIEluZGV4IGV4dGVuZHMgQmFzZVxuICBjb25zdHJ1Y3RvcjogKEBpbmRleCkgLT5cbiAgICBzdXBlcigpXG5cbiAgY2hpbGRyZW46IFsnaW5kZXgnXVxuXG4gIGNvbXBpbGVUb0ZyYWdtZW50czogKG8pIC0+XG4gICAgW10uY29uY2F0IEBtYWtlQ29kZShcIltcIiksIEBpbmRleC5jb21waWxlVG9GcmFnbWVudHMobywgTEVWRUxfUEFSRU4pLCBAbWFrZUNvZGUoXCJdXCIpXG5cbiAgc2hvdWxkQ2FjaGU6IC0+XG4gICAgQGluZGV4LnNob3VsZENhY2hlKClcblxuICBhc3ROb2RlOiAobykgLT5cbiAgICAjIEJhYmVsIGRvZXNu4oCZdCBoYXZlIGFuIEFTVCBub2RlIGZvciBgSW5kZXhgLCBidXQgcmF0aGVyIGp1c3QgaW5jbHVkZXNcbiAgICAjIHRoaXMgSW5kZXggbm9kZeKAmXMgY2hpbGQgYGluZGV4YCBJZGVudGlmaWVyIG5vZGUgYXMgdGhlIGBwcm9wZXJ0eWAgb2ZcbiAgICAjIHRoZSBgTWVtYmVyRXhwcmVzc2lvbmAgbm9kZS4gVGhlIGZhY3QgdGhhdCB0aGUgYE1lbWJlckV4cHJlc3Npb25g4oCZc1xuICAgICMgYHByb3BlcnR5YCBpcyBhbiBJbmRleCBtZWFucyB0aGF0IGBjb21wdXRlZGAgaXMgYHRydWVgIGZvciB0aGVcbiAgICAjIGBNZW1iZXJFeHByZXNzaW9uYC5cbiAgICBAaW5kZXguYXN0IG9cblxuIyMjIyBSYW5nZVxuXG4jIEEgcmFuZ2UgbGl0ZXJhbC4gUmFuZ2VzIGNhbiBiZSB1c2VkIHRvIGV4dHJhY3QgcG9ydGlvbnMgKHNsaWNlcykgb2YgYXJyYXlzLFxuIyB0byBzcGVjaWZ5IGEgcmFuZ2UgZm9yIGNvbXByZWhlbnNpb25zLCBvciBhcyBhIHZhbHVlLCB0byBiZSBleHBhbmRlZCBpbnRvIHRoZVxuIyBjb3JyZXNwb25kaW5nIGFycmF5IG9mIGludGVnZXJzIGF0IHJ1bnRpbWUuXG5leHBvcnRzLlJhbmdlID0gY2xhc3MgUmFuZ2UgZXh0ZW5kcyBCYXNlXG5cbiAgY2hpbGRyZW46IFsnZnJvbScsICd0byddXG5cbiAgY29uc3RydWN0b3I6IChAZnJvbSwgQHRvLCB0YWcpIC0+XG4gICAgc3VwZXIoKVxuXG4gICAgQGV4Y2x1c2l2ZSA9IHRhZyBpcyAnZXhjbHVzaXZlJ1xuICAgIEBlcXVhbHMgPSBpZiBAZXhjbHVzaXZlIHRoZW4gJycgZWxzZSAnPSdcblxuICAjIENvbXBpbGVzIHRoZSByYW5nZSdzIHNvdXJjZSB2YXJpYWJsZXMgLS0gd2hlcmUgaXQgc3RhcnRzIGFuZCB3aGVyZSBpdCBlbmRzLlxuICAjIEJ1dCBvbmx5IGlmIHRoZXkgbmVlZCB0byBiZSBjYWNoZWQgdG8gYXZvaWQgZG91YmxlIGV2YWx1YXRpb24uXG4gIGNvbXBpbGVWYXJpYWJsZXM6IChvKSAtPlxuICAgIG8gPSBtZXJnZSBvLCB0b3A6IHRydWVcbiAgICBzaG91bGRDYWNoZSA9IGRlbCBvLCAnc2hvdWxkQ2FjaGUnXG4gICAgW0Bmcm9tQywgQGZyb21WYXJdID0gQGNhY2hlVG9Db2RlRnJhZ21lbnRzIEBmcm9tLmNhY2hlIG8sIExFVkVMX0xJU1QsIHNob3VsZENhY2hlXG4gICAgW0B0b0MsIEB0b1Zhcl0gICAgID0gQGNhY2hlVG9Db2RlRnJhZ21lbnRzIEB0by5jYWNoZSBvLCBMRVZFTF9MSVNULCBzaG91bGRDYWNoZVxuICAgIFtAc3RlcCwgQHN0ZXBWYXJdICA9IEBjYWNoZVRvQ29kZUZyYWdtZW50cyBzdGVwLmNhY2hlIG8sIExFVkVMX0xJU1QsIHNob3VsZENhY2hlIGlmIHN0ZXAgPSBkZWwgbywgJ3N0ZXAnXG4gICAgQGZyb21OdW0gPSBpZiBAZnJvbS5pc051bWJlcigpIHRoZW4gcGFyc2VOdW1iZXIgQGZyb21WYXIgZWxzZSBudWxsXG4gICAgQHRvTnVtICAgPSBpZiBAdG8uaXNOdW1iZXIoKSAgIHRoZW4gcGFyc2VOdW1iZXIgQHRvVmFyICAgZWxzZSBudWxsXG4gICAgQHN0ZXBOdW0gPSBpZiBzdGVwPy5pc051bWJlcigpIHRoZW4gcGFyc2VOdW1iZXIgQHN0ZXBWYXIgZWxzZSBudWxsXG5cbiAgIyBXaGVuIGNvbXBpbGVkIG5vcm1hbGx5LCB0aGUgcmFuZ2UgcmV0dXJucyB0aGUgY29udGVudHMgb2YgdGhlICpmb3IgbG9vcCpcbiAgIyBuZWVkZWQgdG8gaXRlcmF0ZSBvdmVyIHRoZSB2YWx1ZXMgaW4gdGhlIHJhbmdlLiBVc2VkIGJ5IGNvbXByZWhlbnNpb25zLlxuICBjb21waWxlTm9kZTogKG8pIC0+XG4gICAgQGNvbXBpbGVWYXJpYWJsZXMgbyB1bmxlc3MgQGZyb21WYXJcbiAgICByZXR1cm4gQGNvbXBpbGVBcnJheShvKSB1bmxlc3Mgby5pbmRleFxuXG4gICAgIyBTZXQgdXAgZW5kcG9pbnRzLlxuICAgIGtub3duICAgID0gQGZyb21OdW0/IGFuZCBAdG9OdW0/XG4gICAgaWR4ICAgICAgPSBkZWwgbywgJ2luZGV4J1xuICAgIGlkeE5hbWUgID0gZGVsIG8sICduYW1lJ1xuICAgIG5hbWVkSW5kZXggPSBpZHhOYW1lIGFuZCBpZHhOYW1lIGlzbnQgaWR4XG4gICAgdmFyUGFydCAgPVxuICAgICAgaWYga25vd24gYW5kIG5vdCBuYW1lZEluZGV4XG4gICAgICAgIFwidmFyICN7aWR4fSA9ICN7QGZyb21DfVwiXG4gICAgICBlbHNlXG4gICAgICAgIFwiI3tpZHh9ID0gI3tAZnJvbUN9XCJcbiAgICB2YXJQYXJ0ICs9IFwiLCAje0B0b0N9XCIgaWYgQHRvQyBpc250IEB0b1ZhclxuICAgIHZhclBhcnQgKz0gXCIsICN7QHN0ZXB9XCIgaWYgQHN0ZXAgaXNudCBAc3RlcFZhclxuICAgIFtsdCwgZ3RdID0gW1wiI3tpZHh9IDwje0BlcXVhbHN9XCIsIFwiI3tpZHh9ID4je0BlcXVhbHN9XCJdXG5cbiAgICAjIEdlbmVyYXRlIHRoZSBjb25kaXRpb24uXG4gICAgW2Zyb20sIHRvXSA9IFtAZnJvbU51bSwgQHRvTnVtXVxuICAgICMgQWx3YXlzIGNoZWNrIGlmIHRoZSBgc3RlcGAgaXNuJ3QgemVybyB0byBhdm9pZCB0aGUgaW5maW5pdGUgbG9vcC5cbiAgICBzdGVwTm90WmVybyA9IFwiI3sgQHN0ZXBOdW0gPyBAc3RlcFZhciB9ICE9PSAwXCJcbiAgICBzdGVwQ29uZCA9IFwiI3sgQHN0ZXBOdW0gPyBAc3RlcFZhciB9ID4gMFwiXG4gICAgbG93ZXJCb3VuZCA9IFwiI3tsdH0gI3sgaWYga25vd24gdGhlbiB0byBlbHNlIEB0b1ZhciB9XCJcbiAgICB1cHBlckJvdW5kID0gXCIje2d0fSAjeyBpZiBrbm93biB0aGVuIHRvIGVsc2UgQHRvVmFyIH1cIlxuICAgIGNvbmRQYXJ0ID1cbiAgICAgIGlmIEBzdGVwP1xuICAgICAgICBpZiBAc3RlcE51bT8gYW5kIEBzdGVwTnVtIGlzbnQgMFxuICAgICAgICAgIGlmIEBzdGVwTnVtID4gMCB0aGVuIFwiI3tsb3dlckJvdW5kfVwiIGVsc2UgXCIje3VwcGVyQm91bmR9XCJcbiAgICAgICAgZWxzZVxuICAgICAgICAgIFwiI3tzdGVwTm90WmVyb30gJiYgKCN7c3RlcENvbmR9ID8gI3tsb3dlckJvdW5kfSA6ICN7dXBwZXJCb3VuZH0pXCJcbiAgICAgIGVsc2VcbiAgICAgICAgaWYga25vd25cbiAgICAgICAgICBcIiN7IGlmIGZyb20gPD0gdG8gdGhlbiBsdCBlbHNlIGd0IH0gI3t0b31cIlxuICAgICAgICBlbHNlXG4gICAgICAgICAgXCIoI3tAZnJvbVZhcn0gPD0gI3tAdG9WYXJ9ID8gI3tsb3dlckJvdW5kfSA6ICN7dXBwZXJCb3VuZH0pXCJcblxuICAgIGNvbmQgPSBpZiBAc3RlcFZhciB0aGVuIFwiI3tAc3RlcFZhcn0gPiAwXCIgZWxzZSBcIiN7QGZyb21WYXJ9IDw9ICN7QHRvVmFyfVwiXG5cbiAgICAjIEdlbmVyYXRlIHRoZSBzdGVwLlxuICAgIHN0ZXBQYXJ0ID0gaWYgQHN0ZXBWYXJcbiAgICAgIFwiI3tpZHh9ICs9ICN7QHN0ZXBWYXJ9XCJcbiAgICBlbHNlIGlmIGtub3duXG4gICAgICBpZiBuYW1lZEluZGV4XG4gICAgICAgIGlmIGZyb20gPD0gdG8gdGhlbiBcIisrI3tpZHh9XCIgZWxzZSBcIi0tI3tpZHh9XCJcbiAgICAgIGVsc2VcbiAgICAgICAgaWYgZnJvbSA8PSB0byB0aGVuIFwiI3tpZHh9KytcIiBlbHNlIFwiI3tpZHh9LS1cIlxuICAgIGVsc2VcbiAgICAgIGlmIG5hbWVkSW5kZXhcbiAgICAgICAgXCIje2NvbmR9ID8gKysje2lkeH0gOiAtLSN7aWR4fVwiXG4gICAgICBlbHNlXG4gICAgICAgIFwiI3tjb25kfSA/ICN7aWR4fSsrIDogI3tpZHh9LS1cIlxuXG4gICAgdmFyUGFydCAgPSBcIiN7aWR4TmFtZX0gPSAje3ZhclBhcnR9XCIgaWYgbmFtZWRJbmRleFxuICAgIHN0ZXBQYXJ0ID0gXCIje2lkeE5hbWV9ID0gI3tzdGVwUGFydH1cIiBpZiBuYW1lZEluZGV4XG5cbiAgICAjIFRoZSBmaW5hbCBsb29wIGJvZHkuXG4gICAgW0BtYWtlQ29kZSBcIiN7dmFyUGFydH07ICN7Y29uZFBhcnR9OyAje3N0ZXBQYXJ0fVwiXVxuXG5cbiAgIyBXaGVuIHVzZWQgYXMgYSB2YWx1ZSwgZXhwYW5kIHRoZSByYW5nZSBpbnRvIHRoZSBlcXVpdmFsZW50IGFycmF5LlxuICBjb21waWxlQXJyYXk6IChvKSAtPlxuICAgIGtub3duID0gQGZyb21OdW0/IGFuZCBAdG9OdW0/XG4gICAgaWYga25vd24gYW5kIE1hdGguYWJzKEBmcm9tTnVtIC0gQHRvTnVtKSA8PSAyMFxuICAgICAgcmFuZ2UgPSBbQGZyb21OdW0uLkB0b051bV1cbiAgICAgIHJhbmdlLnBvcCgpIGlmIEBleGNsdXNpdmVcbiAgICAgIHJldHVybiBbQG1ha2VDb2RlIFwiWyN7IHJhbmdlLmpvaW4oJywgJykgfV1cIl1cbiAgICBpZHQgICAgPSBAdGFiICsgVEFCXG4gICAgaSAgICAgID0gby5zY29wZS5mcmVlVmFyaWFibGUgJ2knLCBzaW5nbGU6IHRydWUsIHJlc2VydmU6IG5vXG4gICAgcmVzdWx0ID0gby5zY29wZS5mcmVlVmFyaWFibGUgJ3Jlc3VsdHMnLCByZXNlcnZlOiBub1xuICAgIHByZSAgICA9IFwiXFxuI3tpZHR9dmFyICN7cmVzdWx0fSA9IFtdO1wiXG4gICAgaWYga25vd25cbiAgICAgIG8uaW5kZXggPSBpXG4gICAgICBib2R5ICAgID0gZnJhZ21lbnRzVG9UZXh0IEBjb21waWxlTm9kZSBvXG4gICAgZWxzZVxuICAgICAgdmFycyAgICA9IFwiI3tpfSA9ICN7QGZyb21DfVwiICsgaWYgQHRvQyBpc250IEB0b1ZhciB0aGVuIFwiLCAje0B0b0N9XCIgZWxzZSAnJ1xuICAgICAgY29uZCAgICA9IFwiI3tAZnJvbVZhcn0gPD0gI3tAdG9WYXJ9XCJcbiAgICAgIGJvZHkgICAgPSBcInZhciAje3ZhcnN9OyAje2NvbmR9ID8gI3tpfSA8I3tAZXF1YWxzfSAje0B0b1Zhcn0gOiAje2l9ID4je0BlcXVhbHN9ICN7QHRvVmFyfTsgI3tjb25kfSA/ICN7aX0rKyA6ICN7aX0tLVwiXG4gICAgcG9zdCAgID0gXCJ7ICN7cmVzdWx0fS5wdXNoKCN7aX0pOyB9XFxuI3tpZHR9cmV0dXJuICN7cmVzdWx0fTtcXG4je28uaW5kZW50fVwiXG4gICAgaGFzQXJncyA9IChub2RlKSAtPiBub2RlPy5jb250YWlucyBpc0xpdGVyYWxBcmd1bWVudHNcbiAgICBhcmdzICAgPSAnLCBhcmd1bWVudHMnIGlmIGhhc0FyZ3MoQGZyb20pIG9yIGhhc0FyZ3MoQHRvKVxuICAgIFtAbWFrZUNvZGUgXCIoZnVuY3Rpb24oKSB7I3twcmV9XFxuI3tpZHR9Zm9yICgje2JvZHl9KSN7cG9zdH19KS5hcHBseSh0aGlzI3thcmdzID8gJyd9KVwiXVxuXG4gIGFzdFByb3BlcnRpZXM6IChvKSAtPlxuICAgIHJldHVybiB7XG4gICAgICBmcm9tOiBAZnJvbT8uYXN0KG8pID8gbnVsbFxuICAgICAgdG86IEB0bz8uYXN0KG8pID8gbnVsbFxuICAgICAgQGV4Y2x1c2l2ZVxuICAgIH1cblxuIyMjIyBTbGljZVxuXG4jIEFuIGFycmF5IHNsaWNlIGxpdGVyYWwuIFVubGlrZSBKYXZhU2NyaXB04oCZcyBgQXJyYXkjc2xpY2VgLCB0aGUgc2Vjb25kIHBhcmFtZXRlclxuIyBzcGVjaWZpZXMgdGhlIGluZGV4IG9mIHRoZSBlbmQgb2YgdGhlIHNsaWNlLCBqdXN0IGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXJcbiMgaXMgdGhlIGluZGV4IG9mIHRoZSBiZWdpbm5pbmcuXG5leHBvcnRzLlNsaWNlID0gY2xhc3MgU2xpY2UgZXh0ZW5kcyBCYXNlXG5cbiAgY2hpbGRyZW46IFsncmFuZ2UnXVxuXG4gIGNvbnN0cnVjdG9yOiAoQHJhbmdlKSAtPlxuICAgIHN1cGVyKClcblxuICAjIFdlIGhhdmUgdG8gYmUgY2FyZWZ1bCB3aGVuIHRyeWluZyB0byBzbGljZSB0aHJvdWdoIHRoZSBlbmQgb2YgdGhlIGFycmF5LFxuICAjIGA5ZTlgIGlzIHVzZWQgYmVjYXVzZSBub3QgYWxsIGltcGxlbWVudGF0aW9ucyByZXNwZWN0IGB1bmRlZmluZWRgIG9yIGAxLzBgLlxuICAjIGA5ZTlgIHNob3VsZCBiZSBzYWZlIGJlY2F1c2UgYDllOWAgPiBgMioqMzJgLCB0aGUgbWF4IGFycmF5IGxlbmd0aC5cbiAgY29tcGlsZU5vZGU6IChvKSAtPlxuICAgIHt0bywgZnJvbX0gPSBAcmFuZ2VcbiAgICAjIEhhbmRsZSBhbiBleHByZXNzaW9uIGluIHRoZSBwcm9wZXJ0eSBhY2Nlc3MsIGUuZy4gYGFbIWIgaW4gYy4uXWAuXG4gICAgaWYgZnJvbT8uc2hvdWxkQ2FjaGUoKVxuICAgICAgZnJvbSA9IG5ldyBWYWx1ZSBuZXcgUGFyZW5zIGZyb21cbiAgICBpZiB0bz8uc2hvdWxkQ2FjaGUoKVxuICAgICAgdG8gPSBuZXcgVmFsdWUgbmV3IFBhcmVucyB0b1xuICAgIGZyb21Db21waWxlZCA9IGZyb20/LmNvbXBpbGVUb0ZyYWdtZW50cyhvLCBMRVZFTF9QQVJFTikgb3IgW0BtYWtlQ29kZSAnMCddXG4gICAgaWYgdG9cbiAgICAgIGNvbXBpbGVkICAgICA9IHRvLmNvbXBpbGVUb0ZyYWdtZW50cyBvLCBMRVZFTF9QQVJFTlxuICAgICAgY29tcGlsZWRUZXh0ID0gZnJhZ21lbnRzVG9UZXh0IGNvbXBpbGVkXG4gICAgICBpZiBub3QgKG5vdCBAcmFuZ2UuZXhjbHVzaXZlIGFuZCArY29tcGlsZWRUZXh0IGlzIC0xKVxuICAgICAgICB0b1N0ciA9ICcsICcgKyBpZiBAcmFuZ2UuZXhjbHVzaXZlXG4gICAgICAgICAgY29tcGlsZWRUZXh0XG4gICAgICAgIGVsc2UgaWYgdG8uaXNOdW1iZXIoKVxuICAgICAgICAgIFwiI3srY29tcGlsZWRUZXh0ICsgMX1cIlxuICAgICAgICBlbHNlXG4gICAgICAgICAgY29tcGlsZWQgPSB0by5jb21waWxlVG9GcmFnbWVudHMgbywgTEVWRUxfQUNDRVNTXG4gICAgICAgICAgXCIrI3tmcmFnbWVudHNUb1RleHQgY29tcGlsZWR9ICsgMSB8fCA5ZTlcIlxuICAgIFtAbWFrZUNvZGUgXCIuc2xpY2UoI3sgZnJhZ21lbnRzVG9UZXh0IGZyb21Db21waWxlZCB9I3sgdG9TdHIgb3IgJycgfSlcIl1cblxuICBhc3ROb2RlOiAobykgLT5cbiAgICBAcmFuZ2UuYXN0IG9cblxuIyMjIyBPYmpcblxuIyBBbiBvYmplY3QgbGl0ZXJhbCwgbm90aGluZyBmYW5jeS5cbmV4cG9ydHMuT2JqID0gY2xhc3MgT2JqIGV4dGVuZHMgQmFzZVxuICBjb25zdHJ1Y3RvcjogKHByb3BzLCBAZ2VuZXJhdGVkID0gbm8pIC0+XG4gICAgc3VwZXIoKVxuXG4gICAgQG9iamVjdHMgPSBAcHJvcGVydGllcyA9IHByb3BzIG9yIFtdXG5cbiAgY2hpbGRyZW46IFsncHJvcGVydGllcyddXG5cbiAgaXNBc3NpZ25hYmxlOiAob3B0cykgLT5cbiAgICBmb3IgcHJvcCBpbiBAcHJvcGVydGllc1xuICAgICAgIyBDaGVjayBmb3IgcmVzZXJ2ZWQgd29yZHMuXG4gICAgICBtZXNzYWdlID0gaXNVbmFzc2lnbmFibGUgcHJvcC51bndyYXBBbGwoKS52YWx1ZVxuICAgICAgcHJvcC5lcnJvciBtZXNzYWdlIGlmIG1lc3NhZ2VcblxuICAgICAgcHJvcCA9IHByb3AudmFsdWUgaWYgcHJvcCBpbnN0YW5jZW9mIEFzc2lnbiBhbmRcbiAgICAgICAgcHJvcC5jb250ZXh0IGlzICdvYmplY3QnIGFuZFxuICAgICAgICBwcm9wLnZhbHVlPy5iYXNlIG5vdCBpbnN0YW5jZW9mIEFyclxuICAgICAgcmV0dXJuIG5vIHVubGVzcyBwcm9wLmlzQXNzaWduYWJsZSBvcHRzXG4gICAgeWVzXG5cbiAgc2hvdWxkQ2FjaGU6IC0+XG4gICAgbm90IEBpc0Fzc2lnbmFibGUoKVxuXG4gICMgQ2hlY2sgaWYgb2JqZWN0IGNvbnRhaW5zIHNwbGF0LlxuICBoYXNTcGxhdDogLT5cbiAgICByZXR1cm4geWVzIGZvciBwcm9wIGluIEBwcm9wZXJ0aWVzIHdoZW4gcHJvcCBpbnN0YW5jZW9mIFNwbGF0XG4gICAgbm9cblxuICAjIE1vdmUgcmVzdCBwcm9wZXJ0eSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICAjIGB7YSwgcmVzdC4uLiwgYn0gPSBvYmpgIC0+IGB7YSwgYiwgcmVzdC4uLn0gPSBvYmpgXG4gICMgYGZvbyA9ICh7YSwgcmVzdC4uLiwgYn0pIC0+YCAtPiBgZm9vID0ge2EsIGIsIHJlc3QuLi59KSAtPmBcbiAgcmVvcmRlclByb3BlcnRpZXM6IC0+XG4gICAgcHJvcHMgPSBAcHJvcGVydGllc1xuICAgIHNwbGF0UHJvcHMgPSBAZ2V0QW5kQ2hlY2tTcGxhdFByb3BzKClcbiAgICBzcGxhdFByb3AgPSBwcm9wcy5zcGxpY2Ugc3BsYXRQcm9wc1swXSwgMVxuICAgIEBvYmplY3RzID0gQHByb3BlcnRpZXMgPSBbXS5jb25jYXQgcHJvcHMsIHNwbGF0UHJvcFxuXG4gIGNvbXBpbGVOb2RlOiAobykgLT5cbiAgICBAcmVvcmRlclByb3BlcnRpZXMoKSBpZiBAaGFzU3BsYXQoKSBhbmQgQGxoc1xuICAgIHByb3BzID0gQHByb3BlcnRpZXNcbiAgICBpZiBAZ2VuZXJhdGVkXG4gICAgICBmb3Igbm9kZSBpbiBwcm9wcyB3aGVuIG5vZGUgaW5zdGFuY2VvZiBWYWx1ZVxuICAgICAgICBub2RlLmVycm9yICdjYW5ub3QgaGF2ZSBhbiBpbXBsaWNpdCB2YWx1ZSBpbiBhbiBpbXBsaWNpdCBvYmplY3QnXG5cbiAgICBpZHQgICAgICA9IG8uaW5kZW50ICs9IFRBQlxuICAgIGxhc3ROb2RlID0gQGxhc3ROb2RlIEBwcm9wZXJ0aWVzXG5cbiAgICAjIElmIHRoaXMgb2JqZWN0IGlzIHRoZSBsZWZ0LWhhbmQgc2lkZSBvZiBhbiBhc3NpZ25tZW50LCBhbGwgaXRzIGNoaWxkcmVuXG4gICAgIyBhcmUgdG9vLlxuICAgIEBwcm9wYWdhdGVMaHMoKVxuXG4gICAgaXNDb21wYWN0ID0geWVzXG4gICAgZm9yIHByb3AgaW4gQHByb3BlcnRpZXNcbiAgICAgIGlmIHByb3AgaW5zdGFuY2VvZiBBc3NpZ24gYW5kIHByb3AuY29udGV4dCBpcyAnb2JqZWN0J1xuICAgICAgICBpc0NvbXBhY3QgPSBub1xuXG4gICAgYW5zd2VyID0gW11cbiAgICBhbnN3ZXIucHVzaCBAbWFrZUNvZGUgaWYgaXNDb21wYWN0IHRoZW4gJycgZWxzZSAnXFxuJ1xuICAgIGZvciBwcm9wLCBpIGluIHByb3BzXG4gICAgICBqb2luID0gaWYgaSBpcyBwcm9wcy5sZW5ndGggLSAxXG4gICAgICAgICcnXG4gICAgICBlbHNlIGlmIGlzQ29tcGFjdFxuICAgICAgICAnLCAnXG4gICAgICBlbHNlIGlmIHByb3AgaXMgbGFzdE5vZGVcbiAgICAgICAgJ1xcbidcbiAgICAgIGVsc2VcbiAgICAgICAgJyxcXG4nXG4gICAgICBpbmRlbnQgPSBpZiBpc0NvbXBhY3QgdGhlbiAnJyBlbHNlIGlkdFxuXG4gICAgICBrZXkgPSBpZiBwcm9wIGluc3RhbmNlb2YgQXNzaWduIGFuZCBwcm9wLmNvbnRleHQgaXMgJ29iamVjdCdcbiAgICAgICAgcHJvcC52YXJpYWJsZVxuICAgICAgZWxzZSBpZiBwcm9wIGluc3RhbmNlb2YgQXNzaWduXG4gICAgICAgIHByb3Aub3BlcmF0b3JUb2tlbi5lcnJvciBcInVuZXhwZWN0ZWQgI3twcm9wLm9wZXJhdG9yVG9rZW4udmFsdWV9XCIgdW5sZXNzIEBsaHNcbiAgICAgICAgcHJvcC52YXJpYWJsZVxuICAgICAgZWxzZVxuICAgICAgICBwcm9wXG4gICAgICBpZiBrZXkgaW5zdGFuY2VvZiBWYWx1ZSBhbmQga2V5Lmhhc1Byb3BlcnRpZXMoKVxuICAgICAgICBrZXkuZXJyb3IgJ2ludmFsaWQgb2JqZWN0IGtleScgaWYgcHJvcC5jb250ZXh0IGlzICdvYmplY3QnIG9yIG5vdCBrZXkudGhpc1xuICAgICAgICBrZXkgID0ga2V5LnByb3BlcnRpZXNbMF0ubmFtZVxuICAgICAgICBwcm9wID0gbmV3IEFzc2lnbiBrZXksIHByb3AsICdvYmplY3QnXG4gICAgICBpZiBrZXkgaXMgcHJvcFxuICAgICAgICBpZiBwcm9wLnNob3VsZENhY2hlKClcbiAgICAgICAgICBba2V5LCB2YWx1ZV0gPSBwcm9wLmJhc2UuY2FjaGUgb1xuICAgICAgICAgIGtleSAgPSBuZXcgUHJvcGVydHlOYW1lIGtleS52YWx1ZSBpZiBrZXkgaW5zdGFuY2VvZiBJZGVudGlmaWVyTGl0ZXJhbFxuICAgICAgICAgIHByb3AgPSBuZXcgQXNzaWduIGtleSwgdmFsdWUsICdvYmplY3QnXG4gICAgICAgIGVsc2UgaWYga2V5IGluc3RhbmNlb2YgVmFsdWUgYW5kIGtleS5iYXNlIGluc3RhbmNlb2YgQ29tcHV0ZWRQcm9wZXJ0eU5hbWVcbiAgICAgICAgICAjIGB7IFtmb28oKV0gfWAgb3V0cHV0IGFzIGB7IFtyZWYgPSBmb28oKV06IHJlZiB9YC5cbiAgICAgICAgICBpZiBwcm9wLmJhc2UudmFsdWUuc2hvdWxkQ2FjaGUoKVxuICAgICAgICAgICAgW2tleSwgdmFsdWVdID0gcHJvcC5iYXNlLnZhbHVlLmNhY2hlIG9cbiAgICAgICAgICAgIGtleSAgPSBuZXcgQ29tcHV0ZWRQcm9wZXJ0eU5hbWUga2V5LnZhbHVlIGlmIGtleSBpbnN0YW5jZW9mIElkZW50aWZpZXJMaXRlcmFsXG4gICAgICAgICAgICBwcm9wID0gbmV3IEFzc2lnbiBrZXksIHZhbHVlLCAnb2JqZWN0J1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICMgYHsgW2V4cHJlc3Npb25dIH1gIG91dHB1dCBhcyBgeyBbZXhwcmVzc2lvbl06IGV4cHJlc3Npb24gfWAuXG4gICAgICAgICAgICBwcm9wID0gbmV3IEFzc2lnbiBrZXksIHByb3AuYmFzZS52YWx1ZSwgJ29iamVjdCdcbiAgICAgICAgZWxzZSBpZiBub3QgcHJvcC5iYXJlTGl0ZXJhbD8oSWRlbnRpZmllckxpdGVyYWwpIGFuZCBwcm9wIG5vdCBpbnN0YW5jZW9mIFNwbGF0XG4gICAgICAgICAgcHJvcCA9IG5ldyBBc3NpZ24gcHJvcCwgcHJvcCwgJ29iamVjdCdcbiAgICAgIGlmIGluZGVudCB0aGVuIGFuc3dlci5wdXNoIEBtYWtlQ29kZSBpbmRlbnRcbiAgICAgIGFuc3dlci5wdXNoIHByb3AuY29tcGlsZVRvRnJhZ21lbnRzKG8sIExFVkVMX1RPUCkuLi5cbiAgICAgIGlmIGpvaW4gdGhlbiBhbnN3ZXIucHVzaCBAbWFrZUNvZGUgam9pblxuICAgIGFuc3dlci5wdXNoIEBtYWtlQ29kZSBpZiBpc0NvbXBhY3QgdGhlbiAnJyBlbHNlIFwiXFxuI3tAdGFifVwiXG4gICAgYW5zd2VyID0gQHdyYXBJbkJyYWNlcyBhbnN3ZXJcbiAgICBpZiBAZnJvbnQgdGhlbiBAd3JhcEluUGFyZW50aGVzZXMgYW5zd2VyIGVsc2UgYW5zd2VyXG5cbiAgZ2V0QW5kQ2hlY2tTcGxhdFByb3BzOiAtPlxuICAgIHJldHVybiB1bmxlc3MgQGhhc1NwbGF0KCkgYW5kIEBsaHNcbiAgICBwcm9wcyA9IEBwcm9wZXJ0aWVzXG4gICAgc3BsYXRQcm9wcyA9IChpIGZvciBwcm9wLCBpIGluIHByb3BzIHdoZW4gcHJvcCBpbnN0YW5jZW9mIFNwbGF0KVxuICAgIHByb3BzW3NwbGF0UHJvcHNbMV1dLmVycm9yIFwibXVsdGlwbGUgc3ByZWFkIGVsZW1lbnRzIGFyZSBkaXNhbGxvd2VkXCIgaWYgc3BsYXRQcm9wcz8ubGVuZ3RoID4gMVxuICAgIHNwbGF0UHJvcHNcblxuICBhc3NpZ25zOiAobmFtZSkgLT5cbiAgICBmb3IgcHJvcCBpbiBAcHJvcGVydGllcyB3aGVuIHByb3AuYXNzaWducyBuYW1lIHRoZW4gcmV0dXJuIHllc1xuICAgIG5vXG5cbiAgZWFjaE5hbWU6IChpdGVyYXRvcikgLT5cbiAgICBmb3IgcHJvcCBpbiBAcHJvcGVydGllc1xuICAgICAgcHJvcCA9IHByb3AudmFsdWUgaWYgcHJvcCBpbnN0YW5jZW9mIEFzc2lnbiBhbmQgcHJvcC5jb250ZXh0IGlzICdvYmplY3QnXG4gICAgICBwcm9wID0gcHJvcC51bndyYXBBbGwoKVxuICAgICAgcHJvcC5lYWNoTmFtZSBpdGVyYXRvciBpZiBwcm9wLmVhY2hOYW1lP1xuXG4gICMgQ29udmVydCDigJxiYXJl4oCdIHByb3BlcnRpZXMgdG8gYE9iamVjdFByb3BlcnR5YHMgKG9yIGBTcGxhdGBzKS5cbiAgZXhwYW5kUHJvcGVydHk6IChwcm9wZXJ0eSkgLT5cbiAgICB7dmFyaWFibGUsIGNvbnRleHQsIG9wZXJhdG9yVG9rZW59ID0gcHJvcGVydHlcbiAgICBrZXkgPSBpZiBwcm9wZXJ0eSBpbnN0YW5jZW9mIEFzc2lnbiBhbmQgY29udGV4dCBpcyAnb2JqZWN0J1xuICAgICAgdmFyaWFibGVcbiAgICBlbHNlIGlmIHByb3BlcnR5IGluc3RhbmNlb2YgQXNzaWduXG4gICAgICBvcGVyYXRvclRva2VuLmVycm9yIFwidW5leHBlY3RlZCAje29wZXJhdG9yVG9rZW4udmFsdWV9XCIgdW5sZXNzIEBsaHNcbiAgICAgIHZhcmlhYmxlXG4gICAgZWxzZVxuICAgICAgcHJvcGVydHlcbiAgICBpZiBrZXkgaW5zdGFuY2VvZiBWYWx1ZSBhbmQga2V5Lmhhc1Byb3BlcnRpZXMoKVxuICAgICAga2V5LmVycm9yICdpbnZhbGlkIG9iamVjdCBrZXknIHVubGVzcyBjb250ZXh0IGlzbnQgJ29iamVjdCcgYW5kIGtleS50aGlzXG4gICAgICBpZiBwcm9wZXJ0eSBpbnN0YW5jZW9mIEFzc2lnblxuICAgICAgICByZXR1cm4gbmV3IE9iamVjdFByb3BlcnR5IGZyb21Bc3NpZ246IHByb3BlcnR5XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0UHJvcGVydHkga2V5OiBwcm9wZXJ0eVxuICAgIHJldHVybiBuZXcgT2JqZWN0UHJvcGVydHkoZnJvbUFzc2lnbjogcHJvcGVydHkpIHVubGVzcyBrZXkgaXMgcHJvcGVydHlcbiAgICByZXR1cm4gcHJvcGVydHkgaWYgcHJvcGVydHkgaW5zdGFuY2VvZiBTcGxhdFxuXG4gICAgbmV3IE9iamVjdFByb3BlcnR5IGtleTogcHJvcGVydHlcblxuICBleHBhbmRQcm9wZXJ0aWVzOiAtPlxuICAgIEBleHBhbmRQcm9wZXJ0eShwcm9wZXJ0eSkgZm9yIHByb3BlcnR5IGluIEBwcm9wZXJ0aWVzXG5cbiAgcHJvcGFnYXRlTGhzOiAoc2V0TGhzKSAtPlxuICAgIEBsaHMgPSB5ZXMgaWYgc2V0TGhzXG4gICAgcmV0dXJuIHVubGVzcyBAbGhzXG5cbiAgICBmb3IgcHJvcGVydHkgaW4gQHByb3BlcnRpZXNcbiAgICAgIGlmIHByb3BlcnR5IGluc3RhbmNlb2YgQXNzaWduIGFuZCBwcm9wZXJ0eS5jb250ZXh0IGlzICdvYmplY3QnXG4gICAgICAgIHt2YWx1ZX0gPSBwcm9wZXJ0eVxuICAgICAgICB1bndyYXBwZWRWYWx1ZSA9IHZhbHVlLnVud3JhcEFsbCgpXG4gICAgICAgIGlmIHVud3JhcHBlZFZhbHVlIGluc3RhbmNlb2YgQXJyIG9yIHVud3JhcHBlZFZhbHVlIGluc3RhbmNlb2YgT2JqXG4gICAgICAgICAgdW53cmFwcGVkVmFsdWUucHJvcGFnYXRlTGhzIHllc1xuICAgICAgICBlbHNlIGlmIHVud3JhcHBlZFZhbHVlIGluc3RhbmNlb2YgQXNzaWduXG4gICAgICAgICAgdW53cmFwcGVkVmFsdWUubmVzdGVkTGhzID0geWVzXG4gICAgICBlbHNlIGlmIHByb3BlcnR5IGluc3RhbmNlb2YgQXNzaWduXG4gICAgICAgICMgU2hvcnRoYW5kIHByb3BlcnR5IHdpdGggZGVmYXVsdCwgZS5nLiBge2EgPSAxfSA9IGJgLlxuICAgICAgICBwcm9wZXJ0eS5uZXN0ZWRMaHMgPSB5ZXNcbiAgICAgIGVsc2UgaWYgcHJvcGVydHkgaW5zdGFuY2VvZiBTcGxhdFxuICAgICAgICBwcm9wZXJ0eS5wcm9wYWdhdGVMaHMgeWVzXG5cbiAgYXN0Tm9kZTogKG8pIC0+XG4gICAgQGdldEFuZENoZWNrU3BsYXRQcm9wcygpXG4gICAgc3VwZXIgb1xuXG4gIGFzdFR5cGU6IC0+XG4gICAgaWYgQGxoc1xuICAgICAgJ09iamVjdFBhdHRlcm4nXG4gICAgZWxzZVxuICAgICAgJ09iamVjdEV4cHJlc3Npb24nXG5cbiAgYXN0UHJvcGVydGllczogKG8pIC0+XG4gICAgcmV0dXJuXG4gICAgICBpbXBsaWNpdDogISFAZ2VuZXJhdGVkXG4gICAgICBwcm9wZXJ0aWVzOlxuICAgICAgICBwcm9wZXJ0eS5hc3QobykgZm9yIHByb3BlcnR5IGluIEBleHBhbmRQcm9wZXJ0aWVzKClcblxuZXhwb3J0cy5PYmplY3RQcm9wZXJ0eSA9IGNsYXNzIE9iamVjdFByb3BlcnR5IGV4dGVuZHMgQmFzZVxuICBjb25zdHJ1Y3RvcjogKHtrZXksIGZyb21Bc3NpZ259KSAtPlxuICAgIHN1cGVyKClcbiAgICBpZiBmcm9tQXNzaWduXG4gICAgICB7dmFyaWFibGU6IEBrZXksIHZhbHVlLCBjb250ZXh0fSA9IGZyb21Bc3NpZ25cbiAgICAgIGlmIGNvbnRleHQgaXMgJ29iamVjdCdcbiAgICAgICAgIyBBbGwgbm9uLXNob3J0aGFuZCBwcm9wZXJ0aWVzIChpLmUuIGluY2x1ZGVzIGA6YCkuXG4gICAgICAgIEB2YWx1ZSA9IHZhbHVlXG4gICAgICBlbHNlXG4gICAgICAgICMgTGVmdC1oYW5kLXNpZGUgc2hvcnRoYW5kIHdpdGggZGVmYXVsdCBlLmcuIGB7YSA9IDF9ID0gYmAuXG4gICAgICAgIEB2YWx1ZSA9IGZyb21Bc3NpZ25cbiAgICAgICAgQHNob3J0aGFuZCA9IHllc1xuICAgICAgQGxvY2F0aW9uRGF0YSA9IGZyb21Bc3NpZ24ubG9jYXRpb25EYXRhXG4gICAgZWxzZVxuICAgICAgIyBTaG9ydGhhbmQgd2l0aG91dCBkZWZhdWx0IGUuZy4gYHthfWAgb3IgYHtAYX1gIG9yIGB7W2FdfWAuXG4gICAgICBAa2V5ID0ga2V5XG4gICAgICBAc2hvcnRoYW5kID0geWVzXG4gICAgICBAbG9jYXRpb25EYXRhID0ga2V5LmxvY2F0aW9uRGF0YVxuXG4gIGFzdFByb3BlcnRpZXM6IChvKSAtPlxuICAgIGlzQ29tcHV0ZWRQcm9wZXJ0eU5hbWUgPSAoQGtleSBpbnN0YW5jZW9mIFZhbHVlIGFuZCBAa2V5LmJhc2UgaW5zdGFuY2VvZiBDb21wdXRlZFByb3BlcnR5TmFtZSkgb3IgQGtleS51bndyYXAoKSBpbnN0YW5jZW9mIFN0cmluZ1dpdGhJbnRlcnBvbGF0aW9uc1xuICAgIGtleUFzdCA9IEBrZXkuYXN0IG8sIExFVkVMX0xJU1RcblxuICAgIHJldHVyblxuICAgICAga2V5OlxuICAgICAgICBpZiBrZXlBc3Q/LmRlY2xhcmF0aW9uXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbiB7fSwga2V5QXN0LCBkZWNsYXJhdGlvbjogbm9cbiAgICAgICAgZWxzZVxuICAgICAgICAgIGtleUFzdFxuICAgICAgdmFsdWU6IEB2YWx1ZT8uYXN0KG8sIExFVkVMX0xJU1QpID8ga2V5QXN0XG4gICAgICBzaG9ydGhhbmQ6ICEhQHNob3J0aGFuZFxuICAgICAgY29tcHV0ZWQ6ICEhaXNDb21wdXRlZFByb3BlcnR5TmFtZVxuICAgICAgbWV0aG9kOiBub1xuXG4jIyMjIEFyclxuXG4jIEFuIGFycmF5IGxpdGVyYWwuXG5leHBvcnRzLkFyciA9IGNsYXNzIEFyciBleHRlbmRzIEJhc2VcbiAgY29uc3RydWN0b3I6IChvYmpzLCBAbGhzID0gbm8pIC0+XG4gICAgc3VwZXIoKVxuICAgIEBvYmplY3RzID0gb2JqcyBvciBbXVxuICAgIEBwcm9wYWdhdGVMaHMoKVxuXG4gIGNoaWxkcmVuOiBbJ29iamVjdHMnXVxuXG4gIGhhc0VsaXNpb246IC0+XG4gICAgcmV0dXJuIHllcyBmb3Igb2JqIGluIEBvYmplY3RzIHdoZW4gb2JqIGluc3RhbmNlb2YgRWxpc2lvblxuICAgIG5vXG5cbiAgaXNBc3NpZ25hYmxlOiAob3B0cykgLT5cbiAgICB7YWxsb3dFeHBhbnNpb24sIGFsbG93Tm9udHJhaWxpbmdTcGxhdCwgYWxsb3dFbXB0eUFycmF5ID0gbm99ID0gb3B0cyA/IHt9XG4gICAgcmV0dXJuIGFsbG93RW1wdHlBcnJheSB1bmxlc3MgQG9iamVjdHMubGVuZ3RoXG5cbiAgICBmb3Igb2JqLCBpIGluIEBvYmplY3RzXG4gICAgICByZXR1cm4gbm8gaWYgbm90IGFsbG93Tm9udHJhaWxpbmdTcGxhdCBhbmQgb2JqIGluc3RhbmNlb2YgU3BsYXQgYW5kIGkgKyAxIGlzbnQgQG9iamVjdHMubGVuZ3RoXG4gICAgICByZXR1cm4gbm8gdW5sZXNzIChhbGxvd0V4cGFuc2lvbiBhbmQgb2JqIGluc3RhbmNlb2YgRXhwYW5zaW9uKSBvciAob2JqLmlzQXNzaWduYWJsZShvcHRzKSBhbmQgKG5vdCBvYmouaXNBdG9taWMgb3Igb2JqLmlzQXRvbWljKCkpKVxuICAgIHllc1xuXG4gIHNob3VsZENhY2hlOiAtPlxuICAgIG5vdCBAaXNBc3NpZ25hYmxlKClcblxuICBjb21waWxlTm9kZTogKG8pIC0+XG4gICAgcmV0dXJuIFtAbWFrZUNvZGUgJ1tdJ10gdW5sZXNzIEBvYmplY3RzLmxlbmd0aFxuICAgIG8uaW5kZW50ICs9IFRBQlxuICAgIGZyYWdtZW50SXNFbGlzaW9uID0gKFsgZnJhZ21lbnQgXSkgLT5cbiAgICAgIGZyYWdtZW50LnR5cGUgaXMgJ0VsaXNpb24nIGFuZCBmcmFnbWVudC5jb2RlLnRyaW0oKSBpcyAnLCdcbiAgICAjIERldGVjdCBpZiBgRWxpc2lvbmBzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5IGFyZSBwcm9jZXNzZWQgKGUuZy4gWywgLCAsIGFdKS5cbiAgICBwYXNzZWRFbGlzaW9uID0gbm9cblxuICAgIGFuc3dlciA9IFtdXG4gICAgZm9yIG9iaiwgb2JqSW5kZXggaW4gQG9iamVjdHNcbiAgICAgIHVud3JhcHBlZE9iaiA9IG9iai51bndyYXBBbGwoKVxuICAgICAgIyBMZXQgYGNvbXBpbGVDb21tZW50RnJhZ21lbnRzYCBrbm93IHRvIGludGVyc3BlcnNlIGJsb2NrIGNvbW1lbnRzXG4gICAgICAjIGludG8gdGhlIGZyYWdtZW50cyBjcmVhdGVkIHdoZW4gY29tcGlsaW5nIHRoaXMgYXJyYXkuXG4gICAgICBpZiB1bndyYXBwZWRPYmouY29tbWVudHMgYW5kXG4gICAgICAgICB1bndyYXBwZWRPYmouY29tbWVudHMuZmlsdGVyKChjb21tZW50KSAtPiBub3QgY29tbWVudC5oZXJlKS5sZW5ndGggaXMgMFxuICAgICAgICB1bndyYXBwZWRPYmouaW5jbHVkZUNvbW1lbnRGcmFnbWVudHMgPSBZRVNcblxuICAgIGNvbXBpbGVkT2JqcyA9IChvYmouY29tcGlsZVRvRnJhZ21lbnRzIG8sIExFVkVMX0xJU1QgZm9yIG9iaiBpbiBAb2JqZWN0cylcbiAgICBvbGVuID0gY29tcGlsZWRPYmpzLmxlbmd0aFxuICAgICMgSWYgYGNvbXBpbGVkT2Jqc2AgaW5jbHVkZXMgbmV3bGluZXMsIHdlIHdpbGwgb3V0cHV0IHRoaXMgYXMgYSBtdWx0aWxpbmVcbiAgICAjIGFycmF5IChpLmUuIHdpdGggYSBuZXdsaW5lIGFuZCBpbmRlbnRhdGlvbiBhZnRlciB0aGUgYFtgKS4gSWYgYW4gZWxlbWVudFxuICAgICMgY29udGFpbnMgbGluZSBjb21tZW50cywgdGhhdCBzaG91bGQgYWxzbyB0cmlnZ2VyIG11bHRpbGluZSBvdXRwdXQgc2luY2VcbiAgICAjIGJ5IGRlZmluaXRpb24gbGluZSBjb21tZW50cyB3aWxsIGludHJvZHVjZSBuZXdsaW5lcyBpbnRvIG91ciBvdXRwdXQuXG4gICAgIyBUaGUgZXhjZXB0aW9uIGlzIGlmIG9ubHkgdGhlIGZpcnN0IGVsZW1lbnQgaGFzIGxpbmUgY29tbWVudHM7IGluIHRoYXRcbiAgICAjIGNhc2UsIG91dHB1dCBhcyB0aGUgY29tcGFjdCBmb3JtIGlmIHdlIG90aGVyd2lzZSB3b3VsZCBoYXZlLCBzbyB0aGF0IHRoZVxuICAgICMgZmlyc3QgZWxlbWVudOKAmXMgbGluZSBjb21tZW50cyBnZXQgb3V0cHV0IGJlZm9yZSBvciBhZnRlciB0aGUgYXJyYXkuXG4gICAgaW5jbHVkZXNMaW5lQ29tbWVudHNPbk5vbkZpcnN0RWxlbWVudCA9IG5vXG4gICAgZm9yIGZyYWdtZW50cywgaW5kZXggaW4gY29tcGlsZWRPYmpzXG4gICAgICBmb3IgZnJhZ21lbnQgaW4gZnJhZ21lbnRzXG4gICAgICAgIGlmIGZyYWdtZW50LmlzSGVyZUNvbW1lbnRcbiAgICAgICAgICBmcmFnbWVudC5jb2RlID0gZnJhZ21lbnQuY29kZS50cmltKClcbiAgICAgICAgZWxzZSBpZiBpbmRleCBpc250IDAgYW5kIGluY2x1ZGVzTGluZUNvbW1lbnRzT25Ob25GaXJzdEVsZW1lbnQgaXMgbm8gYW5kIGhhc0xpbmVDb21tZW50cyBmcmFnbWVudFxuICAgICAgICAgIGluY2x1ZGVzTGluZUNvbW1lbnRzT25Ob25GaXJzdEVsZW1lbnQgPSB5ZXNcbiAgICAgICMgQWRkICcsICcgaWYgYWxsIGBFbGlzaW9uc2AgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheSBhcmUgcHJvY2Vzc2VkIChlLmcuIFssICwgLCBhXSkgYW5kXG4gICAgICAjIGVsZW1lbnQgaXNuJ3QgYEVsaXNpb25gIG9yIGxhc3QgZWxlbWVudCBpcyBgRWxpc2lvbmAgKGUuZy4gW2EsLGIsLF0pXG4gICAgICBpZiBpbmRleCBpc250IDAgYW5kIHBhc3NlZEVsaXNpb24gYW5kIChub3QgZnJhZ21lbnRJc0VsaXNpb24oZnJhZ21lbnRzKSBvciBpbmRleCBpcyBvbGVuIC0gMSlcbiAgICAgICAgYW5zd2VyLnB1c2ggQG1ha2VDb2RlICcsICdcbiAgICAgIHBhc3NlZEVsaXNpb24gPSBwYXNzZWRFbGlzaW9uIG9yIG5vdCBmcmFnbWVudElzRWxpc2lvbiBmcmFnbWVudHNcbiAgICAgIGFuc3dlci5wdXNoIGZyYWdtZW50cy4uLlxuICAgIGlmIGluY2x1ZGVzTGluZUNvbW1lbnRzT25Ob25GaXJzdEVsZW1lbnQgb3IgJ1xcbicgaW4gZnJhZ21lbnRzVG9UZXh0KGFuc3dlcilcbiAgICAgIGZvciBmcmFnbWVudCwgZnJhZ21lbnRJbmRleCBpbiBhbnN3ZXJcbiAgICAgICAgaWYgZnJhZ21lbnQuaXNIZXJlQ29tbWVudFxuICAgICAgICAgIGZyYWdtZW50LmNvZGUgPSBcIiN7bXVsdGlkZW50KGZyYWdtZW50LmNvZGUsIG8uaW5kZW50LCBubyl9XFxuI3tvLmluZGVudH1cIlxuICAgICAgICBlbHNlIGlmIGZyYWdtZW50LmNvZGUgaXMgJywgJyBhbmQgbm90IGZyYWdtZW50Py5pc0VsaXNpb24gYW5kIGZyYWdtZW50LnR5cGUgbm90IGluIFsnU3RyaW5nTGl0ZXJhbCcsICdTdHJpbmdXaXRoSW50ZXJwb2xhdGlvbnMnXVxuICAgICAgICAgIGZyYWdtZW50LmNvZGUgPSBcIixcXG4je28uaW5kZW50fVwiXG4gICAgICBhbnN3ZXIudW5zaGlmdCBAbWFrZUNvZGUgXCJbXFxuI3tvLmluZGVudH1cIlxuICAgICAgYW5zd2VyLnB1c2ggQG1ha2VDb2RlIFwiXFxuI3tAdGFifV1cIlxuICAgIGVsc2VcbiAgICAgIGZvciBmcmFnbWVudCBpbiBhbnN3ZXIgd2hlbiBmcmFnbWVudC5pc0hlcmVDb21tZW50XG4gICAgICAgIGZyYWdtZW50LmNvZGUgPSBcIiN7ZnJhZ21lbnQuY29kZX0gXCJcbiAgICAgIGFuc3dlci51bnNoaWZ0IEBtYWtlQ29kZSAnWydcbiAgICAgIGFuc3dlci5wdXNoIEBtYWtlQ29kZSAnXSdcbiAgICBhbnN3ZXJcblxuICBhc3NpZ25zOiAobmFtZSkgLT5cbiAgICBmb3Igb2JqIGluIEBvYmplY3RzIHdoZW4gb2JqLmFzc2lnbnMgbmFtZSB0aGVuIHJldHVybiB5ZXNcbiAgICBub1xuXG4gIGVhY2hOYW1lOiAoaXRlcmF0b3IpIC0+XG4gICAgZm9yIG9iaiBpbiBAb2JqZWN0c1xuICAgICAgb2JqID0gb2JqLnVud3JhcEFsbCgpXG4gICAgICBvYmouZWFjaE5hbWUgaXRlcmF0b3JcblxuICAjIElmIHRoaXMgYXJyYXkgaXMgdGhlIGxlZnQtaGFuZCBzaWRlIG9mIGFuIGFzc2lnbm1lbnQsIGFsbCBpdHMgY2hpbGRyZW5cbiAgIyBhcmUgdG9vLlxuICBwcm9wYWdhdGVMaHM6IChzZXRMaHMpIC0+XG4gICAgQGxocyA9IHllcyBpZiBzZXRMaHNcbiAgICByZXR1cm4gdW5sZXNzIEBsaHNcbiAgICBmb3Igb2JqZWN0IGluIEBvYmplY3RzXG4gICAgICBvYmplY3QubGhzID0geWVzIGlmIG9iamVjdCBpbnN0YW5jZW9mIFNwbGF0IG9yIG9iamVjdCBpbnN0YW5jZW9mIEV4cGFuc2lvblxuICAgICAgdW53cmFwcGVkT2JqZWN0ID0gb2JqZWN0LnVud3JhcEFsbCgpXG4gICAgICBpZiB1bndyYXBwZWRPYmplY3QgaW5zdGFuY2VvZiBBcnIgb3IgdW53cmFwcGVkT2JqZWN0IGluc3RhbmNlb2YgT2JqXG4gICAgICAgIHVud3JhcHBlZE9iamVjdC5wcm9wYWdhdGVMaHMgeWVzXG4gICAgICBlbHNlIGlmIHVud3JhcHBlZE9iamVjdCBpbnN0YW5jZW9mIEFzc2lnblxuICAgICAgICB1bndyYXBwZWRPYmplY3QubmVzdGVkTGhzID0geWVzXG5cbiAgYXN0VHlwZTogLT5cbiAgICBpZiBAbGhzXG4gICAgICAnQXJyYXlQYXR0ZXJuJ1xuICAgIGVsc2VcbiAgICAgICdBcnJheUV4cHJlc3Npb24nXG5cbiAgYXN0UHJvcGVydGllczogKG8pIC0+XG4gICAgcmV0dXJuXG4gICAgICBlbGVtZW50czpcbiAgICAgICAgb2JqZWN0LmFzdChvLCBMRVZFTF9MSVNUKSBmb3Igb2JqZWN0IGluIEBvYmplY3RzXG5cbiMjIyMgQ2xhc3NcblxuIyBUaGUgQ29mZmVlU2NyaXB0IGNsYXNzIGRlZmluaXRpb24uXG4jIEluaXRpYWxpemUgYSAqKkNsYXNzKiogd2l0aCBpdHMgbmFtZSwgYW4gb3B0aW9uYWwgc3VwZXJjbGFzcywgYW5kIGEgYm9keS5cblxuZXhwb3J0cy5DbGFzcyA9IGNsYXNzIENsYXNzIGV4dGVuZHMgQmFzZVxuICBjaGlsZHJlbjogWyd2YXJpYWJsZScsICdwYXJlbnQnLCAnYm9keSddXG5cbiAgY29uc3RydWN0b3I6IChAdmFyaWFibGUsIEBwYXJlbnQsIEBib2R5KSAtPlxuICAgIHN1cGVyKClcbiAgICB1bmxlc3MgQGJvZHk/XG4gICAgICBAYm9keSA9IG5ldyBCbG9ja1xuICAgICAgQGhhc0dlbmVyYXRlZEJvZHkgPSB5ZXNcblxuICBjb21waWxlTm9kZTogKG8pIC0+XG4gICAgQG5hbWUgICAgICAgICAgPSBAZGV0ZXJtaW5lTmFtZSgpXG4gICAgZXhlY3V0YWJsZUJvZHkgPSBAd2Fsa0JvZHkgb1xuXG4gICAgIyBTcGVjaWFsIGhhbmRsaW5nIHRvIGFsbG93IGBjbGFzcyBleHByLkEgZXh0ZW5kcyBBYCBkZWNsYXJhdGlvbnNcbiAgICBwYXJlbnROYW1lICAgID0gQHBhcmVudC5iYXNlLnZhbHVlIGlmIEBwYXJlbnQgaW5zdGFuY2VvZiBWYWx1ZSBhbmQgbm90IEBwYXJlbnQuaGFzUHJvcGVydGllcygpXG4gICAgQGhhc05hbWVDbGFzaCA9IEBuYW1lPyBhbmQgQG5hbWUgaXMgcGFyZW50TmFtZVxuXG4gICAgbm9kZSA9IEBcblxuICAgIGlmIGV4ZWN1dGFibGVCb2R5IG9yIEBoYXNOYW1lQ2xhc2hcbiAgICAgIG5vZGUgPSBuZXcgRXhlY3V0YWJsZUNsYXNzQm9keSBub2RlLCBleGVjdXRhYmxlQm9keVxuICAgIGVsc2UgaWYgbm90IEBuYW1lPyBhbmQgby5sZXZlbCBpcyBMRVZFTF9UT1BcbiAgICAgICMgQW5vbnltb3VzIGNsYXNzZXMgYXJlIG9ubHkgdmFsaWQgaW4gZXhwcmVzc2lvbnNcbiAgICAgIG5vZGUgPSBuZXcgUGFyZW5zIG5vZGVcblxuICAgIGlmIEBib3VuZE1ldGhvZHMubGVuZ3RoIGFuZCBAcGFyZW50XG4gICAgICBAdmFyaWFibGUgPz0gbmV3IElkZW50aWZpZXJMaXRlcmFsIG8uc2NvcGUuZnJlZVZhcmlhYmxlICdfY2xhc3MnXG4gICAgICBbQHZhcmlhYmxlLCBAdmFyaWFibGVSZWZdID0gQHZhcmlhYmxlLmNhY2hlIG8gdW5sZXNzIEB2YXJpYWJsZVJlZj9cblxuICAgIGlmIEB2YXJpYWJsZVxuICAgICAgbm9kZSA9IG5ldyBBc3NpZ24gQHZhcmlhYmxlLCBub2RlLCBudWxsLCB7IEBtb2R1bGVEZWNsYXJhdGlvbiB9XG5cbiAgICBAY29tcGlsZU5vZGUgPSBAY29tcGlsZUNsYXNzRGVjbGFyYXRpb25cbiAgICB0cnlcbiAgICAgIHJldHVybiBub2RlLmNvbXBpbGVUb0ZyYWdtZW50cyBvXG4gICAgZmluYWxseVxuICAgICAgZGVsZXRlIEBjb21waWxlTm9kZVxuXG4gIGNvbXBpbGVDbGFzc0RlY2xhcmF0aW9uOiAobykgLT5cbiAgICBAY3RvciA/PSBAbWFrZURlZmF1bHRDb25zdHJ1Y3RvcigpIGlmIEBleHRlcm5hbEN0b3Igb3IgQGJvdW5kTWV0aG9kcy5sZW5ndGhcbiAgICBAY3Rvcj8ubm9SZXR1cm4gPSB0cnVlXG5cbiAgICBAcHJveHlCb3VuZE1ldGhvZHMoKSBpZiBAYm91bmRNZXRob2RzLmxlbmd0aFxuXG4gICAgby5pbmRlbnQgKz0gVEFCXG5cbiAgICByZXN1bHQgPSBbXVxuICAgIHJlc3VsdC5wdXNoIEBtYWtlQ29kZSBcImNsYXNzIFwiXG4gICAgcmVzdWx0LnB1c2ggQG1ha2VDb2RlIEBuYW1lIGlmIEBuYW1lXG4gICAgQGNvbXBpbGVDb21tZW50RnJhZ21lbnRzIG8sIEB2YXJpYWJsZSwgcmVzdWx0IGlmIEB2YXJpYWJsZT8uY29tbWVudHM/XG4gICAgcmVzdWx0LnB1c2ggQG1ha2VDb2RlICcgJyBpZiBAbmFtZVxuICAgIHJlc3VsdC5wdXNoIEBtYWtlQ29kZSgnZXh0ZW5kcyAnKSwgQHBhcmVudC5jb21waWxlVG9GcmFnbWVudHMobykuLi4sIEBtYWtlQ29kZSAnICcgaWYgQHBhcmVudFxuXG4gICAgcmVzdWx0LnB1c2ggQG1ha2VDb2RlICd7J1xuICAgIHVubGVzcyBAYm9keS5pc0VtcHR5KClcbiAgICAgIEBib2R5LnNwYWNlZCA9IHRydWVcbiAgICAgIHJlc3VsdC5wdXNoIEBtYWtlQ29kZSAnXFxuJ1xuICAgICAgcmVzdWx0LnB1c2ggQGJvZHkuY29tcGlsZVRvRnJhZ21lbnRzKG8sIExFVkVMX1RPUCkuLi5cbiAgICAgIHJlc3VsdC5wdXNoIEBtYWtlQ29kZSBcIlxcbiN7QHRhYn1cIlxuICAgIHJlc3VsdC5wdXNoIEBtYWtlQ29kZSAnfSdcblxuICAgIHJlc3VsdFxuXG4gICMgRmlndXJlIG91dCB0aGUgYXBwcm9wcmlhdGUgbmFtZSBmb3IgdGhpcyBjbGFzc1xuICBkZXRlcm1pbmVOYW1lOiAtPlxuICAgIHJldHVybiBudWxsIHVubGVzcyBAdmFyaWFibGVcbiAgICBbLi4uLCB0YWlsXSA9IEB2YXJpYWJsZS5wcm9wZXJ0aWVzXG4gICAgbm9kZSA9IGlmIHRhaWxcbiAgICAgIHRhaWwgaW5zdGFuY2VvZiBBY2Nlc3MgYW5kIHRhaWwubmFtZVxuICAgIGVsc2VcbiAgICAgIEB2YXJpYWJsZS5iYXNlXG4gICAgdW5sZXNzIG5vZGUgaW5zdGFuY2VvZiBJZGVudGlmaWVyTGl0ZXJhbCBvciBub2RlIGluc3RhbmNlb2YgUHJvcGVydHlOYW1lXG4gICAgICByZXR1cm4gbnVsbFxuICAgIG5hbWUgPSBub2RlLnZhbHVlXG4gICAgdW5sZXNzIHRhaWxcbiAgICAgIG1lc3NhZ2UgPSBpc1VuYXNzaWduYWJsZSBuYW1lXG4gICAgICBAdmFyaWFibGUuZXJyb3IgbWVzc2FnZSBpZiBtZXNzYWdlXG4gICAgaWYgbmFtZSBpbiBKU19GT1JCSURERU4gdGhlbiBcIl8je25hbWV9XCIgZWxzZSBuYW1lXG5cbiAgd2Fsa0JvZHk6IChvKSAtPlxuICAgIEBjdG9yICAgICAgICAgID0gbnVsbFxuICAgIEBib3VuZE1ldGhvZHMgID0gW11cbiAgICBleGVjdXRhYmxlQm9keSA9IG51bGxcblxuICAgIGluaXRpYWxpemVyICAgICA9IFtdXG4gICAgeyBleHByZXNzaW9ucyB9ID0gQGJvZHlcblxuICAgIGkgPSAwXG4gICAgZm9yIGV4cHJlc3Npb24gaW4gZXhwcmVzc2lvbnMuc2xpY2UoKVxuICAgICAgaWYgZXhwcmVzc2lvbiBpbnN0YW5jZW9mIFZhbHVlIGFuZCBleHByZXNzaW9uLmlzT2JqZWN0IHRydWVcbiAgICAgICAgeyBwcm9wZXJ0aWVzIH0gPSBleHByZXNzaW9uLmJhc2VcbiAgICAgICAgZXhwcnMgICAgID0gW11cbiAgICAgICAgZW5kICAgICAgID0gMFxuICAgICAgICBzdGFydCAgICAgPSAwXG4gICAgICAgIHB1c2hTbGljZSA9IC0+IGV4cHJzLnB1c2ggbmV3IFZhbHVlIG5ldyBPYmogcHJvcGVydGllc1tzdGFydC4uLmVuZF0sIHRydWUgaWYgZW5kID4gc3RhcnRcblxuICAgICAgICB3aGlsZSBhc3NpZ24gPSBwcm9wZXJ0aWVzW2VuZF1cbiAgICAgICAgICBpZiBpbml0aWFsaXplckV4cHJlc3Npb24gPSBAYWRkSW5pdGlhbGl6ZXJFeHByZXNzaW9uIGFzc2lnbiwgb1xuICAgICAgICAgICAgcHVzaFNsaWNlKClcbiAgICAgICAgICAgIGV4cHJzLnB1c2ggaW5pdGlhbGl6ZXJFeHByZXNzaW9uXG4gICAgICAgICAgICBpbml0aWFsaXplci5wdXNoIGluaXRpYWxpemVyRXhwcmVzc2lvblxuICAgICAgICAgICAgc3RhcnQgPSBlbmQgKyAxXG4gICAgICAgICAgZW5kKytcbiAgICAgICAgcHVzaFNsaWNlKClcblxuICAgICAgICBleHByZXNzaW9uc1tpLi5pXSA9IGV4cHJzXG4gICAgICAgIGkgKz0gZXhwcnMubGVuZ3RoXG4gICAgICBlbHNlXG4gICAgICAgIGlmIGluaXRpYWxpemVyRXhwcmVzc2lvbiA9IEBhZGRJbml0aWFsaXplckV4cHJlc3Npb24gZXhwcmVzc2lvbiwgb1xuICAgICAgICAgIGluaXRpYWxpemVyLnB1c2ggaW5pdGlhbGl6ZXJFeHByZXNzaW9uXG4gICAgICAgICAgZXhwcmVzc2lvbnNbaV0gPSBpbml0aWFsaXplckV4cHJlc3Npb25cbiAgICAgICAgaSArPSAxXG5cbiAgICBmb3IgbWV0aG9kIGluIGluaXRpYWxpemVyIHdoZW4gbWV0aG9kIGluc3RhbmNlb2YgQ29kZVxuICAgICAgaWYgbWV0aG9kLmN0b3JcbiAgICAgICAgbWV0aG9kLmVycm9yICdDYW5ub3QgZGVmaW5lIG1vcmUgdGhhbiBvbmUgY29uc3RydWN0b3IgaW4gYSBjbGFzcycgaWYgQGN0b3JcbiAgICAgICAgQGN0b3IgPSBtZXRob2RcbiAgICAgIGVsc2UgaWYgbWV0aG9kLmlzU3RhdGljIGFuZCBtZXRob2QuYm91bmRcbiAgICAgICAgbWV0aG9kLmNvbnRleHQgPSBAbmFtZVxuICAgICAgZWxzZSBpZiBtZXRob2QuYm91bmRcbiAgICAgICAgQGJvdW5kTWV0aG9kcy5wdXNoIG1ldGhvZFxuXG4gICAgcmV0dXJuIHVubGVzcyBvLmNvbXBpbGluZ1xuICAgIGlmIGluaXRpYWxpemVyLmxlbmd0aCBpc250IGV4cHJlc3Npb25zLmxlbmd0aFxuICAgICAgQGJvZHkuZXhwcmVzc2lvbnMgPSAoZXhwcmVzc2lvbi5ob2lzdCgpIGZvciBleHByZXNzaW9uIGluIGluaXRpYWxpemVyKVxuICAgICAgbmV3IEJsb2NrIGV4cHJlc3Npb25zXG5cbiAgIyBBZGQgYW4gZXhwcmVzc2lvbiB0byB0aGUgY2xhc3MgaW5pdGlhbGl6ZXJcbiAgI1xuICAjIFRoaXMgaXMgdGhlIGtleSBtZXRob2QgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgYW4gZXhwcmVzc2lvbiBpbiBhIGNsYXNzXG4gICMgYm9keSBzaG91bGQgYXBwZWFyIGluIHRoZSBpbml0aWFsaXplciBvciB0aGUgZXhlY3V0YWJsZSBib2R5LiBJZiB0aGUgZ2l2ZW5cbiAgIyBgbm9kZWAgaXMgdmFsaWQgaW4gYSBjbGFzcyBib2R5IHRoZSBtZXRob2Qgd2lsbCByZXR1cm4gYSAobmV3LCBtb2RpZmllZCxcbiAgIyBvciBpZGVudGljYWwpIG5vZGUgZm9yIGluY2x1c2lvbiBpbiB0aGUgY2xhc3MgaW5pdGlhbGl6ZXIsIG90aGVyd2lzZVxuICAjIG5vdGhpbmcgd2lsbCBiZSByZXR1cm5lZCBhbmQgdGhlIG5vZGUgd2lsbCBhcHBlYXIgaW4gdGhlIGV4ZWN1dGFibGUgYm9keS5cbiAgI1xuICAjIEF0IHRpbWUgb2Ygd3JpdGluZywgb25seSBtZXRob2RzIChpbnN0YW5jZSBhbmQgc3RhdGljKSBhcmUgdmFsaWQgaW4gRVNcbiAgIyBjbGFzcyBpbml0aWFsaXplcnMuIEFzIG5ldyBFUyBjbGFzcyBmZWF0dXJlcyAoc3VjaCBhcyBjbGFzcyBmaWVsZHMpIHJlYWNoXG4gICMgU3RhZ2UgNCwgdGhpcyBtZXRob2Qgd2lsbCBuZWVkIHRvIGJlIHVwZGF0ZWQgdG8gc3VwcG9ydCB0aGVtLiBXZVxuICAjIGFkZGl0aW9uYWxseSBhbGxvdyBgUGFzc3Rocm91Z2hMaXRlcmFsYHMgKGJhY2t0aWNrZWQgZXhwcmVzc2lvbnMpIGluIHRoZVxuICAjIGluaXRpYWxpemVyIGFzIGFuIGVzY2FwZSBoYXRjaCBmb3IgRVMgZmVhdHVyZXMgdGhhdCBhcmUgbm90IGltcGxlbWVudGVkXG4gICMgKGUuZy4gZ2V0dGVycyBhbmQgc2V0dGVycyBkZWZpbmVkIHZpYSB0aGUgYGdldGAgYW5kIGBzZXRgIGtleXdvcmRzIGFzXG4gICMgb3Bwb3NlZCB0byB0aGUgYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kKS5cbiAgYWRkSW5pdGlhbGl6ZXJFeHByZXNzaW9uOiAobm9kZSwgbykgLT5cbiAgICBpZiBub2RlLnVud3JhcEFsbCgpIGluc3RhbmNlb2YgUGFzc3Rocm91Z2hMaXRlcmFsXG4gICAgICBub2RlXG4gICAgZWxzZSBpZiBAdmFsaWRJbml0aWFsaXplck1ldGhvZCBub2RlXG4gICAgICBAYWRkSW5pdGlhbGl6ZXJNZXRob2Qgbm9kZVxuICAgIGVsc2UgaWYgbm90IG8uY29tcGlsaW5nIGFuZCBAdmFsaWRDbGFzc1Byb3BlcnR5IG5vZGVcbiAgICAgIEBhZGRDbGFzc1Byb3BlcnR5IG5vZGVcbiAgICBlbHNlIGlmIG5vdCBvLmNvbXBpbGluZyBhbmQgQHZhbGlkQ2xhc3NQcm90b3R5cGVQcm9wZXJ0eSBub2RlXG4gICAgICBAYWRkQ2xhc3NQcm90b3R5cGVQcm9wZXJ0eSBub2RlXG4gICAgZWxzZVxuICAgICAgbnVsbFxuXG4gICMgQ2hlY2tzIGlmIHRoZSBnaXZlbiBub2RlIGlzIGEgdmFsaWQgRVMgY2xhc3MgaW5pdGlhbGl6ZXIgbWV0aG9kLlxuICB2YWxpZEluaXRpYWxpemVyTWV0aG9kOiAobm9kZSkgLT5cbiAgICByZXR1cm4gbm8gdW5sZXNzIG5vZGUgaW5zdGFuY2VvZiBBc3NpZ24gYW5kIG5vZGUudmFsdWUgaW5zdGFuY2VvZiBDb2RlXG4gICAgcmV0dXJuIHllcyBpZiBub2RlLmNvbnRleHQgaXMgJ29iamVjdCcgYW5kIG5vdCBub2RlLnZhcmlhYmxlLmhhc1Byb3BlcnRpZXMoKVxuICAgIHJldHVybiBub2RlLnZhcmlhYmxlLmxvb2tzU3RhdGljKEBuYW1lKSBhbmQgKEBuYW1lIG9yIG5vdCBub2RlLnZhbHVlLmJvdW5kKVxuXG4gICMgUmV0dXJucyBhIGNvbmZpZ3VyZWQgY2xhc3MgaW5pdGlhbGl6ZXIgbWV0aG9kXG4gIGFkZEluaXRpYWxpemVyTWV0aG9kOiAoYXNzaWduKSAtPlxuICAgIHsgdmFyaWFibGUsIHZhbHVlOiBtZXRob2QsIG9wZXJhdG9yVG9rZW4gfSA9IGFzc2lnblxuICAgIG1ldGhvZC5pc01ldGhvZCA9IHllc1xuICAgIG1ldGhvZC5pc1N0YXRpYyA9IHZhcmlhYmxlLmxvb2tzU3RhdGljIEBuYW1lXG5cbiAgICBpZiBtZXRob2QuaXNTdGF0aWNcbiAgICAgIG1ldGhvZC5uYW1lID0gdmFyaWFibGUucHJvcGVydGllc1swXVxuICAgIGVsc2VcbiAgICAgIG1ldGhvZE5hbWUgID0gdmFyaWFibGUuYmFzZVxuICAgICAgbWV0aG9kLm5hbWUgPSBuZXcgKGlmIG1ldGhvZE5hbWUuc2hvdWxkQ2FjaGUoKSB0aGVuIEluZGV4IGVsc2UgQWNjZXNzKSBtZXRob2ROYW1lXG4gICAgICBtZXRob2QubmFtZS51cGRhdGVMb2NhdGlvbkRhdGFJZk1pc3NpbmcgbWV0aG9kTmFtZS5sb2NhdGlvbkRhdGFcbiAgICAgIGlzQ29uc3RydWN0b3IgPVxuICAgICAgICBpZiBtZXRob2ROYW1lIGluc3RhbmNlb2YgU3RyaW5nTGl0ZXJhbFxuICAgICAgICAgIG1ldGhvZE5hbWUub3JpZ2luYWxWYWx1ZSBpcyAnY29uc3RydWN0b3InXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBtZXRob2ROYW1lLnZhbHVlIGlzICdjb25zdHJ1Y3RvcidcbiAgICAgIG1ldGhvZC5jdG9yID0gKGlmIEBwYXJlbnQgdGhlbiAnZGVyaXZlZCcgZWxzZSAnYmFzZScpIGlmIGlzQ29uc3RydWN0b3JcbiAgICAgIG1ldGhvZC5lcnJvciAnQ2Fubm90IGRlZmluZSBhIGNvbnN0cnVjdG9yIGFzIGEgYm91bmQgKGZhdCBhcnJvdykgZnVuY3Rpb24nIGlmIG1ldGhvZC5ib3VuZCBhbmQgbWV0aG9kLmN0b3JcblxuICAgIG1ldGhvZC5vcGVyYXRvclRva2VuID0gb3BlcmF0b3JUb2tlblxuICAgIG1ldGhvZFxuXG4gIHZhbGlkQ2xhc3NQcm9wZXJ0eTogKG5vZGUpIC0+XG4gICAgcmV0dXJuIG5vIHVubGVzcyBub2RlIGluc3RhbmNlb2YgQXNzaWduXG4gICAgcmV0dXJuIG5vZGUudmFyaWFibGUubG9va3NTdGF0aWMgQG5hbWVcblxuICBhZGRDbGFzc1Byb3BlcnR5OiAoYXNzaWduKSAtPlxuICAgIHt2YXJpYWJsZSwgdmFsdWUsIG9wZXJhdG9yVG9rZW59ID0gYXNzaWduXG4gICAge3N0YXRpY0NsYXNzTmFtZX0gPSB2YXJpYWJsZS5sb29rc1N0YXRpYyBAbmFtZVxuICAgIG5ldyBDbGFzc1Byb3BlcnR5KHtcbiAgICAgIG5hbWU6IHZhcmlhYmxlLnByb3BlcnRpZXNbMF1cbiAgICAgIGlzU3RhdGljOiB5ZXNcbiAgICAgIHN0YXRpY0NsYXNzTmFtZVxuICAgICAgdmFsdWVcbiAgICAgIG9wZXJhdG9yVG9rZW5cbiAgICB9KS53aXRoTG9jYXRpb25EYXRhRnJvbSBhc3NpZ25cblxuICB2YWxpZENsYXNzUHJvdG90eXBlUHJvcGVydHk6IChub2RlKSAtPlxuICAgIHJldHVybiBubyB1bmxlc3Mgbm9kZSBpbnN0YW5jZW9mIEFzc2lnblxuICAgIG5vZGUuY29udGV4dCBpcyAnb2JqZWN0JyBhbmQgbm90IG5vZGUudmFyaWFibGUuaGFzUHJvcGVydGllcygpXG5cbiAgYWRkQ2xhc3NQcm90b3R5cGVQcm9wZXJ0eTogKGFzc2lnbikgLT5cbiAgICB7dmFyaWFibGUsIHZhbHVlfSA9IGFzc2lnblxuICAgIG5ldyBDbGFzc1Byb3RvdHlwZVByb3BlcnR5KHtcbiAgICAgIG5hbWU6IHZhcmlhYmxlLmJhc2VcbiAgICAgIHZhbHVlXG4gICAgfSkud2l0aExvY2F0aW9uRGF0YUZyb20gYXNzaWduXG5cbiAgbWFrZURlZmF1bHRDb25zdHJ1Y3RvcjogLT5cbiAgICBjdG9yID0gQGFkZEluaXRpYWxpemVyTWV0aG9kIG5ldyBBc3NpZ24gKG5ldyBWYWx1ZSBuZXcgUHJvcGVydHlOYW1lICdjb25zdHJ1Y3RvcicpLCBuZXcgQ29kZVxuICAgIEBib2R5LnVuc2hpZnQgY3RvclxuXG4gICAgaWYgQHBhcmVudFxuICAgICAgY3Rvci5ib2R5LnB1c2ggbmV3IFN1cGVyQ2FsbCBuZXcgU3VwZXIsIFtuZXcgU3BsYXQgbmV3IElkZW50aWZpZXJMaXRlcmFsICdhcmd1bWVudHMnXVxuXG4gICAgaWYgQGV4dGVybmFsQ3RvclxuICAgICAgYXBwbHlDdG9yID0gbmV3IFZhbHVlIEBleHRlcm5hbEN0b3IsIFsgbmV3IEFjY2VzcyBuZXcgUHJvcGVydHlOYW1lICdhcHBseScgXVxuICAgICAgYXBwbHlBcmdzID0gWyBuZXcgVGhpc0xpdGVyYWwsIG5ldyBJZGVudGlmaWVyTGl0ZXJhbCAnYXJndW1lbnRzJyBdXG4gICAgICBjdG9yLmJvZHkucHVzaCBuZXcgQ2FsbCBhcHBseUN0b3IsIGFwcGx5QXJnc1xuICAgICAgY3Rvci5ib2R5Lm1ha2VSZXR1cm4oKVxuXG4gICAgY3RvclxuXG4gIHByb3h5Qm91bmRNZXRob2RzOiAtPlxuICAgIEBjdG9yLnRoaXNBc3NpZ25tZW50cyA9IGZvciBtZXRob2QgaW4gQGJvdW5kTWV0aG9kc1xuICAgICAgbWV0aG9kLmNsYXNzVmFyaWFibGUgPSBAdmFyaWFibGVSZWYgaWYgQHBhcmVudFxuXG4gICAgICBuYW1lID0gbmV3IFZhbHVlKG5ldyBUaGlzTGl0ZXJhbCwgWyBtZXRob2QubmFtZSBdKVxuICAgICAgbmV3IEFzc2lnbiBuYW1lLCBuZXcgQ2FsbChuZXcgVmFsdWUobmFtZSwgW25ldyBBY2Nlc3MgbmV3IFByb3BlcnR5TmFtZSAnYmluZCddKSwgW25ldyBUaGlzTGl0ZXJhbF0pXG5cbiAgICBudWxsXG5cbiAgZGVjbGFyZU5hbWU6IChvKSAtPlxuICAgIHJldHVybiB1bmxlc3MgKG5hbWUgPSBAdmFyaWFibGU/LnVud3JhcCgpKSBpbnN0YW5jZW9mIElkZW50aWZpZXJMaXRlcmFsXG4gICAgYWxyZWFkeURlY2xhcmVkID0gby5zY29wZS5maW5kIG5hbWUudmFsdWVcbiAgICBuYW1lLmlzRGVjbGFyYXRpb24gPSBub3QgYWxyZWFkeURlY2xhcmVkXG5cbiAgaXNTdGF0ZW1lbnRBc3Q6IC0+IHllc1xuXG4gIGFzdE5vZGU6IChvKSAtPlxuICAgIGlmIGp1bXBOb2RlID0gQGJvZHkuanVtcHMoKVxuICAgICAganVtcE5vZGUuZXJyb3IgJ0NsYXNzIGJvZGllcyBjYW5ub3QgY29udGFpbiBwdXJlIHN0YXRlbWVudHMnXG4gICAgaWYgYXJndW1lbnRzTm9kZSA9IEBib2R5LmNvbnRhaW5zIGlzTGl0ZXJhbEFyZ3VtZW50c1xuICAgICAgYXJndW1lbnRzTm9kZS5lcnJvciBcIkNsYXNzIGJvZGllcyBzaG91bGRuJ3QgcmVmZXJlbmNlIGFyZ3VtZW50c1wiXG4gICAgQGRlY2xhcmVOYW1lIG9cbiAgICBAbmFtZSA9IEBkZXRlcm1pbmVOYW1lKClcbiAgICBAYm9keS5pc0NsYXNzQm9keSA9IHllc1xuICAgIEBib2R5LmxvY2F0aW9uRGF0YSA9IHplcm9XaWR0aExvY2F0aW9uRGF0YUZyb21FbmRMb2NhdGlvbiBAbG9jYXRpb25EYXRhIGlmIEBoYXNHZW5lcmF0ZWRCb2R5XG4gICAgQHdhbGtCb2R5IG9cbiAgICBzbmlmZkRpcmVjdGl2ZXMgQGJvZHkuZXhwcmVzc2lvbnNcbiAgICBAY3Rvcj8ubm9SZXR1cm4gPSB5ZXNcblxuICAgIHN1cGVyIG9cblxuICBhc3RUeXBlOiAobykgLT5cbiAgICBpZiBvLmxldmVsIGlzIExFVkVMX1RPUFxuICAgICAgJ0NsYXNzRGVjbGFyYXRpb24nXG4gICAgZWxzZVxuICAgICAgJ0NsYXNzRXhwcmVzc2lvbidcblxuICBhc3RQcm9wZXJ0aWVzOiAobykgLT5cbiAgICByZXR1cm5cbiAgICAgIGlkOiBAdmFyaWFibGU/LmFzdChvKSA/IG51bGxcbiAgICAgIHN1cGVyQ2xhc3M6IEBwYXJlbnQ/LmFzdChvLCBMRVZFTF9QQVJFTikgPyBudWxsXG4gICAgICBib2R5OiBAYm9keS5hc3QgbywgTEVWRUxfVE9QXG5cbmV4cG9ydHMuRXhlY3V0YWJsZUNsYXNzQm9keSA9IGNsYXNzIEV4ZWN1dGFibGVDbGFzc0JvZHkgZXh0ZW5kcyBCYXNlXG4gIGNoaWxkcmVuOiBbICdjbGFzcycsICdib2R5JyBdXG5cbiAgZGVmYXVsdENsYXNzVmFyaWFibGVOYW1lOiAnX0NsYXNzJ1xuXG4gIGNvbnN0cnVjdG9yOiAoQGNsYXNzLCBAYm9keSA9IG5ldyBCbG9jaykgLT5cbiAgICBzdXBlcigpXG5cbiAgY29tcGlsZU5vZGU6IChvKSAtPlxuICAgIGlmIGp1bXBOb2RlID0gQGJvZHkuanVtcHMoKVxuICAgICAganVtcE5vZGUuZXJyb3IgJ0NsYXNzIGJvZGllcyBjYW5ub3QgY29udGFpbiBwdXJlIHN0YXRlbWVudHMnXG4gICAgaWYgYXJndW1lbnRzTm9kZSA9IEBib2R5LmNvbnRhaW5zIGlzTGl0ZXJhbEFyZ3VtZW50c1xuICAgICAgYXJndW1lbnRzTm9kZS5lcnJvciBcIkNsYXNzIGJvZGllcyBzaG91bGRuJ3QgcmVmZXJlbmNlIGFyZ3VtZW50c1wiXG5cbiAgICBwYXJhbXMgID0gW11cbiAgICBhcmdzICAgID0gW25ldyBUaGlzTGl0ZXJhbF1cbiAgICB3cmFwcGVyID0gbmV3IENvZGUgcGFyYW1zLCBAYm9keVxuICAgIGtsYXNzICAgPSBuZXcgUGFyZW5zIG5ldyBDYWxsIChuZXcgVmFsdWUgd3JhcHBlciwgW25ldyBBY2Nlc3MgbmV3IFByb3BlcnR5TmFtZSAnY2FsbCddKSwgYXJnc1xuXG4gICAgQGJvZHkuc3BhY2VkID0gdHJ1ZVxuXG4gICAgby5jbGFzc1Njb3BlID0gd3JhcHBlci5tYWtlU2NvcGUgby5zY29wZVxuXG4gICAgQG5hbWUgICAgICA9IEBjbGFzcy5uYW1lID8gby5jbGFzc1Njb3BlLmZyZWVWYXJpYWJsZSBAZGVmYXVsdENsYXNzVmFyaWFibGVOYW1lXG4gICAgaWRlbnQgICAgICA9IG5ldyBJZGVudGlmaWVyTGl0ZXJhbCBAbmFtZVxuICAgIGRpcmVjdGl2ZXMgPSBAd2Fsa0JvZHkoKVxuICAgIEBzZXRDb250ZXh0KClcblxuICAgIGlmIEBjbGFzcy5oYXNOYW1lQ2xhc2hcbiAgICAgIHBhcmVudCA9IG5ldyBJZGVudGlmaWVyTGl0ZXJhbCBvLmNsYXNzU2NvcGUuZnJlZVZhcmlhYmxlICdzdXBlckNsYXNzJ1xuICAgICAgd3JhcHBlci5wYXJhbXMucHVzaCBuZXcgUGFyYW0gcGFyZW50XG4gICAgICBhcmdzLnB1c2ggQGNsYXNzLnBhcmVudFxuICAgICAgQGNsYXNzLnBhcmVudCA9IHBhcmVudFxuXG4gICAgaWYgQGV4dGVybmFsQ3RvclxuICAgICAgZXh0ZXJuYWxDdG9yID0gbmV3IElkZW50aWZpZXJMaXRlcmFsIG8uY2xhc3NTY29wZS5mcmVlVmFyaWFibGUgJ2N0b3InLCByZXNlcnZlOiBub1xuICAgICAgQGNsYXNzLmV4dGVybmFsQ3RvciA9IGV4dGVybmFsQ3RvclxuICAgICAgQGV4dGVybmFsQ3Rvci52YXJpYWJsZS5iYXNlID0gZXh0ZXJuYWxDdG9yXG5cbiAgICBpZiBAbmFtZSBpc250IEBjbGFzcy5uYW1lXG4gICAgICBAYm9keS5leHByZXNzaW9ucy51bnNoaWZ0IG5ldyBBc3NpZ24gKG5ldyBJZGVudGlmaWVyTGl0ZXJhbCBAbmFtZSksIEBjbGFzc1xuICAgIGVsc2VcbiAgICAgIEBib2R5LmV4cHJlc3Npb25zLnVuc2hpZnQgQGNsYXNzXG4gICAgQGJvZHkuZXhwcmVzc2lvbnMudW5zaGlmdCBkaXJlY3RpdmVzLi4uXG4gICAgQGJvZHkucHVzaCBpZGVudFxuXG4gICAga2xhc3MuY29tcGlsZVRvRnJhZ21lbnRzIG9cblxuICAjIFRyYXZlcnNlIHRoZSBjbGFzcydzIGNoaWxkcmVuIGFuZDpcbiAgIyAtIEhvaXN0IHZhbGlkIEVTIHByb3BlcnRpZXMgaW50byBgQHByb3BlcnRpZXNgXG4gICMgLSBIb2lzdCBzdGF0aWMgYXNzaWdubWVudHMgaW50byBgQHByb3BlcnRpZXNgXG4gICMgLSBDb252ZXJ0IGludmFsaWQgRVMgcHJvcGVydGllcyBpbnRvIGNsYXNzIG9yIHByb3RvdHlwZSBhc3NpZ25tZW50c1xuICB3YWxrQm9keTogLT5cbiAgICBkaXJlY3RpdmVzICA9IFtdXG5cbiAgICBpbmRleCA9IDBcbiAgICB3aGlsZSBleHByID0gQGJvZHkuZXhwcmVzc2lvbnNbaW5kZXhdXG4gICAgICBicmVhayB1bmxlc3MgZXhwciBpbnN0YW5jZW9mIFZhbHVlIGFuZCBleHByLmlzU3RyaW5nKClcbiAgICAgIGlmIGV4cHIuaG9pc3RlZFxuICAgICAgICBpbmRleCsrXG4gICAgICBlbHNlXG4gICAgICAgIGRpcmVjdGl2ZXMucHVzaCBAYm9keS5leHByZXNzaW9ucy5zcGxpY2UoaW5kZXgsIDEpLi4uXG5cbiAgICBAdHJhdmVyc2VDaGlsZHJlbiBmYWxzZSwgKGNoaWxkKSA9PlxuICAgICAgcmV0dXJuIGZhbHNlIGlmIGNoaWxkIGluc3RhbmNlb2YgQ2xhc3Mgb3IgY2hpbGQgaW5zdGFuY2VvZiBIb2lzdFRhcmdldFxuXG4gICAgICBjb250ID0gdHJ1ZVxuICAgICAgaWYgY2hpbGQgaW5zdGFuY2VvZiBCbG9ja1xuICAgICAgICBmb3Igbm9kZSwgaSBpbiBjaGlsZC5leHByZXNzaW9uc1xuICAgICAgICAgIGlmIG5vZGUgaW5zdGFuY2VvZiBWYWx1ZSBhbmQgbm9kZS5pc09iamVjdCh0cnVlKVxuICAgICAgICAgICAgY29udCA9IGZhbHNlXG4gICAgICAgICAgICBjaGlsZC5leHByZXNzaW9uc1tpXSA9IEBhZGRQcm9wZXJ0aWVzIG5vZGUuYmFzZS5wcm9wZXJ0aWVzXG4gICAgICAgICAgZWxzZSBpZiBub2RlIGluc3RhbmNlb2YgQXNzaWduIGFuZCBub2RlLnZhcmlhYmxlLmxvb2tzU3RhdGljIEBuYW1lXG4gICAgICAgICAgICBub2RlLnZhbHVlLmlzU3RhdGljID0geWVzXG4gICAgICAgIGNoaWxkLmV4cHJlc3Npb25zID0gZmxhdHRlbiBjaGlsZC5leHByZXNzaW9uc1xuICAgICAgY29udFxuXG4gICAgZGlyZWN0aXZlc1xuXG4gIHNldENvbnRleHQ6IC0+XG4gICAgQGJvZHkudHJhdmVyc2VDaGlsZHJlbiBmYWxzZSwgKG5vZGUpID0+XG4gICAgICBpZiBub2RlIGluc3RhbmNlb2YgVGhpc0xpdGVyYWxcbiAgICAgICAgbm9kZS52YWx1ZSAgID0gQG5hbWVcbiAgICAgIGVsc2UgaWYgbm9kZSBpbnN0YW5jZW9mIENvZGUgYW5kIG5vZGUuYm91bmQgYW5kIChub2RlLmlzU3RhdGljIG9yIG5vdCBub2RlLm5hbWUpXG4gICAgICAgIG5vZGUuY29udGV4dCA9IEBuYW1lXG5cbiAgIyBNYWtlIGNsYXNzL3Byb3RvdHlwZSBhc3NpZ25tZW50cyBmb3IgaW52YWxpZCBFUyBwcm9wZXJ0aWVzXG4gIGFkZFByb3BlcnRpZXM6IChhc3NpZ25zKSAtPlxuICAgIHJlc3VsdCA9IGZvciBhc3NpZ24gaW4gYXNzaWduc1xuICAgICAgdmFyaWFibGUgPSBhc3NpZ24udmFyaWFibGVcbiAgICAgIGJhc2UgICAgID0gdmFyaWFibGU/LmJhc2VcbiAgICAgIHZhbHVlICAgID0gYXNzaWduLnZhbHVlXG4gICAgICBkZWxldGUgYXNzaWduLmNvbnRleHRcblxuICAgICAgaWYgYmFzZS52YWx1ZSBpcyAnY29uc3RydWN0b3InXG4gICAgICAgIGlmIHZhbHVlIGluc3RhbmNlb2YgQ29kZVxuICAgICAgICAgIGJhc2UuZXJyb3IgJ2NvbnN0cnVjdG9ycyBtdXN0IGJlIGRlZmluZWQgYXQgdGhlIHRvcCBsZXZlbCBvZiBhIGNsYXNzIGJvZHknXG5cbiAgICAgICAgIyBUaGUgY2xhc3Mgc2NvcGUgaXMgbm90IGF2YWlsYWJsZSB5ZXQsIHNvIHJldHVybiB0aGUgYXNzaWdubWVudCB0byB1cGRhdGUgbGF0ZXJcbiAgICAgICAgYXNzaWduID0gQGV4dGVybmFsQ3RvciA9IG5ldyBBc3NpZ24gbmV3IFZhbHVlLCB2YWx1ZVxuICAgICAgZWxzZSBpZiBub3QgYXNzaWduLnZhcmlhYmxlLnRoaXNcbiAgICAgICAgbmFtZSA9XG4gICAgICAgICAgaWYgYmFzZSBpbnN0YW5jZW9mIENvbXB1dGVkUHJvcGVydHlOYW1lXG4gICAgICAgICAgICBuZXcgSW5kZXggYmFzZS52YWx1ZVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG5ldyAoaWYgYmFzZS5zaG91bGRDYWNoZSgpIHRoZW4gSW5kZXggZWxzZSBBY2Nlc3MpIGJhc2VcbiAgICAgICAgcHJvdG90eXBlID0gbmV3IEFjY2VzcyBuZXcgUHJvcGVydHlOYW1lICdwcm90b3R5cGUnXG4gICAgICAgIHZhcmlhYmxlICA9IG5ldyBWYWx1ZSBuZXcgVGhpc0xpdGVyYWwoKSwgWyBwcm90b3R5cGUsIG5hbWUgXVxuXG4gICAgICAgIGFzc2lnbi52YXJpYWJsZSA9IHZhcmlhYmxlXG4gICAgICBlbHNlIGlmIGFzc2lnbi52YWx1ZSBpbnN0YW5jZW9mIENvZGVcbiAgICAgICAgYXNzaWduLnZhbHVlLmlzU3RhdGljID0gdHJ1ZVxuXG4gICAgICBhc3NpZ25cbiAgICBjb21wYWN0IHJlc3VsdFxuXG5leHBvcnRzLkNsYXNzUHJvcGVydHkgPSBjbGFzcyBDbGFzc1Byb3BlcnR5IGV4dGVuZHMgQmFzZVxuICBjb25zdHJ1Y3RvcjogKHtAbmFtZSwgQGlzU3RhdGljLCBAc3RhdGljQ2xhc3NOYW1lLCBAdmFsdWUsIEBvcGVyYXRvclRva2VufSkgLT5cbiAgICBzdXBlcigpXG5cbiAgY2hpbGRyZW46IFsnbmFtZScsICd2YWx1ZScsICdzdGF0aWNDbGFzc05hbWUnXVxuXG4gIGlzU3RhdGVtZW50OiBZRVNcblxuICBhc3RQcm9wZXJ0aWVzOiAobykgLT5cbiAgICByZXR1cm5cbiAgICAgIGtleTogQG5hbWUuYXN0IG8sIExFVkVMX0xJU1RcbiAgICAgIHZhbHVlOiBAdmFsdWUuYXN0IG8sIExFVkVMX0xJU1RcbiAgICAgIHN0YXRpYzogISFAaXNTdGF0aWNcbiAgICAgIGNvbXB1dGVkOiBAbmFtZSBpbnN0YW5jZW9mIEluZGV4IG9yIEBuYW1lIGluc3RhbmNlb2YgQ29tcHV0ZWRQcm9wZXJ0eU5hbWVcbiAgICAgIG9wZXJhdG9yOiBAb3BlcmF0b3JUb2tlbj8udmFsdWUgPyAnPSdcbiAgICAgIHN0YXRpY0NsYXNzTmFtZTogQHN0YXRpY0NsYXNzTmFtZT8uYXN0KG8pID8gbnVsbFxuXG5leHBvcnRzLkNsYXNzUHJvdG90eXBlUHJvcGVydHkgPSBjbGFzcyBDbGFzc1Byb3RvdHlwZVByb3BlcnR5IGV4dGVuZHMgQmFzZVxuICBjb25zdHJ1Y3RvcjogKHtAbmFtZSwgQHZhbHVlfSkgLT5cbiAgICBzdXBlcigpXG5cbiAgY2hpbGRyZW46IFsnbmFtZScsICd2YWx1ZSddXG5cbiAgaXNTdGF0ZW1lbnQ6IFlFU1xuXG4gIGFzdFByb3BlcnRpZXM6IChvKSAtPlxuICAgIHJldHVyblxuICAgICAga2V5OiBAbmFtZS5hc3QgbywgTEVWRUxfTElTVFxuICAgICAgdmFsdWU6IEB2YWx1ZS5hc3QgbywgTEVWRUxfTElTVFxuICAgICAgY29tcHV0ZWQ6IEBuYW1lIGluc3RhbmNlb2YgQ29tcHV0ZWRQcm9wZXJ0eU5hbWUgb3IgQG5hbWUgaW5zdGFuY2VvZiBTdHJpbmdXaXRoSW50ZXJwb2xhdGlvbnNcblxuIyMjIyBJbXBvcnQgYW5kIEV4cG9ydFxuXG5leHBvcnRzLk1vZHVsZURlY2xhcmF0aW9uID0gY2xhc3MgTW9kdWxlRGVjbGFyYXRpb24gZXh0ZW5kcyBCYXNlXG4gIGNvbnN0cnVjdG9yOiAoQGNsYXVzZSwgQHNvdXJjZSwgQGFzc2VydGlvbnMpIC0+XG4gICAgc3VwZXIoKVxuICAgIEBjaGVja1NvdXJjZSgpXG5cbiAgY2hpbGRyZW46IFsnY2xhdXNlJywgJ3NvdXJjZScsICdhc3NlcnRpb25zJ11cblxuICBpc1N0YXRlbWVudDogWUVTXG4gIGp1bXBzOiAgICAgICBUSElTXG4gIG1ha2VSZXR1cm46ICBUSElTXG5cbiAgY2hlY2tTb3VyY2U6IC0+XG4gICAgaWYgQHNvdXJjZT8gYW5kIEBzb3VyY2UgaW5zdGFuY2VvZiBTdHJpbmdXaXRoSW50ZXJwb2xhdGlvbnNcbiAgICAgIEBzb3VyY2UuZXJyb3IgJ3RoZSBuYW1lIG9mIHRoZSBtb2R1bGUgdG8gYmUgaW1wb3J0ZWQgZnJvbSBtdXN0IGJlIGFuIHVuaW50ZXJwb2xhdGVkIHN0cmluZydcblxuICBjaGVja1Njb3BlOiAobywgbW9kdWxlRGVjbGFyYXRpb25UeXBlKSAtPlxuICAgICMgVE9ETzogd291bGQgYmUgYXBwcm9wcmlhdGUgdG8gZmxhZyB0aGlzIGVycm9yIGR1cmluZyBBU1QgZ2VuZXJhdGlvbiAoYXNcbiAgICAjIHdlbGwgYXMgd2hlbiBjb21waWxpbmcgdG8gSlMpLiBCdXQgYG8uaW5kZW50YCBpc27igJl0IHRyYWNrZWQgZHVyaW5nIEFTVFxuICAgICMgZ2VuZXJhdGlvbiwgYW5kIHRoZXJlIGRvZXNu4oCZdCBzZWVtIHRvIGJlIGEgY3VycmVudCBhbHRlcm5hdGl2ZSB3YXkgdG8gdHJhY2tcbiAgICAjIHdoZXRoZXIgd2XigJlyZSBhdCB0aGUg4oCccHJvZ3JhbSB0b3AtbGV2ZWzigJ0uXG4gICAgaWYgby5pbmRlbnQubGVuZ3RoIGlzbnQgMFxuICAgICAgQGVycm9yIFwiI3ttb2R1bGVEZWNsYXJhdGlvblR5cGV9IHN0YXRlbWVudHMgbXVzdCBiZSBhdCB0b3AtbGV2ZWwgc2NvcGVcIlxuXG4gIGFzdEFzc2VydGlvbnM6IChvKSAtPlxuICAgIGlmIEBhc3NlcnRpb25zPy5wcm9wZXJ0aWVzP1xuICAgICAgQGFzc2VydGlvbnMucHJvcGVydGllcy5tYXAgKGFzc2VydGlvbikgPT5cbiAgICAgICAgeyBzdGFydCwgZW5kLCBsb2MsIGxlZnQsIHJpZ2h0IH0gPSBhc3NlcnRpb24uYXN0KG8pXG4gICAgICAgIHsgdHlwZTogJ0ltcG9ydEF0dHJpYnV0ZScsIHN0YXJ0LCBlbmQsIGxvYywga2V5OiBsZWZ0LCB2YWx1ZTogcmlnaHQgfVxuICAgIGVsc2VcbiAgICAgIFtdXG5cbmV4cG9ydHMuSW1wb3J0RGVjbGFyYXRpb24gPSBjbGFzcyBJbXBvcnREZWNsYXJhdGlvbiBleHRlbmRzIE1vZHVsZURlY2xhcmF0aW9uXG4gIGNvbXBpbGVOb2RlOiAobykgLT5cbiAgICBAY2hlY2tTY29wZSBvLCAnaW1wb3J0J1xuICAgIG8uaW1wb3J0ZWRTeW1ib2xzID0gW11cblxuICAgIGNvZGUgPSBbXVxuICAgIGNvZGUucHVzaCBAbWFrZUNvZGUgXCIje0B0YWJ9aW1wb3J0IFwiXG4gICAgY29kZS5wdXNoIEBjbGF1c2UuY29tcGlsZU5vZGUobykuLi4gaWYgQGNsYXVzZT9cblxuICAgIGlmIEBzb3VyY2U/LnZhbHVlP1xuICAgICAgY29kZS5wdXNoIEBtYWtlQ29kZSAnIGZyb20gJyB1bmxlc3MgQGNsYXVzZSBpcyBudWxsXG4gICAgICBjb2RlLnB1c2ggQG1ha2VDb2RlIEBzb3VyY2UudmFsdWVcbiAgICAgIGlmIEBhc3NlcnRpb25zP1xuICAgICAgICBjb2RlLnB1c2ggQG1ha2VDb2RlICcgYXNzZXJ0ICdcbiAgICAgICAgY29kZS5wdXNoIEBhc3NlcnRpb25zLmNvbXBpbGVUb0ZyYWdtZW50cyhvKS4uLlxuXG4gICAgY29kZS5wdXNoIEBtYWtlQ29kZSAnOydcbiAgICBjb2RlXG5cbiAgYXN0Tm9kZTogKG8pIC0+XG4gICAgby5pbXBvcnRlZFN5bWJvbHMgPSBbXVxuICAgIHN1cGVyIG9cblxuICBhc3RQcm9wZXJ0aWVzOiAobykgLT5cbiAgICByZXQgPVxuICAgICAgc3BlY2lmaWVyczogQGNsYXVzZT8uYXN0KG8pID8gW11cbiAgICAgIHNvdXJjZTogQHNvdXJjZS5hc3Qgb1xuICAgICAgYXNzZXJ0aW9uczogQGFzdEFzc2VydGlvbnMobylcbiAgICByZXQuaW1wb3J0S2luZCA9ICd2YWx1ZScgaWYgQGNsYXVzZVxuICAgIHJldFxuXG5leHBvcnRzLkltcG9ydENsYXVzZSA9IGNsYXNzIEltcG9ydENsYXVzZSBleHRlbmRzIEJhc2VcbiAgY29uc3RydWN0b3I6IChAZGVmYXVsdEJpbmRpbmcsIEBuYW1lZEltcG9ydHMpIC0+XG4gICAgc3VwZXIoKVxuXG4gIGNoaWxkcmVuOiBbJ2RlZmF1bHRCaW5kaW5nJywgJ25hbWVkSW1wb3J0cyddXG5cbiAgY29tcGlsZU5vZGU6IChvKSAtPlxuICAgIGNvZGUgPSBbXVxuXG4gICAgaWYgQGRlZmF1bHRCaW5kaW5nP1xuICAgICAgY29kZS5wdXNoIEBkZWZhdWx0QmluZGluZy5jb21waWxlTm9kZShvKS4uLlxuICAgICAgY29kZS5wdXNoIEBtYWtlQ29kZSAnLCAnIGlmIEBuYW1lZEltcG9ydHM/XG5cbiAgICBpZiBAbmFtZWRJbXBvcnRzP1xuICAgICAgY29kZS5wdXNoIEBuYW1lZEltcG9ydHMuY29tcGlsZU5vZGUobykuLi5cblxuICAgIGNvZGVcblxuICBhc3ROb2RlOiAobykgLT5cbiAgICAjIFRoZSBBU1QgZm9yIGBJbXBvcnRDbGF1c2VgIGlzIHRoZSBub24tbmVzdGVkIGxpc3Qgb2YgaW1wb3J0IHNwZWNpZmllcnNcbiAgICAjIHRoYXQgd2lsbCBiZSB0aGUgYHNwZWNpZmllcnNgIHByb3BlcnR5IG9mIGFuIGBJbXBvcnREZWNsYXJhdGlvbmAgQVNUXG4gICAgY29tcGFjdCBmbGF0dGVuIFtcbiAgICAgIEBkZWZhdWx0QmluZGluZz8uYXN0IG9cbiAgICAgIEBuYW1lZEltcG9ydHM/LmFzdCBvXG4gICAgXVxuXG5leHBvcnRzLkV4cG9ydERlY2xhcmF0aW9uID0gY2xhc3MgRXhwb3J0RGVjbGFyYXRpb24gZXh0ZW5kcyBNb2R1bGVEZWNsYXJhdGlvblxuICBjb21waWxlTm9kZTogKG8pIC0+XG4gICAgQGNoZWNrU2NvcGUgbywgJ2V4cG9ydCdcbiAgICBAY2hlY2tGb3JBbm9ueW1vdXNDbGFzc0V4cG9ydCgpXG5cbiAgICBjb2RlID0gW11cbiAgICBjb2RlLnB1c2ggQG1ha2VDb2RlIFwiI3tAdGFifWV4cG9ydCBcIlxuICAgIGNvZGUucHVzaCBAbWFrZUNvZGUgJ2RlZmF1bHQgJyBpZiBAIGluc3RhbmNlb2YgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXG5cbiAgICBpZiBAIG5vdCBpbnN0YW5jZW9mIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiBhbmRcbiAgICAgICAoQGNsYXVzZSBpbnN0YW5jZW9mIEFzc2lnbiBvciBAY2xhdXNlIGluc3RhbmNlb2YgQ2xhc3MpXG4gICAgICBjb2RlLnB1c2ggQG1ha2VDb2RlICd2YXIgJ1xuICAgICAgQGNsYXVzZS5tb2R1bGVEZWNsYXJhdGlvbiA9ICdleHBvcnQnXG5cbiAgICBpZiBAY2xhdXNlLmJvZHk/IGFuZCBAY2xhdXNlLmJvZHkgaW5zdGFuY2VvZiBCbG9ja1xuICAgICAgY29kZSA9IGNvZGUuY29uY2F0IEBjbGF1c2UuY29tcGlsZVRvRnJhZ21lbnRzIG8sIExFVkVMX1RPUFxuICAgIGVsc2VcbiAgICAgIGNvZGUgPSBjb2RlLmNvbmNhdCBAY2xhdXNlLmNvbXBpbGVOb2RlIG9cblxuICAgIGlmIEBzb3VyY2U/LnZhbHVlP1xuICAgICAgY29kZS5wdXNoIEBtYWtlQ29kZSBcIiBmcm9tICN7QHNvdXJjZS52YWx1ZX1cIlxuICAgICAgaWYgQGFzc2VydGlvbnM/XG4gICAgICAgIGNvZGUucHVzaCBAbWFrZUNvZGUgJyBhc3NlcnQgJ1xuICAgICAgICBjb2RlLnB1c2ggQGFzc2VydGlvbnMuY29tcGlsZVRvRnJhZ21lbnRzKG8pLi4uXG5cbiAgICBjb2RlLnB1c2ggQG1ha2VDb2RlICc7J1xuICAgIGNvZGVcblxuICAjIFByZXZlbnQgZXhwb3J0aW5nIGFuIGFub255bW91cyBjbGFzczsgYWxsIGV4cG9ydGVkIG1lbWJlcnMgbXVzdCBiZSBuYW1lZFxuICBjaGVja0ZvckFub255bW91c0NsYXNzRXhwb3J0OiAtPlxuICAgIGlmIEAgbm90IGluc3RhbmNlb2YgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uIGFuZCBAY2xhdXNlIGluc3RhbmNlb2YgQ2xhc3MgYW5kIG5vdCBAY2xhdXNlLnZhcmlhYmxlXG4gICAgICBAY2xhdXNlLmVycm9yICdhbm9ueW1vdXMgY2xhc3NlcyBjYW5ub3QgYmUgZXhwb3J0ZWQnXG5cbiAgYXN0Tm9kZTogKG8pIC0+XG4gICAgQGNoZWNrRm9yQW5vbnltb3VzQ2xhc3NFeHBvcnQoKVxuICAgIHN1cGVyIG9cblxuZXhwb3J0cy5FeHBvcnROYW1lZERlY2xhcmF0aW9uID0gY2xhc3MgRXhwb3J0TmFtZWREZWNsYXJhdGlvbiBleHRlbmRzIEV4cG9ydERlY2xhcmF0aW9uXG4gIGFzdFByb3BlcnRpZXM6IChvKSAtPlxuICAgIHJldCA9XG4gICAgICBzb3VyY2U6IEBzb3VyY2U/LmFzdChvKSA/IG51bGxcbiAgICAgIGFzc2VydGlvbnM6IEBhc3RBc3NlcnRpb25zKG8pXG4gICAgICBleHBvcnRLaW5kOiAndmFsdWUnXG4gICAgY2xhdXNlQXN0ID0gQGNsYXVzZS5hc3Qgb1xuICAgIGlmIEBjbGF1c2UgaW5zdGFuY2VvZiBFeHBvcnRTcGVjaWZpZXJMaXN0XG4gICAgICByZXQuc3BlY2lmaWVycyA9IGNsYXVzZUFzdFxuICAgICAgcmV0LmRlY2xhcmF0aW9uID0gbnVsbFxuICAgIGVsc2VcbiAgICAgIHJldC5zcGVjaWZpZXJzID0gW11cbiAgICAgIHJldC5kZWNsYXJhdGlvbiA9IGNsYXVzZUFzdFxuICAgIHJldFxuXG5leHBvcnRzLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IGNsYXNzIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiBleHRlbmRzIEV4cG9ydERlY2xhcmF0aW9uXG4gIGFzdFByb3BlcnRpZXM6IChvKSAtPlxuICAgIHJldHVyblxuICAgICAgZGVjbGFyYXRpb246IEBjbGF1c2UuYXN0IG9cbiAgICAgIGFzc2VydGlvbnM6IEBhc3RBc3NlcnRpb25zKG8pXG5cbmV4cG9ydHMuRXhwb3J0QWxsRGVjbGFyYXRpb24gPSBjbGFzcyBFeHBvcnRBbGxEZWNsYXJhdGlvbiBleHRlbmRzIEV4cG9ydERlY2xhcmF0aW9uXG4gIGFzdFByb3BlcnRpZXM6IChvKSAtPlxuICAgIHJldHVyblxuICAgICAgc291cmNlOiBAc291cmNlLmFzdCBvXG4gICAgICBhc3NlcnRpb25zOiBAYXN0QXNzZXJ0aW9ucyhvKVxuICAgICAgZXhwb3J0S2luZDogJ3ZhbHVlJ1xuXG5leHBvcnRzLk1vZHVsZVNwZWNpZmllckxpc3QgPSBjbGFzcyBNb2R1bGVTcGVjaWZpZXJMaXN0IGV4dGVuZHMgQmFzZVxuICBjb25zdHJ1Y3RvcjogKEBzcGVjaWZpZXJzKSAtPlxuICAgIHN1cGVyKClcblxuICBjaGlsZHJlbjogWydzcGVjaWZpZXJzJ11cblxuICBjb21waWxlTm9kZTogKG8pIC0+XG4gICAgY29kZSA9IFtdXG4gICAgby5pbmRlbnQgKz0gVEFCXG4gICAgY29tcGlsZWRMaXN0ID0gKHNwZWNpZmllci5jb21waWxlVG9GcmFnbWVudHMgbywgTEVWRUxfTElTVCBmb3Igc3BlY2lmaWVyIGluIEBzcGVjaWZpZXJzKVxuXG4gICAgaWYgQHNwZWNpZmllcnMubGVuZ3RoIGlzbnQgMFxuICAgICAgY29kZS5wdXNoIEBtYWtlQ29kZSBcIntcXG4je28uaW5kZW50fVwiXG4gICAgICBmb3IgZnJhZ21lbnRzLCBpbmRleCBpbiBjb21waWxlZExpc3RcbiAgICAgICAgY29kZS5wdXNoIEBtYWtlQ29kZShcIixcXG4je28uaW5kZW50fVwiKSBpZiBpbmRleFxuICAgICAgICBjb2RlLnB1c2ggZnJhZ21lbnRzLi4uXG4gICAgICBjb2RlLnB1c2ggQG1ha2VDb2RlIFwiXFxufVwiXG4gICAgZWxzZVxuICAgICAgY29kZS5wdXNoIEBtYWtlQ29kZSAne30nXG4gICAgY29kZVxuXG4gIGFzdE5vZGU6IChvKSAtPlxuICAgIHNwZWNpZmllci5hc3QobykgZm9yIHNwZWNpZmllciBpbiBAc3BlY2lmaWVyc1xuXG5leHBvcnRzLkltcG9ydFNwZWNpZmllckxpc3QgPSBjbGFzcyBJbXBvcnRTcGVjaWZpZXJMaXN0IGV4dGVuZHMgTW9kdWxlU3BlY2lmaWVyTGlzdFxuXG5leHBvcnRzLkV4cG9ydFNwZWNpZmllckxpc3QgPSBjbGFzcyBFeHBvcnRTcGVjaWZpZXJMaXN0IGV4dGVuZHMgTW9kdWxlU3BlY2lmaWVyTGlzdFxuXG5leHBvcnRzLk1vZHVsZVNwZWNpZmllciA9IGNsYXNzIE1vZHVsZVNwZWNpZmllciBleHRlbmRzIEJhc2VcbiAgY29uc3RydWN0b3I6IChAb3JpZ2luYWwsIEBhbGlhcywgQG1vZHVsZURlY2xhcmF0aW9uVHlwZSkgLT5cbiAgICBzdXBlcigpXG5cbiAgICBpZiBAb3JpZ2luYWwuY29tbWVudHMgb3IgQGFsaWFzPy5jb21tZW50c1xuICAgICAgQGNvbW1lbnRzID0gW11cbiAgICAgIEBjb21tZW50cy5wdXNoIEBvcmlnaW5hbC5jb21tZW50cy4uLiBpZiBAb3JpZ2luYWwuY29tbWVudHNcbiAgICAgIEBjb21tZW50cy5wdXNoIEBhbGlhcy5jb21tZW50cy4uLiAgICBpZiBAYWxpYXM/LmNvbW1lbnRzXG5cbiAgICAjIFRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSBlbnRlcmluZyB0aGUgbG9jYWwgc2NvcGVcbiAgICBAaWRlbnRpZmllciA9IGlmIEBhbGlhcz8gdGhlbiBAYWxpYXMudmFsdWUgZWxzZSBAb3JpZ2luYWwudmFsdWVcblxuICBjaGlsZHJlbjogWydvcmlnaW5hbCcsICdhbGlhcyddXG5cbiAgY29tcGlsZU5vZGU6IChvKSAtPlxuICAgIEBhZGRJZGVudGlmaWVyVG9TY29wZSBvXG4gICAgY29kZSA9IFtdXG4gICAgY29kZS5wdXNoIEBtYWtlQ29kZSBAb3JpZ2luYWwudmFsdWVcbiAgICBjb2RlLnB1c2ggQG1ha2VDb2RlIFwiIGFzICN7QGFsaWFzLnZhbHVlfVwiIGlmIEBhbGlhcz9cbiAgICBjb2RlXG5cbiAgYWRkSWRlbnRpZmllclRvU2NvcGU6IChvKSAtPlxuICAgIG8uc2NvcGUuZmluZCBAaWRlbnRpZmllciwgQG1vZHVsZURlY2xhcmF0aW9uVHlwZVxuXG4gIGFzdE5vZGU6IChvKSAtPlxuICAgIEBhZGRJZGVudGlmaWVyVG9TY29wZSBvXG4gICAgc3VwZXIgb1xuXG5leHBvcnRzLkltcG9ydFNwZWNpZmllciA9IGNsYXNzIEltcG9ydFNwZWNpZmllciBleHRlbmRzIE1vZHVsZVNwZWNpZmllclxuICBjb25zdHJ1Y3RvcjogKGltcG9ydGVkLCBsb2NhbCkgLT5cbiAgICBzdXBlciBpbXBvcnRlZCwgbG9jYWwsICdpbXBvcnQnXG5cbiAgYWRkSWRlbnRpZmllclRvU2NvcGU6IChvKSAtPlxuICAgICMgUGVyIHRoZSBzcGVjLCBzeW1ib2xzIGNhbuKAmXQgYmUgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXNcbiAgICAjIChlLmcuIGBpbXBvcnQgeyBmb28sIGZvbyB9IGZyb20gJ2xpYidgIGlzIGludmFsaWQpXG4gICAgaWYgQGlkZW50aWZpZXIgaW4gby5pbXBvcnRlZFN5bWJvbHMgb3Igby5zY29wZS5jaGVjayhAaWRlbnRpZmllcilcbiAgICAgIEBlcnJvciBcIicje0BpZGVudGlmaWVyfScgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZFwiXG4gICAgZWxzZVxuICAgICAgby5pbXBvcnRlZFN5bWJvbHMucHVzaCBAaWRlbnRpZmllclxuICAgIHN1cGVyIG9cblxuICBhc3RQcm9wZXJ0aWVzOiAobykgLT5cbiAgICBvcmlnaW5hbEFzdCA9IEBvcmlnaW5hbC5hc3Qgb1xuICAgIHJldHVyblxuICAgICAgaW1wb3J0ZWQ6IG9yaWdpbmFsQXN0XG4gICAgICBsb2NhbDogQGFsaWFzPy5hc3QobykgPyBvcmlnaW5hbEFzdFxuICAgICAgaW1wb3J0S2luZDogbnVsbFxuXG5leHBvcnRzLkltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSBjbGFzcyBJbXBvcnREZWZhdWx0U3BlY2lmaWVyIGV4dGVuZHMgSW1wb3J0U3BlY2lmaWVyXG4gIGFzdFByb3BlcnRpZXM6IChvKSAtPlxuICAgIHJldHVyblxuICAgICAgbG9jYWw6IEBvcmlnaW5hbC5hc3Qgb1xuXG5leHBvcnRzLkltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGNsYXNzIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllciBleHRlbmRzIEltcG9ydFNwZWNpZmllclxuICBhc3RQcm9wZXJ0aWVzOiAobykgLT5cbiAgICByZXR1cm5cbiAgICAgIGxvY2FsOiBAYWxpYXMuYXN0IG9cblxuZXhwb3J0cy5FeHBvcnRTcGVjaWZpZXIgPSBjbGFzcyBFeHBvcnRTcGVjaWZpZXIgZXh0ZW5kcyBNb2R1bGVTcGVjaWZpZXJcbiAgY29uc3RydWN0b3I6IChsb2NhbCwgZXhwb3J0ZWQpIC0+XG4gICAgc3VwZXIgbG9jYWwsIGV4cG9ydGVkLCAnZXhwb3J0J1xuXG4gIGFzdFByb3BlcnRpZXM6IChvKSAtPlxuICAgIG9yaWdpbmFsQXN0ID0gQG9yaWdpbmFsLmFzdCBvXG4gICAgcmV0dXJuXG4gICAgICBsb2NhbDogb3JpZ2luYWxBc3RcbiAgICAgIGV4cG9ydGVkOiBAYWxpYXM/LmFzdChvKSA/IG9yaWdpbmFsQXN0XG5cbmV4cG9ydHMuRHluYW1pY0ltcG9ydCA9IGNsYXNzIER5bmFtaWNJbXBvcnQgZXh0ZW5kcyBCYXNlXG4gIGNvbXBpbGVOb2RlOiAtPlxuICAgIFtAbWFrZUNvZGUgJ2ltcG9ydCddXG5cbiAgYXN0VHlwZTogLT4gJ0ltcG9ydCdcblxuZXhwb3J0cy5EeW5hbWljSW1wb3J0Q2FsbCA9IGNsYXNzIER5bmFtaWNJbXBvcnRDYWxsIGV4dGVuZHMgQ2FsbFxuICBjb21waWxlTm9kZTogKG8pIC0+XG4gICAgQGNoZWNrQXJndW1lbnRzKClcbiAgICBzdXBlciBvXG5cbiAgY2hlY2tBcmd1bWVudHM6IC0+XG4gICAgdW5sZXNzIDEgPD0gQGFyZ3MubGVuZ3RoIDw9IDJcbiAgICAgIEBlcnJvciAnaW1wb3J0KCkgYWNjZXB0cyBlaXRoZXIgb25lIG9yIHR3byBhcmd1bWVudHMnXG5cbiAgYXN0Tm9kZTogKG8pIC0+XG4gICAgQGNoZWNrQXJndW1lbnRzKClcbiAgICBzdXBlciBvXG5cbiMjIyMgQXNzaWduXG5cbiMgVGhlICoqQXNzaWduKiogaXMgdXNlZCB0byBhc3NpZ24gYSBsb2NhbCB2YXJpYWJsZSB0byB2YWx1ZSwgb3IgdG8gc2V0IHRoZVxuIyBwcm9wZXJ0eSBvZiBhbiBvYmplY3QgLS0gaW5jbHVkaW5nIHdpdGhpbiBvYmplY3QgbGl0ZXJhbHMuXG5leHBvcnRzLkFzc2lnbiA9IGNsYXNzIEFzc2lnbiBleHRlbmRzIEJhc2VcbiAgY29uc3RydWN0b3I6IChAdmFyaWFibGUsIEB2YWx1ZSwgQGNvbnRleHQsIG9wdGlvbnMgPSB7fSkgLT5cbiAgICBzdXBlcigpXG4gICAge0BwYXJhbSwgQHN1YnBhdHRlcm4sIEBvcGVyYXRvclRva2VuLCBAbW9kdWxlRGVjbGFyYXRpb24sIEBvcmlnaW5hbENvbnRleHQgPSBAY29udGV4dH0gPSBvcHRpb25zXG4gICAgQHByb3BhZ2F0ZUxocygpXG5cbiAgY2hpbGRyZW46IFsndmFyaWFibGUnLCAndmFsdWUnXVxuXG4gIGlzQXNzaWduYWJsZTogWUVTXG5cbiAgaXNTdGF0ZW1lbnQ6IChvKSAtPlxuICAgIG8/LmxldmVsIGlzIExFVkVMX1RPUCBhbmQgQGNvbnRleHQ/IGFuZCAoQG1vZHVsZURlY2xhcmF0aW9uIG9yIFwiP1wiIGluIEBjb250ZXh0KVxuXG4gIGNoZWNrTmFtZUFzc2lnbmFiaWxpdHk6IChvLCB2YXJCYXNlKSAtPlxuICAgIGlmIG8uc2NvcGUudHlwZSh2YXJCYXNlLnZhbHVlKSBpcyAnaW1wb3J0J1xuICAgICAgdmFyQmFzZS5lcnJvciBcIicje3ZhckJhc2UudmFsdWV9JyBpcyByZWFkLW9ubHlcIlxuXG4gIGFzc2lnbnM6IChuYW1lKSAtPlxuICAgIEBbaWYgQGNvbnRleHQgaXMgJ29iamVjdCcgdGhlbiAndmFsdWUnIGVsc2UgJ3ZhcmlhYmxlJ10uYXNzaWducyBuYW1lXG5cbiAgdW5mb2xkU29hazogKG8pIC0+XG4gICAgdW5mb2xkU29hayBvLCB0aGlzLCAndmFyaWFibGUnXG5cbiAgYWRkU2NvcGVWYXJpYWJsZXM6IChvLCB7XG4gICAgIyBEdXJpbmcgQVNUIGdlbmVyYXRpb24sIHdlIG5lZWQgdG8gYWxsb3cgYXNzaWdubWVudCB0byB0aGVzZSBjb25zdHJ1Y3RzXG4gICAgIyB0aGF0IGFyZSBjb25zaWRlcmVkIOKAnHVuYXNzaWduYWJsZeKAnSBkdXJpbmcgY29tcGlsZS10by1KUywgd2hpbGUgc3RpbGxcbiAgICAjIGZsYWdnaW5nIHRoaW5ncyBsaWtlIGBbbnVsbF0gPSBiYC5cbiAgICBhbGxvd0Fzc2lnbm1lbnRUb0V4cGFuc2lvbiA9IG5vLFxuICAgIGFsbG93QXNzaWdubWVudFRvTm9udHJhaWxpbmdTcGxhdCA9IG5vLFxuICAgIGFsbG93QXNzaWdubWVudFRvRW1wdHlBcnJheSA9IG5vLFxuICAgIGFsbG93QXNzaWdubWVudFRvQ29tcGxleFNwbGF0ID0gbm9cbiAgfSA9IHt9KSAtPlxuICAgIHJldHVybiB1bmxlc3Mgbm90IEBjb250ZXh0IG9yIEBjb250ZXh0IGlzICcqKj0nXG5cbiAgICB2YXJCYXNlID0gQHZhcmlhYmxlLnVud3JhcEFsbCgpXG4gICAgaWYgbm90IHZhckJhc2UuaXNBc3NpZ25hYmxlIHtcbiAgICAgIGFsbG93RXhwYW5zaW9uOiBhbGxvd0Fzc2lnbm1lbnRUb0V4cGFuc2lvblxuICAgICAgYWxsb3dOb250cmFpbGluZ1NwbGF0OiBhbGxvd0Fzc2lnbm1lbnRUb05vbnRyYWlsaW5nU3BsYXRcbiAgICAgIGFsbG93RW1wdHlBcnJheTogYWxsb3dBc3NpZ25tZW50VG9FbXB0eUFycmF5XG4gICAgICBhbGxvd0NvbXBsZXhTcGxhdDogYWxsb3dBc3NpZ25tZW50VG9Db21wbGV4U3BsYXRcbiAgICB9XG4gICAgICBAdmFyaWFibGUuZXJyb3IgXCInI3tAdmFyaWFibGUuY29tcGlsZSBvfScgY2FuJ3QgYmUgYXNzaWduZWRcIlxuXG4gICAgdmFyQmFzZS5lYWNoTmFtZSAobmFtZSkgPT5cbiAgICAgIHJldHVybiBpZiBuYW1lLmhhc1Byb3BlcnRpZXM/KClcblxuICAgICAgbWVzc2FnZSA9IGlzVW5hc3NpZ25hYmxlIG5hbWUudmFsdWVcbiAgICAgIG5hbWUuZXJyb3IgbWVzc2FnZSBpZiBtZXNzYWdlXG5cbiAgICAgICMgYG1vZHVsZURlY2xhcmF0aW9uYCBjYW4gYmUgYCdpbXBvcnQnYCBvciBgJ2V4cG9ydCdgLlxuICAgICAgQGNoZWNrTmFtZUFzc2lnbmFiaWxpdHkgbywgbmFtZVxuICAgICAgaWYgQG1vZHVsZURlY2xhcmF0aW9uXG4gICAgICAgIG8uc2NvcGUuYWRkIG5hbWUudmFsdWUsIEBtb2R1bGVEZWNsYXJhdGlvblxuICAgICAgICBuYW1lLmlzRGVjbGFyYXRpb24gPSB5ZXNcbiAgICAgIGVsc2UgaWYgQHBhcmFtXG4gICAgICAgIG8uc2NvcGUuYWRkIG5hbWUudmFsdWUsXG4gICAgICAgICAgaWYgQHBhcmFtIGlzICdhbHdheXNEZWNsYXJlJ1xuICAgICAgICAgICAgJ3ZhcidcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAncGFyYW0nXG4gICAgICBlbHNlXG4gICAgICAgIGFscmVhZHlEZWNsYXJlZCA9IG8uc2NvcGUuZmluZCBuYW1lLnZhbHVlXG4gICAgICAgIG5hbWUuaXNEZWNsYXJhdGlvbiA/PSBub3QgYWxyZWFkeURlY2xhcmVkXG4gICAgICAgICMgSWYgdGhpcyBhc3NpZ25tZW50IGlkZW50aWZpZXIgaGFzIG9uZSBvciBtb3JlIGhlcmVjb21tZW50c1xuICAgICAgICAjIGF0dGFjaGVkLCBvdXRwdXQgdGhlbSBhcyBwYXJ0IG9mIHRoZSBkZWNsYXJhdGlvbnMgbGluZSAodW5sZXNzXG4gICAgICAgICMgb3RoZXIgaGVyZWNvbW1lbnRzIGFyZSBhbHJlYWR5IHN0YWdlZCB0aGVyZSkgZm9yIGNvbXBhdGliaWxpdHlcbiAgICAgICAgIyB3aXRoIEZsb3cgdHlwaW5nLiBEb27igJl0IGRvIHRoaXMgaWYgdGhpcyBhc3NpZ25tZW50IGlzIGZvciBhXG4gICAgICAgICMgY2xhc3MsIGUuZy4gYENsYXNzTmFtZSA9IGNsYXNzIENsYXNzTmFtZSB7YCwgYXMgRmxvdyByZXF1aXJlc1xuICAgICAgICAjIHRoZSBjb21tZW50IHRvIGJlIGJldHdlZW4gdGhlIGNsYXNzIG5hbWUgYW5kIHRoZSBge2AuXG4gICAgICAgIGlmIG5hbWUuY29tbWVudHMgYW5kIG5vdCBvLnNjb3BlLmNvbW1lbnRzW25hbWUudmFsdWVdIGFuZFxuICAgICAgICAgICBAdmFsdWUgbm90IGluc3RhbmNlb2YgQ2xhc3MgYW5kXG4gICAgICAgICAgIG5hbWUuY29tbWVudHMuZXZlcnkoKGNvbW1lbnQpIC0+IGNvbW1lbnQuaGVyZSBhbmQgbm90IGNvbW1lbnQubXVsdGlsaW5lKVxuICAgICAgICAgIGNvbW1lbnRzTm9kZSA9IG5ldyBJZGVudGlmaWVyTGl0ZXJhbCBuYW1lLnZhbHVlXG4gICAgICAgICAgY29tbWVudHNOb2RlLmNvbW1lbnRzID0gbmFtZS5jb21tZW50c1xuICAgICAgICAgIGNvbW1lbnRGcmFnbWVudHMgPSBbXVxuICAgICAgICAgIEBjb21waWxlQ29tbWVudEZyYWdtZW50cyBvLCBjb21tZW50c05vZGUsIGNvbW1lbnRGcmFnbWVudHNcbiAgICAgICAgICBvLnNjb3BlLmNvbW1lbnRzW25hbWUudmFsdWVdID0gY29tbWVudEZyYWdtZW50c1xuXG4gICMgQ29tcGlsZSBhbiBhc3NpZ25tZW50LCBkZWxlZ2F0aW5nIHRvIGBjb21waWxlRGVzdHJ1Y3R1cmluZ2Agb3JcbiAgIyBgY29tcGlsZVNwbGljZWAgaWYgYXBwcm9wcmlhdGUuIEtlZXAgdHJhY2sgb2YgdGhlIG5hbWUgb2YgdGhlIGJhc2Ugb2JqZWN0XG4gICMgd2UndmUgYmVlbiBhc3NpZ25lZCB0bywgZm9yIGNvcnJlY3QgaW50ZXJuYWwgcmVmZXJlbmNlcy4gSWYgdGhlIHZhcmlhYmxlXG4gICMgaGFzIG5vdCBiZWVuIHNlZW4geWV0IHdpdGhpbiB0aGUgY3VycmVudCBzY29wZSwgZGVjbGFyZSBpdC5cbiAgY29tcGlsZU5vZGU6IChvKSAtPlxuICAgIGlzVmFsdWUgPSBAdmFyaWFibGUgaW5zdGFuY2VvZiBWYWx1ZVxuICAgIGlmIGlzVmFsdWVcbiAgICAgICMgSWYgYEB2YXJpYWJsZWAgaXMgYW4gYXJyYXkgb3IgYW4gb2JqZWN0LCB3ZeKAmXJlIGRlc3RydWN0dXJpbmc7XG4gICAgICAjIGlmIGl04oCZcyBhbHNvIGBpc0Fzc2lnbmFibGUoKWAsIHRoZSBkZXN0cnVjdHVyaW5nIHN5bnRheCBpcyBzdXBwb3J0ZWRcbiAgICAgICMgaW4gRVMgYW5kIHdlIGNhbiBvdXRwdXQgaXQgYXMgaXM7IG90aGVyd2lzZSB3ZSBgQGNvbXBpbGVEZXN0cnVjdHVyaW5nYFxuICAgICAgIyBhbmQgY29udmVydCB0aGlzIEVTLXVuc3VwcG9ydGVkIGRlc3RydWN0dXJpbmcgaW50byBhY2NlcHRhYmxlIG91dHB1dC5cbiAgICAgIGlmIEB2YXJpYWJsZS5pc0FycmF5KCkgb3IgQHZhcmlhYmxlLmlzT2JqZWN0KClcbiAgICAgICAgdW5sZXNzIEB2YXJpYWJsZS5pc0Fzc2lnbmFibGUoKVxuICAgICAgICAgIGlmIEB2YXJpYWJsZS5pc09iamVjdCgpIGFuZCBAdmFyaWFibGUuYmFzZS5oYXNTcGxhdCgpXG4gICAgICAgICAgICByZXR1cm4gQGNvbXBpbGVPYmplY3REZXN0cnVjdCBvXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIEBjb21waWxlRGVzdHJ1Y3R1cmluZyBvXG5cbiAgICAgIHJldHVybiBAY29tcGlsZVNwbGljZSAgICAgICBvIGlmIEB2YXJpYWJsZS5pc1NwbGljZSgpXG4gICAgICByZXR1cm4gQGNvbXBpbGVDb25kaXRpb25hbCAgbyBpZiBAaXNDb25kaXRpb25hbCgpXG4gICAgICByZXR1cm4gQGNvbXBpbGVTcGVjaWFsTWF0aCAgbyBpZiBAY29udGV4dCBpbiBbJy8vPScsICclJT0nXVxuXG4gICAgQGFkZFNjb3BlVmFyaWFibGVzIG9cbiAgICBpZiBAdmFsdWUgaW5zdGFuY2VvZiBDb2RlXG4gICAgICBpZiBAdmFsdWUuaXNTdGF0aWNcbiAgICAgICAgQHZhbHVlLm5hbWUgPSBAdmFyaWFibGUucHJvcGVydGllc1swXVxuICAgICAgZWxzZSBpZiBAdmFyaWFibGUucHJvcGVydGllcz8ubGVuZ3RoID49IDJcbiAgICAgICAgW3Byb3BlcnRpZXMuLi4sIHByb3RvdHlwZSwgbmFtZV0gPSBAdmFyaWFibGUucHJvcGVydGllc1xuICAgICAgICBAdmFsdWUubmFtZSA9IG5hbWUgaWYgcHJvdG90eXBlLm5hbWU/LnZhbHVlIGlzICdwcm90b3R5cGUnXG5cbiAgICB2YWwgPSBAdmFsdWUuY29tcGlsZVRvRnJhZ21lbnRzIG8sIExFVkVMX0xJU1RcbiAgICBjb21waWxlZE5hbWUgPSBAdmFyaWFibGUuY29tcGlsZVRvRnJhZ21lbnRzIG8sIExFVkVMX0xJU1RcblxuICAgIGlmIEBjb250ZXh0IGlzICdvYmplY3QnXG4gICAgICBpZiBAdmFyaWFibGUuc2hvdWxkQ2FjaGUoKVxuICAgICAgICBjb21waWxlZE5hbWUudW5zaGlmdCBAbWFrZUNvZGUgJ1snXG4gICAgICAgIGNvbXBpbGVkTmFtZS5wdXNoIEBtYWtlQ29kZSAnXSdcbiAgICAgIHJldHVybiBjb21waWxlZE5hbWUuY29uY2F0IEBtYWtlQ29kZSgnOiAnKSwgdmFsXG5cbiAgICBhbnN3ZXIgPSBjb21waWxlZE5hbWUuY29uY2F0IEBtYWtlQ29kZShcIiAjeyBAY29udGV4dCBvciAnPScgfSBcIiksIHZhbFxuICAgICMgUGVyIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9EZXN0cnVjdHVyaW5nX2Fzc2lnbm1lbnQjQXNzaWdubWVudF93aXRob3V0X2RlY2xhcmF0aW9uLFxuICAgICMgaWYgd2XigJlyZSBkZXN0cnVjdHVyaW5nIHdpdGhvdXQgZGVjbGFyaW5nLCB0aGUgZGVzdHJ1Y3R1cmluZyBhc3NpZ25tZW50IG11c3QgYmUgd3JhcHBlZCBpbiBwYXJlbnRoZXNlcy5cbiAgICAjIFRoZSBhc3NpZ25tZW50IGlzIHdyYXBwZWQgaW4gcGFyZW50aGVzZXMgaWYgJ28ubGV2ZWwnIGhhcyBsb3dlciBwcmVjZWRlbmNlIHRoYW4gTEVWRUxfTElTVCAoMylcbiAgICAjIChpLmUuIExFVkVMX0NPTkQgKDQpLCBMRVZFTF9PUCAoNSkgb3IgTEVWRUxfQUNDRVNTICg2KSksIG9yIGlmIHdlJ3JlIGRlc3RydWN0dXJpbmcgb2JqZWN0LCBlLmcuIHthLGJ9ID0gb2JqLlxuICAgIGlmIG8ubGV2ZWwgPiBMRVZFTF9MSVNUIG9yIGlzVmFsdWUgYW5kIEB2YXJpYWJsZS5iYXNlIGluc3RhbmNlb2YgT2JqIGFuZCBub3QgQG5lc3RlZExocyBhbmQgbm90IChAcGFyYW0gaXMgeWVzKVxuICAgICAgQHdyYXBJblBhcmVudGhlc2VzIGFuc3dlclxuICAgIGVsc2VcbiAgICAgIGFuc3dlclxuXG4gICMgT2JqZWN0IHJlc3QgcHJvcGVydHkgaXMgbm90IGFzc2lnbmFibGU6IGB7e2F9Li4ufWBcbiAgY29tcGlsZU9iamVjdERlc3RydWN0OiAobykgLT5cbiAgICBAdmFyaWFibGUuYmFzZS5yZW9yZGVyUHJvcGVydGllcygpXG4gICAge3Byb3BlcnRpZXM6IHByb3BzfSA9IEB2YXJpYWJsZS5iYXNlXG4gICAgWy4uLiwgc3BsYXRdID0gcHJvcHNcbiAgICBzcGxhdFByb3AgPSBzcGxhdC5uYW1lXG4gICAgYXNzaWducyA9IFtdXG4gICAgcmVmVmFsID0gbmV3IFZhbHVlIG5ldyBJZGVudGlmaWVyTGl0ZXJhbCBvLnNjb3BlLmZyZWVWYXJpYWJsZSAncmVmJ1xuICAgIHByb3BzLnNwbGljZSAtMSwgMSwgbmV3IFNwbGF0IHJlZlZhbFxuICAgIGFzc2lnbnMucHVzaCBuZXcgQXNzaWduKG5ldyBWYWx1ZShuZXcgT2JqIHByb3BzKSwgQHZhbHVlKS5jb21waWxlVG9GcmFnbWVudHMgbywgTEVWRUxfTElTVFxuICAgIGFzc2lnbnMucHVzaCBuZXcgQXNzaWduKG5ldyBWYWx1ZShzcGxhdFByb3ApLCByZWZWYWwpLmNvbXBpbGVUb0ZyYWdtZW50cyBvLCBMRVZFTF9MSVNUXG4gICAgQGpvaW5GcmFnbWVudEFycmF5cyBhc3NpZ25zLCAnLCAnXG5cbiAgIyBCcmllZiBpbXBsZW1lbnRhdGlvbiBvZiByZWN1cnNpdmUgcGF0dGVybiBtYXRjaGluZywgd2hlbiBhc3NpZ25pbmcgYXJyYXkgb3JcbiAgIyBvYmplY3QgbGl0ZXJhbHMgdG8gYSB2YWx1ZS4gUGVla3MgYXQgdGhlaXIgcHJvcGVydGllcyB0byBhc3NpZ24gaW5uZXIgbmFtZXMuXG4gIGNvbXBpbGVEZXN0cnVjdHVyaW5nOiAobykgLT5cbiAgICB0b3AgICAgICAgPSBvLmxldmVsIGlzIExFVkVMX1RPUFxuICAgIHt2YWx1ZX0gICA9IHRoaXNcbiAgICB7b2JqZWN0c30gPSBAdmFyaWFibGUuYmFzZVxuICAgIG9sZW4gICAgICA9IG9iamVjdHMubGVuZ3RoXG5cbiAgICAjIFNwZWNpYWwtY2FzZSBmb3IgYHt9ID0gYWAgYW5kIGBbXSA9IGFgIChlbXB0eSBwYXR0ZXJucykuXG4gICAgIyBDb21waWxlIHRvIHNpbXBseSBgYWAuXG4gICAgaWYgb2xlbiBpcyAwXG4gICAgICBjb2RlID0gdmFsdWUuY29tcGlsZVRvRnJhZ21lbnRzIG9cbiAgICAgIHJldHVybiBpZiBvLmxldmVsID49IExFVkVMX09QIHRoZW4gQHdyYXBJblBhcmVudGhlc2VzIGNvZGUgZWxzZSBjb2RlXG4gICAgW29ial0gPSBvYmplY3RzXG5cbiAgICBAZGlzYWxsb3dMb25lRXhwYW5zaW9uKClcbiAgICB7c3BsYXRzLCBleHBhbnMsIHNwbGF0c0FuZEV4cGFuc30gPSBAZ2V0QW5kQ2hlY2tTcGxhdHNBbmRFeHBhbnNpb25zKClcblxuICAgIGlzU3BsYXQgPSBzcGxhdHM/Lmxlbmd0aCA+IDBcbiAgICBpc0V4cGFucyA9IGV4cGFucz8ubGVuZ3RoID4gMFxuXG4gICAgdnZhciAgICAgPSB2YWx1ZS5jb21waWxlVG9GcmFnbWVudHMgbywgTEVWRUxfTElTVFxuICAgIHZ2YXJUZXh0ID0gZnJhZ21lbnRzVG9UZXh0IHZ2YXJcbiAgICBhc3NpZ25zICA9IFtdXG4gICAgcHVzaEFzc2lnbiA9ICh2YXJpYWJsZSwgdmFsKSA9PlxuICAgICAgYXNzaWducy5wdXNoIG5ldyBBc3NpZ24odmFyaWFibGUsIHZhbCwgbnVsbCwgcGFyYW06IEBwYXJhbSwgc3VicGF0dGVybjogeWVzKS5jb21waWxlVG9GcmFnbWVudHMgbywgTEVWRUxfTElTVFxuXG4gICAgaWYgaXNTcGxhdFxuICAgICAgc3BsYXRWYXIgPSBvYmplY3RzW3NwbGF0c1swXV0ubmFtZS51bndyYXAoKVxuICAgICAgaWYgc3BsYXRWYXIgaW5zdGFuY2VvZiBBcnIgb3Igc3BsYXRWYXIgaW5zdGFuY2VvZiBPYmpcbiAgICAgICAgc3BsYXRWYXJSZWYgPSBuZXcgSWRlbnRpZmllckxpdGVyYWwgby5zY29wZS5mcmVlVmFyaWFibGUgJ3JlZidcbiAgICAgICAgb2JqZWN0c1tzcGxhdHNbMF1dLm5hbWUgPSBzcGxhdFZhclJlZlxuICAgICAgICBzcGxhdFZhckFzc2lnbiA9IC0+IHB1c2hBc3NpZ24gbmV3IFZhbHVlKHNwbGF0VmFyKSwgc3BsYXRWYXJSZWZcblxuICAgICMgQXQgdGhpcyBwb2ludCwgdGhlcmUgYXJlIHNldmVyYWwgdGhpbmdzIHRvIGRlc3RydWN0dXJlLiBTbyB0aGUgYGZuKClgIGluXG4gICAgIyBge2EsIGJ9ID0gZm4oKWAgbXVzdCBiZSBjYWNoZWQsIGZvciBleGFtcGxlLiBNYWtlIHZ2YXIgaW50byBhIHNpbXBsZVxuICAgICMgdmFyaWFibGUgaWYgaXQgaXNu4oCZdCBhbHJlYWR5LlxuICAgIGlmIHZhbHVlLnVud3JhcCgpIG5vdCBpbnN0YW5jZW9mIElkZW50aWZpZXJMaXRlcmFsIG9yIEB2YXJpYWJsZS5hc3NpZ25zKHZ2YXJUZXh0KVxuICAgICAgcmVmID0gby5zY29wZS5mcmVlVmFyaWFibGUgJ3JlZidcbiAgICAgIGFzc2lnbnMucHVzaCBbQG1ha2VDb2RlKHJlZiArICcgPSAnKSwgdnZhci4uLl1cbiAgICAgIHZ2YXIgPSBbQG1ha2VDb2RlIHJlZl1cbiAgICAgIHZ2YXJUZXh0ID0gcmVmXG5cbiAgICBzbGljZXIgPSAodHlwZSkgLT4gKHZ2YXIsIHN0YXJ0LCBlbmQgPSBubykgLT5cbiAgICAgIHZ2YXIgPSBuZXcgSWRlbnRpZmllckxpdGVyYWwgdnZhciB1bmxlc3MgdnZhciBpbnN0YW5jZW9mIFZhbHVlXG4gICAgICBhcmdzID0gW3Z2YXIsIG5ldyBOdW1iZXJMaXRlcmFsKHN0YXJ0KV1cbiAgICAgIGFyZ3MucHVzaCBuZXcgTnVtYmVyTGl0ZXJhbCBlbmQgaWYgZW5kXG4gICAgICBzbGljZSA9IG5ldyBWYWx1ZSAobmV3IElkZW50aWZpZXJMaXRlcmFsIHV0aWxpdHkgdHlwZSwgbyksIFtuZXcgQWNjZXNzIG5ldyBQcm9wZXJ0eU5hbWUgJ2NhbGwnXVxuICAgICAgbmV3IFZhbHVlIG5ldyBDYWxsIHNsaWNlLCBhcmdzXG5cbiAgICAjIEhlbHBlciB3aGljaCBvdXRwdXRzIGBbXS5zbGljZWAgY29kZS5cbiAgICBjb21wU2xpY2UgPSBzbGljZXIgXCJzbGljZVwiXG5cbiAgICAjIEhlbHBlciB3aGljaCBvdXRwdXRzIGBbXS5zcGxpY2VgIGNvZGUuXG4gICAgY29tcFNwbGljZSA9IHNsaWNlciBcInNwbGljZVwiXG5cbiAgICAjIENoZWNrIGlmIGBvYmplY3RzYCBhcnJheSBjb250YWlucyBhbnkgaW5zdGFuY2Ugb2YgYEFzc2lnbmAsIGUuZy4ge2E6MX0uXG4gICAgaGFzT2JqQXNzaWducyA9IChvYmpzKSAtPlxuICAgICAgKGkgZm9yIG9iaiwgaSBpbiBvYmpzIHdoZW4gb2JqIGluc3RhbmNlb2YgQXNzaWduIGFuZCBvYmouY29udGV4dCBpcyAnb2JqZWN0JylcblxuICAgICMgQ2hlY2sgaWYgYG9iamVjdHNgIGFycmF5IGNvbnRhaW5zIGFueSB1bmFzc2lnbmFibGUgb2JqZWN0LlxuICAgIG9iaklzVW5hc3NpZ25hYmxlID0gKG9ianMpIC0+XG4gICAgICByZXR1cm4geWVzIGZvciBvYmogaW4gb2JqcyB3aGVuIG5vdCBvYmouaXNBc3NpZ25hYmxlKClcbiAgICAgIG5vXG5cbiAgICAjIGBvYmplY3RzYCBhcmUgY29tcGxleCB3aGVuIHRoZXJlIGlzIG9iamVjdCBhc3NpZ24gKHthOjF9KSxcbiAgICAjIHVuYXNzaWduYWJsZSBvYmplY3QsIG9yIGp1c3QgYSBzaW5nbGUgbm9kZS5cbiAgICBjb21wbGV4T2JqZWN0cyA9IChvYmpzKSAtPlxuICAgICAgaGFzT2JqQXNzaWducyhvYmpzKS5sZW5ndGggb3Igb2JqSXNVbmFzc2lnbmFibGUob2Jqcykgb3Igb2xlbiBpcyAxXG5cbiAgICAjIFwiQ29tcGxleFwiIGBvYmplY3RzYCBhcmUgcHJvY2Vzc2VkIGluIGEgbG9vcC5cbiAgICAjIEV4YW1wbGVzOiBbYSwgYiwge2MsIHIuLi59LCBkXSwgW2EsIC4uLiwge2IsIHIuLi59LCBjLCBkXVxuICAgIGxvb3BPYmplY3RzID0gKG9ianMsIHZ2YXIsIHZ2YXJUeHQpID0+XG4gICAgICBmb3Igb2JqLCBpIGluIG9ianNcbiAgICAgICAgIyBgRWxpc2lvbmAgY2FuIGJlIHNraXBwZWQuXG4gICAgICAgIGNvbnRpbnVlIGlmIG9iaiBpbnN0YW5jZW9mIEVsaXNpb25cbiAgICAgICAgIyBJZiBgb2JqYCBpcyB7YTogMX1cbiAgICAgICAgaWYgb2JqIGluc3RhbmNlb2YgQXNzaWduIGFuZCBvYmouY29udGV4dCBpcyAnb2JqZWN0J1xuICAgICAgICAgIHt2YXJpYWJsZToge2Jhc2U6IGlkeH0sIHZhbHVlOiB2dmFyfSA9IG9ialxuICAgICAgICAgIHt2YXJpYWJsZTogdnZhcn0gPSB2dmFyIGlmIHZ2YXIgaW5zdGFuY2VvZiBBc3NpZ25cbiAgICAgICAgICBpZHggPVxuICAgICAgICAgICAgaWYgdnZhci50aGlzXG4gICAgICAgICAgICAgIHZ2YXIucHJvcGVydGllc1swXS5uYW1lXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG5ldyBQcm9wZXJ0eU5hbWUgdnZhci51bndyYXAoKS52YWx1ZVxuICAgICAgICAgIGFjYyA9IGlkeC51bndyYXAoKSBpbnN0YW5jZW9mIFByb3BlcnR5TmFtZVxuICAgICAgICAgIHZ2YWwgPSBuZXcgVmFsdWUgdmFsdWUsIFtuZXcgKGlmIGFjYyB0aGVuIEFjY2VzcyBlbHNlIEluZGV4KSBpZHhdXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAjIGBvYmpgIGlzIFthLi4uXSwge2EuLi59IG9yIGFcbiAgICAgICAgICB2dmFyID0gc3dpdGNoXG4gICAgICAgICAgICB3aGVuIG9iaiBpbnN0YW5jZW9mIFNwbGF0IHRoZW4gbmV3IFZhbHVlIG9iai5uYW1lXG4gICAgICAgICAgICBlbHNlIG9ialxuICAgICAgICAgIHZ2YWwgPSBzd2l0Y2hcbiAgICAgICAgICAgIHdoZW4gb2JqIGluc3RhbmNlb2YgU3BsYXQgdGhlbiBjb21wU2xpY2UodnZhclR4dCwgaSlcbiAgICAgICAgICAgIGVsc2UgbmV3IFZhbHVlIG5ldyBMaXRlcmFsKHZ2YXJUeHQpLCBbbmV3IEluZGV4IG5ldyBOdW1iZXJMaXRlcmFsIGldXG4gICAgICAgIG1lc3NhZ2UgPSBpc1VuYXNzaWduYWJsZSB2dmFyLnVud3JhcCgpLnZhbHVlXG4gICAgICAgIHZ2YXIuZXJyb3IgbWVzc2FnZSBpZiBtZXNzYWdlXG4gICAgICAgIHB1c2hBc3NpZ24gdnZhciwgdnZhbFxuXG4gICAgIyBcIlNpbXBsZVwiIGBvYmplY3RzYCBjYW4gYmUgc3BsaXQgYW5kIGNvbXBpbGVkIHRvIGFycmF5cywgW2EsIGIsIGNdID0gYXJyLCBbYSwgYiwgYy4uLl0gPSBhcnJcbiAgICBhc3NpZ25PYmplY3RzID0gKG9ianMsIHZ2YXIsIHZ2YXJUeHQpID0+XG4gICAgICB2dmFyID0gbmV3IFZhbHVlIG5ldyBBcnIob2JqcywgeWVzKVxuICAgICAgdnZhbCA9IGlmIHZ2YXJUeHQgaW5zdGFuY2VvZiBWYWx1ZSB0aGVuIHZ2YXJUeHQgZWxzZSBuZXcgVmFsdWUgbmV3IExpdGVyYWwodnZhclR4dClcbiAgICAgIHB1c2hBc3NpZ24gdnZhciwgdnZhbFxuXG4gICAgcHJvY2Vzc09iamVjdHMgPSAob2JqcywgdnZhciwgdnZhclR4dCkgLT5cbiAgICAgIGlmIGNvbXBsZXhPYmplY3RzIG9ianNcbiAgICAgICAgbG9vcE9iamVjdHMgb2JqcywgdnZhciwgdnZhclR4dFxuICAgICAgZWxzZVxuICAgICAgICBhc3NpZ25PYmplY3RzIG9ianMsIHZ2YXIsIHZ2YXJUeHRcblxuICAgICMgSW4gY2FzZSB0aGVyZSBpcyBgU3BsYXRgIG9yIGBFeHBhbnNpb25gIGluIGBvYmplY3RzYCxcbiAgICAjIHdlIGNhbiBzcGxpdCBhcnJheSBpbiB0d28gc2ltcGxlIHN1YmFycmF5cy5cbiAgICAjIGBTcGxhdGAgW2EsIGIsIGMuLi4sIGQsIGVdIGNhbiBiZSBzcGxpdCBpbnRvICBbYSwgYiwgYy4uLl0gYW5kIFtkLCBlXS5cbiAgICAjIGBFeHBhbnNpb25gIFthLCBiLCAuLi4sIGMsIGRdIGNhbiBiZSBzcGxpdCBpbnRvIFthLCBiXSBhbmQgW2MsIGRdLlxuICAgICMgRXhhbXBsZXM6XG4gICAgIyBhKSBgU3BsYXRgXG4gICAgIyAgIENTOiBbYSwgYiwgYy4uLiwgZCwgZV0gPSBhcnJcbiAgICAjICAgSlM6IFthLCBiLCAuLi5jXSA9IGFyciwgW2QsIGVdID0gc3BsaWNlLmNhbGwoYywgLTIpXG4gICAgIyBiKSBgRXhwYW5zaW9uYFxuICAgICMgICBDUzogW2EsIGIsIC4uLiwgZCwgZV0gPSBhcnJcbiAgICAjICAgSlM6IFthLCBiXSA9IGFyciwgW2QsIGVdID0gc2xpY2UuY2FsbChhcnIsIC0yKVxuICAgIGlmIHNwbGF0c0FuZEV4cGFucy5sZW5ndGhcbiAgICAgIGV4cElkeCA9IHNwbGF0c0FuZEV4cGFuc1swXVxuICAgICAgbGVmdE9ianMgPSBvYmplY3RzLnNsaWNlIDAsIGV4cElkeCArIChpZiBpc1NwbGF0IHRoZW4gMSBlbHNlIDApXG4gICAgICByaWdodE9ianMgPSBvYmplY3RzLnNsaWNlIGV4cElkeCArIDFcbiAgICAgIHByb2Nlc3NPYmplY3RzIGxlZnRPYmpzLCB2dmFyLCB2dmFyVGV4dCBpZiBsZWZ0T2Jqcy5sZW5ndGggaXNudCAwXG4gICAgICBpZiByaWdodE9ianMubGVuZ3RoIGlzbnQgMFxuICAgICAgICAjIFNsaWNlIG9yIHNwbGljZSBgb2JqZWN0c2AuXG4gICAgICAgIHJlZkV4cCA9IHN3aXRjaFxuICAgICAgICAgIHdoZW4gaXNTcGxhdCB0aGVuIGNvbXBTcGxpY2UgbmV3IFZhbHVlKG9iamVjdHNbZXhwSWR4XS5uYW1lKSwgcmlnaHRPYmpzLmxlbmd0aCAqIC0xXG4gICAgICAgICAgd2hlbiBpc0V4cGFucyB0aGVuIGNvbXBTbGljZSB2dmFyVGV4dCwgcmlnaHRPYmpzLmxlbmd0aCAqIC0xXG4gICAgICAgIGlmIGNvbXBsZXhPYmplY3RzIHJpZ2h0T2Jqc1xuICAgICAgICAgIHJlc3RWYXIgPSByZWZFeHBcbiAgICAgICAgICByZWZFeHAgPSBvLnNjb3BlLmZyZWVWYXJpYWJsZSAncmVmJ1xuICAgICAgICAgIGFzc2lnbnMucHVzaCBbQG1ha2VDb2RlKHJlZkV4cCArICcgPSAnKSwgcmVzdFZhci5jb21waWxlVG9GcmFnbWVudHMobywgTEVWRUxfTElTVCkuLi5dXG4gICAgICAgIHByb2Nlc3NPYmplY3RzIHJpZ2h0T2JqcywgdnZhciwgcmVmRXhwXG4gICAgZWxzZVxuICAgICAgIyBUaGVyZSBpcyBubyBgU3BsYXRgIG9yIGBFeHBhbnNpb25gIGluIGBvYmplY3RzYC5cbiAgICAgIHByb2Nlc3NPYmplY3RzIG9iamVjdHMsIHZ2YXIsIHZ2YXJUZXh0XG4gICAgc3BsYXRWYXJBc3NpZ24/KClcbiAgICBhc3NpZ25zLnB1c2ggdnZhciB1bmxlc3MgdG9wIG9yIEBzdWJwYXR0ZXJuXG4gICAgZnJhZ21lbnRzID0gQGpvaW5GcmFnbWVudEFycmF5cyBhc3NpZ25zLCAnLCAnXG4gICAgaWYgby5sZXZlbCA8IExFVkVMX0xJU1QgdGhlbiBmcmFnbWVudHMgZWxzZSBAd3JhcEluUGFyZW50aGVzZXMgZnJhZ21lbnRzXG5cbiAgIyBEaXNhbGxvdyBgWy4uLl0gPSBhYCBmb3Igc29tZSByZWFzb24uIChDb3VsZCBiZSBlcXVpdmFsZW50IHRvIGBbXSA9IGFgPylcbiAgZGlzYWxsb3dMb25lRXhwYW5zaW9uOiAtPlxuICAgIHJldHVybiB1bmxlc3MgQHZhcmlhYmxlLmJhc2UgaW5zdGFuY2VvZiBBcnJcbiAgICB7b2JqZWN0c30gPSBAdmFyaWFibGUuYmFzZVxuICAgIHJldHVybiB1bmxlc3Mgb2JqZWN0cz8ubGVuZ3RoIGlzIDFcbiAgICBbbG9uZU9iamVjdF0gPSBvYmplY3RzXG4gICAgaWYgbG9uZU9iamVjdCBpbnN0YW5jZW9mIEV4cGFuc2lvblxuICAgICAgbG9uZU9iamVjdC5lcnJvciAnRGVzdHJ1Y3R1cmluZyBhc3NpZ25tZW50IGhhcyBubyB0YXJnZXQnXG5cbiAgIyBTaG93IGVycm9yIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgYFNwbGF0YCwgb3IgYEV4cGFuc2lvbmAuXG4gICMgRXhhbXBsZXM6IFthLCBiLCBjLi4uLCBkLCBlLCBmLi4uXSwgW2EsIGIsIC4uLiwgYywgZCwgLi4uXSwgW2EsIGIsIC4uLiwgYywgZCwgZS4uLl1cbiAgZ2V0QW5kQ2hlY2tTcGxhdHNBbmRFeHBhbnNpb25zOiAtPlxuICAgIHJldHVybiB7c3BsYXRzOiBbXSwgZXhwYW5zOiBbXSwgc3BsYXRzQW5kRXhwYW5zOiBbXX0gdW5sZXNzIEB2YXJpYWJsZS5iYXNlIGluc3RhbmNlb2YgQXJyXG4gICAge29iamVjdHN9ID0gQHZhcmlhYmxlLmJhc2VcblxuICAgICMgQ291bnQgYWxsIGBTcGxhdHNgOiBbYSwgYiwgYy4uLiwgZCwgZV1cbiAgICBzcGxhdHMgPSAoaSBmb3Igb2JqLCBpIGluIG9iamVjdHMgd2hlbiBvYmogaW5zdGFuY2VvZiBTcGxhdClcbiAgICAjIENvdW50IGFsbCBgRXhwYW5zaW9uc2A6IFthLCBiLCAuLi4sIGMsIGRdXG4gICAgZXhwYW5zID0gKGkgZm9yIG9iaiwgaSBpbiBvYmplY3RzIHdoZW4gb2JqIGluc3RhbmNlb2YgRXhwYW5zaW9uKVxuICAgICMgQ29tYmluZSBzcGxhdHMgYW5kIGV4cGFuc2lvbnMuXG4gICAgc3BsYXRzQW5kRXhwYW5zID0gW3NwbGF0cy4uLiwgZXhwYW5zLi4uXVxuICAgIGlmIHNwbGF0c0FuZEV4cGFucy5sZW5ndGggPiAxXG4gICAgICAjIFNvcnQgJ3NwbGF0c0FuZEV4cGFucycgc28gd2UgY2FuIHNob3cgZXJyb3IgYXQgZmlyc3QgZGlzYWxsb3dlZCB0b2tlbi5cbiAgICAgIG9iamVjdHNbc3BsYXRzQW5kRXhwYW5zLnNvcnQoKVsxXV0uZXJyb3IgXCJtdWx0aXBsZSBzcGxhdHMvZXhwYW5zaW9ucyBhcmUgZGlzYWxsb3dlZCBpbiBhbiBhc3NpZ25tZW50XCJcbiAgICB7c3BsYXRzLCBleHBhbnMsIHNwbGF0c0FuZEV4cGFuc31cblxuICAjIFdoZW4gY29tcGlsaW5nIGEgY29uZGl0aW9uYWwgYXNzaWdubWVudCwgdGFrZSBjYXJlIHRvIGVuc3VyZSB0aGF0IHRoZVxuICAjIG9wZXJhbmRzIGFyZSBvbmx5IGV2YWx1YXRlZCBvbmNlLCBldmVuIHRob3VnaCB3ZSBoYXZlIHRvIHJlZmVyZW5jZSB0aGVtXG4gICMgbW9yZSB0aGFuIG9uY2UuXG4gIGNvbXBpbGVDb25kaXRpb25hbDogKG8pIC0+XG4gICAgW2xlZnQsIHJpZ2h0XSA9IEB2YXJpYWJsZS5jYWNoZVJlZmVyZW5jZSBvXG4gICAgIyBEaXNhbGxvdyBjb25kaXRpb25hbCBhc3NpZ25tZW50IG9mIHVuZGVmaW5lZCB2YXJpYWJsZXMuXG4gICAgaWYgbm90IGxlZnQucHJvcGVydGllcy5sZW5ndGggYW5kIGxlZnQuYmFzZSBpbnN0YW5jZW9mIExpdGVyYWwgYW5kXG4gICAgICAgICAgIGxlZnQuYmFzZSBub3QgaW5zdGFuY2VvZiBUaGlzTGl0ZXJhbCBhbmQgbm90IG8uc2NvcGUuY2hlY2sgbGVmdC5iYXNlLnZhbHVlXG4gICAgICBAdGhyb3dVbmFzc2lnbmFibGVDb25kaXRpb25hbEVycm9yIGxlZnQuYmFzZS52YWx1ZVxuICAgIGlmIFwiP1wiIGluIEBjb250ZXh0XG4gICAgICBvLmlzRXhpc3RlbnRpYWxFcXVhbHMgPSB0cnVlXG4gICAgICBuZXcgSWYobmV3IEV4aXN0ZW5jZShsZWZ0KSwgcmlnaHQsIHR5cGU6ICdpZicpLmFkZEVsc2UobmV3IEFzc2lnbihyaWdodCwgQHZhbHVlLCAnPScpKS5jb21waWxlVG9GcmFnbWVudHMgb1xuICAgIGVsc2VcbiAgICAgIGZyYWdtZW50cyA9IG5ldyBPcChAY29udGV4dFsuLi4tMV0sIGxlZnQsIG5ldyBBc3NpZ24ocmlnaHQsIEB2YWx1ZSwgJz0nKSkuY29tcGlsZVRvRnJhZ21lbnRzIG9cbiAgICAgIGlmIG8ubGV2ZWwgPD0gTEVWRUxfTElTVCB0aGVuIGZyYWdtZW50cyBlbHNlIEB3cmFwSW5QYXJlbnRoZXNlcyBmcmFnbWVudHNcblxuICAjIENvbnZlcnQgc3BlY2lhbCBtYXRoIGFzc2lnbm1lbnQgb3BlcmF0b3JzIGxpa2UgYGEgLy89IGJgIHRvIHRoZSBlcXVpdmFsZW50XG4gICMgZXh0ZW5kZWQgZm9ybSBgYSA9IGEgKiogYmAgYW5kIHRoZW4gY29tcGlsZXMgdGhhdC5cbiAgY29tcGlsZVNwZWNpYWxNYXRoOiAobykgLT5cbiAgICBbbGVmdCwgcmlnaHRdID0gQHZhcmlhYmxlLmNhY2hlUmVmZXJlbmNlIG9cbiAgICBuZXcgQXNzaWduKGxlZnQsIG5ldyBPcChAY29udGV4dFsuLi4tMV0sIHJpZ2h0LCBAdmFsdWUpKS5jb21waWxlVG9GcmFnbWVudHMgb1xuXG4gICMgQ29tcGlsZSB0aGUgYXNzaWdubWVudCBmcm9tIGFuIGFycmF5IHNwbGljZSBsaXRlcmFsLCB1c2luZyBKYXZhU2NyaXB0J3NcbiAgIyBgQXJyYXkjc3BsaWNlYCBtZXRob2QuXG4gIGNvbXBpbGVTcGxpY2U6IChvKSAtPlxuICAgIHtyYW5nZToge2Zyb20sIHRvLCBleGNsdXNpdmV9fSA9IEB2YXJpYWJsZS5wcm9wZXJ0aWVzLnBvcCgpXG4gICAgdW53cmFwcGVkVmFyID0gQHZhcmlhYmxlLnVud3JhcEFsbCgpXG4gICAgaWYgdW53cmFwcGVkVmFyLmNvbW1lbnRzXG4gICAgICBtb3ZlQ29tbWVudHMgdW53cmFwcGVkVmFyLCBAXG4gICAgICBkZWxldGUgQHZhcmlhYmxlLmNvbW1lbnRzXG4gICAgbmFtZSA9IEB2YXJpYWJsZS5jb21waWxlIG9cbiAgICBpZiBmcm9tXG4gICAgICBbZnJvbURlY2wsIGZyb21SZWZdID0gQGNhY2hlVG9Db2RlRnJhZ21lbnRzIGZyb20uY2FjaGUgbywgTEVWRUxfT1BcbiAgICBlbHNlXG4gICAgICBmcm9tRGVjbCA9IGZyb21SZWYgPSAnMCdcbiAgICBpZiB0b1xuICAgICAgaWYgZnJvbT8uaXNOdW1iZXIoKSBhbmQgdG8uaXNOdW1iZXIoKVxuICAgICAgICB0byA9IHRvLmNvbXBpbGUobykgLSBmcm9tUmVmXG4gICAgICAgIHRvICs9IDEgdW5sZXNzIGV4Y2x1c2l2ZVxuICAgICAgZWxzZVxuICAgICAgICB0byA9IHRvLmNvbXBpbGUobywgTEVWRUxfQUNDRVNTKSArICcgLSAnICsgZnJvbVJlZlxuICAgICAgICB0byArPSAnICsgMScgdW5sZXNzIGV4Y2x1c2l2ZVxuICAgIGVsc2VcbiAgICAgIHRvID0gXCI5ZTlcIlxuICAgIFt2YWxEZWYsIHZhbFJlZl0gPSBAdmFsdWUuY2FjaGUgbywgTEVWRUxfTElTVFxuICAgIGFuc3dlciA9IFtdLmNvbmNhdCBAbWFrZUNvZGUoXCIje3V0aWxpdHkgJ3NwbGljZScsIG99LmFwcGx5KCN7bmFtZX0sIFsje2Zyb21EZWNsfSwgI3t0b31dLmNvbmNhdChcIiksIHZhbERlZiwgQG1ha2VDb2RlKFwiKSksIFwiKSwgdmFsUmVmXG4gICAgaWYgby5sZXZlbCA+IExFVkVMX1RPUCB0aGVuIEB3cmFwSW5QYXJlbnRoZXNlcyBhbnN3ZXIgZWxzZSBhbnN3ZXJcblxuICBlYWNoTmFtZTogKGl0ZXJhdG9yKSAtPlxuICAgIEB2YXJpYWJsZS51bndyYXBBbGwoKS5lYWNoTmFtZSBpdGVyYXRvclxuXG4gIGlzRGVmYXVsdEFzc2lnbm1lbnQ6IC0+IEBwYXJhbSBvciBAbmVzdGVkTGhzXG5cbiAgcHJvcGFnYXRlTGhzOiAtPlxuICAgIHJldHVybiB1bmxlc3MgQHZhcmlhYmxlPy5pc0FycmF5PygpIG9yIEB2YXJpYWJsZT8uaXNPYmplY3Q/KClcbiAgICAjIFRoaXMgaXMgdGhlIGxlZnQtaGFuZCBzaWRlIG9mIGFuIGFzc2lnbm1lbnQ7IGxldCBgQXJyYCBhbmQgYE9iamBcbiAgICAjIGtub3cgdGhhdCwgc28gdGhhdCB0aG9zZSBub2RlcyBrbm93IHRoYXQgdGhleeKAmXJlIGFzc2lnbmFibGUgYXNcbiAgICAjIGRlc3RydWN0dXJlZCB2YXJpYWJsZXMuXG4gICAgQHZhcmlhYmxlLmJhc2UucHJvcGFnYXRlTGhzIHllc1xuXG4gIHRocm93VW5hc3NpZ25hYmxlQ29uZGl0aW9uYWxFcnJvcjogKG5hbWUpIC0+XG4gICAgQHZhcmlhYmxlLmVycm9yIFwidGhlIHZhcmlhYmxlIFxcXCIje25hbWV9XFxcIiBjYW4ndCBiZSBhc3NpZ25lZCB3aXRoICN7QGNvbnRleHR9IGJlY2F1c2UgaXQgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGJlZm9yZVwiXG5cbiAgaXNDb25kaXRpb25hbDogLT5cbiAgICBAY29udGV4dCBpbiBbJ3x8PScsICcmJj0nLCAnPz0nXVxuXG4gIGlzU3RhdGVtZW50QXN0OiBOT1xuXG4gIGFzdE5vZGU6IChvKSAtPlxuICAgIEBkaXNhbGxvd0xvbmVFeHBhbnNpb24oKVxuICAgIEBnZXRBbmRDaGVja1NwbGF0c0FuZEV4cGFuc2lvbnMoKVxuICAgIGlmIEBpc0NvbmRpdGlvbmFsKClcbiAgICAgIHZhcmlhYmxlID0gQHZhcmlhYmxlLnVud3JhcCgpXG4gICAgICBpZiB2YXJpYWJsZSBpbnN0YW5jZW9mIElkZW50aWZpZXJMaXRlcmFsIGFuZCBub3Qgby5zY29wZS5jaGVjayB2YXJpYWJsZS52YWx1ZVxuICAgICAgICBAdGhyb3dVbmFzc2lnbmFibGVDb25kaXRpb25hbEVycm9yIHZhcmlhYmxlLnZhbHVlXG4gICAgQGFkZFNjb3BlVmFyaWFibGVzIG8sIGFsbG93QXNzaWdubWVudFRvRXhwYW5zaW9uOiB5ZXMsIGFsbG93QXNzaWdubWVudFRvTm9udHJhaWxpbmdTcGxhdDogeWVzLCBhbGxvd0Fzc2lnbm1lbnRUb0VtcHR5QXJyYXk6IHllcywgYWxsb3dBc3NpZ25tZW50VG9Db21wbGV4U3BsYXQ6IHllc1xuICAgIHN1cGVyIG9cblxuICBhc3RUeXBlOiAtPlxuICAgIGlmIEBpc0RlZmF1bHRBc3NpZ25tZW50KClcbiAgICAgICdBc3NpZ25tZW50UGF0dGVybidcbiAgICBlbHNlXG4gICAgICAnQXNzaWdubWVudEV4cHJlc3Npb24nXG5cbiAgYXN0UHJvcGVydGllczogKG8pIC0+XG4gICAgcmV0ID1cbiAgICAgIHJpZ2h0OiBAdmFsdWUuYXN0IG8sIExFVkVMX0xJU1RcbiAgICAgIGxlZnQ6IEB2YXJpYWJsZS5hc3QgbywgTEVWRUxfTElTVFxuXG4gICAgdW5sZXNzIEBpc0RlZmF1bHRBc3NpZ25tZW50KClcbiAgICAgIHJldC5vcGVyYXRvciA9IEBvcmlnaW5hbENvbnRleHQgPyAnPSdcblxuICAgIHJldFxuXG4jIyMjIEZ1bmNHbHlwaFxuXG5leHBvcnRzLkZ1bmNHbHlwaCA9IGNsYXNzIEZ1bmNHbHlwaCBleHRlbmRzIEJhc2VcbiAgY29uc3RydWN0b3I6IChAZ2x5cGgpIC0+XG4gICAgc3VwZXIoKVxuXG4jIyMjIENvZGVcblxuIyBBIGZ1bmN0aW9uIGRlZmluaXRpb24uIFRoaXMgaXMgdGhlIG9ubHkgbm9kZSB0aGF0IGNyZWF0ZXMgYSBuZXcgU2NvcGUuXG4jIFdoZW4gZm9yIHRoZSBwdXJwb3NlcyBvZiB3YWxraW5nIHRoZSBjb250ZW50cyBvZiBhIGZ1bmN0aW9uIGJvZHksIHRoZSBDb2RlXG4jIGhhcyBubyAqY2hpbGRyZW4qIC0tIHRoZXkncmUgd2l0aGluIHRoZSBpbm5lciBzY29wZS5cbmV4cG9ydHMuQ29kZSA9IGNsYXNzIENvZGUgZXh0ZW5kcyBCYXNlXG4gIGNvbnN0cnVjdG9yOiAocGFyYW1zLCBib2R5LCBAZnVuY0dseXBoLCBAcGFyYW1TdGFydCkgLT5cbiAgICBzdXBlcigpXG5cbiAgICBAcGFyYW1zICAgICAgPSBwYXJhbXMgb3IgW11cbiAgICBAYm9keSAgICAgICAgPSBib2R5IG9yIG5ldyBCbG9ja1xuICAgIEBib3VuZCAgICAgICA9IEBmdW5jR2x5cGg/LmdseXBoIGlzICc9PidcbiAgICBAaXNHZW5lcmF0b3IgPSBub1xuICAgIEBpc0FzeW5jICAgICA9IG5vXG4gICAgQGlzTWV0aG9kICAgID0gbm9cblxuICAgIEBib2R5LnRyYXZlcnNlQ2hpbGRyZW4gbm8sIChub2RlKSA9PlxuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBPcCBhbmQgbm9kZS5pc1lpZWxkKCkpIG9yIG5vZGUgaW5zdGFuY2VvZiBZaWVsZFJldHVyblxuICAgICAgICBAaXNHZW5lcmF0b3IgPSB5ZXNcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgT3AgYW5kIG5vZGUuaXNBd2FpdCgpKSBvciBub2RlIGluc3RhbmNlb2YgQXdhaXRSZXR1cm5cbiAgICAgICAgQGlzQXN5bmMgPSB5ZXNcbiAgICAgIGlmIG5vZGUgaW5zdGFuY2VvZiBGb3IgYW5kIG5vZGUuaXNBd2FpdCgpXG4gICAgICAgIEBpc0FzeW5jID0geWVzXG5cbiAgICBAcHJvcGFnYXRlTGhzKClcblxuICBjaGlsZHJlbjogWydwYXJhbXMnLCAnYm9keSddXG5cbiAgaXNTdGF0ZW1lbnQ6IC0+IEBpc01ldGhvZFxuXG4gIGp1bXBzOiBOT1xuXG4gIG1ha2VTY29wZTogKHBhcmVudFNjb3BlKSAtPiBuZXcgU2NvcGUgcGFyZW50U2NvcGUsIEBib2R5LCB0aGlzXG5cbiAgIyBDb21waWxhdGlvbiBjcmVhdGVzIGEgbmV3IHNjb3BlIHVubGVzcyBleHBsaWNpdGx5IGFza2VkIHRvIHNoYXJlIHdpdGggdGhlXG4gICMgb3V0ZXIgc2NvcGUuIEhhbmRsZXMgc3BsYXQgcGFyYW1ldGVycyBpbiB0aGUgcGFyYW1ldGVyIGxpc3QgYnkgc2V0dGluZ1xuICAjIHN1Y2ggcGFyYW1ldGVycyB0byBiZSB0aGUgZmluYWwgcGFyYW1ldGVyIGluIHRoZSBmdW5jdGlvbiBkZWZpbml0aW9uLCBhc1xuICAjIHJlcXVpcmVkIHBlciB0aGUgRVMyMDE1IHNwZWMuIElmIHRoZSBDb2ZmZWVTY3JpcHQgZnVuY3Rpb24gZGVmaW5pdGlvbiBoYWRcbiAgIyBwYXJhbWV0ZXJzIGFmdGVyIHRoZSBzcGxhdCwgdGhleSBhcmUgZGVjbGFyZWQgdmlhIGV4cHJlc3Npb25zIGluIHRoZVxuICAjIGZ1bmN0aW9uIGJvZHkuXG4gIGNvbXBpbGVOb2RlOiAobykgLT5cbiAgICBAY2hlY2tGb3JBc3luY09yR2VuZXJhdG9yQ29uc3RydWN0b3IoKVxuXG4gICAgaWYgQGJvdW5kXG4gICAgICBAY29udGV4dCA9IG8uc2NvcGUubWV0aG9kLmNvbnRleHQgaWYgby5zY29wZS5tZXRob2Q/LmJvdW5kXG4gICAgICBAY29udGV4dCA9ICd0aGlzJyB1bmxlc3MgQGNvbnRleHRcblxuICAgIEB1cGRhdGVPcHRpb25zIG9cbiAgICBwYXJhbXMgICAgICAgICAgID0gW11cbiAgICBleHBycyAgICAgICAgICAgID0gW11cbiAgICB0aGlzQXNzaWdubWVudHMgID0gQHRoaXNBc3NpZ25tZW50cz8uc2xpY2UoKSA/IFtdXG4gICAgcGFyYW1zQWZ0ZXJTcGxhdCA9IFtdXG4gICAgaGF2ZVNwbGF0UGFyYW0gICA9IG5vXG4gICAgaGF2ZUJvZHlQYXJhbSAgICA9IG5vXG5cbiAgICBAY2hlY2tGb3JEdXBsaWNhdGVQYXJhbXMoKVxuICAgIEBkaXNhbGxvd0xvbmVFeHBhbnNpb25BbmRNdWx0aXBsZVNwbGF0cygpXG5cbiAgICAjIFNlcGFyYXRlIGB0aGlzYCBhc3NpZ25tZW50cy5cbiAgICBAZWFjaFBhcmFtTmFtZSAobmFtZSwgbm9kZSwgcGFyYW0sIG9iaikgLT5cbiAgICAgIGlmIG5vZGUudGhpc1xuICAgICAgICBuYW1lICAgPSBub2RlLnByb3BlcnRpZXNbMF0ubmFtZS52YWx1ZVxuICAgICAgICBuYW1lICAgPSBcIl8je25hbWV9XCIgaWYgbmFtZSBpbiBKU19GT1JCSURERU5cbiAgICAgICAgdGFyZ2V0ID0gbmV3IElkZW50aWZpZXJMaXRlcmFsIG8uc2NvcGUuZnJlZVZhcmlhYmxlIG5hbWUsIHJlc2VydmU6IG5vXG4gICAgICAgICMgYFBhcmFtYCBpcyBvYmplY3QgZGVzdHJ1Y3R1cmluZyB3aXRoIGEgZGVmYXVsdCB2YWx1ZTogKHtAcHJvcCA9IDF9KSAtPlxuICAgICAgICAjIEluIGEgY2FzZSB3aGVuIHRoZSB2YXJpYWJsZSBuYW1lIGlzIGFscmVhZHkgcmVzZXJ2ZWQsIHdlIGhhdmUgdG8gYXNzaWduXG4gICAgICAgICMgYSBuZXcgdmFyaWFibGUgbmFtZSB0byB0aGUgZGVzdHJ1Y3R1cmVkIHZhcmlhYmxlOiAoe3Byb3A6cHJvcDEgPSAxfSkgLT5cbiAgICAgICAgcmVwbGFjZW1lbnQgPVxuICAgICAgICAgICAgaWYgcGFyYW0ubmFtZSBpbnN0YW5jZW9mIE9iaiBhbmQgb2JqIGluc3RhbmNlb2YgQXNzaWduIGFuZFxuICAgICAgICAgICAgICAgIG9iai5vcGVyYXRvclRva2VuLnZhbHVlIGlzICc9J1xuICAgICAgICAgICAgICBuZXcgQXNzaWduIChuZXcgSWRlbnRpZmllckxpdGVyYWwgbmFtZSksIHRhcmdldCwgJ29iamVjdCcgIywgb3BlcmF0b3JUb2tlbjogbmV3IExpdGVyYWwgJzonXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHRhcmdldFxuICAgICAgICBwYXJhbS5yZW5hbWVQYXJhbSBub2RlLCByZXBsYWNlbWVudFxuICAgICAgICB0aGlzQXNzaWdubWVudHMucHVzaCBuZXcgQXNzaWduIG5vZGUsIHRhcmdldFxuXG4gICAgIyBQYXJzZSB0aGUgcGFyYW1ldGVycywgYWRkaW5nIHRoZW0gdG8gdGhlIGxpc3Qgb2YgcGFyYW1ldGVycyB0byBwdXQgaW4gdGhlXG4gICAgIyBmdW5jdGlvbiBkZWZpbml0aW9uOyBhbmQgZGVhbGluZyB3aXRoIHNwbGF0cyBvciBleHBhbnNpb25zLCBpbmNsdWRpbmdcbiAgICAjIGFkZGluZyBleHByZXNzaW9ucyB0byB0aGUgZnVuY3Rpb24gYm9keSB0byBkZWNsYXJlIGFsbCBwYXJhbWV0ZXJcbiAgICAjIHZhcmlhYmxlcyB0aGF0IHdvdWxkIGhhdmUgYmVlbiBhZnRlciB0aGUgc3BsYXQvZXhwYW5zaW9uIHBhcmFtZXRlci5cbiAgICAjIElmIHdlIGVuY291bnRlciBhIHBhcmFtZXRlciB0aGF0IG5lZWRzIHRvIGJlIGRlY2xhcmVkIGluIHRoZSBmdW5jdGlvblxuICAgICMgYm9keSBmb3IgYW55IHJlYXNvbiwgZm9yIGV4YW1wbGUgaXTigJlzIGRlc3RydWN0dXJlZCB3aXRoIGB0aGlzYCwgYWxzb1xuICAgICMgZGVjbGFyZSBhbmQgYXNzaWduIGFsbCBzdWJzZXF1ZW50IHBhcmFtZXRlcnMgaW4gdGhlIGZ1bmN0aW9uIGJvZHkgc28gdGhhdFxuICAgICMgYW55IG5vbi1pZGVtcG90ZW50IHBhcmFtZXRlcnMgYXJlIGV2YWx1YXRlZCBpbiB0aGUgY29ycmVjdCBvcmRlci5cbiAgICBmb3IgcGFyYW0sIGkgaW4gQHBhcmFtc1xuICAgICAgIyBXYXMgYC4uLmAgdXNlZCB3aXRoIHRoaXMgcGFyYW1ldGVyPyBTcGxhdC9leHBhbnNpb24gcGFyYW1ldGVycyBjYW5ub3RcbiAgICAgICMgaGF2ZSBkZWZhdWx0IHZhbHVlcywgc28gd2UgbmVlZCBub3Qgd29ycnkgYWJvdXQgdGhhdC5cbiAgICAgIGlmIHBhcmFtLnNwbGF0IG9yIHBhcmFtIGluc3RhbmNlb2YgRXhwYW5zaW9uXG4gICAgICAgIGhhdmVTcGxhdFBhcmFtID0geWVzXG4gICAgICAgIGlmIHBhcmFtLnNwbGF0XG4gICAgICAgICAgaWYgcGFyYW0ubmFtZSBpbnN0YW5jZW9mIEFyciBvciBwYXJhbS5uYW1lIGluc3RhbmNlb2YgT2JqXG4gICAgICAgICAgICAjIFNwbGF0IGFycmF5cyBhcmUgdHJlYXRlZCBvZGRseSBieSBFUzsgZGVhbCB3aXRoIHRoZW0gdGhlIGxlZ2FjeVxuICAgICAgICAgICAgIyB3YXkgaW4gdGhlIGZ1bmN0aW9uIGJvZHkuIFRPRE86IFNob3VsZCB0aGlzIGJlIGhhbmRsZWQgaW4gdGhlXG4gICAgICAgICAgICAjIGZ1bmN0aW9uIHBhcmFtZXRlciBsaXN0LCBhbmQgaWYgc28sIGhvdz9cbiAgICAgICAgICAgIHNwbGF0UGFyYW1OYW1lID0gby5zY29wZS5mcmVlVmFyaWFibGUgJ2FyZydcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoIHJlZiA9IG5ldyBWYWx1ZSBuZXcgSWRlbnRpZmllckxpdGVyYWwgc3BsYXRQYXJhbU5hbWVcbiAgICAgICAgICAgIGV4cHJzLnB1c2ggbmV3IEFzc2lnbiBuZXcgVmFsdWUocGFyYW0ubmFtZSksIHJlZlxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoIHJlZiA9IHBhcmFtLmFzUmVmZXJlbmNlIG9cbiAgICAgICAgICAgIHNwbGF0UGFyYW1OYW1lID0gZnJhZ21lbnRzVG9UZXh0IHJlZi5jb21waWxlTm9kZVdpdGhvdXRDb21tZW50cyBvXG4gICAgICAgICAgaWYgcGFyYW0uc2hvdWxkQ2FjaGUoKVxuICAgICAgICAgICAgZXhwcnMucHVzaCBuZXcgQXNzaWduIG5ldyBWYWx1ZShwYXJhbS5uYW1lKSwgcmVmXG4gICAgICAgIGVsc2UgIyBgcGFyYW1gIGlzIGFuIEV4cGFuc2lvblxuICAgICAgICAgIHNwbGF0UGFyYW1OYW1lID0gby5zY29wZS5mcmVlVmFyaWFibGUgJ2FyZ3MnXG4gICAgICAgICAgcGFyYW1zLnB1c2ggbmV3IFZhbHVlIG5ldyBJZGVudGlmaWVyTGl0ZXJhbCBzcGxhdFBhcmFtTmFtZVxuXG4gICAgICAgIG8uc2NvcGUucGFyYW1ldGVyIHNwbGF0UGFyYW1OYW1lXG5cbiAgICAgICMgUGFyc2UgYWxsIG90aGVyIHBhcmFtZXRlcnM7IGlmIGEgc3BsYXQgcGFyYW1hdGVyIGhhcyBub3QgeWV0IGJlZW5cbiAgICAgICMgZW5jb3VudGVyZWQsIGFkZCB0aGVzZSBvdGhlciBwYXJhbWV0ZXJzIHRvIHRoZSBsaXN0IHRvIGJlIG91dHB1dCBpblxuICAgICAgIyB0aGUgZnVuY3Rpb24gZGVmaW5pdGlvbi5cbiAgICAgIGVsc2VcbiAgICAgICAgaWYgcGFyYW0uc2hvdWxkQ2FjaGUoKSBvciBoYXZlQm9keVBhcmFtXG4gICAgICAgICAgcGFyYW0uYXNzaWduZWRJbkJvZHkgPSB5ZXNcbiAgICAgICAgICBoYXZlQm9keVBhcmFtID0geWVzXG4gICAgICAgICAgIyBUaGlzIHBhcmFtZXRlciBjYW5ub3QgYmUgZGVjbGFyZWQgb3IgYXNzaWduZWQgaW4gdGhlIHBhcmFtZXRlclxuICAgICAgICAgICMgbGlzdC4gU28gcHV0IGEgcmVmZXJlbmNlIGluIHRoZSBwYXJhbWV0ZXIgbGlzdCBhbmQgYWRkIGEgc3RhdGVtZW50XG4gICAgICAgICAgIyB0byB0aGUgZnVuY3Rpb24gYm9keSBhc3NpZ25pbmcgaXQsIGUuZy5cbiAgICAgICAgICAjIGAoYXJnKSA9PiB7IHZhciBhID0gYXJnLmE7IH1gLCB3aXRoIGEgZGVmYXVsdCB2YWx1ZSBpZiBpdCBoYXMgb25lLlxuICAgICAgICAgIGlmIHBhcmFtLnZhbHVlP1xuICAgICAgICAgICAgY29uZGl0aW9uID0gbmV3IE9wICc9PT0nLCBwYXJhbSwgbmV3IFVuZGVmaW5lZExpdGVyYWxcbiAgICAgICAgICAgIGlmVHJ1ZSA9IG5ldyBBc3NpZ24gbmV3IFZhbHVlKHBhcmFtLm5hbWUpLCBwYXJhbS52YWx1ZVxuICAgICAgICAgICAgZXhwcnMucHVzaCBuZXcgSWYgY29uZGl0aW9uLCBpZlRydWVcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBleHBycy5wdXNoIG5ldyBBc3NpZ24gbmV3IFZhbHVlKHBhcmFtLm5hbWUpLCBwYXJhbS5hc1JlZmVyZW5jZShvKSwgbnVsbCwgcGFyYW06ICdhbHdheXNEZWNsYXJlJ1xuXG4gICAgICAgICMgSWYgdGhpcyBwYXJhbWV0ZXIgY29tZXMgYmVmb3JlIHRoZSBzcGxhdCBvciBleHBhbnNpb24sIGl0IHdpbGwgZ29cbiAgICAgICAgIyBpbiB0aGUgZnVuY3Rpb24gZGVmaW5pdGlvbiBwYXJhbWV0ZXIgbGlzdC5cbiAgICAgICAgdW5sZXNzIGhhdmVTcGxhdFBhcmFtXG4gICAgICAgICAgIyBJZiB0aGlzIHBhcmFtZXRlciBoYXMgYSBkZWZhdWx0IHZhbHVlLCBhbmQgaXQgaGFzbuKAmXQgYWxyZWFkeSBiZWVuXG4gICAgICAgICAgIyBzZXQgYnkgdGhlIGBzaG91bGRDYWNoZSgpYCBibG9jayBhYm92ZSwgZGVmaW5lIGl0IGFzIGEgc3RhdGVtZW50IGluXG4gICAgICAgICAgIyB0aGUgZnVuY3Rpb24gYm9keS4gVGhpcyBwYXJhbWV0ZXIgY29tZXMgYWZ0ZXIgdGhlIHNwbGF0IHBhcmFtZXRlcixcbiAgICAgICAgICAjIHNvIHdlIGNhbuKAmXQgZGVmaW5lIGl0cyBkZWZhdWx0IHZhbHVlIGluIHRoZSBwYXJhbWV0ZXIgbGlzdC5cbiAgICAgICAgICBpZiBwYXJhbS5zaG91bGRDYWNoZSgpXG4gICAgICAgICAgICByZWYgPSBwYXJhbS5hc1JlZmVyZW5jZSBvXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgcGFyYW0udmFsdWU/IGFuZCBub3QgcGFyYW0uYXNzaWduZWRJbkJvZHlcbiAgICAgICAgICAgICAgcmVmID0gbmV3IEFzc2lnbiBuZXcgVmFsdWUocGFyYW0ubmFtZSksIHBhcmFtLnZhbHVlLCBudWxsLCBwYXJhbTogeWVzXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHJlZiA9IHBhcmFtXG4gICAgICAgICAgIyBBZGQgdGhpcyBwYXJhbWV0ZXLigJlzIHJlZmVyZW5jZShzKSB0byB0aGUgZnVuY3Rpb24gc2NvcGUuXG4gICAgICAgICAgaWYgcGFyYW0ubmFtZSBpbnN0YW5jZW9mIEFyciBvciBwYXJhbS5uYW1lIGluc3RhbmNlb2YgT2JqXG4gICAgICAgICAgICAjIFRoaXMgcGFyYW1ldGVyIGlzIGRlc3RydWN0dXJlZC5cbiAgICAgICAgICAgIHBhcmFtLm5hbWUubGhzID0geWVzXG4gICAgICAgICAgICB1bmxlc3MgcGFyYW0uc2hvdWxkQ2FjaGUoKVxuICAgICAgICAgICAgICBwYXJhbS5uYW1lLmVhY2hOYW1lIChwcm9wKSAtPlxuICAgICAgICAgICAgICAgIG8uc2NvcGUucGFyYW1ldGVyIHByb3AudmFsdWVcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAjIFRoaXMgY29tcGlsYXRpb24gb2YgdGhlIHBhcmFtZXRlciBpcyBvbmx5IHRvIGdldCBpdHMgbmFtZSB0byBhZGRcbiAgICAgICAgICAgICMgdG8gdGhlIHNjb3BlIG5hbWUgdHJhY2tpbmc7IHNpbmNlIHRoZSBjb21waWxhdGlvbiBvdXRwdXQgaGVyZVxuICAgICAgICAgICAgIyBpc27igJl0IGtlcHQgZm9yIGV2ZW50dWFsIG91dHB1dCwgZG9u4oCZdCBpbmNsdWRlIGNvbW1lbnRzIGluIHRoaXNcbiAgICAgICAgICAgICMgY29tcGlsYXRpb24sIHNvIHRoYXQgdGhleSBnZXQgb3V0cHV0IHRoZSDigJxyZWFs4oCdIHRpbWUgdGhpcyBwYXJhbVxuICAgICAgICAgICAgIyBpcyBjb21waWxlZC5cbiAgICAgICAgICAgIHBhcmFtVG9BZGRUb1Njb3BlID0gaWYgcGFyYW0udmFsdWU/IHRoZW4gcGFyYW0gZWxzZSByZWZcbiAgICAgICAgICAgIG8uc2NvcGUucGFyYW1ldGVyIGZyYWdtZW50c1RvVGV4dCBwYXJhbVRvQWRkVG9TY29wZS5jb21waWxlVG9GcmFnbWVudHNXaXRob3V0Q29tbWVudHMgb1xuICAgICAgICAgIHBhcmFtcy5wdXNoIHJlZlxuICAgICAgICBlbHNlXG4gICAgICAgICAgcGFyYW1zQWZ0ZXJTcGxhdC5wdXNoIHBhcmFtXG4gICAgICAgICAgIyBJZiB0aGlzIHBhcmFtZXRlciBoYWQgYSBkZWZhdWx0IHZhbHVlLCBzaW5jZSBpdOKAmXMgbm8gbG9uZ2VyIGluIHRoZVxuICAgICAgICAgICMgZnVuY3Rpb24gcGFyYW1ldGVyIGxpc3Qgd2UgbmVlZCB0byBhc3NpZ24gaXRzIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgICAjIChpZiBuZWNlc3NhcnkpIGFzIGFuIGV4cHJlc3Npb24gaW4gdGhlIGJvZHkuXG4gICAgICAgICAgaWYgcGFyYW0udmFsdWU/IGFuZCBub3QgcGFyYW0uc2hvdWxkQ2FjaGUoKVxuICAgICAgICAgICAgY29uZGl0aW9uID0gbmV3IE9wICc9PT0nLCBwYXJhbSwgbmV3IFVuZGVmaW5lZExpdGVyYWxcbiAgICAgICAgICAgIGlmVHJ1ZSA9IG5ldyBBc3NpZ24gbmV3IFZhbHVlKHBhcmFtLm5hbWUpLCBwYXJhbS52YWx1ZVxuICAgICAgICAgICAgZXhwcnMucHVzaCBuZXcgSWYgY29uZGl0aW9uLCBpZlRydWVcbiAgICAgICAgICAjIEFkZCB0aGlzIHBhcmFtZXRlciB0byB0aGUgc2NvcGUsIHNpbmNlIGl0IHdvdWxkbuKAmXQgaGF2ZSBiZWVuIGFkZGVkXG4gICAgICAgICAgIyB5ZXQgc2luY2UgaXQgd2FzIHNraXBwZWQgZWFybGllci5cbiAgICAgICAgICBvLnNjb3BlLmFkZCBwYXJhbS5uYW1lLnZhbHVlLCAndmFyJywgeWVzIGlmIHBhcmFtLm5hbWU/LnZhbHVlP1xuXG4gICAgIyBJZiB0aGVyZSB3ZXJlIHBhcmFtZXRlcnMgYWZ0ZXIgdGhlIHNwbGF0IG9yIGV4cGFuc2lvbiBwYXJhbWV0ZXIsIHRob3NlXG4gICAgIyBwYXJhbWV0ZXJzIG5lZWQgdG8gYmUgYXNzaWduZWQgaW4gdGhlIGJvZHkgb2YgdGhlIGZ1bmN0aW9uLlxuICAgIGlmIHBhcmFtc0FmdGVyU3BsYXQubGVuZ3RoIGlzbnQgMFxuICAgICAgIyBDcmVhdGUgYSBkZXN0cnVjdHVyZWQgYXNzaWdubWVudCwgZS5nLiBgW2EsIGIsIGNdID0gW2FyZ3MuLi4sIGIsIGNdYFxuICAgICAgZXhwcnMudW5zaGlmdCBuZXcgQXNzaWduIG5ldyBWYWx1ZShcbiAgICAgICAgICBuZXcgQXJyIFtuZXcgU3BsYXQobmV3IElkZW50aWZpZXJMaXRlcmFsKHNwbGF0UGFyYW1OYW1lKSksIChwYXJhbS5hc1JlZmVyZW5jZSBvIGZvciBwYXJhbSBpbiBwYXJhbXNBZnRlclNwbGF0KS4uLl1cbiAgICAgICAgKSwgbmV3IFZhbHVlIG5ldyBJZGVudGlmaWVyTGl0ZXJhbCBzcGxhdFBhcmFtTmFtZVxuXG4gICAgIyBBZGQgbmV3IGV4cHJlc3Npb25zIHRvIHRoZSBmdW5jdGlvbiBib2R5XG4gICAgd2FzRW1wdHkgPSBAYm9keS5pc0VtcHR5KClcbiAgICBAZGlzYWxsb3dTdXBlckluUGFyYW1EZWZhdWx0cygpXG4gICAgQGNoZWNrU3VwZXJDYWxsc0luQ29uc3RydWN0b3JCb2R5KClcbiAgICBAYm9keS5leHByZXNzaW9ucy51bnNoaWZ0IHRoaXNBc3NpZ25tZW50cy4uLiB1bmxlc3MgQGV4cGFuZEN0b3JTdXBlciB0aGlzQXNzaWdubWVudHNcbiAgICBAYm9keS5leHByZXNzaW9ucy51bnNoaWZ0IGV4cHJzLi4uXG4gICAgaWYgQGlzTWV0aG9kIGFuZCBAYm91bmQgYW5kIG5vdCBAaXNTdGF0aWMgYW5kIEBjbGFzc1ZhcmlhYmxlXG4gICAgICBib3VuZE1ldGhvZENoZWNrID0gbmV3IFZhbHVlIG5ldyBMaXRlcmFsIHV0aWxpdHkgJ2JvdW5kTWV0aG9kQ2hlY2snLCBvXG4gICAgICBAYm9keS5leHByZXNzaW9ucy51bnNoaWZ0IG5ldyBDYWxsKGJvdW5kTWV0aG9kQ2hlY2ssIFtuZXcgVmFsdWUobmV3IFRoaXNMaXRlcmFsKSwgQGNsYXNzVmFyaWFibGVdKVxuICAgIEBib2R5Lm1ha2VSZXR1cm4oKSB1bmxlc3Mgd2FzRW1wdHkgb3IgQG5vUmV0dXJuXG5cbiAgICAjIEphdmFTY3JpcHQgZG9lc27igJl0IGFsbG93IGJvdW5kIChgPT5gKSBmdW5jdGlvbnMgdG8gYWxzbyBiZSBnZW5lcmF0b3JzLlxuICAgICMgVGhpcyBpcyB1c3VhbGx5IGNhdWdodCB2aWEgYE9wOjpjb21waWxlQ29udGludWF0aW9uYCwgYnV0IGRvdWJsZS1jaGVjazpcbiAgICBpZiBAYm91bmQgYW5kIEBpc0dlbmVyYXRvclxuICAgICAgeWllbGROb2RlID0gQGJvZHkuY29udGFpbnMgKG5vZGUpIC0+IG5vZGUgaW5zdGFuY2VvZiBPcCBhbmQgbm9kZS5vcGVyYXRvciBpcyAneWllbGQnXG4gICAgICAoeWllbGROb2RlIG9yIEApLmVycm9yICd5aWVsZCBjYW5ub3Qgb2NjdXIgaW5zaWRlIGJvdW5kIChmYXQgYXJyb3cpIGZ1bmN0aW9ucydcblxuICAgICMgQXNzZW1ibGUgdGhlIG91dHB1dFxuICAgIG1vZGlmaWVycyA9IFtdXG4gICAgbW9kaWZpZXJzLnB1c2ggJ3N0YXRpYycgaWYgQGlzTWV0aG9kIGFuZCBAaXNTdGF0aWNcbiAgICBtb2RpZmllcnMucHVzaCAnYXN5bmMnICBpZiBAaXNBc3luY1xuICAgIHVubGVzcyBAaXNNZXRob2Qgb3IgQGJvdW5kXG4gICAgICBtb2RpZmllcnMucHVzaCBcImZ1bmN0aW9uI3tpZiBAaXNHZW5lcmF0b3IgdGhlbiAnKicgZWxzZSAnJ31cIlxuICAgIGVsc2UgaWYgQGlzR2VuZXJhdG9yXG4gICAgICBtb2RpZmllcnMucHVzaCAnKidcblxuICAgIHNpZ25hdHVyZSA9IFtAbWFrZUNvZGUgJygnXVxuICAgICMgQmxvY2sgY29tbWVudHMgYmV0d2VlbiBhIGZ1bmN0aW9uIG5hbWUgYW5kIGAoYCBnZXQgb3V0cHV0IGJldHdlZW5cbiAgICAjIGBmdW5jdGlvbmAgYW5kIGAoYC5cbiAgICBpZiBAcGFyYW1TdGFydD8uY29tbWVudHM/XG4gICAgICBAY29tcGlsZUNvbW1lbnRGcmFnbWVudHMgbywgQHBhcmFtU3RhcnQsIHNpZ25hdHVyZVxuICAgIGZvciBwYXJhbSwgaSBpbiBwYXJhbXNcbiAgICAgIHNpZ25hdHVyZS5wdXNoIEBtYWtlQ29kZSAnLCAnIGlmIGkgaXNudCAwXG4gICAgICBzaWduYXR1cmUucHVzaCBAbWFrZUNvZGUgJy4uLicgaWYgaGF2ZVNwbGF0UGFyYW0gYW5kIGkgaXMgcGFyYW1zLmxlbmd0aCAtIDFcbiAgICAgICMgQ29tcGlsZSB0aGlzIHBhcmFtZXRlciwgYnV0IGlmIGFueSBnZW5lcmF0ZWQgdmFyaWFibGVzIGdldCBjcmVhdGVkXG4gICAgICAjIChlLmcuIGByZWZgKSwgc2hpZnQgdGhvc2UgaW50byB0aGUgcGFyZW50IHNjb3BlIHNpbmNlIHdlIGNhbuKAmXQgcHV0IGFcbiAgICAgICMgYHZhcmAgbGluZSBpbnNpZGUgYSBmdW5jdGlvbiBwYXJhbWV0ZXIgbGlzdC5cbiAgICAgIHNjb3BlVmFyaWFibGVzQ291bnQgPSBvLnNjb3BlLnZhcmlhYmxlcy5sZW5ndGhcbiAgICAgIHNpZ25hdHVyZS5wdXNoIHBhcmFtLmNvbXBpbGVUb0ZyYWdtZW50cyhvLCBMRVZFTF9QQVJFTikuLi5cbiAgICAgIGlmIHNjb3BlVmFyaWFibGVzQ291bnQgaXNudCBvLnNjb3BlLnZhcmlhYmxlcy5sZW5ndGhcbiAgICAgICAgZ2VuZXJhdGVkVmFyaWFibGVzID0gby5zY29wZS52YXJpYWJsZXMuc3BsaWNlIHNjb3BlVmFyaWFibGVzQ291bnRcbiAgICAgICAgby5zY29wZS5wYXJlbnQudmFyaWFibGVzLnB1c2ggZ2VuZXJhdGVkVmFyaWFibGVzLi4uXG4gICAgc2lnbmF0dXJlLnB1c2ggQG1ha2VDb2RlICcpJ1xuICAgICMgQmxvY2sgY29tbWVudHMgYmV0d2VlbiBgKWAgYW5kIGAtPmAvYD0+YCBnZXQgb3V0cHV0IGJldHdlZW4gYClgIGFuZCBge2AuXG4gICAgaWYgQGZ1bmNHbHlwaD8uY29tbWVudHM/XG4gICAgICBjb21tZW50LnVuc2hpZnQgPSBubyBmb3IgY29tbWVudCBpbiBAZnVuY0dseXBoLmNvbW1lbnRzXG4gICAgICBAY29tcGlsZUNvbW1lbnRGcmFnbWVudHMgbywgQGZ1bmNHbHlwaCwgc2lnbmF0dXJlXG5cbiAgICBib2R5ID0gQGJvZHkuY29tcGlsZVdpdGhEZWNsYXJhdGlvbnMgbyB1bmxlc3MgQGJvZHkuaXNFbXB0eSgpXG5cbiAgICAjIFdlIG5lZWQgdG8gY29tcGlsZSB0aGUgYm9keSBiZWZvcmUgbWV0aG9kIG5hbWVzIHRvIGVuc3VyZSBgc3VwZXJgXG4gICAgIyByZWZlcmVuY2VzIGFyZSBoYW5kbGVkLlxuICAgIGlmIEBpc01ldGhvZFxuICAgICAgW21ldGhvZFNjb3BlLCBvLnNjb3BlXSA9IFtvLnNjb3BlLCBvLnNjb3BlLnBhcmVudF1cbiAgICAgIG5hbWUgPSBAbmFtZS5jb21waWxlVG9GcmFnbWVudHMgb1xuICAgICAgbmFtZS5zaGlmdCgpIGlmIG5hbWVbMF0uY29kZSBpcyAnLidcbiAgICAgIG8uc2NvcGUgPSBtZXRob2RTY29wZVxuXG4gICAgYW5zd2VyID0gQGpvaW5GcmFnbWVudEFycmF5cyAoQG1ha2VDb2RlIG0gZm9yIG0gaW4gbW9kaWZpZXJzKSwgJyAnXG4gICAgYW5zd2VyLnB1c2ggQG1ha2VDb2RlICcgJyBpZiBtb2RpZmllcnMubGVuZ3RoIGFuZCBuYW1lXG4gICAgYW5zd2VyLnB1c2ggbmFtZS4uLiBpZiBuYW1lXG4gICAgYW5zd2VyLnB1c2ggc2lnbmF0dXJlLi4uXG4gICAgYW5zd2VyLnB1c2ggQG1ha2VDb2RlICcgPT4nIGlmIEBib3VuZCBhbmQgbm90IEBpc01ldGhvZFxuICAgIGFuc3dlci5wdXNoIEBtYWtlQ29kZSAnIHsnXG4gICAgYW5zd2VyLnB1c2ggQG1ha2VDb2RlKCdcXG4nKSwgYm9keS4uLiwgQG1ha2VDb2RlKFwiXFxuI3tAdGFifVwiKSBpZiBib2R5Py5sZW5ndGhcbiAgICBhbnN3ZXIucHVzaCBAbWFrZUNvZGUgJ30nXG5cbiAgICByZXR1cm4gaW5kZW50SW5pdGlhbCBhbnN3ZXIsIEAgaWYgQGlzTWV0aG9kXG4gICAgaWYgQGZyb250IG9yIChvLmxldmVsID49IExFVkVMX0FDQ0VTUykgdGhlbiBAd3JhcEluUGFyZW50aGVzZXMgYW5zd2VyIGVsc2UgYW5zd2VyXG5cbiAgdXBkYXRlT3B0aW9uczogKG8pIC0+XG4gICAgby5zY29wZSAgICAgICAgID0gZGVsKG8sICdjbGFzc1Njb3BlJykgb3IgQG1ha2VTY29wZSBvLnNjb3BlXG4gICAgby5zY29wZS5zaGFyZWQgID0gZGVsKG8sICdzaGFyZWRTY29wZScpXG4gICAgby5pbmRlbnQgICAgICAgICs9IFRBQlxuICAgIGRlbGV0ZSBvLmJhcmVcbiAgICBkZWxldGUgby5pc0V4aXN0ZW50aWFsRXF1YWxzXG5cbiAgY2hlY2tGb3JEdXBsaWNhdGVQYXJhbXM6IC0+XG4gICAgcGFyYW1OYW1lcyA9IFtdXG4gICAgQGVhY2hQYXJhbU5hbWUgKG5hbWUsIG5vZGUsIHBhcmFtKSAtPlxuICAgICAgbm9kZS5lcnJvciBcIm11bHRpcGxlIHBhcmFtZXRlcnMgbmFtZWQgJyN7bmFtZX0nXCIgaWYgbmFtZSBpbiBwYXJhbU5hbWVzXG4gICAgICBwYXJhbU5hbWVzLnB1c2ggbmFtZVxuXG4gIGVhY2hQYXJhbU5hbWU6IChpdGVyYXRvcikgLT5cbiAgICBwYXJhbS5lYWNoTmFtZSBpdGVyYXRvciBmb3IgcGFyYW0gaW4gQHBhcmFtc1xuXG4gICMgU2hvcnQtY2lyY3VpdCBgdHJhdmVyc2VDaGlsZHJlbmAgbWV0aG9kIHRvIHByZXZlbnQgaXQgZnJvbSBjcm9zc2luZyBzY29wZVxuICAjIGJvdW5kYXJpZXMgdW5sZXNzIGBjcm9zc1Njb3BlYCBpcyBgdHJ1ZWAuXG4gIHRyYXZlcnNlQ2hpbGRyZW46IChjcm9zc1Njb3BlLCBmdW5jKSAtPlxuICAgIHN1cGVyKGNyb3NzU2NvcGUsIGZ1bmMpIGlmIGNyb3NzU2NvcGVcblxuICAjIFNob3J0LWNpcmN1aXQgYHJlcGxhY2VJbkNvbnRleHRgIG1ldGhvZCB0byBwcmV2ZW50IGl0IGZyb20gY3Jvc3NpbmcgY29udGV4dCBib3VuZGFyaWVzLiBCb3VuZFxuICAjIGZ1bmN0aW9ucyBoYXZlIHRoZSBzYW1lIGNvbnRleHQuXG4gIHJlcGxhY2VJbkNvbnRleHQ6IChjaGlsZCwgcmVwbGFjZW1lbnQpIC0+XG4gICAgaWYgQGJvdW5kXG4gICAgICBzdXBlciBjaGlsZCwgcmVwbGFjZW1lbnRcbiAgICBlbHNlXG4gICAgICBmYWxzZVxuXG4gIGRpc2FsbG93U3VwZXJJblBhcmFtRGVmYXVsdHM6ICh7Zm9yQXN0fSA9IHt9KSAtPlxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgQGN0b3JcblxuICAgIEBlYWNoU3VwZXJDYWxsIEJsb2NrLndyYXAoQHBhcmFtcyksIChzdXBlckNhbGwpIC0+XG4gICAgICBzdXBlckNhbGwuZXJyb3IgXCInc3VwZXInIGlzIG5vdCBhbGxvd2VkIGluIGNvbnN0cnVjdG9yIHBhcmFtZXRlciBkZWZhdWx0c1wiXG4gICAgLCBjaGVja0ZvclRoaXNCZWZvcmVTdXBlcjogbm90IGZvckFzdFxuXG4gIGNoZWNrU3VwZXJDYWxsc0luQ29uc3RydWN0b3JCb2R5OiAtPlxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgQGN0b3JcblxuICAgIHNlZW5TdXBlciA9IEBlYWNoU3VwZXJDYWxsIEBib2R5LCAoc3VwZXJDYWxsKSA9PlxuICAgICAgc3VwZXJDYWxsLmVycm9yIFwiJ3N1cGVyJyBpcyBvbmx5IGFsbG93ZWQgaW4gZGVyaXZlZCBjbGFzcyBjb25zdHJ1Y3RvcnNcIiBpZiBAY3RvciBpcyAnYmFzZSdcblxuICAgIHNlZW5TdXBlclxuXG4gIGZsYWdUaGlzUGFyYW1JbkRlcml2ZWRDbGFzc0NvbnN0cnVjdG9yV2l0aG91dENhbGxpbmdTdXBlcjogKHBhcmFtKSAtPlxuICAgIHBhcmFtLmVycm9yIFwiQ2FuJ3QgdXNlIEBwYXJhbXMgaW4gZGVyaXZlZCBjbGFzcyBjb25zdHJ1Y3RvcnMgd2l0aG91dCBjYWxsaW5nIHN1cGVyXCJcblxuICBjaGVja0ZvckFzeW5jT3JHZW5lcmF0b3JDb25zdHJ1Y3RvcjogLT5cbiAgICBpZiBAY3RvclxuICAgICAgQG5hbWUuZXJyb3IgJ0NsYXNzIGNvbnN0cnVjdG9yIG1heSBub3QgYmUgYXN5bmMnICAgICAgIGlmIEBpc0FzeW5jXG4gICAgICBAbmFtZS5lcnJvciAnQ2xhc3MgY29uc3RydWN0b3IgbWF5IG5vdCBiZSBhIGdlbmVyYXRvcicgaWYgQGlzR2VuZXJhdG9yXG5cbiAgZGlzYWxsb3dMb25lRXhwYW5zaW9uQW5kTXVsdGlwbGVTcGxhdHM6IC0+XG4gICAgc2VlblNwbGF0UGFyYW0gPSBub1xuICAgIGZvciBwYXJhbSBpbiBAcGFyYW1zXG4gICAgICAjIFdhcyBgLi4uYCB1c2VkIHdpdGggdGhpcyBwYXJhbWV0ZXI/IChPbmx5IG9uZSBzdWNoIHBhcmFtZXRlciBpcyBhbGxvd2VkXG4gICAgICAjIHBlciBmdW5jdGlvbi4pXG4gICAgICBpZiBwYXJhbS5zcGxhdCBvciBwYXJhbSBpbnN0YW5jZW9mIEV4cGFuc2lvblxuICAgICAgICBpZiBzZWVuU3BsYXRQYXJhbVxuICAgICAgICAgIHBhcmFtLmVycm9yICdvbmx5IG9uZSBzcGxhdCBvciBleHBhbnNpb24gcGFyYW1ldGVyIGlzIGFsbG93ZWQgcGVyIGZ1bmN0aW9uIGRlZmluaXRpb24nXG4gICAgICAgIGVsc2UgaWYgcGFyYW0gaW5zdGFuY2VvZiBFeHBhbnNpb24gYW5kIEBwYXJhbXMubGVuZ3RoIGlzIDFcbiAgICAgICAgICBwYXJhbS5lcnJvciAnYW4gZXhwYW5zaW9uIHBhcmFtZXRlciBjYW5ub3QgYmUgdGhlIG9ubHkgcGFyYW1ldGVyIGluIGEgZnVuY3Rpb24gZGVmaW5pdGlvbidcbiAgICAgICAgc2VlblNwbGF0UGFyYW0gPSB5ZXNcblxuICBleHBhbmRDdG9yU3VwZXI6ICh0aGlzQXNzaWdubWVudHMpIC0+XG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBAY3RvclxuXG4gICAgc2VlblN1cGVyID0gQGVhY2hTdXBlckNhbGwgQGJvZHksIChzdXBlckNhbGwpID0+XG4gICAgICBzdXBlckNhbGwuZXhwcmVzc2lvbnMgPSB0aGlzQXNzaWdubWVudHNcblxuICAgIGhhdmVUaGlzUGFyYW0gPSB0aGlzQXNzaWdubWVudHMubGVuZ3RoIGFuZCB0aGlzQXNzaWdubWVudHMubGVuZ3RoIGlzbnQgQHRoaXNBc3NpZ25tZW50cz8ubGVuZ3RoXG4gICAgaWYgQGN0b3IgaXMgJ2Rlcml2ZWQnIGFuZCBub3Qgc2VlblN1cGVyIGFuZCBoYXZlVGhpc1BhcmFtXG4gICAgICBwYXJhbSA9IHRoaXNBc3NpZ25tZW50c1swXS52YXJpYWJsZVxuICAgICAgQGZsYWdUaGlzUGFyYW1JbkRlcml2ZWRDbGFzc0NvbnN0cnVjdG9yV2l0aG91dENhbGxpbmdTdXBlciBwYXJhbVxuXG4gICAgc2VlblN1cGVyXG5cbiAgIyBGaW5kIGFsbCBzdXBlciBjYWxscyBpbiB0aGUgZ2l2ZW4gY29udGV4dCBub2RlO1xuICAjIHJldHVybnMgYHRydWVgIGlmIGBpdGVyYXRvcmAgaXMgY2FsbGVkLlxuICBlYWNoU3VwZXJDYWxsOiAoY29udGV4dCwgaXRlcmF0b3IsIHtjaGVja0ZvclRoaXNCZWZvcmVTdXBlciA9IHllc30gPSB7fSkgLT5cbiAgICBzZWVuU3VwZXIgPSBub1xuXG4gICAgY29udGV4dC50cmF2ZXJzZUNoaWxkcmVuIHllcywgKGNoaWxkKSA9PlxuICAgICAgaWYgY2hpbGQgaW5zdGFuY2VvZiBTdXBlckNhbGxcbiAgICAgICAgIyBgc3VwZXJgIGluIGEgY29uc3RydWN0b3IgKHRoZSBvbmx5IGBzdXBlcmAgd2l0aG91dCBhbiBhY2Nlc3NvcilcbiAgICAgICAgIyBjYW5ub3QgYmUgZ2l2ZW4gYW4gYXJndW1lbnQgd2l0aCBhIHJlZmVyZW5jZSB0byBgdGhpc2AsIGFzIHRoYXQgd291bGRcbiAgICAgICAgIyBiZSByZWZlcmVuY2luZyBgdGhpc2AgYmVmb3JlIGNhbGxpbmcgYHN1cGVyYC5cbiAgICAgICAgdW5sZXNzIGNoaWxkLnZhcmlhYmxlLmFjY2Vzc29yXG4gICAgICAgICAgY2hpbGRBcmdzID0gY2hpbGQuYXJncy5maWx0ZXIgKGFyZykgLT5cbiAgICAgICAgICAgIGFyZyBub3QgaW5zdGFuY2VvZiBDbGFzcyBhbmQgKGFyZyBub3QgaW5zdGFuY2VvZiBDb2RlIG9yIGFyZy5ib3VuZClcbiAgICAgICAgICBCbG9jay53cmFwKGNoaWxkQXJncykudHJhdmVyc2VDaGlsZHJlbiB5ZXMsIChub2RlKSA9PlxuICAgICAgICAgICAgbm9kZS5lcnJvciBcIkNhbid0IGNhbGwgc3VwZXIgd2l0aCBAcGFyYW1zIGluIGRlcml2ZWQgY2xhc3MgY29uc3RydWN0b3JzXCIgaWYgbm9kZS50aGlzXG4gICAgICAgIHNlZW5TdXBlciA9IHllc1xuICAgICAgICBpdGVyYXRvciBjaGlsZFxuICAgICAgZWxzZSBpZiBjaGVja0ZvclRoaXNCZWZvcmVTdXBlciBhbmQgY2hpbGQgaW5zdGFuY2VvZiBUaGlzTGl0ZXJhbCBhbmQgQGN0b3IgaXMgJ2Rlcml2ZWQnIGFuZCBub3Qgc2VlblN1cGVyXG4gICAgICAgIGNoaWxkLmVycm9yIFwiQ2FuJ3QgcmVmZXJlbmNlICd0aGlzJyBiZWZvcmUgY2FsbGluZyBzdXBlciBpbiBkZXJpdmVkIGNsYXNzIGNvbnN0cnVjdG9yc1wiXG5cbiAgICAgICMgYHN1cGVyYCBoYXMgdGhlIHNhbWUgdGFyZ2V0IGluIGJvdW5kIChhcnJvdykgZnVuY3Rpb25zLCBzbyBjaGVjayB0aGVtIHRvb1xuICAgICAgY2hpbGQgbm90IGluc3RhbmNlb2YgU3VwZXJDYWxsIGFuZCAoY2hpbGQgbm90IGluc3RhbmNlb2YgQ29kZSBvciBjaGlsZC5ib3VuZClcblxuICAgIHNlZW5TdXBlclxuXG4gIHByb3BhZ2F0ZUxoczogLT5cbiAgICBmb3IgcGFyYW0gaW4gQHBhcmFtc1xuICAgICAge25hbWV9ID0gcGFyYW1cbiAgICAgIGlmIG5hbWUgaW5zdGFuY2VvZiBBcnIgb3IgbmFtZSBpbnN0YW5jZW9mIE9ialxuICAgICAgICBuYW1lLnByb3BhZ2F0ZUxocyB5ZXNcbiAgICAgIGVsc2UgaWYgcGFyYW0gaW5zdGFuY2VvZiBFeHBhbnNpb25cbiAgICAgICAgcGFyYW0ubGhzID0geWVzXG5cbiAgYXN0QWRkUGFyYW1zVG9TY29wZTogKG8pIC0+XG4gICAgQGVhY2hQYXJhbU5hbWUgKG5hbWUpIC0+XG4gICAgICBvLnNjb3BlLmFkZCBuYW1lLCAncGFyYW0nXG5cbiAgYXN0Tm9kZTogKG8pIC0+XG4gICAgQHVwZGF0ZU9wdGlvbnMgb1xuICAgIEBjaGVja0ZvckFzeW5jT3JHZW5lcmF0b3JDb25zdHJ1Y3RvcigpXG4gICAgQGNoZWNrRm9yRHVwbGljYXRlUGFyYW1zKClcbiAgICBAZGlzYWxsb3dTdXBlckluUGFyYW1EZWZhdWx0cyBmb3JBc3Q6IHllc1xuICAgIEBkaXNhbGxvd0xvbmVFeHBhbnNpb25BbmRNdWx0aXBsZVNwbGF0cygpXG4gICAgc2VlblN1cGVyID0gQGNoZWNrU3VwZXJDYWxsc0luQ29uc3RydWN0b3JCb2R5KClcbiAgICBpZiBAY3RvciBpcyAnZGVyaXZlZCcgYW5kIG5vdCBzZWVuU3VwZXJcbiAgICAgIEBlYWNoUGFyYW1OYW1lIChuYW1lLCBub2RlKSA9PlxuICAgICAgICBpZiBub2RlLnRoaXNcbiAgICAgICAgICBAZmxhZ1RoaXNQYXJhbUluRGVyaXZlZENsYXNzQ29uc3RydWN0b3JXaXRob3V0Q2FsbGluZ1N1cGVyIG5vZGVcbiAgICBAYXN0QWRkUGFyYW1zVG9TY29wZSBvXG4gICAgQGJvZHkubWFrZVJldHVybiBudWxsLCB5ZXMgdW5sZXNzIEBib2R5LmlzRW1wdHkoKSBvciBAbm9SZXR1cm5cblxuICAgIHN1cGVyIG9cblxuICBhc3RUeXBlOiAtPlxuICAgIGlmIEBpc01ldGhvZFxuICAgICAgJ0NsYXNzTWV0aG9kJ1xuICAgIGVsc2UgaWYgQGJvdW5kXG4gICAgICAnQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24nXG4gICAgZWxzZVxuICAgICAgJ0Z1bmN0aW9uRXhwcmVzc2lvbidcblxuICBwYXJhbUZvckFzdDogKHBhcmFtKSAtPlxuICAgIHJldHVybiBwYXJhbSBpZiBwYXJhbSBpbnN0YW5jZW9mIEV4cGFuc2lvblxuICAgIHtuYW1lLCB2YWx1ZSwgc3BsYXR9ID0gcGFyYW1cbiAgICBpZiBzcGxhdFxuICAgICAgbmV3IFNwbGF0IG5hbWUsIGxoczogeWVzLCBwb3N0Zml4OiBzcGxhdC5wb3N0Zml4XG4gICAgICAud2l0aExvY2F0aW9uRGF0YUZyb20gcGFyYW1cbiAgICBlbHNlIGlmIHZhbHVlP1xuICAgICAgbmV3IEFzc2lnbiBuYW1lLCB2YWx1ZSwgbnVsbCwgcGFyYW06IHllc1xuICAgICAgLndpdGhMb2NhdGlvbkRhdGFGcm9tIGxvY2F0aW9uRGF0YTogbWVyZ2VMb2NhdGlvbkRhdGEgbmFtZS5sb2NhdGlvbkRhdGEsIHZhbHVlLmxvY2F0aW9uRGF0YVxuICAgIGVsc2VcbiAgICAgIG5hbWVcblxuICBtZXRob2RBc3RQcm9wZXJ0aWVzOiAobykgLT5cbiAgICBnZXRJc0NvbXB1dGVkID0gPT5cbiAgICAgIHJldHVybiB5ZXMgaWYgQG5hbWUgaW5zdGFuY2VvZiBJbmRleFxuICAgICAgcmV0dXJuIHllcyBpZiBAbmFtZSBpbnN0YW5jZW9mIENvbXB1dGVkUHJvcGVydHlOYW1lXG4gICAgICByZXR1cm4geWVzIGlmIEBuYW1lLm5hbWUgaW5zdGFuY2VvZiBDb21wdXRlZFByb3BlcnR5TmFtZVxuICAgICAgbm9cblxuICAgIHJldHVyblxuICAgICAgc3RhdGljOiAhIUBpc1N0YXRpY1xuICAgICAga2V5OiBAbmFtZS5hc3Qgb1xuICAgICAgY29tcHV0ZWQ6IGdldElzQ29tcHV0ZWQoKVxuICAgICAga2luZDpcbiAgICAgICAgaWYgQGN0b3JcbiAgICAgICAgICAnY29uc3RydWN0b3InXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAnbWV0aG9kJ1xuICAgICAgb3BlcmF0b3I6IEBvcGVyYXRvclRva2VuPy52YWx1ZSA/ICc9J1xuICAgICAgc3RhdGljQ2xhc3NOYW1lOiBAaXNTdGF0aWMuc3RhdGljQ2xhc3NOYW1lPy5hc3QobykgPyBudWxsXG4gICAgICBib3VuZDogISFAYm91bmRcblxuICBhc3RQcm9wZXJ0aWVzOiAobykgLT5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnblxuICAgICAgcGFyYW1zOiBAcGFyYW1Gb3JBc3QocGFyYW0pLmFzdChvKSBmb3IgcGFyYW0gaW4gQHBhcmFtc1xuICAgICAgYm9keTogQGJvZHkuYXN0IChPYmplY3QuYXNzaWduIHt9LCBvLCBjaGVja0ZvckRpcmVjdGl2ZXM6IHllcyksIExFVkVMX1RPUFxuICAgICAgZ2VuZXJhdG9yOiAhIUBpc0dlbmVyYXRvclxuICAgICAgYXN5bmM6ICEhQGlzQXN5bmNcbiAgICAgICMgV2UgbmV2ZXIgZ2VuZXJhdGUgbmFtZWQgZnVuY3Rpb25zLCBzbyBzcGVjaWZ5IGBpZGAgYXMgYG51bGxgLCB3aGljaFxuICAgICAgIyBtYXRjaGVzIHRoZSBCYWJlbCBBU1QgZm9yIGFub255bW91cyBmdW5jdGlvbiBleHByZXNzaW9ucy9hcnJvdyBmdW5jdGlvbnNcbiAgICAgIGlkOiBudWxsXG4gICAgICBoYXNJbmRlbnRlZEJvZHk6IEBib2R5LmxvY2F0aW9uRGF0YS5maXJzdF9saW5lID4gQGZ1bmNHbHlwaD8ubG9jYXRpb25EYXRhLmZpcnN0X2xpbmVcbiAgICAsXG4gICAgICBpZiBAaXNNZXRob2QgdGhlbiBAbWV0aG9kQXN0UHJvcGVydGllcyBvIGVsc2Uge31cblxuICBhc3RMb2NhdGlvbkRhdGE6IC0+XG4gICAgZnVuY3Rpb25Mb2NhdGlvbkRhdGEgPSBzdXBlcigpXG4gICAgcmV0dXJuIGZ1bmN0aW9uTG9jYXRpb25EYXRhIHVubGVzcyBAaXNNZXRob2RcblxuICAgIGFzdExvY2F0aW9uRGF0YSA9IG1lcmdlQXN0TG9jYXRpb25EYXRhIEBuYW1lLmFzdExvY2F0aW9uRGF0YSgpLCBmdW5jdGlvbkxvY2F0aW9uRGF0YVxuICAgIGlmIEBpc1N0YXRpYy5zdGF0aWNDbGFzc05hbWU/XG4gICAgICBhc3RMb2NhdGlvbkRhdGEgPSBtZXJnZUFzdExvY2F0aW9uRGF0YSBAaXNTdGF0aWMuc3RhdGljQ2xhc3NOYW1lLmFzdExvY2F0aW9uRGF0YSgpLCBhc3RMb2NhdGlvbkRhdGFcbiAgICBhc3RMb2NhdGlvbkRhdGFcblxuIyMjIyBQYXJhbVxuXG4jIEEgcGFyYW1ldGVyIGluIGEgZnVuY3Rpb24gZGVmaW5pdGlvbi4gQmV5b25kIGEgdHlwaWNhbCBKYXZhU2NyaXB0IHBhcmFtZXRlcixcbiMgdGhlc2UgcGFyYW1ldGVycyBjYW4gYWxzbyBhdHRhY2ggdGhlbXNlbHZlcyB0byB0aGUgY29udGV4dCBvZiB0aGUgZnVuY3Rpb24sXG4jIGFzIHdlbGwgYXMgYmUgYSBzcGxhdCwgZ2F0aGVyaW5nIHVwIGEgZ3JvdXAgb2YgcGFyYW1ldGVycyBpbnRvIGFuIGFycmF5LlxuZXhwb3J0cy5QYXJhbSA9IGNsYXNzIFBhcmFtIGV4dGVuZHMgQmFzZVxuICBjb25zdHJ1Y3RvcjogKEBuYW1lLCBAdmFsdWUsIEBzcGxhdCkgLT5cbiAgICBzdXBlcigpXG5cbiAgICBtZXNzYWdlID0gaXNVbmFzc2lnbmFibGUgQG5hbWUudW53cmFwQWxsKCkudmFsdWVcbiAgICBAbmFtZS5lcnJvciBtZXNzYWdlIGlmIG1lc3NhZ2VcbiAgICBpZiBAbmFtZSBpbnN0YW5jZW9mIE9iaiBhbmQgQG5hbWUuZ2VuZXJhdGVkXG4gICAgICB0b2tlbiA9IEBuYW1lLm9iamVjdHNbMF0ub3BlcmF0b3JUb2tlblxuICAgICAgdG9rZW4uZXJyb3IgXCJ1bmV4cGVjdGVkICN7dG9rZW4udmFsdWV9XCJcblxuICBjaGlsZHJlbjogWyduYW1lJywgJ3ZhbHVlJ11cblxuICBjb21waWxlVG9GcmFnbWVudHM6IChvKSAtPlxuICAgIEBuYW1lLmNvbXBpbGVUb0ZyYWdtZW50cyBvLCBMRVZFTF9MSVNUXG5cbiAgY29tcGlsZVRvRnJhZ21lbnRzV2l0aG91dENvbW1lbnRzOiAobykgLT5cbiAgICBAbmFtZS5jb21waWxlVG9GcmFnbWVudHNXaXRob3V0Q29tbWVudHMgbywgTEVWRUxfTElTVFxuXG4gIGFzUmVmZXJlbmNlOiAobykgLT5cbiAgICByZXR1cm4gQHJlZmVyZW5jZSBpZiBAcmVmZXJlbmNlXG4gICAgbm9kZSA9IEBuYW1lXG4gICAgaWYgbm9kZS50aGlzXG4gICAgICBuYW1lID0gbm9kZS5wcm9wZXJ0aWVzWzBdLm5hbWUudmFsdWVcbiAgICAgIG5hbWUgPSBcIl8je25hbWV9XCIgaWYgbmFtZSBpbiBKU19GT1JCSURERU5cbiAgICAgIG5vZGUgPSBuZXcgSWRlbnRpZmllckxpdGVyYWwgby5zY29wZS5mcmVlVmFyaWFibGUgbmFtZVxuICAgIGVsc2UgaWYgbm9kZS5zaG91bGRDYWNoZSgpXG4gICAgICBub2RlID0gbmV3IElkZW50aWZpZXJMaXRlcmFsIG8uc2NvcGUuZnJlZVZhcmlhYmxlICdhcmcnXG4gICAgbm9kZSA9IG5ldyBWYWx1ZSBub2RlXG4gICAgbm9kZS51cGRhdGVMb2NhdGlvbkRhdGFJZk1pc3NpbmcgQGxvY2F0aW9uRGF0YVxuICAgIEByZWZlcmVuY2UgPSBub2RlXG5cbiAgc2hvdWxkQ2FjaGU6IC0+XG4gICAgQG5hbWUuc2hvdWxkQ2FjaGUoKVxuXG4gICMgSXRlcmF0ZXMgdGhlIG5hbWUgb3IgbmFtZXMgb2YgYSBgUGFyYW1gLlxuICAjIEluIGEgc2Vuc2UsIGEgZGVzdHJ1Y3R1cmVkIHBhcmFtZXRlciByZXByZXNlbnRzIG11bHRpcGxlIEpTIHBhcmFtZXRlcnMuIFRoaXNcbiAgIyBtZXRob2QgYWxsb3dzIHRvIGl0ZXJhdGUgdGhlbSBhbGwuXG4gICMgVGhlIGBpdGVyYXRvcmAgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYXMgYGl0ZXJhdG9yKG5hbWUsIG5vZGUpYCB3aGVyZVxuICAjIGBuYW1lYCBpcyB0aGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyIGFuZCBgbm9kZWAgaXMgdGhlIEFTVCBub2RlIGNvcnJlc3BvbmRpbmdcbiAgIyB0byB0aGF0IG5hbWUuXG4gIGVhY2hOYW1lOiAoaXRlcmF0b3IsIG5hbWUgPSBAbmFtZSkgLT5cbiAgICBjaGVja0Fzc2lnbmFiaWxpdHlPZkxpdGVyYWwgPSAobGl0ZXJhbCkgLT5cbiAgICAgIG1lc3NhZ2UgPSBpc1VuYXNzaWduYWJsZSBsaXRlcmFsLnZhbHVlXG4gICAgICBpZiBtZXNzYWdlXG4gICAgICAgIGxpdGVyYWwuZXJyb3IgbWVzc2FnZVxuICAgICAgdW5sZXNzIGxpdGVyYWwuaXNBc3NpZ25hYmxlKClcbiAgICAgICAgbGl0ZXJhbC5lcnJvciBcIicje2xpdGVyYWwudmFsdWV9JyBjYW4ndCBiZSBhc3NpZ25lZFwiXG5cbiAgICBhdFBhcmFtID0gKG9iaiwgb3JpZ2luYWxPYmogPSBudWxsKSA9PiBpdGVyYXRvciBcIkAje29iai5wcm9wZXJ0aWVzWzBdLm5hbWUudmFsdWV9XCIsIG9iaiwgQCwgb3JpZ2luYWxPYmpcbiAgICBpZiBuYW1lIGluc3RhbmNlb2YgQ2FsbFxuICAgICAgbmFtZS5lcnJvciBcIkZ1bmN0aW9uIGludm9jYXRpb24gY2FuJ3QgYmUgYXNzaWduZWRcIlxuXG4gICAgIyAqIHNpbXBsZSBsaXRlcmFscyBgZm9vYFxuICAgIGlmIG5hbWUgaW5zdGFuY2VvZiBMaXRlcmFsXG4gICAgICBjaGVja0Fzc2lnbmFiaWxpdHlPZkxpdGVyYWwgbmFtZVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yIG5hbWUudmFsdWUsIG5hbWUsIEBcbiAgICAjICogYXQtcGFyYW1zIGBAZm9vYFxuICAgIHJldHVybiBhdFBhcmFtIG5hbWUgaWYgbmFtZSBpbnN0YW5jZW9mIFZhbHVlXG4gICAgZm9yIG9iaiBpbiBuYW1lLm9iamVjdHMgPyBbXVxuICAgICAgIyBTYXZlIG9yaWdpbmFsIG9iai5cbiAgICAgIG5PYmogPSBvYmpcbiAgICAgICMgKiBkZXN0cnVjdHVyZWQgcGFyYW1ldGVyIHdpdGggZGVmYXVsdCB2YWx1ZVxuICAgICAgaWYgb2JqIGluc3RhbmNlb2YgQXNzaWduIGFuZCBub3Qgb2JqLmNvbnRleHQ/XG4gICAgICAgIG9iaiA9IG9iai52YXJpYWJsZVxuICAgICAgIyAqIGFzc2lnbm1lbnRzIHdpdGhpbiBkZXN0cnVjdHVyZWQgcGFyYW1ldGVycyBge2ZvbzpiYXJ9YFxuICAgICAgaWYgb2JqIGluc3RhbmNlb2YgQXNzaWduXG4gICAgICAgICMgLi4uIHBvc3NpYmx5IHdpdGggYSBkZWZhdWx0IHZhbHVlXG4gICAgICAgIGlmIG9iai52YWx1ZSBpbnN0YW5jZW9mIEFzc2lnblxuICAgICAgICAgIG9iaiA9IG9iai52YWx1ZS52YXJpYWJsZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgb2JqID0gb2JqLnZhbHVlXG4gICAgICAgIEBlYWNoTmFtZSBpdGVyYXRvciwgb2JqLnVud3JhcCgpXG4gICAgICAjICogc3BsYXRzIHdpdGhpbiBkZXN0cnVjdHVyZWQgcGFyYW1ldGVycyBgW3hzLi4uXWBcbiAgICAgIGVsc2UgaWYgb2JqIGluc3RhbmNlb2YgU3BsYXRcbiAgICAgICAgbm9kZSA9IG9iai5uYW1lLnVud3JhcCgpXG4gICAgICAgIGl0ZXJhdG9yIG5vZGUudmFsdWUsIG5vZGUsIEBcbiAgICAgIGVsc2UgaWYgb2JqIGluc3RhbmNlb2YgVmFsdWVcbiAgICAgICAgIyAqIGRlc3RydWN0dXJlZCBwYXJhbWV0ZXJzIHdpdGhpbiBkZXN0cnVjdHVyZWQgcGFyYW1ldGVycyBgW3thfV1gXG4gICAgICAgIGlmIG9iai5pc0FycmF5KCkgb3Igb2JqLmlzT2JqZWN0KClcbiAgICAgICAgICBAZWFjaE5hbWUgaXRlcmF0b3IsIG9iai5iYXNlXG4gICAgICAgICMgKiBhdC1wYXJhbXMgd2l0aGluIGRlc3RydWN0dXJlZCBwYXJhbWV0ZXJzIGB7QGZvb31gXG4gICAgICAgIGVsc2UgaWYgb2JqLnRoaXNcbiAgICAgICAgICBhdFBhcmFtIG9iaiwgbk9ialxuICAgICAgICAjICogc2ltcGxlIGRlc3RydWN0dXJlZCBwYXJhbWV0ZXJzIHtmb299XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBjaGVja0Fzc2lnbmFiaWxpdHlPZkxpdGVyYWwgb2JqLmJhc2VcbiAgICAgICAgICBpdGVyYXRvciBvYmouYmFzZS52YWx1ZSwgb2JqLmJhc2UsIEBcbiAgICAgIGVsc2UgaWYgb2JqIGluc3RhbmNlb2YgRWxpc2lvblxuICAgICAgICBvYmpcbiAgICAgIGVsc2UgaWYgb2JqIG5vdCBpbnN0YW5jZW9mIEV4cGFuc2lvblxuICAgICAgICBvYmouZXJyb3IgXCJpbGxlZ2FsIHBhcmFtZXRlciAje29iai5jb21waWxlKCl9XCJcbiAgICByZXR1cm5cblxuICAjIFJlbmFtZSBhIHBhcmFtIGJ5IHJlcGxhY2luZyB0aGUgZ2l2ZW4gQVNUIG5vZGUgZm9yIGEgbmFtZSB3aXRoIGEgbmV3IG5vZGUuXG4gICMgVGhpcyBuZWVkcyB0byBlbnN1cmUgdGhhdCB0aGUgdGhlIHNvdXJjZSBmb3Igb2JqZWN0IGRlc3RydWN0dXJpbmcgZG9lcyBub3QgY2hhbmdlLlxuICByZW5hbWVQYXJhbTogKG5vZGUsIG5ld05vZGUpIC0+XG4gICAgaXNOb2RlICAgICAgPSAoY2FuZGlkYXRlKSAtPiBjYW5kaWRhdGUgaXMgbm9kZVxuICAgIHJlcGxhY2VtZW50ID0gKG5vZGUsIHBhcmVudCkgPT5cbiAgICAgIGlmIHBhcmVudCBpbnN0YW5jZW9mIE9ialxuICAgICAgICBrZXkgPSBub2RlXG4gICAgICAgIGtleSA9IG5vZGUucHJvcGVydGllc1swXS5uYW1lIGlmIG5vZGUudGhpc1xuICAgICAgICAjIE5vIG5lZWQgdG8gYXNzaWduIGEgbmV3IHZhcmlhYmxlIGZvciB0aGUgZGVzdHJ1Y3R1cmVkIHZhcmlhYmxlIGlmIHRoZSB2YXJpYWJsZSBpc24ndCByZXNlcnZlZC5cbiAgICAgICAgIyBFeGFtcGxlczpcbiAgICAgICAgIyBgKHtAZm9vfSkgLT5gICBzaG91bGQgY29tcGlsZSB0byBgKHtmb299KSB7IHRoaXMuZm9vID0gZm9vfWBcbiAgICAgICAgIyBgZm9vID0gMTsgKHtAZm9vfSkgLT5gIHNob3VsZCBjb21waWxlIHRvIGBmb28gPSAxOyAoe2Zvbzpmb28xfSkgeyB0aGlzLmZvbyA9IGZvbzEgfWBcbiAgICAgICAgaWYgbm9kZS50aGlzIGFuZCBrZXkudmFsdWUgaXMgbmV3Tm9kZS52YWx1ZVxuICAgICAgICAgIG5ldyBWYWx1ZSBuZXdOb2RlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBuZXcgQXNzaWduIG5ldyBWYWx1ZShrZXkpLCBuZXdOb2RlLCAnb2JqZWN0J1xuICAgICAgZWxzZVxuICAgICAgICBuZXdOb2RlXG5cbiAgICBAcmVwbGFjZUluQ29udGV4dCBpc05vZGUsIHJlcGxhY2VtZW50XG5cbiMjIyMgU3BsYXRcblxuIyBBIHNwbGF0LCBlaXRoZXIgYXMgYSBwYXJhbWV0ZXIgdG8gYSBmdW5jdGlvbiwgYW4gYXJndW1lbnQgdG8gYSBjYWxsLFxuIyBvciBhcyBwYXJ0IG9mIGEgZGVzdHJ1Y3R1cmluZyBhc3NpZ25tZW50LlxuZXhwb3J0cy5TcGxhdCA9IGNsYXNzIFNwbGF0IGV4dGVuZHMgQmFzZVxuICBjb25zdHJ1Y3RvcjogKG5hbWUsIHtAbGhzLCBAcG9zdGZpeCA9IHRydWV9ID0ge30pIC0+XG4gICAgc3VwZXIoKVxuICAgIEBuYW1lID0gaWYgbmFtZS5jb21waWxlIHRoZW4gbmFtZSBlbHNlIG5ldyBMaXRlcmFsIG5hbWVcblxuICBjaGlsZHJlbjogWyduYW1lJ11cblxuICBzaG91bGRDYWNoZTogLT4gbm9cblxuICBpc0Fzc2lnbmFibGU6ICh7YWxsb3dDb21wbGV4U3BsYXQgPSBub30gPSB7fSktPlxuICAgIHJldHVybiBhbGxvd0NvbXBsZXhTcGxhdCBpZiBAbmFtZSBpbnN0YW5jZW9mIE9iaiBvciBAbmFtZSBpbnN0YW5jZW9mIFBhcmVuc1xuICAgIEBuYW1lLmlzQXNzaWduYWJsZSgpIGFuZCAobm90IEBuYW1lLmlzQXRvbWljIG9yIEBuYW1lLmlzQXRvbWljKCkpXG5cbiAgYXNzaWduczogKG5hbWUpIC0+XG4gICAgQG5hbWUuYXNzaWducyBuYW1lXG5cbiAgY29tcGlsZU5vZGU6IChvKSAtPlxuICAgIGNvbXBpbGVkU3BsYXQgPSBbQG1ha2VDb2RlKCcuLi4nKSwgQG5hbWUuY29tcGlsZVRvRnJhZ21lbnRzKG8sIExFVkVMX09QKS4uLl1cbiAgICByZXR1cm4gY29tcGlsZWRTcGxhdCB1bmxlc3MgQGpzeFxuICAgIHJldHVybiBbQG1ha2VDb2RlKCd7JyksIGNvbXBpbGVkU3BsYXQuLi4sIEBtYWtlQ29kZSgnfScpXVxuXG4gIHVud3JhcDogLT4gQG5hbWVcblxuICBwcm9wYWdhdGVMaHM6IChzZXRMaHMpIC0+XG4gICAgQGxocyA9IHllcyBpZiBzZXRMaHNcbiAgICByZXR1cm4gdW5sZXNzIEBsaHNcbiAgICBAbmFtZS5wcm9wYWdhdGVMaHM/IHllc1xuXG4gIGFzdFR5cGU6IC0+XG4gICAgaWYgQGpzeFxuICAgICAgJ0pTWFNwcmVhZEF0dHJpYnV0ZSdcbiAgICBlbHNlIGlmIEBsaHNcbiAgICAgICdSZXN0RWxlbWVudCdcbiAgICBlbHNlXG4gICAgICAnU3ByZWFkRWxlbWVudCdcblxuICBhc3RQcm9wZXJ0aWVzOiAobykgLT4ge1xuICAgIGFyZ3VtZW50OiBAbmFtZS5hc3QgbywgTEVWRUxfT1BcbiAgICBAcG9zdGZpeFxuICB9XG5cbiMjIyMgRXhwYW5zaW9uXG5cbiMgVXNlZCB0byBza2lwIHZhbHVlcyBpbnNpZGUgYW4gYXJyYXkgZGVzdHJ1Y3R1cmluZyAocGF0dGVybiBtYXRjaGluZykgb3JcbiMgcGFyYW1ldGVyIGxpc3QuXG5leHBvcnRzLkV4cGFuc2lvbiA9IGNsYXNzIEV4cGFuc2lvbiBleHRlbmRzIEJhc2VcblxuICBzaG91bGRDYWNoZTogTk9cblxuICBjb21waWxlTm9kZTogKG8pIC0+XG4gICAgQHRocm93TGhzRXJyb3IoKVxuXG4gIGFzUmVmZXJlbmNlOiAobykgLT5cbiAgICB0aGlzXG5cbiAgZWFjaE5hbWU6IChpdGVyYXRvcikgLT5cblxuICB0aHJvd0xoc0Vycm9yOiAtPlxuICAgIEBlcnJvciAnRXhwYW5zaW9uIG11c3QgYmUgdXNlZCBpbnNpZGUgYSBkZXN0cnVjdHVyaW5nIGFzc2lnbm1lbnQgb3IgcGFyYW1ldGVyIGxpc3QnXG5cbiAgYXN0Tm9kZTogKG8pIC0+XG4gICAgdW5sZXNzIEBsaHNcbiAgICAgIEB0aHJvd0xoc0Vycm9yKClcblxuICAgIHN1cGVyIG9cblxuICBhc3RUeXBlOiAtPiAnUmVzdEVsZW1lbnQnXG5cbiAgYXN0UHJvcGVydGllczogLT5cbiAgICByZXR1cm5cbiAgICAgIGFyZ3VtZW50OiBudWxsXG5cbiMjIyMgRWxpc2lvblxuXG4jIEFycmF5IGVsaXNpb24gZWxlbWVudCAoZm9yIGV4YW1wbGUsIFssYSwgLCAsIGIsICwgYywgLF0pLlxuZXhwb3J0cy5FbGlzaW9uID0gY2xhc3MgRWxpc2lvbiBleHRlbmRzIEJhc2VcblxuICBpc0Fzc2lnbmFibGU6IFlFU1xuXG4gIHNob3VsZENhY2hlOiBOT1xuXG4gIGNvbXBpbGVUb0ZyYWdtZW50czogKG8sIGxldmVsKSAtPlxuICAgIGZyYWdtZW50ID0gc3VwZXIgbywgbGV2ZWxcbiAgICBmcmFnbWVudC5pc0VsaXNpb24gPSB5ZXNcbiAgICBmcmFnbWVudFxuXG4gIGNvbXBpbGVOb2RlOiAobykgLT5cbiAgICBbQG1ha2VDb2RlICcsICddXG5cbiAgYXNSZWZlcmVuY2U6IChvKSAtPlxuICAgIHRoaXNcblxuICBlYWNoTmFtZTogKGl0ZXJhdG9yKSAtPlxuXG4gIGFzdE5vZGU6IC0+XG4gICAgbnVsbFxuXG4jIyMjIFdoaWxlXG5cbiMgQSB3aGlsZSBsb29wLCB0aGUgb25seSBzb3J0IG9mIGxvdy1sZXZlbCBsb29wIGV4cG9zZWQgYnkgQ29mZmVlU2NyaXB0LiBGcm9tXG4jIGl0LCBhbGwgb3RoZXIgbG9vcHMgY2FuIGJlIG1hbnVmYWN0dXJlZC4gVXNlZnVsIGluIGNhc2VzIHdoZXJlIHlvdSBuZWVkIG1vcmVcbiMgZmxleGliaWxpdHkgb3IgbW9yZSBzcGVlZCB0aGFuIGEgY29tcHJlaGVuc2lvbiBjYW4gcHJvdmlkZS5cbmV4cG9ydHMuV2hpbGUgPSBjbGFzcyBXaGlsZSBleHRlbmRzIEJhc2VcbiAgY29uc3RydWN0b3I6IChAY29uZGl0aW9uLCB7aW52ZXJ0OiBAaW52ZXJ0ZWQsIEBndWFyZCwgQGlzTG9vcH0gPSB7fSkgLT5cbiAgICBzdXBlcigpXG5cbiAgY2hpbGRyZW46IFsnY29uZGl0aW9uJywgJ2d1YXJkJywgJ2JvZHknXVxuXG4gIGlzU3RhdGVtZW50OiBZRVNcblxuICBtYWtlUmV0dXJuOiAocmVzdWx0cywgbWFyaykgLT5cbiAgICByZXR1cm4gc3VwZXIocmVzdWx0cywgbWFyaykgaWYgcmVzdWx0c1xuICAgIEByZXR1cm5zID0gbm90IEBqdW1wcygpXG4gICAgaWYgbWFya1xuICAgICAgQGJvZHkubWFrZVJldHVybihyZXN1bHRzLCBtYXJrKSBpZiBAcmV0dXJuc1xuICAgICAgcmV0dXJuXG4gICAgdGhpc1xuXG4gIGFkZEJvZHk6IChAYm9keSkgLT5cbiAgICB0aGlzXG5cbiAganVtcHM6IC0+XG4gICAge2V4cHJlc3Npb25zfSA9IEBib2R5XG4gICAgcmV0dXJuIG5vIHVubGVzcyBleHByZXNzaW9ucy5sZW5ndGhcbiAgICBmb3Igbm9kZSBpbiBleHByZXNzaW9uc1xuICAgICAgcmV0dXJuIGp1bXBOb2RlIGlmIGp1bXBOb2RlID0gbm9kZS5qdW1wcyBsb29wOiB5ZXNcbiAgICBub1xuXG4gICMgVGhlIG1haW4gZGlmZmVyZW5jZSBmcm9tIGEgSmF2YVNjcmlwdCAqd2hpbGUqIGlzIHRoYXQgdGhlIENvZmZlZVNjcmlwdFxuICAjICp3aGlsZSogY2FuIGJlIHVzZWQgYXMgYSBwYXJ0IG9mIGEgbGFyZ2VyIGV4cHJlc3Npb24gLS0gd2hpbGUgbG9vcHMgbWF5XG4gICMgcmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGNvbXB1dGVkIHJlc3VsdCBvZiBlYWNoIGl0ZXJhdGlvbi5cbiAgY29tcGlsZU5vZGU6IChvKSAtPlxuICAgIG8uaW5kZW50ICs9IFRBQlxuICAgIHNldCAgICAgID0gJydcbiAgICB7Ym9keX0gICA9IHRoaXNcbiAgICBpZiBib2R5LmlzRW1wdHkoKVxuICAgICAgYm9keSA9IEBtYWtlQ29kZSAnJ1xuICAgIGVsc2VcbiAgICAgIGlmIEByZXR1cm5zXG4gICAgICAgIGJvZHkubWFrZVJldHVybiBydmFyID0gby5zY29wZS5mcmVlVmFyaWFibGUgJ3Jlc3VsdHMnXG4gICAgICAgIHNldCAgPSBcIiN7QHRhYn0je3J2YXJ9ID0gW107XFxuXCJcbiAgICAgIGlmIEBndWFyZFxuICAgICAgICBpZiBib2R5LmV4cHJlc3Npb25zLmxlbmd0aCA+IDFcbiAgICAgICAgICBib2R5LmV4cHJlc3Npb25zLnVuc2hpZnQgbmV3IElmIChuZXcgUGFyZW5zIEBndWFyZCkuaW52ZXJ0KCksIG5ldyBTdGF0ZW1lbnRMaXRlcmFsIFwiY29udGludWVcIlxuICAgICAgICBlbHNlXG4gICAgICAgICAgYm9keSA9IEJsb2NrLndyYXAgW25ldyBJZiBAZ3VhcmQsIGJvZHldIGlmIEBndWFyZFxuICAgICAgYm9keSA9IFtdLmNvbmNhdCBAbWFrZUNvZGUoXCJcXG5cIiksIChib2R5LmNvbXBpbGVUb0ZyYWdtZW50cyBvLCBMRVZFTF9UT1ApLCBAbWFrZUNvZGUoXCJcXG4je0B0YWJ9XCIpXG4gICAgYW5zd2VyID0gW10uY29uY2F0IEBtYWtlQ29kZShzZXQgKyBAdGFiICsgXCJ3aGlsZSAoXCIpLCBAcHJvY2Vzc2VkQ29uZGl0aW9uKCkuY29tcGlsZVRvRnJhZ21lbnRzKG8sIExFVkVMX1BBUkVOKSxcbiAgICAgIEBtYWtlQ29kZShcIikge1wiKSwgYm9keSwgQG1ha2VDb2RlKFwifVwiKVxuICAgIGlmIEByZXR1cm5zXG4gICAgICBhbnN3ZXIucHVzaCBAbWFrZUNvZGUgXCJcXG4je0B0YWJ9cmV0dXJuICN7cnZhcn07XCJcbiAgICBhbnN3ZXJcblxuICBwcm9jZXNzZWRDb25kaXRpb246IC0+XG4gICAgQHByb2Nlc3NlZENvbmRpdGlvbkNhY2hlID89IGlmIEBpbnZlcnRlZCB0aGVuIEBjb25kaXRpb24uaW52ZXJ0KCkgZWxzZSBAY29uZGl0aW9uXG5cbiAgYXN0VHlwZTogLT4gJ1doaWxlU3RhdGVtZW50J1xuXG4gIGFzdFByb3BlcnRpZXM6IChvKSAtPlxuICAgIHJldHVyblxuICAgICAgdGVzdDogQGNvbmRpdGlvbi5hc3QgbywgTEVWRUxfUEFSRU5cbiAgICAgIGJvZHk6IEBib2R5LmFzdCBvLCBMRVZFTF9UT1BcbiAgICAgIGd1YXJkOiBAZ3VhcmQ/LmFzdChvKSA/IG51bGxcbiAgICAgIGludmVydGVkOiAhIUBpbnZlcnRlZFxuICAgICAgcG9zdGZpeDogISFAcG9zdGZpeFxuICAgICAgbG9vcDogISFAaXNMb29wXG5cbiMjIyMgT3BcblxuIyBTaW1wbGUgQXJpdGhtZXRpYyBhbmQgbG9naWNhbCBvcGVyYXRpb25zLiBQZXJmb3JtcyBzb21lIGNvbnZlcnNpb24gZnJvbVxuIyBDb2ZmZWVTY3JpcHQgb3BlcmF0aW9ucyBpbnRvIHRoZWlyIEphdmFTY3JpcHQgZXF1aXZhbGVudHMuXG5leHBvcnRzLk9wID0gY2xhc3MgT3AgZXh0ZW5kcyBCYXNlXG4gIGNvbnN0cnVjdG9yOiAob3AsIGZpcnN0LCBzZWNvbmQsIGZsaXAsIHtAaW52ZXJ0T3BlcmF0b3IsIEBvcmlnaW5hbE9wZXJhdG9yID0gb3B9ID0ge30pIC0+XG4gICAgc3VwZXIoKVxuXG4gICAgaWYgb3AgaXMgJ25ldydcbiAgICAgIGlmICgoZmlyc3RDYWxsID0gdW53cmFwcGVkID0gZmlyc3QudW53cmFwKCkpIGluc3RhbmNlb2YgQ2FsbCBvciAoZmlyc3RDYWxsID0gdW53cmFwcGVkLmJhc2UpIGluc3RhbmNlb2YgQ2FsbCkgYW5kIG5vdCBmaXJzdENhbGwuZG8gYW5kIG5vdCBmaXJzdENhbGwuaXNOZXdcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZSBmaXJzdENhbGwubmV3SW5zdGFuY2UoKSwgaWYgZmlyc3RDYWxsIGlzIHVud3JhcHBlZCB0aGVuIFtdIGVsc2UgdW53cmFwcGVkLnByb3BlcnRpZXNcbiAgICAgIGZpcnN0ID0gbmV3IFBhcmVucyBmaXJzdCB1bmxlc3MgZmlyc3QgaW5zdGFuY2VvZiBQYXJlbnMgb3IgZmlyc3QudW53cmFwKCkgaW5zdGFuY2VvZiBJZGVudGlmaWVyTGl0ZXJhbCBvciBmaXJzdC5oYXNQcm9wZXJ0aWVzPygpXG4gICAgICBjYWxsID0gbmV3IENhbGwgZmlyc3QsIFtdXG4gICAgICBjYWxsLmxvY2F0aW9uRGF0YSA9IEBsb2NhdGlvbkRhdGFcbiAgICAgIGNhbGwuaXNOZXcgPSB5ZXNcbiAgICAgIHJldHVybiBjYWxsXG5cbiAgICBAb3BlcmF0b3IgPSBDT05WRVJTSU9OU1tvcF0gb3Igb3BcbiAgICBAZmlyc3QgICAgPSBmaXJzdFxuICAgIEBzZWNvbmQgICA9IHNlY29uZFxuICAgIEBmbGlwICAgICA9ICEhZmxpcFxuXG4gICAgaWYgQG9wZXJhdG9yIGluIFsnLS0nLCAnKysnXVxuICAgICAgbWVzc2FnZSA9IGlzVW5hc3NpZ25hYmxlIEBmaXJzdC51bndyYXBBbGwoKS52YWx1ZVxuICAgICAgQGZpcnN0LmVycm9yIG1lc3NhZ2UgaWYgbWVzc2FnZVxuXG4gICAgcmV0dXJuIHRoaXNcblxuICAjIFRoZSBtYXAgb2YgY29udmVyc2lvbnMgZnJvbSBDb2ZmZWVTY3JpcHQgdG8gSmF2YVNjcmlwdCBzeW1ib2xzLlxuICBDT05WRVJTSU9OUyA9XG4gICAgJz09JzogICAgICAgICc9PT0nXG4gICAgJyE9JzogICAgICAgICchPT0nXG4gICAgJ29mJzogICAgICAgICdpbidcbiAgICAneWllbGRmcm9tJzogJ3lpZWxkKidcblxuICAjIFRoZSBtYXAgb2YgaW52ZXJ0aWJsZSBvcGVyYXRvcnMuXG4gIElOVkVSU0lPTlMgPVxuICAgICchPT0nOiAnPT09J1xuICAgICc9PT0nOiAnIT09J1xuXG4gIGNoaWxkcmVuOiBbJ2ZpcnN0JywgJ3NlY29uZCddXG5cbiAgaXNOdW1iZXI6IC0+XG4gICAgQGlzVW5hcnkoKSBhbmQgQG9wZXJhdG9yIGluIFsnKycsICctJ10gYW5kXG4gICAgICBAZmlyc3QgaW5zdGFuY2VvZiBWYWx1ZSBhbmQgQGZpcnN0LmlzTnVtYmVyKClcblxuICBpc0F3YWl0OiAtPlxuICAgIEBvcGVyYXRvciBpcyAnYXdhaXQnXG5cbiAgaXNZaWVsZDogLT5cbiAgICBAb3BlcmF0b3IgaW4gWyd5aWVsZCcsICd5aWVsZConXVxuXG4gIGlzVW5hcnk6IC0+XG4gICAgbm90IEBzZWNvbmRcblxuICBzaG91bGRDYWNoZTogLT5cbiAgICBub3QgQGlzTnVtYmVyKClcblxuICAjIEFtIEkgY2FwYWJsZSBvZlxuICAjIFtQeXRob24tc3R5bGUgY29tcGFyaXNvbiBjaGFpbmluZ10oaHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9yZWZlcmVuY2UvZXhwcmVzc2lvbnMuaHRtbCNub3QtaW4pP1xuICBpc0NoYWluYWJsZTogLT5cbiAgICBAb3BlcmF0b3IgaW4gWyc8JywgJz4nLCAnPj0nLCAnPD0nLCAnPT09JywgJyE9PSddXG5cbiAgaXNDaGFpbjogLT5cbiAgICBAaXNDaGFpbmFibGUoKSBhbmQgQGZpcnN0LmlzQ2hhaW5hYmxlKClcblxuICBpbnZlcnQ6IC0+XG4gICAgaWYgQGlzSW5PcGVyYXRvcigpXG4gICAgICBAaW52ZXJ0T3BlcmF0b3IgPSAnISdcbiAgICAgIHJldHVybiBAXG4gICAgaWYgQGlzQ2hhaW4oKVxuICAgICAgYWxsSW52ZXJ0YWJsZSA9IHllc1xuICAgICAgY3VyciA9IHRoaXNcbiAgICAgIHdoaWxlIGN1cnIgYW5kIGN1cnIub3BlcmF0b3JcbiAgICAgICAgYWxsSW52ZXJ0YWJsZSBhbmQ9IChjdXJyLm9wZXJhdG9yIG9mIElOVkVSU0lPTlMpXG4gICAgICAgIGN1cnIgPSBjdXJyLmZpcnN0XG4gICAgICByZXR1cm4gbmV3IFBhcmVucyh0aGlzKS5pbnZlcnQoKSB1bmxlc3MgYWxsSW52ZXJ0YWJsZVxuICAgICAgY3VyciA9IHRoaXNcbiAgICAgIHdoaWxlIGN1cnIgYW5kIGN1cnIub3BlcmF0b3JcbiAgICAgICAgY3Vyci5pbnZlcnQgPSAhY3Vyci5pbnZlcnRcbiAgICAgICAgY3Vyci5vcGVyYXRvciA9IElOVkVSU0lPTlNbY3Vyci5vcGVyYXRvcl1cbiAgICAgICAgY3VyciA9IGN1cnIuZmlyc3RcbiAgICAgIHRoaXNcbiAgICBlbHNlIGlmIG9wID0gSU5WRVJTSU9OU1tAb3BlcmF0b3JdXG4gICAgICBAb3BlcmF0b3IgPSBvcFxuICAgICAgaWYgQGZpcnN0LnVud3JhcCgpIGluc3RhbmNlb2YgT3BcbiAgICAgICAgQGZpcnN0LmludmVydCgpXG4gICAgICB0aGlzXG4gICAgZWxzZSBpZiBAc2Vjb25kXG4gICAgICBuZXcgUGFyZW5zKHRoaXMpLmludmVydCgpXG4gICAgZWxzZSBpZiBAb3BlcmF0b3IgaXMgJyEnIGFuZCAoZnN0ID0gQGZpcnN0LnVud3JhcCgpKSBpbnN0YW5jZW9mIE9wIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZzdC5vcGVyYXRvciBpbiBbJyEnLCAnaW4nLCAnaW5zdGFuY2VvZiddXG4gICAgICBmc3RcbiAgICBlbHNlXG4gICAgICBuZXcgT3AgJyEnLCB0aGlzXG5cbiAgdW5mb2xkU29hazogKG8pIC0+XG4gICAgQG9wZXJhdG9yIGluIFsnKysnLCAnLS0nLCAnZGVsZXRlJ10gYW5kIHVuZm9sZFNvYWsgbywgdGhpcywgJ2ZpcnN0J1xuXG4gIGdlbmVyYXRlRG86IChleHApIC0+XG4gICAgcGFzc2VkUGFyYW1zID0gW11cbiAgICBmdW5jID0gaWYgZXhwIGluc3RhbmNlb2YgQXNzaWduIGFuZCAocmVmID0gZXhwLnZhbHVlLnVud3JhcCgpKSBpbnN0YW5jZW9mIENvZGVcbiAgICAgIHJlZlxuICAgIGVsc2VcbiAgICAgIGV4cFxuICAgIGZvciBwYXJhbSBpbiBmdW5jLnBhcmFtcyBvciBbXVxuICAgICAgaWYgcGFyYW0udmFsdWVcbiAgICAgICAgcGFzc2VkUGFyYW1zLnB1c2ggcGFyYW0udmFsdWVcbiAgICAgICAgZGVsZXRlIHBhcmFtLnZhbHVlXG4gICAgICBlbHNlXG4gICAgICAgIHBhc3NlZFBhcmFtcy5wdXNoIHBhcmFtXG4gICAgY2FsbCA9IG5ldyBDYWxsIGV4cCwgcGFzc2VkUGFyYW1zXG4gICAgY2FsbC5kbyA9IHllc1xuICAgIGNhbGxcblxuICBpc0luT3BlcmF0b3I6IC0+XG4gICAgQG9yaWdpbmFsT3BlcmF0b3IgaXMgJ2luJ1xuXG4gIGNvbXBpbGVOb2RlOiAobykgLT5cbiAgICBpZiBAaXNJbk9wZXJhdG9yKClcbiAgICAgIGluTm9kZSA9IG5ldyBJbiBAZmlyc3QsIEBzZWNvbmRcbiAgICAgIHJldHVybiAoaWYgQGludmVydE9wZXJhdG9yIHRoZW4gaW5Ob2RlLmludmVydCgpIGVsc2UgaW5Ob2RlKS5jb21waWxlTm9kZSBvXG4gICAgaWYgQGludmVydE9wZXJhdG9yXG4gICAgICBAaW52ZXJ0T3BlcmF0b3IgPSBudWxsXG4gICAgICByZXR1cm4gQGludmVydCgpLmNvbXBpbGVOb2RlKG8pXG4gICAgcmV0dXJuIE9wOjpnZW5lcmF0ZURvKEBmaXJzdCkuY29tcGlsZU5vZGUgbyBpZiBAb3BlcmF0b3IgaXMgJ2RvJ1xuICAgIGlzQ2hhaW4gPSBAaXNDaGFpbigpXG4gICAgIyBJbiBjaGFpbnMsIHRoZXJlJ3Mgbm8gbmVlZCB0byB3cmFwIGJhcmUgb2JqIGxpdGVyYWxzIGluIHBhcmVucyxcbiAgICAjIGFzIHRoZSBjaGFpbmVkIGV4cHJlc3Npb24gaXMgd3JhcHBlZC5cbiAgICBAZmlyc3QuZnJvbnQgPSBAZnJvbnQgdW5sZXNzIGlzQ2hhaW5cbiAgICBAY2hlY2tEZWxldGVPcGVyYW5kIG9cbiAgICByZXR1cm4gQGNvbXBpbGVDb250aW51YXRpb24gbyBpZiBAaXNZaWVsZCgpIG9yIEBpc0F3YWl0KClcbiAgICByZXR1cm4gQGNvbXBpbGVVbmFyeSAgICAgICAgbyBpZiBAaXNVbmFyeSgpXG4gICAgcmV0dXJuIEBjb21waWxlQ2hhaW4gICAgICAgIG8gaWYgaXNDaGFpblxuICAgIHN3aXRjaCBAb3BlcmF0b3JcbiAgICAgIHdoZW4gJz8nICB0aGVuIEBjb21waWxlRXhpc3RlbmNlIG8sIEBzZWNvbmQuaXNEZWZhdWx0VmFsdWVcbiAgICAgIHdoZW4gJy8vJyB0aGVuIEBjb21waWxlRmxvb3JEaXZpc2lvbiBvXG4gICAgICB3aGVuICclJScgdGhlbiBAY29tcGlsZU1vZHVsbyBvXG4gICAgICBlbHNlXG4gICAgICAgIGxocyA9IEBmaXJzdC5jb21waWxlVG9GcmFnbWVudHMgbywgTEVWRUxfT1BcbiAgICAgICAgcmhzID0gQHNlY29uZC5jb21waWxlVG9GcmFnbWVudHMgbywgTEVWRUxfT1BcbiAgICAgICAgYW5zd2VyID0gW10uY29uY2F0IGxocywgQG1ha2VDb2RlKFwiICN7QG9wZXJhdG9yfSBcIiksIHJoc1xuICAgICAgICBpZiBvLmxldmVsIDw9IExFVkVMX09QIHRoZW4gYW5zd2VyIGVsc2UgQHdyYXBJblBhcmVudGhlc2VzIGFuc3dlclxuXG4gICMgTWltaWMgUHl0aG9uJ3MgY2hhaW5lZCBjb21wYXJpc29ucyB3aGVuIG11bHRpcGxlIGNvbXBhcmlzb24gb3BlcmF0b3JzIGFyZVxuICAjIHVzZWQgc2VxdWVudGlhbGx5LiBGb3IgZXhhbXBsZTpcbiAgI1xuICAjICAgICBiaW4vY29mZmVlIC1lICdjb25zb2xlLmxvZyA1MCA8IDY1ID4gMTAnXG4gICMgICAgIHRydWVcbiAgY29tcGlsZUNoYWluOiAobykgLT5cbiAgICBbQGZpcnN0LnNlY29uZCwgc2hhcmVkXSA9IEBmaXJzdC5zZWNvbmQuY2FjaGUgb1xuICAgIGZzdCA9IEBmaXJzdC5jb21waWxlVG9GcmFnbWVudHMgbywgTEVWRUxfT1BcbiAgICBmcmFnbWVudHMgPSBmc3QuY29uY2F0IEBtYWtlQ29kZShcIiAje2lmIEBpbnZlcnQgdGhlbiAnJiYnIGVsc2UgJ3x8J30gXCIpLFxuICAgICAgKHNoYXJlZC5jb21waWxlVG9GcmFnbWVudHMgbyksIEBtYWtlQ29kZShcIiAje0BvcGVyYXRvcn0gXCIpLCAoQHNlY29uZC5jb21waWxlVG9GcmFnbWVudHMgbywgTEVWRUxfT1ApXG4gICAgQHdyYXBJblBhcmVudGhlc2VzIGZyYWdtZW50c1xuXG4gICMgS2VlcCByZWZlcmVuY2UgdG8gdGhlIGxlZnQgZXhwcmVzc2lvbiwgdW5sZXNzIHRoaXMgYW4gZXhpc3RlbnRpYWwgYXNzaWdubWVudFxuICBjb21waWxlRXhpc3RlbmNlOiAobywgY2hlY2tPbmx5VW5kZWZpbmVkKSAtPlxuICAgIGlmIEBmaXJzdC5zaG91bGRDYWNoZSgpXG4gICAgICByZWYgPSBuZXcgSWRlbnRpZmllckxpdGVyYWwgby5zY29wZS5mcmVlVmFyaWFibGUgJ3JlZidcbiAgICAgIGZzdCA9IG5ldyBQYXJlbnMgbmV3IEFzc2lnbiByZWYsIEBmaXJzdFxuICAgIGVsc2VcbiAgICAgIGZzdCA9IEBmaXJzdFxuICAgICAgcmVmID0gZnN0XG4gICAgbmV3IElmKG5ldyBFeGlzdGVuY2UoZnN0LCBjaGVja09ubHlVbmRlZmluZWQpLCByZWYsIHR5cGU6ICdpZicpLmFkZEVsc2UoQHNlY29uZCkuY29tcGlsZVRvRnJhZ21lbnRzIG9cblxuICAjIENvbXBpbGUgYSB1bmFyeSAqKk9wKiouXG4gIGNvbXBpbGVVbmFyeTogKG8pIC0+XG4gICAgcGFydHMgPSBbXVxuICAgIG9wID0gQG9wZXJhdG9yXG4gICAgcGFydHMucHVzaCBbQG1ha2VDb2RlIG9wXVxuICAgIGlmIG9wIGlzICchJyBhbmQgQGZpcnN0IGluc3RhbmNlb2YgRXhpc3RlbmNlXG4gICAgICBAZmlyc3QubmVnYXRlZCA9IG5vdCBAZmlyc3QubmVnYXRlZFxuICAgICAgcmV0dXJuIEBmaXJzdC5jb21waWxlVG9GcmFnbWVudHMgb1xuICAgIGlmIG8ubGV2ZWwgPj0gTEVWRUxfQUNDRVNTXG4gICAgICByZXR1cm4gKG5ldyBQYXJlbnMgdGhpcykuY29tcGlsZVRvRnJhZ21lbnRzIG9cbiAgICBwbHVzTWludXMgPSBvcCBpbiBbJysnLCAnLSddXG4gICAgcGFydHMucHVzaCBbQG1ha2VDb2RlKCcgJyldIGlmIG9wIGluIFsndHlwZW9mJywgJ2RlbGV0ZSddIG9yXG4gICAgICAgICAgICAgICAgICAgICAgcGx1c01pbnVzIGFuZCBAZmlyc3QgaW5zdGFuY2VvZiBPcCBhbmQgQGZpcnN0Lm9wZXJhdG9yIGlzIG9wXG4gICAgaWYgcGx1c01pbnVzIGFuZCBAZmlyc3QgaW5zdGFuY2VvZiBPcFxuICAgICAgQGZpcnN0ID0gbmV3IFBhcmVucyBAZmlyc3RcbiAgICBwYXJ0cy5wdXNoIEBmaXJzdC5jb21waWxlVG9GcmFnbWVudHMgbywgTEVWRUxfT1BcbiAgICBwYXJ0cy5yZXZlcnNlKCkgaWYgQGZsaXBcbiAgICBAam9pbkZyYWdtZW50QXJyYXlzIHBhcnRzLCAnJ1xuXG4gIGNvbXBpbGVDb250aW51YXRpb246IChvKSAtPlxuICAgIHBhcnRzID0gW11cbiAgICBvcCA9IEBvcGVyYXRvclxuICAgIEBjaGVja0NvbnRpbnVhdGlvbiBvIHVubGVzcyBAaXNBd2FpdCgpXG4gICAgaWYgJ2V4cHJlc3Npb24nIGluIE9iamVjdC5rZXlzKEBmaXJzdCkgYW5kIG5vdCAoQGZpcnN0IGluc3RhbmNlb2YgVGhyb3cpXG4gICAgICBwYXJ0cy5wdXNoIEBmaXJzdC5leHByZXNzaW9uLmNvbXBpbGVUb0ZyYWdtZW50cyBvLCBMRVZFTF9PUCBpZiBAZmlyc3QuZXhwcmVzc2lvbj9cbiAgICBlbHNlXG4gICAgICBwYXJ0cy5wdXNoIFtAbWFrZUNvZGUgXCIoXCJdIGlmIG8ubGV2ZWwgPj0gTEVWRUxfUEFSRU5cbiAgICAgIHBhcnRzLnB1c2ggW0BtYWtlQ29kZSBvcF1cbiAgICAgIHBhcnRzLnB1c2ggW0BtYWtlQ29kZSBcIiBcIl0gaWYgQGZpcnN0LmJhc2U/LnZhbHVlIGlzbnQgJydcbiAgICAgIHBhcnRzLnB1c2ggQGZpcnN0LmNvbXBpbGVUb0ZyYWdtZW50cyBvLCBMRVZFTF9PUFxuICAgICAgcGFydHMucHVzaCBbQG1ha2VDb2RlIFwiKVwiXSBpZiBvLmxldmVsID49IExFVkVMX1BBUkVOXG4gICAgQGpvaW5GcmFnbWVudEFycmF5cyBwYXJ0cywgJydcblxuICBjaGVja0NvbnRpbnVhdGlvbjogKG8pIC0+XG4gICAgdW5sZXNzIG8uc2NvcGUucGFyZW50P1xuICAgICAgQGVycm9yIFwiI3tAb3BlcmF0b3J9IGNhbiBvbmx5IG9jY3VyIGluc2lkZSBmdW5jdGlvbnNcIlxuICAgIGlmIG8uc2NvcGUubWV0aG9kPy5ib3VuZCBhbmQgby5zY29wZS5tZXRob2QuaXNHZW5lcmF0b3JcbiAgICAgIEBlcnJvciAneWllbGQgY2Fubm90IG9jY3VyIGluc2lkZSBib3VuZCAoZmF0IGFycm93KSBmdW5jdGlvbnMnXG5cbiAgY29tcGlsZUZsb29yRGl2aXNpb246IChvKSAtPlxuICAgIGZsb29yID0gbmV3IFZhbHVlIG5ldyBJZGVudGlmaWVyTGl0ZXJhbCgnTWF0aCcpLCBbbmV3IEFjY2VzcyBuZXcgUHJvcGVydHlOYW1lICdmbG9vciddXG4gICAgc2Vjb25kID0gaWYgQHNlY29uZC5zaG91bGRDYWNoZSgpIHRoZW4gbmV3IFBhcmVucyBAc2Vjb25kIGVsc2UgQHNlY29uZFxuICAgIGRpdiA9IG5ldyBPcCAnLycsIEBmaXJzdCwgc2Vjb25kXG4gICAgbmV3IENhbGwoZmxvb3IsIFtkaXZdKS5jb21waWxlVG9GcmFnbWVudHMgb1xuXG4gIGNvbXBpbGVNb2R1bG86IChvKSAtPlxuICAgIG1vZCA9IG5ldyBWYWx1ZSBuZXcgTGl0ZXJhbCB1dGlsaXR5ICdtb2R1bG8nLCBvXG4gICAgbmV3IENhbGwobW9kLCBbQGZpcnN0LCBAc2Vjb25kXSkuY29tcGlsZVRvRnJhZ21lbnRzIG9cblxuICB0b1N0cmluZzogKGlkdCkgLT5cbiAgICBzdXBlciBpZHQsIEBjb25zdHJ1Y3Rvci5uYW1lICsgJyAnICsgQG9wZXJhdG9yXG5cbiAgY2hlY2tEZWxldGVPcGVyYW5kOiAobykgLT5cbiAgICBpZiBAb3BlcmF0b3IgaXMgJ2RlbGV0ZScgYW5kIG8uc2NvcGUuY2hlY2soQGZpcnN0LnVud3JhcEFsbCgpLnZhbHVlKVxuICAgICAgQGVycm9yICdkZWxldGUgb3BlcmFuZCBtYXkgbm90IGJlIGFyZ3VtZW50IG9yIHZhcidcblxuICBhc3ROb2RlOiAobykgLT5cbiAgICBAY2hlY2tDb250aW51YXRpb24gbyBpZiBAaXNZaWVsZCgpXG4gICAgQGNoZWNrRGVsZXRlT3BlcmFuZCBvXG4gICAgc3VwZXIgb1xuXG4gIGFzdFR5cGU6IC0+XG4gICAgcmV0dXJuICdBd2FpdEV4cHJlc3Npb24nIGlmIEBpc0F3YWl0KClcbiAgICByZXR1cm4gJ1lpZWxkRXhwcmVzc2lvbicgaWYgQGlzWWllbGQoKVxuICAgIHJldHVybiAnQ2hhaW5lZENvbXBhcmlzb24nIGlmIEBpc0NoYWluKClcbiAgICBzd2l0Y2ggQG9wZXJhdG9yXG4gICAgICB3aGVuICd8fCcsICcmJicsICc/JyB0aGVuICdMb2dpY2FsRXhwcmVzc2lvbidcbiAgICAgIHdoZW4gJysrJywgJy0tJyAgICAgIHRoZW4gJ1VwZGF0ZUV4cHJlc3Npb24nXG4gICAgICBlbHNlXG4gICAgICAgIGlmIEBpc1VuYXJ5KCkgICAgICB0aGVuICdVbmFyeUV4cHJlc3Npb24nXG4gICAgICAgIGVsc2UgICAgICAgICAgICAgICAgICAgICdCaW5hcnlFeHByZXNzaW9uJ1xuXG4gIG9wZXJhdG9yQXN0OiAtPlxuICAgIFwiI3tpZiBAaW52ZXJ0T3BlcmF0b3IgdGhlbiBcIiN7QGludmVydE9wZXJhdG9yfSBcIiBlbHNlICcnfSN7QG9yaWdpbmFsT3BlcmF0b3J9XCJcblxuICBjaGFpbkFzdFByb3BlcnRpZXM6IChvKSAtPlxuICAgIG9wZXJhdG9ycyA9IFtAb3BlcmF0b3JBc3QoKV1cbiAgICBvcGVyYW5kcyA9IFtAc2Vjb25kXVxuICAgIGN1cnJlbnRPcCA9IEBmaXJzdFxuICAgIGxvb3BcbiAgICAgIG9wZXJhdG9ycy51bnNoaWZ0IGN1cnJlbnRPcC5vcGVyYXRvckFzdCgpXG4gICAgICBvcGVyYW5kcy51bnNoaWZ0IGN1cnJlbnRPcC5zZWNvbmRcbiAgICAgIGN1cnJlbnRPcCA9IGN1cnJlbnRPcC5maXJzdFxuICAgICAgdW5sZXNzIGN1cnJlbnRPcC5pc0NoYWluYWJsZSgpXG4gICAgICAgIG9wZXJhbmRzLnVuc2hpZnQgY3VycmVudE9wXG4gICAgICAgIGJyZWFrXG4gICAgcmV0dXJuIHtcbiAgICAgIG9wZXJhdG9yc1xuICAgICAgb3BlcmFuZHM6IChvcGVyYW5kLmFzdChvLCBMRVZFTF9PUCkgZm9yIG9wZXJhbmQgaW4gb3BlcmFuZHMpXG4gICAgfVxuXG4gIGFzdFByb3BlcnRpZXM6IChvKSAtPlxuICAgIHJldHVybiBAY2hhaW5Bc3RQcm9wZXJ0aWVzKG8pIGlmIEBpc0NoYWluKClcblxuICAgIGZpcnN0QXN0ID0gQGZpcnN0LmFzdCBvLCBMRVZFTF9PUFxuICAgIHNlY29uZEFzdCA9IEBzZWNvbmQ/LmFzdCBvLCBMRVZFTF9PUFxuICAgIG9wZXJhdG9yQXN0ID0gQG9wZXJhdG9yQXN0KClcbiAgICBzd2l0Y2hcbiAgICAgIHdoZW4gQGlzVW5hcnkoKVxuICAgICAgICBhcmd1bWVudCA9XG4gICAgICAgICAgaWYgQGlzWWllbGQoKSBhbmQgQGZpcnN0LnVud3JhcCgpLnZhbHVlIGlzICcnXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmlyc3RBc3RcbiAgICAgICAgcmV0dXJuIHthcmd1bWVudH0gaWYgQGlzQXdhaXQoKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFyZ3VtZW50XG4gICAgICAgICAgZGVsZWdhdGU6IEBvcGVyYXRvciBpcyAneWllbGQqJ1xuICAgICAgICB9IGlmIEBpc1lpZWxkKClcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhcmd1bWVudFxuICAgICAgICAgIG9wZXJhdG9yOiBvcGVyYXRvckFzdFxuICAgICAgICAgIHByZWZpeDogIUBmbGlwXG4gICAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuXG4gICAgICAgICAgbGVmdDogZmlyc3RBc3RcbiAgICAgICAgICByaWdodDogc2Vjb25kQXN0XG4gICAgICAgICAgb3BlcmF0b3I6IG9wZXJhdG9yQXN0XG5cbiMjIyMgSW5cbmV4cG9ydHMuSW4gPSBjbGFzcyBJbiBleHRlbmRzIEJhc2VcbiAgY29uc3RydWN0b3I6IChAb2JqZWN0LCBAYXJyYXkpIC0+XG4gICAgc3VwZXIoKVxuXG4gIGNoaWxkcmVuOiBbJ29iamVjdCcsICdhcnJheSddXG5cbiAgaW52ZXJ0OiBORUdBVEVcblxuICBjb21waWxlTm9kZTogKG8pIC0+XG4gICAgaWYgQGFycmF5IGluc3RhbmNlb2YgVmFsdWUgYW5kIEBhcnJheS5pc0FycmF5KCkgYW5kIEBhcnJheS5iYXNlLm9iamVjdHMubGVuZ3RoXG4gICAgICBmb3Igb2JqIGluIEBhcnJheS5iYXNlLm9iamVjdHMgd2hlbiBvYmogaW5zdGFuY2VvZiBTcGxhdFxuICAgICAgICBoYXNTcGxhdCA9IHllc1xuICAgICAgICBicmVha1xuICAgICAgIyBgY29tcGlsZU9yVGVzdGAgb25seSBpZiB3ZSBoYXZlIGFuIGFycmF5IGxpdGVyYWwgd2l0aCBubyBzcGxhdHNcbiAgICAgIHJldHVybiBAY29tcGlsZU9yVGVzdCBvIHVubGVzcyBoYXNTcGxhdFxuICAgIEBjb21waWxlTG9vcFRlc3Qgb1xuXG4gIGNvbXBpbGVPclRlc3Q6IChvKSAtPlxuICAgIFtzdWIsIHJlZl0gPSBAb2JqZWN0LmNhY2hlIG8sIExFVkVMX09QXG4gICAgW2NtcCwgY25qXSA9IGlmIEBuZWdhdGVkIHRoZW4gWycgIT09ICcsICcgJiYgJ10gZWxzZSBbJyA9PT0gJywgJyB8fCAnXVxuICAgIHRlc3RzID0gW11cbiAgICBmb3IgaXRlbSwgaSBpbiBAYXJyYXkuYmFzZS5vYmplY3RzXG4gICAgICBpZiBpIHRoZW4gdGVzdHMucHVzaCBAbWFrZUNvZGUgY25qXG4gICAgICB0ZXN0cyA9IHRlc3RzLmNvbmNhdCAoaWYgaSB0aGVuIHJlZiBlbHNlIHN1YiksIEBtYWtlQ29kZShjbXApLCBpdGVtLmNvbXBpbGVUb0ZyYWdtZW50cyhvLCBMRVZFTF9BQ0NFU1MpXG4gICAgaWYgby5sZXZlbCA8IExFVkVMX09QIHRoZW4gdGVzdHMgZWxzZSBAd3JhcEluUGFyZW50aGVzZXMgdGVzdHNcblxuICBjb21waWxlTG9vcFRlc3Q6IChvKSAtPlxuICAgIFtzdWIsIHJlZl0gPSBAb2JqZWN0LmNhY2hlIG8sIExFVkVMX0xJU1RcbiAgICBmcmFnbWVudHMgPSBbXS5jb25jYXQgQG1ha2VDb2RlKHV0aWxpdHkoJ2luZGV4T2YnLCBvKSArIFwiLmNhbGwoXCIpLCBAYXJyYXkuY29tcGlsZVRvRnJhZ21lbnRzKG8sIExFVkVMX0xJU1QpLFxuICAgICAgQG1ha2VDb2RlKFwiLCBcIiksIHJlZiwgQG1ha2VDb2RlKFwiKSBcIiArIGlmIEBuZWdhdGVkIHRoZW4gJzwgMCcgZWxzZSAnPj0gMCcpXG4gICAgcmV0dXJuIGZyYWdtZW50cyBpZiBmcmFnbWVudHNUb1RleHQoc3ViKSBpcyBmcmFnbWVudHNUb1RleHQocmVmKVxuICAgIGZyYWdtZW50cyA9IHN1Yi5jb25jYXQgQG1ha2VDb2RlKCcsICcpLCBmcmFnbWVudHNcbiAgICBpZiBvLmxldmVsIDwgTEVWRUxfTElTVCB0aGVuIGZyYWdtZW50cyBlbHNlIEB3cmFwSW5QYXJlbnRoZXNlcyBmcmFnbWVudHNcblxuICB0b1N0cmluZzogKGlkdCkgLT5cbiAgICBzdXBlciBpZHQsIEBjb25zdHJ1Y3Rvci5uYW1lICsgaWYgQG5lZ2F0ZWQgdGhlbiAnIScgZWxzZSAnJ1xuXG4jIyMjIFRyeVxuXG4jIEEgY2xhc3NpYyAqdHJ5L2NhdGNoL2ZpbmFsbHkqIGJsb2NrLlxuZXhwb3J0cy5UcnkgPSBjbGFzcyBUcnkgZXh0ZW5kcyBCYXNlXG4gIGNvbnN0cnVjdG9yOiAoQGF0dGVtcHQsIEBjYXRjaCwgQGVuc3VyZSwgQGZpbmFsbHlUYWcpIC0+XG4gICAgc3VwZXIoKVxuXG4gIGNoaWxkcmVuOiBbJ2F0dGVtcHQnLCAnY2F0Y2gnLCAnZW5zdXJlJ11cblxuICBpc1N0YXRlbWVudDogWUVTXG5cbiAganVtcHM6IChvKSAtPiBAYXR0ZW1wdC5qdW1wcyhvKSBvciBAY2F0Y2g/Lmp1bXBzKG8pXG5cbiAgbWFrZVJldHVybjogKHJlc3VsdHMsIG1hcmspIC0+XG4gICAgaWYgbWFya1xuICAgICAgQGF0dGVtcHQ/Lm1ha2VSZXR1cm4gcmVzdWx0cywgbWFya1xuICAgICAgQGNhdGNoPy5tYWtlUmV0dXJuIHJlc3VsdHMsIG1hcmtcbiAgICAgIHJldHVyblxuICAgIEBhdHRlbXB0ID0gQGF0dGVtcHQubWFrZVJldHVybiByZXN1bHRzIGlmIEBhdHRlbXB0XG4gICAgQGNhdGNoICAgPSBAY2F0Y2ggIC5tYWtlUmV0dXJuIHJlc3VsdHMgaWYgQGNhdGNoXG4gICAgdGhpc1xuXG4gICMgQ29tcGlsYXRpb24gaXMgbW9yZSBvciBsZXNzIGFzIHlvdSB3b3VsZCBleHBlY3QgLS0gdGhlICpmaW5hbGx5KiBjbGF1c2VcbiAgIyBpcyBvcHRpb25hbCwgdGhlICpjYXRjaCogaXMgbm90LlxuICBjb21waWxlTm9kZTogKG8pIC0+XG4gICAgb3JpZ2luYWxJbmRlbnQgPSBvLmluZGVudFxuICAgIG8uaW5kZW50ICArPSBUQUJcbiAgICB0cnlQYXJ0ICAgPSBAYXR0ZW1wdC5jb21waWxlVG9GcmFnbWVudHMgbywgTEVWRUxfVE9QXG5cbiAgICBjYXRjaFBhcnQgPSBpZiBAY2F0Y2hcbiAgICAgIEBjYXRjaC5jb21waWxlVG9GcmFnbWVudHMgbWVyZ2UobywgaW5kZW50OiBvcmlnaW5hbEluZGVudCksIExFVkVMX1RPUFxuICAgIGVsc2UgdW5sZXNzIEBlbnN1cmUgb3IgQGNhdGNoXG4gICAgICBnZW5lcmF0ZWRFcnJvclZhcmlhYmxlTmFtZSA9IG8uc2NvcGUuZnJlZVZhcmlhYmxlICdlcnJvcicsIHJlc2VydmU6IG5vXG4gICAgICBbQG1ha2VDb2RlKFwiIGNhdGNoICgje2dlbmVyYXRlZEVycm9yVmFyaWFibGVOYW1lfSkge31cIildXG4gICAgZWxzZVxuICAgICAgW11cblxuICAgIGVuc3VyZVBhcnQgPSBpZiBAZW5zdXJlIHRoZW4gKFtdLmNvbmNhdCBAbWFrZUNvZGUoXCIgZmluYWxseSB7XFxuXCIpLCBAZW5zdXJlLmNvbXBpbGVUb0ZyYWdtZW50cyhvLCBMRVZFTF9UT1ApLFxuICAgICAgQG1ha2VDb2RlKFwiXFxuI3tAdGFifX1cIikpIGVsc2UgW11cblxuICAgIFtdLmNvbmNhdCBAbWFrZUNvZGUoXCIje0B0YWJ9dHJ5IHtcXG5cIiksXG4gICAgICB0cnlQYXJ0LFxuICAgICAgQG1ha2VDb2RlKFwiXFxuI3tAdGFifX1cIiksIGNhdGNoUGFydCwgZW5zdXJlUGFydFxuXG4gIGFzdFR5cGU6IC0+ICdUcnlTdGF0ZW1lbnQnXG5cbiAgYXN0UHJvcGVydGllczogKG8pIC0+XG4gICAgcmV0dXJuXG4gICAgICBibG9jazogQGF0dGVtcHQuYXN0IG8sIExFVkVMX1RPUFxuICAgICAgaGFuZGxlcjogQGNhdGNoPy5hc3QobykgPyBudWxsXG4gICAgICBmaW5hbGl6ZXI6XG4gICAgICAgIGlmIEBlbnN1cmU/XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbiBAZW5zdXJlLmFzdChvLCBMRVZFTF9UT1ApLFxuICAgICAgICAgICAgIyBJbmNsdWRlIGBmaW5hbGx5YCBrZXl3b3JkIGluIGxvY2F0aW9uIGRhdGEuXG4gICAgICAgICAgICBtZXJnZUFzdExvY2F0aW9uRGF0YShcbiAgICAgICAgICAgICAgamlzb25Mb2NhdGlvbkRhdGFUb0FzdExvY2F0aW9uRGF0YShAZmluYWxseVRhZy5sb2NhdGlvbkRhdGEpLFxuICAgICAgICAgICAgICBAZW5zdXJlLmFzdExvY2F0aW9uRGF0YSgpXG4gICAgICAgICAgICApXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBudWxsXG5cbmV4cG9ydHMuQ2F0Y2ggPSBjbGFzcyBDYXRjaCBleHRlbmRzIEJhc2VcbiAgY29uc3RydWN0b3I6IChAcmVjb3ZlcnksIEBlcnJvclZhcmlhYmxlKSAtPlxuICAgIHN1cGVyKClcbiAgICBAZXJyb3JWYXJpYWJsZT8udW53cmFwKCkucHJvcGFnYXRlTGhzPyB5ZXNcblxuICBjaGlsZHJlbjogWydyZWNvdmVyeScsICdlcnJvclZhcmlhYmxlJ11cblxuICBpc1N0YXRlbWVudDogWUVTXG5cbiAganVtcHM6IChvKSAtPiBAcmVjb3ZlcnkuanVtcHMgb1xuXG4gIG1ha2VSZXR1cm46IChyZXN1bHRzLCBtYXJrKSAtPlxuICAgIHJldCA9IEByZWNvdmVyeS5tYWtlUmV0dXJuIHJlc3VsdHMsIG1hcmtcbiAgICByZXR1cm4gaWYgbWFya1xuICAgIEByZWNvdmVyeSA9IHJldFxuICAgIHRoaXNcblxuICBjb21waWxlTm9kZTogKG8pIC0+XG4gICAgby5pbmRlbnQgICs9IFRBQlxuICAgIGdlbmVyYXRlZEVycm9yVmFyaWFibGVOYW1lID0gby5zY29wZS5mcmVlVmFyaWFibGUgJ2Vycm9yJywgcmVzZXJ2ZTogbm9cbiAgICBwbGFjZWhvbGRlciA9IG5ldyBJZGVudGlmaWVyTGl0ZXJhbCBnZW5lcmF0ZWRFcnJvclZhcmlhYmxlTmFtZVxuICAgIEBjaGVja1VuYXNzaWduYWJsZSgpXG4gICAgaWYgQGVycm9yVmFyaWFibGVcbiAgICAgIEByZWNvdmVyeS51bnNoaWZ0IG5ldyBBc3NpZ24gQGVycm9yVmFyaWFibGUsIHBsYWNlaG9sZGVyXG4gICAgW10uY29uY2F0IEBtYWtlQ29kZShcIiBjYXRjaCAoXCIpLCBwbGFjZWhvbGRlci5jb21waWxlVG9GcmFnbWVudHMobyksIEBtYWtlQ29kZShcIikge1xcblwiKSxcbiAgICAgIEByZWNvdmVyeS5jb21waWxlVG9GcmFnbWVudHMobywgTEVWRUxfVE9QKSwgQG1ha2VDb2RlKFwiXFxuI3tAdGFifX1cIilcblxuICBjaGVja1VuYXNzaWduYWJsZTogLT5cbiAgICBpZiBAZXJyb3JWYXJpYWJsZVxuICAgICAgbWVzc2FnZSA9IGlzVW5hc3NpZ25hYmxlIEBlcnJvclZhcmlhYmxlLnVud3JhcEFsbCgpLnZhbHVlXG4gICAgICBAZXJyb3JWYXJpYWJsZS5lcnJvciBtZXNzYWdlIGlmIG1lc3NhZ2VcblxuICBhc3ROb2RlOiAobykgLT5cbiAgICBAY2hlY2tVbmFzc2lnbmFibGUoKVxuICAgIEBlcnJvclZhcmlhYmxlPy5lYWNoTmFtZSAobmFtZSkgLT5cbiAgICAgIGFscmVhZHlEZWNsYXJlZCA9IG8uc2NvcGUuZmluZCBuYW1lLnZhbHVlXG4gICAgICBuYW1lLmlzRGVjbGFyYXRpb24gPSBub3QgYWxyZWFkeURlY2xhcmVkXG5cbiAgICBzdXBlciBvXG5cbiAgYXN0VHlwZTogLT4gJ0NhdGNoQ2xhdXNlJ1xuXG4gIGFzdFByb3BlcnRpZXM6IChvKSAtPlxuICAgIHJldHVyblxuICAgICAgcGFyYW06IEBlcnJvclZhcmlhYmxlPy5hc3QobykgPyBudWxsXG4gICAgICBib2R5OiBAcmVjb3ZlcnkuYXN0IG8sIExFVkVMX1RPUFxuXG4jIyMjIFRocm93XG5cbiMgU2ltcGxlIG5vZGUgdG8gdGhyb3cgYW4gZXhjZXB0aW9uLlxuZXhwb3J0cy5UaHJvdyA9IGNsYXNzIFRocm93IGV4dGVuZHMgQmFzZVxuICBjb25zdHJ1Y3RvcjogKEBleHByZXNzaW9uKSAtPlxuICAgIHN1cGVyKClcblxuICBjaGlsZHJlbjogWydleHByZXNzaW9uJ11cblxuICBpc1N0YXRlbWVudDogWUVTXG4gIGp1bXBzOiAgICAgICBOT1xuXG4gICMgQSAqKlRocm93KiogaXMgYWxyZWFkeSBhIHJldHVybiwgb2Ygc29ydHMuLi5cbiAgbWFrZVJldHVybjogVEhJU1xuXG4gIGNvbXBpbGVOb2RlOiAobykgLT5cbiAgICBmcmFnbWVudHMgPSBAZXhwcmVzc2lvbi5jb21waWxlVG9GcmFnbWVudHMgbywgTEVWRUxfTElTVFxuICAgIHVuc2hpZnRBZnRlckNvbW1lbnRzIGZyYWdtZW50cywgQG1ha2VDb2RlICd0aHJvdyAnXG4gICAgZnJhZ21lbnRzLnVuc2hpZnQgQG1ha2VDb2RlIEB0YWJcbiAgICBmcmFnbWVudHMucHVzaCBAbWFrZUNvZGUgJzsnXG4gICAgZnJhZ21lbnRzXG5cbiAgYXN0VHlwZTogLT4gJ1Rocm93U3RhdGVtZW50J1xuXG4gIGFzdFByb3BlcnRpZXM6IChvKSAtPlxuICAgIHJldHVyblxuICAgICAgYXJndW1lbnQ6IEBleHByZXNzaW9uLmFzdCBvLCBMRVZFTF9MSVNUXG5cbiMjIyMgRXhpc3RlbmNlXG5cbiMgQ2hlY2tzIGEgdmFyaWFibGUgZm9yIGV4aXN0ZW5jZSAtLSBub3QgYG51bGxgIGFuZCBub3QgYHVuZGVmaW5lZGAuIFRoaXMgaXNcbiMgc2ltaWxhciB0byBgLm5pbD9gIGluIFJ1YnksIGFuZCBhdm9pZHMgaGF2aW5nIHRvIGNvbnN1bHQgYSBKYXZhU2NyaXB0IHRydXRoXG4jIHRhYmxlLiBPcHRpb25hbGx5IG9ubHkgY2hlY2sgaWYgYSB2YXJpYWJsZSBpcyBub3QgYHVuZGVmaW5lZGAuXG5leHBvcnRzLkV4aXN0ZW5jZSA9IGNsYXNzIEV4aXN0ZW5jZSBleHRlbmRzIEJhc2VcbiAgY29uc3RydWN0b3I6IChAZXhwcmVzc2lvbiwgb25seU5vdFVuZGVmaW5lZCA9IG5vKSAtPlxuICAgIHN1cGVyKClcbiAgICBAY29tcGFyaXNvblRhcmdldCA9IGlmIG9ubHlOb3RVbmRlZmluZWQgdGhlbiAndW5kZWZpbmVkJyBlbHNlICdudWxsJ1xuICAgIHNhbHZhZ2VkQ29tbWVudHMgPSBbXVxuICAgIEBleHByZXNzaW9uLnRyYXZlcnNlQ2hpbGRyZW4geWVzLCAoY2hpbGQpIC0+XG4gICAgICBpZiBjaGlsZC5jb21tZW50c1xuICAgICAgICBmb3IgY29tbWVudCBpbiBjaGlsZC5jb21tZW50c1xuICAgICAgICAgIHNhbHZhZ2VkQ29tbWVudHMucHVzaCBjb21tZW50IHVubGVzcyBjb21tZW50IGluIHNhbHZhZ2VkQ29tbWVudHNcbiAgICAgICAgZGVsZXRlIGNoaWxkLmNvbW1lbnRzXG4gICAgYXR0YWNoQ29tbWVudHNUb05vZGUgc2FsdmFnZWRDb21tZW50cywgQFxuICAgIG1vdmVDb21tZW50cyBAZXhwcmVzc2lvbiwgQFxuXG4gIGNoaWxkcmVuOiBbJ2V4cHJlc3Npb24nXVxuXG4gIGludmVydDogTkVHQVRFXG5cbiAgY29tcGlsZU5vZGU6IChvKSAtPlxuICAgIEBleHByZXNzaW9uLmZyb250ID0gQGZyb250XG4gICAgY29kZSA9IEBleHByZXNzaW9uLmNvbXBpbGUgbywgTEVWRUxfT1BcbiAgICBpZiBAZXhwcmVzc2lvbi51bndyYXAoKSBpbnN0YW5jZW9mIElkZW50aWZpZXJMaXRlcmFsIGFuZCBub3Qgby5zY29wZS5jaGVjayBjb2RlXG4gICAgICBbY21wLCBjbmpdID0gaWYgQG5lZ2F0ZWQgdGhlbiBbJz09PScsICd8fCddIGVsc2UgWychPT0nLCAnJiYnXVxuICAgICAgY29kZSA9IFwidHlwZW9mICN7Y29kZX0gI3tjbXB9IFxcXCJ1bmRlZmluZWRcXFwiXCIgKyBpZiBAY29tcGFyaXNvblRhcmdldCBpc250ICd1bmRlZmluZWQnIHRoZW4gXCIgI3tjbmp9ICN7Y29kZX0gI3tjbXB9ICN7QGNvbXBhcmlzb25UYXJnZXR9XCIgZWxzZSAnJ1xuICAgIGVsc2VcbiAgICAgICMgV2UgZXhwbGljaXR5IHdhbnQgdG8gdXNlIGxvb3NlIGVxdWFsaXR5IChgPT1gKSB3aGVuIGNvbXBhcmluZyBhZ2FpbnN0IGBudWxsYCxcbiAgICAgICMgc28gdGhhdCBhbiBleGlzdGVuY2UgY2hlY2sgcm91Z2hseSBjb3JyZXNwb25kcyB0byBhIGNoZWNrIGZvciB0cnV0aGluZXNzLlxuICAgICAgIyBEbyAqbm90KiBjaGFuZ2UgdGhpcyB0byBgPT09YCBmb3IgYG51bGxgLCBhcyB0aGlzIHdpbGwgYnJlYWsgbW91bnRhaW5zIG9mXG4gICAgICAjIGV4aXN0aW5nIGNvZGUuIFdoZW4gY29tcGFyaW5nIG9ubHkgYWdhaW5zdCBgdW5kZWZpbmVkYCwgaG93ZXZlciwgd2Ugd2FudCB0b1xuICAgICAgIyB1c2UgYD09PWAgYmVjYXVzZSB0aGlzIHVzZSBjYXNlIGlzIGZvciBwYXJpdHkgd2l0aCBFUzIwMTUrIGRlZmF1bHQgdmFsdWVzLFxuICAgICAgIyB3aGljaCBvbmx5IGdldCBhc3NpZ25lZCB3aGVuIHRoZSB2YXJpYWJsZSBpcyBgdW5kZWZpbmVkYCAoYnV0IG5vdCBgbnVsbGApLlxuICAgICAgY21wID0gaWYgQGNvbXBhcmlzb25UYXJnZXQgaXMgJ251bGwnXG4gICAgICAgIGlmIEBuZWdhdGVkIHRoZW4gJz09JyBlbHNlICchPSdcbiAgICAgIGVsc2UgIyBgdW5kZWZpbmVkYFxuICAgICAgICBpZiBAbmVnYXRlZCB0aGVuICc9PT0nIGVsc2UgJyE9PSdcbiAgICAgIGNvZGUgPSBcIiN7Y29kZX0gI3tjbXB9ICN7QGNvbXBhcmlzb25UYXJnZXR9XCJcbiAgICBbQG1ha2VDb2RlKGlmIG8ubGV2ZWwgPD0gTEVWRUxfQ09ORCB0aGVuIGNvZGUgZWxzZSBcIigje2NvZGV9KVwiKV1cblxuICBhc3RUeXBlOiAtPiAnVW5hcnlFeHByZXNzaW9uJ1xuXG4gIGFzdFByb3BlcnRpZXM6IChvKSAtPlxuICAgIHJldHVyblxuICAgICAgYXJndW1lbnQ6IEBleHByZXNzaW9uLmFzdCBvXG4gICAgICBvcGVyYXRvcjogJz8nXG4gICAgICBwcmVmaXg6IG5vXG5cbiMjIyMgUGFyZW5zXG5cbiMgQW4gZXh0cmEgc2V0IG9mIHBhcmVudGhlc2VzLCBzcGVjaWZpZWQgZXhwbGljaXRseSBpbiB0aGUgc291cmNlLiBBdCBvbmUgdGltZVxuIyB3ZSB0cmllZCB0byBjbGVhbiB1cCB0aGUgcmVzdWx0cyBieSBkZXRlY3RpbmcgYW5kIHJlbW92aW5nIHJlZHVuZGFudFxuIyBwYXJlbnRoZXNlcywgYnV0IG5vIGxvbmdlciAtLSB5b3UgY2FuIHB1dCBpbiBhcyBtYW55IGFzIHlvdSBwbGVhc2UuXG4jXG4jIFBhcmVudGhlc2VzIGFyZSBhIGdvb2Qgd2F5IHRvIGZvcmNlIGFueSBzdGF0ZW1lbnQgdG8gYmVjb21lIGFuIGV4cHJlc3Npb24uXG5leHBvcnRzLlBhcmVucyA9IGNsYXNzIFBhcmVucyBleHRlbmRzIEJhc2VcbiAgY29uc3RydWN0b3I6IChAYm9keSkgLT5cbiAgICBzdXBlcigpXG5cbiAgY2hpbGRyZW46IFsnYm9keSddXG5cbiAgdW53cmFwOiAtPiBAYm9keVxuXG4gIHNob3VsZENhY2hlOiAtPiBAYm9keS5zaG91bGRDYWNoZSgpXG5cbiAgY29tcGlsZU5vZGU6IChvKSAtPlxuICAgIGV4cHIgPSBAYm9keS51bndyYXAoKVxuICAgICMgSWYgdGhlc2UgcGFyZW50aGVzZXMgYXJlIHdyYXBwaW5nIGFuIGBJZGVudGlmaWVyTGl0ZXJhbGAgZm9sbG93ZWQgYnkgYVxuICAgICMgYmxvY2sgY29tbWVudCwgb3V0cHV0IHRoZSBwYXJlbnRoZXNlcyAob3IgcHV0IGFub3RoZXIgd2F5LCBkb27igJl0IG9wdGltaXplXG4gICAgIyBhd2F5IHRoZXNlIHJlZHVuZGFudCBwYXJlbnRoZXNlcykuIFRoaXMgaXMgYmVjYXVzZSBGbG93IHJlcXVpcmVzXG4gICAgIyBwYXJlbnRoZXNlcyBpbiBjZXJ0YWluIGNpcmN1bXN0YW5jZXMgdG8gZGlzdGluZ3Vpc2ggaWRlbnRpZmllcnMgZm9sbG93ZWRcbiAgICAjIGJ5IGNvbW1lbnQtYmFzZWQgdHlwZSBhbm5vdGF0aW9ucyBmcm9tIEphdmFTY3JpcHQgbGFiZWxzLlxuICAgIHNob3VsZFdyYXBDb21tZW50ID0gZXhwci5jb21tZW50cz8uc29tZShcbiAgICAgIChjb21tZW50KSAtPiBjb21tZW50LmhlcmUgYW5kIG5vdCBjb21tZW50LnVuc2hpZnQgYW5kIG5vdCBjb21tZW50Lm5ld0xpbmUpXG4gICAgaWYgZXhwciBpbnN0YW5jZW9mIFZhbHVlIGFuZCBleHByLmlzQXRvbWljKCkgYW5kIG5vdCBAanN4QXR0cmlidXRlIGFuZCBub3Qgc2hvdWxkV3JhcENvbW1lbnRcbiAgICAgIGV4cHIuZnJvbnQgPSBAZnJvbnRcbiAgICAgIHJldHVybiBleHByLmNvbXBpbGVUb0ZyYWdtZW50cyBvXG4gICAgZnJhZ21lbnRzID0gZXhwci5jb21waWxlVG9GcmFnbWVudHMgbywgTEVWRUxfUEFSRU5cbiAgICBiYXJlID0gby5sZXZlbCA8IExFVkVMX09QIGFuZCBub3Qgc2hvdWxkV3JhcENvbW1lbnQgYW5kIChcbiAgICAgICAgZXhwciBpbnN0YW5jZW9mIE9wIGFuZCBub3QgZXhwci5pc0luT3BlcmF0b3IoKSBvciBleHByLnVud3JhcCgpIGluc3RhbmNlb2YgQ2FsbCBvclxuICAgICAgICAoZXhwciBpbnN0YW5jZW9mIEZvciBhbmQgZXhwci5yZXR1cm5zKVxuICAgICAgKSBhbmQgKG8ubGV2ZWwgPCBMRVZFTF9DT05EIG9yIGZyYWdtZW50cy5sZW5ndGggPD0gMylcbiAgICByZXR1cm4gQHdyYXBJbkJyYWNlcyBmcmFnbWVudHMgaWYgQGpzeEF0dHJpYnV0ZVxuICAgIGlmIGJhcmUgdGhlbiBmcmFnbWVudHMgZWxzZSBAd3JhcEluUGFyZW50aGVzZXMgZnJhZ21lbnRzXG5cbiAgYXN0Tm9kZTogKG8pIC0+IEBib2R5LnVud3JhcCgpLmFzdCBvLCBMRVZFTF9QQVJFTlxuXG4jIyMjIFN0cmluZ1dpdGhJbnRlcnBvbGF0aW9uc1xuXG5leHBvcnRzLlN0cmluZ1dpdGhJbnRlcnBvbGF0aW9ucyA9IGNsYXNzIFN0cmluZ1dpdGhJbnRlcnBvbGF0aW9ucyBleHRlbmRzIEJhc2VcbiAgY29uc3RydWN0b3I6IChAYm9keSwge0BxdW90ZSwgQHN0YXJ0UXVvdGUsIEBqc3hBdHRyaWJ1dGV9ID0ge30pIC0+XG4gICAgc3VwZXIoKVxuXG4gIEBmcm9tU3RyaW5nTGl0ZXJhbDogKHN0cmluZ0xpdGVyYWwpIC0+XG4gICAgdXBkYXRlZFN0cmluZyA9IHN0cmluZ0xpdGVyYWwud2l0aG91dFF1b3Rlc0luTG9jYXRpb25EYXRhKClcbiAgICB1cGRhdGVkU3RyaW5nVmFsdWUgPSBuZXcgVmFsdWUodXBkYXRlZFN0cmluZykud2l0aExvY2F0aW9uRGF0YUZyb20gdXBkYXRlZFN0cmluZ1xuICAgIG5ldyBTdHJpbmdXaXRoSW50ZXJwb2xhdGlvbnMgQmxvY2sud3JhcChbdXBkYXRlZFN0cmluZ1ZhbHVlXSksIHF1b3RlOiBzdHJpbmdMaXRlcmFsLnF1b3RlLCBqc3hBdHRyaWJ1dGU6IHN0cmluZ0xpdGVyYWwuanN4QXR0cmlidXRlXG4gICAgLndpdGhMb2NhdGlvbkRhdGFGcm9tIHN0cmluZ0xpdGVyYWxcblxuICBjaGlsZHJlbjogWydib2R5J11cblxuICAjIGB1bndyYXBgIHJldHVybnMgYHRoaXNgIHRvIHN0b3AgYW5jZXN0b3Igbm9kZXMgcmVhY2hpbmcgaW4gdG8gZ3JhYiBAYm9keSxcbiAgIyBhbmQgdXNpbmcgQGJvZHkuY29tcGlsZU5vZGUuIGBTdHJpbmdXaXRoSW50ZXJwb2xhdGlvbnMuY29tcGlsZU5vZGVgIGlzXG4gICMgX3RoZV8gY3VzdG9tIGxvZ2ljIHRvIG91dHB1dCBpbnRlcnBvbGF0ZWQgc3RyaW5ncyBhcyBjb2RlLlxuICB1bndyYXA6IC0+IHRoaXNcblxuICBzaG91bGRDYWNoZTogLT4gQGJvZHkuc2hvdWxkQ2FjaGUoKVxuXG4gIGV4dHJhY3RFbGVtZW50czogKG8sIHtpbmNsdWRlSW50ZXJwb2xhdGlvbldyYXBwZXJzLCBpc0pzeH0gPSB7fSkgLT5cbiAgICAjIEFzc3VtZXMgdGhhdCBgZXhwcmAgaXMgYEJsb2NrYFxuICAgIGV4cHIgPSBAYm9keS51bndyYXAoKVxuXG4gICAgZWxlbWVudHMgPSBbXVxuICAgIHNhbHZhZ2VkQ29tbWVudHMgPSBbXVxuICAgIGV4cHIudHJhdmVyc2VDaGlsZHJlbiBubywgKG5vZGUpID0+XG4gICAgICBpZiBub2RlIGluc3RhbmNlb2YgU3RyaW5nTGl0ZXJhbFxuICAgICAgICBpZiBub2RlLmNvbW1lbnRzXG4gICAgICAgICAgc2FsdmFnZWRDb21tZW50cy5wdXNoIG5vZGUuY29tbWVudHMuLi5cbiAgICAgICAgICBkZWxldGUgbm9kZS5jb21tZW50c1xuICAgICAgICBlbGVtZW50cy5wdXNoIG5vZGVcbiAgICAgICAgcmV0dXJuIHllc1xuICAgICAgZWxzZSBpZiBub2RlIGluc3RhbmNlb2YgSW50ZXJwb2xhdGlvblxuICAgICAgICBpZiBzYWx2YWdlZENvbW1lbnRzLmxlbmd0aCBpc250IDBcbiAgICAgICAgICBmb3IgY29tbWVudCBpbiBzYWx2YWdlZENvbW1lbnRzXG4gICAgICAgICAgICBjb21tZW50LnVuc2hpZnQgPSB5ZXNcbiAgICAgICAgICAgIGNvbW1lbnQubmV3TGluZSA9IHllc1xuICAgICAgICAgIGF0dGFjaENvbW1lbnRzVG9Ob2RlIHNhbHZhZ2VkQ29tbWVudHMsIG5vZGVcbiAgICAgICAgaWYgKHVud3JhcHBlZCA9IG5vZGUuZXhwcmVzc2lvbj8udW53cmFwQWxsKCkpIGluc3RhbmNlb2YgUGFzc3Rocm91Z2hMaXRlcmFsIGFuZCB1bndyYXBwZWQuZ2VuZXJhdGVkIGFuZCBub3QgKGlzSnN4IGFuZCBvLmNvbXBpbGluZylcbiAgICAgICAgICBpZiBvLmNvbXBpbGluZ1xuICAgICAgICAgICAgY29tbWVudFBsYWNlaG9sZGVyID0gbmV3IFN0cmluZ0xpdGVyYWwoJycpLndpdGhMb2NhdGlvbkRhdGFGcm9tIG5vZGVcbiAgICAgICAgICAgIGNvbW1lbnRQbGFjZWhvbGRlci5jb21tZW50cyA9IHVud3JhcHBlZC5jb21tZW50c1xuICAgICAgICAgICAgKGNvbW1lbnRQbGFjZWhvbGRlci5jb21tZW50cyA/PSBbXSkucHVzaCBub2RlLmNvbW1lbnRzLi4uIGlmIG5vZGUuY29tbWVudHNcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2ggbmV3IFZhbHVlIGNvbW1lbnRQbGFjZWhvbGRlclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGVtcHR5ID0gbmV3IEludGVycG9sYXRpb24oKS53aXRoTG9jYXRpb25EYXRhRnJvbSBub2RlXG4gICAgICAgICAgICBlbXB0eS5jb21tZW50cyA9IG5vZGUuY29tbWVudHNcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2ggZW1wdHlcbiAgICAgICAgZWxzZSBpZiBub2RlLmV4cHJlc3Npb24gb3IgaW5jbHVkZUludGVycG9sYXRpb25XcmFwcGVyc1xuICAgICAgICAgIChub2RlLmV4cHJlc3Npb24/LmNvbW1lbnRzID89IFtdKS5wdXNoIG5vZGUuY29tbWVudHMuLi4gaWYgbm9kZS5jb21tZW50c1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2ggaWYgaW5jbHVkZUludGVycG9sYXRpb25XcmFwcGVycyB0aGVuIG5vZGUgZWxzZSBub2RlLmV4cHJlc3Npb25cbiAgICAgICAgcmV0dXJuIG5vXG4gICAgICBlbHNlIGlmIG5vZGUuY29tbWVudHNcbiAgICAgICAgIyBUaGlzIG5vZGUgaXMgZ2V0dGluZyBkaXNjYXJkZWQsIGJ1dCBzYWx2YWdlIGl0cyBjb21tZW50cy5cbiAgICAgICAgaWYgZWxlbWVudHMubGVuZ3RoIGlzbnQgMCBhbmQgZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV0gbm90IGluc3RhbmNlb2YgU3RyaW5nTGl0ZXJhbFxuICAgICAgICAgIGZvciBjb21tZW50IGluIG5vZGUuY29tbWVudHNcbiAgICAgICAgICAgIGNvbW1lbnQudW5zaGlmdCA9IG5vXG4gICAgICAgICAgICBjb21tZW50Lm5ld0xpbmUgPSB5ZXNcbiAgICAgICAgICBhdHRhY2hDb21tZW50c1RvTm9kZSBub2RlLmNvbW1lbnRzLCBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXVxuICAgICAgICBlbHNlXG4gICAgICAgICAgc2FsdmFnZWRDb21tZW50cy5wdXNoIG5vZGUuY29tbWVudHMuLi5cbiAgICAgICAgZGVsZXRlIG5vZGUuY29tbWVudHNcbiAgICAgIHJldHVybiB5ZXNcblxuICAgIGVsZW1lbnRzXG5cbiAgY29tcGlsZU5vZGU6IChvKSAtPlxuICAgIEBjb21tZW50cyA/PSBAc3RhcnRRdW90ZT8uY29tbWVudHNcblxuICAgIGlmIEBqc3hBdHRyaWJ1dGVcbiAgICAgIHdyYXBwZWQgPSBuZXcgUGFyZW5zIG5ldyBTdHJpbmdXaXRoSW50ZXJwb2xhdGlvbnMgQGJvZHlcbiAgICAgIHdyYXBwZWQuanN4QXR0cmlidXRlID0geWVzXG4gICAgICByZXR1cm4gd3JhcHBlZC5jb21waWxlTm9kZSBvXG5cbiAgICBlbGVtZW50cyA9IEBleHRyYWN0RWxlbWVudHMgbywgaXNKc3g6IEBqc3hcblxuICAgIGZyYWdtZW50cyA9IFtdXG4gICAgZnJhZ21lbnRzLnB1c2ggQG1ha2VDb2RlICdgJyB1bmxlc3MgQGpzeFxuICAgIGZvciBlbGVtZW50IGluIGVsZW1lbnRzXG4gICAgICBpZiBlbGVtZW50IGluc3RhbmNlb2YgU3RyaW5nTGl0ZXJhbFxuICAgICAgICB1bnF1b3RlZEVsZW1lbnRWYWx1ZSA9IGlmIEBqc3ggdGhlbiBlbGVtZW50LnVucXVvdGVkVmFsdWVGb3JKU1ggZWxzZSBlbGVtZW50LnVucXVvdGVkVmFsdWVGb3JUZW1wbGF0ZUxpdGVyYWxcbiAgICAgICAgZnJhZ21lbnRzLnB1c2ggQG1ha2VDb2RlIHVucXVvdGVkRWxlbWVudFZhbHVlXG4gICAgICBlbHNlXG4gICAgICAgIGZyYWdtZW50cy5wdXNoIEBtYWtlQ29kZSAnJCcgdW5sZXNzIEBqc3hcbiAgICAgICAgY29kZSA9IGVsZW1lbnQuY29tcGlsZVRvRnJhZ21lbnRzKG8sIExFVkVMX1BBUkVOKVxuICAgICAgICBpZiBub3QgQGlzTmVzdGVkVGFnKGVsZW1lbnQpIG9yXG4gICAgICAgICAgIGNvZGUuc29tZSgoZnJhZ21lbnQpIC0+IGZyYWdtZW50LmNvbW1lbnRzPy5zb21lKChjb21tZW50KSAtPiBjb21tZW50LmhlcmUgaXMgbm8pKVxuICAgICAgICAgIGNvZGUgPSBAd3JhcEluQnJhY2VzIGNvZGVcbiAgICAgICAgICAjIEZsYWcgdGhlIGB7YCBhbmQgYH1gIGZyYWdtZW50cyBhcyBoYXZpbmcgYmVlbiBnZW5lcmF0ZWQgYnkgdGhpc1xuICAgICAgICAgICMgYFN0cmluZ1dpdGhJbnRlcnBvbGF0aW9uc2Agbm9kZSwgc28gdGhhdCBgY29tcGlsZUNvbW1lbnRzYCBrbm93c1xuICAgICAgICAgICMgdG8gdHJlYXQgdGhlbSBhcyBib3VuZHMuIEJ1dCB0aGUgYnJhY2VzIGFyZSB1bm5lY2Vzc2FyeSBpZiBhbGwgb2ZcbiAgICAgICAgICAjIHRoZSBlbmNsb3NlZCBjb21tZW50cyBhcmUgYC8qICovYCBjb21tZW50cy4gRG9u4oCZdCB0cnVzdFxuICAgICAgICAgICMgYGZyYWdtZW50LnR5cGVgLCB3aGljaCBjYW4gcmVwb3J0IG1pbmlmaWVkIHZhcmlhYmxlIG5hbWVzIHdoZW5cbiAgICAgICAgICAjIHRoaXMgY29tcGlsZXIgaXMgbWluaWZpZWQuXG4gICAgICAgICAgY29kZVswXS5pc1N0cmluZ1dpdGhJbnRlcnBvbGF0aW9ucyA9IHllc1xuICAgICAgICAgIGNvZGVbY29kZS5sZW5ndGggLSAxXS5pc1N0cmluZ1dpdGhJbnRlcnBvbGF0aW9ucyA9IHllc1xuICAgICAgICBmcmFnbWVudHMucHVzaCBjb2RlLi4uXG4gICAgZnJhZ21lbnRzLnB1c2ggQG1ha2VDb2RlICdgJyB1bmxlc3MgQGpzeFxuICAgIGZyYWdtZW50c1xuXG4gIGlzTmVzdGVkVGFnOiAoZWxlbWVudCkgLT5cbiAgICBjYWxsID0gZWxlbWVudC51bndyYXBBbGw/KClcbiAgICBAanN4IGFuZCBjYWxsIGluc3RhbmNlb2YgSlNYRWxlbWVudFxuXG4gIGFzdFR5cGU6IC0+ICdUZW1wbGF0ZUxpdGVyYWwnXG5cbiAgYXN0UHJvcGVydGllczogKG8pIC0+XG4gICAgZWxlbWVudHMgPSBAZXh0cmFjdEVsZW1lbnRzIG8sIGluY2x1ZGVJbnRlcnBvbGF0aW9uV3JhcHBlcnM6IHllc1xuICAgIFsuLi4sIGxhc3RdID0gZWxlbWVudHNcblxuICAgIHF1YXNpcyA9IFtdXG4gICAgZXhwcmVzc2lvbnMgPSBbXVxuXG4gICAgZm9yIGVsZW1lbnQsIGluZGV4IGluIGVsZW1lbnRzXG4gICAgICBpZiBlbGVtZW50IGluc3RhbmNlb2YgU3RyaW5nTGl0ZXJhbFxuICAgICAgICBxdWFzaXMucHVzaCBuZXcgVGVtcGxhdGVFbGVtZW50KFxuICAgICAgICAgIGVsZW1lbnQub3JpZ2luYWxWYWx1ZVxuICAgICAgICAgIHRhaWw6IGVsZW1lbnQgaXMgbGFzdFxuICAgICAgICApLndpdGhMb2NhdGlvbkRhdGFGcm9tKGVsZW1lbnQpLmFzdCBvXG4gICAgICBlbHNlICMgSW50ZXJwb2xhdGlvblxuICAgICAgICB7ZXhwcmVzc2lvbn0gPSBlbGVtZW50XG4gICAgICAgIG5vZGUgPVxuICAgICAgICAgIHVubGVzcyBleHByZXNzaW9uP1xuICAgICAgICAgICAgZW1wdHlJbnRlcnBvbGF0aW9uID0gbmV3IEVtcHR5SW50ZXJwb2xhdGlvbigpXG4gICAgICAgICAgICBlbXB0eUludGVycG9sYXRpb24ubG9jYXRpb25EYXRhID0gZW1wdHlFeHByZXNzaW9uTG9jYXRpb25EYXRhIHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbk5vZGU6IGVsZW1lbnRcbiAgICAgICAgICAgICAgb3BlbmluZ0JyYWNlOiAnI3snXG4gICAgICAgICAgICAgIGNsb3NpbmdCcmFjZTogJ30nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbXB0eUludGVycG9sYXRpb25cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBleHByZXNzaW9uLnVud3JhcEFsbCgpXG4gICAgICAgIGV4cHJlc3Npb25zLnB1c2ggYXN0QXNCbG9ja0lmTmVlZGVkIG5vZGUsIG9cblxuICAgIHtleHByZXNzaW9ucywgcXVhc2lzLCBAcXVvdGV9XG5cbmV4cG9ydHMuVGVtcGxhdGVFbGVtZW50ID0gY2xhc3MgVGVtcGxhdGVFbGVtZW50IGV4dGVuZHMgQmFzZVxuICBjb25zdHJ1Y3RvcjogKEB2YWx1ZSwge0B0YWlsfSA9IHt9KSAtPlxuICAgIHN1cGVyKClcblxuICBhc3RQcm9wZXJ0aWVzOiAtPlxuICAgIHJldHVyblxuICAgICAgdmFsdWU6XG4gICAgICAgIHJhdzogQHZhbHVlXG4gICAgICB0YWlsOiAhIUB0YWlsXG5cbmV4cG9ydHMuSW50ZXJwb2xhdGlvbiA9IGNsYXNzIEludGVycG9sYXRpb24gZXh0ZW5kcyBCYXNlXG4gIGNvbnN0cnVjdG9yOiAoQGV4cHJlc3Npb24pIC0+XG4gICAgc3VwZXIoKVxuXG4gIGNoaWxkcmVuOiBbJ2V4cHJlc3Npb24nXVxuXG4jIFJlcHJlc2VudHMgdGhlIGNvbnRlbnRzIG9mIGFuIGVtcHR5IGludGVycG9sYXRpb24gKGUuZy4gYCN7fWApLlxuIyBPbmx5IHVzZWQgZHVyaW5nIEFTVCBnZW5lcmF0aW9uLlxuZXhwb3J0cy5FbXB0eUludGVycG9sYXRpb24gPSBjbGFzcyBFbXB0eUludGVycG9sYXRpb24gZXh0ZW5kcyBCYXNlXG4gIGNvbnN0cnVjdG9yOiAtPlxuICAgIHN1cGVyKClcblxuIyMjIyBGb3JcblxuIyBDb2ZmZWVTY3JpcHQncyByZXBsYWNlbWVudCBmb3IgdGhlICpmb3IqIGxvb3AgaXMgb3VyIGFycmF5IGFuZCBvYmplY3RcbiMgY29tcHJlaGVuc2lvbnMsIHRoYXQgY29tcGlsZSBpbnRvICpmb3IqIGxvb3BzIGhlcmUuIFRoZXkgYWxzbyBhY3QgYXMgYW5cbiMgZXhwcmVzc2lvbiwgYWJsZSB0byByZXR1cm4gdGhlIHJlc3VsdCBvZiBlYWNoIGZpbHRlcmVkIGl0ZXJhdGlvbi5cbiNcbiMgVW5saWtlIFB5dGhvbiBhcnJheSBjb21wcmVoZW5zaW9ucywgdGhleSBjYW4gYmUgbXVsdGktbGluZSwgYW5kIHlvdSBjYW4gcGFzc1xuIyB0aGUgY3VycmVudCBpbmRleCBvZiB0aGUgbG9vcCBhcyBhIHNlY29uZCBwYXJhbWV0ZXIuIFVubGlrZSBSdWJ5IGJsb2NrcyxcbiMgeW91IGNhbiBtYXAgYW5kIGZpbHRlciBpbiBhIHNpbmdsZSBwYXNzLlxuZXhwb3J0cy5Gb3IgPSBjbGFzcyBGb3IgZXh0ZW5kcyBXaGlsZVxuICBjb25zdHJ1Y3RvcjogKGJvZHksIHNvdXJjZSkgLT5cbiAgICBzdXBlcigpXG4gICAgQGFkZEJvZHkgYm9keVxuICAgIEBhZGRTb3VyY2Ugc291cmNlXG5cbiAgY2hpbGRyZW46IFsnYm9keScsICdzb3VyY2UnLCAnZ3VhcmQnLCAnc3RlcCddXG5cbiAgaXNBd2FpdDogLT4gQGF3YWl0ID8gbm9cblxuICBhZGRCb2R5OiAoYm9keSkgLT5cbiAgICBAYm9keSA9IEJsb2NrLndyYXAgW2JvZHldXG4gICAge2V4cHJlc3Npb25zfSA9IEBib2R5XG4gICAgaWYgZXhwcmVzc2lvbnMubGVuZ3RoXG4gICAgICBAYm9keS5sb2NhdGlvbkRhdGEgPz0gbWVyZ2VMb2NhdGlvbkRhdGEgZXhwcmVzc2lvbnNbMF0ubG9jYXRpb25EYXRhLCBleHByZXNzaW9uc1tleHByZXNzaW9ucy5sZW5ndGggLSAxXS5sb2NhdGlvbkRhdGFcbiAgICB0aGlzXG5cbiAgYWRkU291cmNlOiAoc291cmNlKSAtPlxuICAgIHtAc291cmNlICA9IG5vfSA9IHNvdXJjZVxuICAgIGF0dHJpYnMgICA9IFtcIm5hbWVcIiwgXCJpbmRleFwiLCBcImd1YXJkXCIsIFwic3RlcFwiLCBcIm93blwiLCBcIm93blRhZ1wiLCBcImF3YWl0XCIsIFwiYXdhaXRUYWdcIiwgXCJvYmplY3RcIiwgXCJmcm9tXCJdXG4gICAgQFthdHRyXSAgID0gc291cmNlW2F0dHJdID8gQFthdHRyXSBmb3IgYXR0ciBpbiBhdHRyaWJzXG4gICAgcmV0dXJuIHRoaXMgdW5sZXNzIEBzb3VyY2VcbiAgICBAaW5kZXguZXJyb3IgJ2Nhbm5vdCB1c2UgaW5kZXggd2l0aCBmb3ItZnJvbScgaWYgQGZyb20gYW5kIEBpbmRleFxuICAgIEBvd25UYWcuZXJyb3IgXCJjYW5ub3QgdXNlIG93biB3aXRoIGZvci0je2lmIEBmcm9tIHRoZW4gJ2Zyb20nIGVsc2UgJ2luJ31cIiBpZiBAb3duIGFuZCBub3QgQG9iamVjdFxuICAgIFtAbmFtZSwgQGluZGV4XSA9IFtAaW5kZXgsIEBuYW1lXSBpZiBAb2JqZWN0XG4gICAgQGluZGV4LmVycm9yICdpbmRleCBjYW5ub3QgYmUgYSBwYXR0ZXJuIG1hdGNoaW5nIGV4cHJlc3Npb24nIGlmIEBpbmRleD8uaXNBcnJheT8oKSBvciBAaW5kZXg/LmlzT2JqZWN0PygpXG4gICAgQGF3YWl0VGFnLmVycm9yICdhd2FpdCBtdXN0IGJlIHVzZWQgd2l0aCBmb3ItZnJvbScgaWYgQGF3YWl0IGFuZCBub3QgQGZyb21cbiAgICBAcmFuZ2UgICA9IEBzb3VyY2UgaW5zdGFuY2VvZiBWYWx1ZSBhbmQgQHNvdXJjZS5iYXNlIGluc3RhbmNlb2YgUmFuZ2UgYW5kIG5vdCBAc291cmNlLnByb3BlcnRpZXMubGVuZ3RoIGFuZCBub3QgQGZyb21cbiAgICBAcGF0dGVybiA9IEBuYW1lIGluc3RhbmNlb2YgVmFsdWVcbiAgICBAbmFtZS51bndyYXAoKS5wcm9wYWdhdGVMaHM/KHllcykgaWYgQHBhdHRlcm5cbiAgICBAaW5kZXguZXJyb3IgJ2luZGV4ZXMgZG8gbm90IGFwcGx5IHRvIHJhbmdlIGxvb3BzJyBpZiBAcmFuZ2UgYW5kIEBpbmRleFxuICAgIEBuYW1lLmVycm9yICdjYW5ub3QgcGF0dGVybiBtYXRjaCBvdmVyIHJhbmdlIGxvb3BzJyBpZiBAcmFuZ2UgYW5kIEBwYXR0ZXJuXG4gICAgQHJldHVybnMgPSBub1xuICAgICMgTW92ZSB1cCBhbnkgY29tbWVudHMgaW4gdGhlIOKAnGBmb3JgIGxpbmXigJ0sIGkuZS4gdGhlIGxpbmUgb2YgY29kZSB3aXRoIGBmb3JgLFxuICAgICMgZnJvbSBhbnkgY2hpbGQgbm9kZXMgb2YgdGhhdCBsaW5lIHVwIHRvIHRoZSBgZm9yYCBub2RlIGl0c2VsZiBzbyB0aGF0IHRoZXNlXG4gICAgIyBjb21tZW50cyBnZXQgb3V0cHV0LCBhbmQgZ2V0IG91dHB1dCBhYm92ZSB0aGUgYGZvcmAgbG9vcC5cbiAgICBmb3IgYXR0cmlidXRlIGluIFsnc291cmNlJywgJ2d1YXJkJywgJ3N0ZXAnLCAnbmFtZScsICdpbmRleCddIHdoZW4gQFthdHRyaWJ1dGVdXG4gICAgICBAW2F0dHJpYnV0ZV0udHJhdmVyc2VDaGlsZHJlbiB5ZXMsIChub2RlKSA9PlxuICAgICAgICBpZiBub2RlLmNvbW1lbnRzXG4gICAgICAgICAgIyBUaGVzZSBjb21tZW50cyBhcmUgYnVyaWVkIHByZXR0eSBkZWVwbHksIHNvIGlmIHRoZXkgaGFwcGVuIHRvIGJlXG4gICAgICAgICAgIyB0cmFpbGluZyBjb21tZW50cyB0aGUgbGluZSB0aGV5IHRyYWlsIHdpbGwgYmUgdW5yZWNvZ25pemFibGUgd2hlblxuICAgICAgICAgICMgd2XigJlyZSBkb25lIGNvbXBpbGluZyB0aGlzIGBmb3JgIGxvb3A7IHNvIGp1c3Qgc2hpZnQgdGhlbSB1cCB0b1xuICAgICAgICAgICMgb3V0cHV0IGFib3ZlIHRoZSBgZm9yYCBsaW5lLlxuICAgICAgICAgIGNvbW1lbnQubmV3TGluZSA9IGNvbW1lbnQudW5zaGlmdCA9IHllcyBmb3IgY29tbWVudCBpbiBub2RlLmNvbW1lbnRzXG4gICAgICAgICAgbW92ZUNvbW1lbnRzIG5vZGUsIEBbYXR0cmlidXRlXVxuICAgICAgbW92ZUNvbW1lbnRzIEBbYXR0cmlidXRlXSwgQFxuICAgIHRoaXNcblxuICAjIFdlbGNvbWUgdG8gdGhlIGhhaXJpZXN0IG1ldGhvZCBpbiBhbGwgb2YgQ29mZmVlU2NyaXB0LiBIYW5kbGVzIHRoZSBpbm5lclxuICAjIGxvb3AsIGZpbHRlcmluZywgc3RlcHBpbmcsIGFuZCByZXN1bHQgc2F2aW5nIGZvciBhcnJheSwgb2JqZWN0LCBhbmQgcmFuZ2VcbiAgIyBjb21wcmVoZW5zaW9ucy4gU29tZSBvZiB0aGUgZ2VuZXJhdGVkIGNvZGUgY2FuIGJlIHNoYXJlZCBpbiBjb21tb24sIGFuZFxuICAjIHNvbWUgY2Fubm90LlxuICBjb21waWxlTm9kZTogKG8pIC0+XG4gICAgYm9keSAgICAgICAgPSBCbG9jay53cmFwIFtAYm9keV1cbiAgICBbLi4uLCBsYXN0XSA9IGJvZHkuZXhwcmVzc2lvbnNcbiAgICBAcmV0dXJucyAgICA9IG5vIGlmIGxhc3Q/Lmp1bXBzKCkgaW5zdGFuY2VvZiBSZXR1cm5cbiAgICBzb3VyY2UgICAgICA9IGlmIEByYW5nZSB0aGVuIEBzb3VyY2UuYmFzZSBlbHNlIEBzb3VyY2VcbiAgICBzY29wZSAgICAgICA9IG8uc2NvcGVcbiAgICBuYW1lICAgICAgICA9IEBuYW1lICBhbmQgKEBuYW1lLmNvbXBpbGUgbywgTEVWRUxfTElTVCkgaWYgbm90IEBwYXR0ZXJuXG4gICAgaW5kZXggICAgICAgPSBAaW5kZXggYW5kIChAaW5kZXguY29tcGlsZSBvLCBMRVZFTF9MSVNUKVxuICAgIHNjb3BlLmZpbmQobmFtZSkgIGlmIG5hbWUgYW5kIG5vdCBAcGF0dGVyblxuICAgIHNjb3BlLmZpbmQoaW5kZXgpIGlmIGluZGV4IGFuZCBAaW5kZXggbm90IGluc3RhbmNlb2YgVmFsdWVcbiAgICBydmFyICAgICAgICA9IHNjb3BlLmZyZWVWYXJpYWJsZSAncmVzdWx0cycgaWYgQHJldHVybnNcbiAgICBpZiBAZnJvbVxuICAgICAgaXZhciA9IHNjb3BlLmZyZWVWYXJpYWJsZSAneCcsIHNpbmdsZTogdHJ1ZSBpZiBAcGF0dGVyblxuICAgIGVsc2VcbiAgICAgIGl2YXIgPSAoQG9iamVjdCBhbmQgaW5kZXgpIG9yIHNjb3BlLmZyZWVWYXJpYWJsZSAnaScsIHNpbmdsZTogdHJ1ZVxuICAgIGt2YXIgICAgICAgID0gKChAcmFuZ2Ugb3IgQGZyb20pIGFuZCBuYW1lKSBvciBpbmRleCBvciBpdmFyXG4gICAga3ZhckFzc2lnbiAgPSBpZiBrdmFyIGlzbnQgaXZhciB0aGVuIFwiI3trdmFyfSA9IFwiIGVsc2UgXCJcIlxuICAgIGlmIEBzdGVwIGFuZCBub3QgQHJhbmdlXG4gICAgICBbc3RlcCwgc3RlcFZhcl0gPSBAY2FjaGVUb0NvZGVGcmFnbWVudHMgQHN0ZXAuY2FjaGUgbywgTEVWRUxfTElTVCwgc2hvdWxkQ2FjaGVPcklzQXNzaWduYWJsZVxuICAgICAgc3RlcE51bSAgID0gcGFyc2VOdW1iZXIgc3RlcFZhciBpZiBAc3RlcC5pc051bWJlcigpXG4gICAgbmFtZSAgICAgICAgPSBpdmFyIGlmIEBwYXR0ZXJuXG4gICAgdmFyUGFydCAgICAgPSAnJ1xuICAgIGd1YXJkUGFydCAgID0gJydcbiAgICBkZWZQYXJ0ICAgICA9ICcnXG4gICAgaWR0MSAgICAgICAgPSBAdGFiICsgVEFCXG4gICAgaWYgQHJhbmdlXG4gICAgICBmb3JQYXJ0RnJhZ21lbnRzID0gc291cmNlLmNvbXBpbGVUb0ZyYWdtZW50cyBtZXJnZSBvLFxuICAgICAgICB7aW5kZXg6IGl2YXIsIG5hbWUsIEBzdGVwLCBzaG91bGRDYWNoZTogc2hvdWxkQ2FjaGVPcklzQXNzaWduYWJsZX1cbiAgICBlbHNlXG4gICAgICBzdmFyICAgID0gQHNvdXJjZS5jb21waWxlIG8sIExFVkVMX0xJU1RcbiAgICAgIGlmIChuYW1lIG9yIEBvd24pIGFuZCBub3QgQGZyb20gYW5kIEBzb3VyY2UudW53cmFwKCkgbm90IGluc3RhbmNlb2YgSWRlbnRpZmllckxpdGVyYWxcbiAgICAgICAgZGVmUGFydCAgICArPSBcIiN7QHRhYn0je3JlZiA9IHNjb3BlLmZyZWVWYXJpYWJsZSAncmVmJ30gPSAje3N2YXJ9O1xcblwiXG4gICAgICAgIHN2YXIgICAgICAgPSByZWZcbiAgICAgIGlmIG5hbWUgYW5kIG5vdCBAcGF0dGVybiBhbmQgbm90IEBmcm9tXG4gICAgICAgIG5hbWVQYXJ0ICAgPSBcIiN7bmFtZX0gPSAje3N2YXJ9WyN7a3Zhcn1dXCJcbiAgICAgIGlmIG5vdCBAb2JqZWN0IGFuZCBub3QgQGZyb21cbiAgICAgICAgZGVmUGFydCArPSBcIiN7QHRhYn0je3N0ZXB9O1xcblwiIGlmIHN0ZXAgaXNudCBzdGVwVmFyXG4gICAgICAgIGRvd24gPSBzdGVwTnVtIDwgMFxuICAgICAgICBsdmFyID0gc2NvcGUuZnJlZVZhcmlhYmxlICdsZW4nIHVubGVzcyBAc3RlcCBhbmQgc3RlcE51bT8gYW5kIGRvd25cbiAgICAgICAgZGVjbGFyZSA9IFwiI3trdmFyQXNzaWdufSN7aXZhcn0gPSAwLCAje2x2YXJ9ID0gI3tzdmFyfS5sZW5ndGhcIlxuICAgICAgICBkZWNsYXJlRG93biA9IFwiI3trdmFyQXNzaWdufSN7aXZhcn0gPSAje3N2YXJ9Lmxlbmd0aCAtIDFcIlxuICAgICAgICBjb21wYXJlID0gXCIje2l2YXJ9IDwgI3tsdmFyfVwiXG4gICAgICAgIGNvbXBhcmVEb3duID0gXCIje2l2YXJ9ID49IDBcIlxuICAgICAgICBpZiBAc3RlcFxuICAgICAgICAgIGlmIHN0ZXBOdW0/XG4gICAgICAgICAgICBpZiBkb3duXG4gICAgICAgICAgICAgIGNvbXBhcmUgPSBjb21wYXJlRG93blxuICAgICAgICAgICAgICBkZWNsYXJlID0gZGVjbGFyZURvd25cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb21wYXJlID0gXCIje3N0ZXBWYXJ9ID4gMCA/ICN7Y29tcGFyZX0gOiAje2NvbXBhcmVEb3dufVwiXG4gICAgICAgICAgICBkZWNsYXJlID0gXCIoI3tzdGVwVmFyfSA+IDAgPyAoI3tkZWNsYXJlfSkgOiAje2RlY2xhcmVEb3dufSlcIlxuICAgICAgICAgIGluY3JlbWVudCA9IFwiI3tpdmFyfSArPSAje3N0ZXBWYXJ9XCJcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGluY3JlbWVudCA9IFwiI3tpZiBrdmFyIGlzbnQgaXZhciB0aGVuIFwiKysje2l2YXJ9XCIgZWxzZSBcIiN7aXZhcn0rK1wifVwiXG4gICAgICAgIGZvclBhcnRGcmFnbWVudHMgPSBbQG1ha2VDb2RlKFwiI3tkZWNsYXJlfTsgI3tjb21wYXJlfTsgI3trdmFyQXNzaWdufSN7aW5jcmVtZW50fVwiKV1cbiAgICBpZiBAcmV0dXJuc1xuICAgICAgcmVzdWx0UGFydCAgID0gXCIje0B0YWJ9I3tydmFyfSA9IFtdO1xcblwiXG4gICAgICByZXR1cm5SZXN1bHQgPSBcIlxcbiN7QHRhYn1yZXR1cm4gI3tydmFyfTtcIlxuICAgICAgYm9keS5tYWtlUmV0dXJuIHJ2YXJcbiAgICBpZiBAZ3VhcmRcbiAgICAgIGlmIGJvZHkuZXhwcmVzc2lvbnMubGVuZ3RoID4gMVxuICAgICAgICBib2R5LmV4cHJlc3Npb25zLnVuc2hpZnQgbmV3IElmIChuZXcgUGFyZW5zIEBndWFyZCkuaW52ZXJ0KCksIG5ldyBTdGF0ZW1lbnRMaXRlcmFsIFwiY29udGludWVcIlxuICAgICAgZWxzZVxuICAgICAgICBib2R5ID0gQmxvY2sud3JhcCBbbmV3IElmIEBndWFyZCwgYm9keV0gaWYgQGd1YXJkXG4gICAgaWYgQHBhdHRlcm5cbiAgICAgIGJvZHkuZXhwcmVzc2lvbnMudW5zaGlmdCBuZXcgQXNzaWduIEBuYW1lLCBpZiBAZnJvbSB0aGVuIG5ldyBJZGVudGlmaWVyTGl0ZXJhbCBrdmFyIGVsc2UgbmV3IExpdGVyYWwgXCIje3N2YXJ9WyN7a3Zhcn1dXCJcblxuICAgIHZhclBhcnQgPSBcIlxcbiN7aWR0MX0je25hbWVQYXJ0fTtcIiBpZiBuYW1lUGFydFxuICAgIGlmIEBvYmplY3RcbiAgICAgIGZvclBhcnRGcmFnbWVudHMgPSBbQG1ha2VDb2RlKFwiI3trdmFyfSBpbiAje3N2YXJ9XCIpXVxuICAgICAgZ3VhcmRQYXJ0ID0gXCJcXG4je2lkdDF9aWYgKCEje3V0aWxpdHkgJ2hhc1Byb3AnLCBvfS5jYWxsKCN7c3Zhcn0sICN7a3Zhcn0pKSBjb250aW51ZTtcIiBpZiBAb3duXG4gICAgZWxzZSBpZiBAZnJvbVxuICAgICAgaWYgQGF3YWl0XG4gICAgICAgIGZvclBhcnRGcmFnbWVudHMgPSBuZXcgT3AgJ2F3YWl0JywgbmV3IFBhcmVucyBuZXcgTGl0ZXJhbCBcIiN7a3Zhcn0gb2YgI3tzdmFyfVwiXG4gICAgICAgIGZvclBhcnRGcmFnbWVudHMgPSBmb3JQYXJ0RnJhZ21lbnRzLmNvbXBpbGVUb0ZyYWdtZW50cyBvLCBMRVZFTF9UT1BcbiAgICAgIGVsc2VcbiAgICAgICAgZm9yUGFydEZyYWdtZW50cyA9IFtAbWFrZUNvZGUoXCIje2t2YXJ9IG9mICN7c3Zhcn1cIildXG4gICAgYm9keUZyYWdtZW50cyA9IGJvZHkuY29tcGlsZVRvRnJhZ21lbnRzIG1lcmdlKG8sIGluZGVudDogaWR0MSksIExFVkVMX1RPUFxuICAgIGlmIGJvZHlGcmFnbWVudHMgYW5kIGJvZHlGcmFnbWVudHMubGVuZ3RoID4gMFxuICAgICAgYm9keUZyYWdtZW50cyA9IFtdLmNvbmNhdCBAbWFrZUNvZGUoJ1xcbicpLCBib2R5RnJhZ21lbnRzLCBAbWFrZUNvZGUoJ1xcbicpXG5cbiAgICBmcmFnbWVudHMgPSBbQG1ha2VDb2RlKGRlZlBhcnQpXVxuICAgIGZyYWdtZW50cy5wdXNoIEBtYWtlQ29kZShyZXN1bHRQYXJ0KSBpZiByZXN1bHRQYXJ0XG4gICAgZm9yQ29kZSA9IGlmIEBhd2FpdCB0aGVuICdmb3IgJyBlbHNlICdmb3IgKCdcbiAgICBmb3JDbG9zZSA9IGlmIEBhd2FpdCB0aGVuICcnIGVsc2UgJyknXG4gICAgZnJhZ21lbnRzID0gZnJhZ21lbnRzLmNvbmNhdCBAbWFrZUNvZGUoQHRhYiksIEBtYWtlQ29kZSggZm9yQ29kZSksXG4gICAgICBmb3JQYXJ0RnJhZ21lbnRzLCBAbWFrZUNvZGUoXCIje2ZvckNsb3NlfSB7I3tndWFyZFBhcnR9I3t2YXJQYXJ0fVwiKSwgYm9keUZyYWdtZW50cyxcbiAgICAgIEBtYWtlQ29kZShAdGFiKSwgQG1ha2VDb2RlKCd9JylcbiAgICBmcmFnbWVudHMucHVzaCBAbWFrZUNvZGUocmV0dXJuUmVzdWx0KSBpZiByZXR1cm5SZXN1bHRcbiAgICBmcmFnbWVudHNcblxuICBhc3ROb2RlOiAobykgLT5cbiAgICBhZGRUb1Njb3BlID0gKG5hbWUpIC0+XG4gICAgICBhbHJlYWR5RGVjbGFyZWQgPSBvLnNjb3BlLmZpbmQgbmFtZS52YWx1ZVxuICAgICAgbmFtZS5pc0RlY2xhcmF0aW9uID0gbm90IGFscmVhZHlEZWNsYXJlZFxuICAgIEBuYW1lPy5lYWNoTmFtZSBhZGRUb1Njb3BlLCBjaGVja0Fzc2lnbmFiaWxpdHk6IG5vXG4gICAgQGluZGV4Py5lYWNoTmFtZSBhZGRUb1Njb3BlLCBjaGVja0Fzc2lnbmFiaWxpdHk6IG5vXG4gICAgc3VwZXIgb1xuXG4gIGFzdFR5cGU6IC0+ICdGb3InXG5cbiAgYXN0UHJvcGVydGllczogKG8pIC0+XG4gICAgcmV0dXJuXG4gICAgICBzb3VyY2U6IEBzb3VyY2U/LmFzdCBvXG4gICAgICBib2R5OiBAYm9keS5hc3QgbywgTEVWRUxfVE9QXG4gICAgICBndWFyZDogQGd1YXJkPy5hc3QobykgPyBudWxsXG4gICAgICBuYW1lOiBAbmFtZT8uYXN0KG8pID8gbnVsbFxuICAgICAgaW5kZXg6IEBpbmRleD8uYXN0KG8pID8gbnVsbFxuICAgICAgc3RlcDogQHN0ZXA/LmFzdChvKSA/IG51bGxcbiAgICAgIHBvc3RmaXg6ICEhQHBvc3RmaXhcbiAgICAgIG93bjogISFAb3duXG4gICAgICBhd2FpdDogISFAYXdhaXRcbiAgICAgIHN0eWxlOiBzd2l0Y2hcbiAgICAgICAgd2hlbiBAZnJvbSAgIHRoZW4gJ2Zyb20nXG4gICAgICAgIHdoZW4gQG9iamVjdCB0aGVuICdvZidcbiAgICAgICAgd2hlbiBAbmFtZSAgIHRoZW4gJ2luJ1xuICAgICAgICBlbHNlICAgICAgICAgICAgICAncmFuZ2UnXG5cbiMjIyMgU3dpdGNoXG5cbiMgQSBKYXZhU2NyaXB0ICpzd2l0Y2gqIHN0YXRlbWVudC4gQ29udmVydHMgaW50byBhIHJldHVybmFibGUgZXhwcmVzc2lvbiBvbi1kZW1hbmQuXG5leHBvcnRzLlN3aXRjaCA9IGNsYXNzIFN3aXRjaCBleHRlbmRzIEJhc2VcbiAgY29uc3RydWN0b3I6IChAc3ViamVjdCwgQGNhc2VzLCBAb3RoZXJ3aXNlKSAtPlxuICAgIHN1cGVyKClcblxuICBjaGlsZHJlbjogWydzdWJqZWN0JywgJ2Nhc2VzJywgJ290aGVyd2lzZSddXG5cbiAgaXNTdGF0ZW1lbnQ6IFlFU1xuXG4gIGp1bXBzOiAobyA9IHtibG9jazogeWVzfSkgLT5cbiAgICBmb3Ige2Jsb2NrfSBpbiBAY2FzZXNcbiAgICAgIHJldHVybiBqdW1wTm9kZSBpZiBqdW1wTm9kZSA9IGJsb2NrLmp1bXBzIG9cbiAgICBAb3RoZXJ3aXNlPy5qdW1wcyBvXG5cbiAgbWFrZVJldHVybjogKHJlc3VsdHMsIG1hcmspIC0+XG4gICAgYmxvY2subWFrZVJldHVybihyZXN1bHRzLCBtYXJrKSBmb3Ige2Jsb2NrfSBpbiBAY2FzZXNcbiAgICBAb3RoZXJ3aXNlIG9yPSBuZXcgQmxvY2sgW25ldyBMaXRlcmFsICd2b2lkIDAnXSBpZiByZXN1bHRzXG4gICAgQG90aGVyd2lzZT8ubWFrZVJldHVybiByZXN1bHRzLCBtYXJrXG4gICAgdGhpc1xuXG4gIGNvbXBpbGVOb2RlOiAobykgLT5cbiAgICBpZHQxID0gby5pbmRlbnQgKyBUQUJcbiAgICBpZHQyID0gby5pbmRlbnQgPSBpZHQxICsgVEFCXG4gICAgZnJhZ21lbnRzID0gW10uY29uY2F0IEBtYWtlQ29kZShAdGFiICsgXCJzd2l0Y2ggKFwiKSxcbiAgICAgIChpZiBAc3ViamVjdCB0aGVuIEBzdWJqZWN0LmNvbXBpbGVUb0ZyYWdtZW50cyhvLCBMRVZFTF9QQVJFTikgZWxzZSBAbWFrZUNvZGUgXCJmYWxzZVwiKSxcbiAgICAgIEBtYWtlQ29kZShcIikge1xcblwiKVxuICAgIGZvciB7Y29uZGl0aW9ucywgYmxvY2t9LCBpIGluIEBjYXNlc1xuICAgICAgZm9yIGNvbmQgaW4gZmxhdHRlbiBbY29uZGl0aW9uc11cbiAgICAgICAgY29uZCAgPSBjb25kLmludmVydCgpIHVubGVzcyBAc3ViamVjdFxuICAgICAgICBmcmFnbWVudHMgPSBmcmFnbWVudHMuY29uY2F0IEBtYWtlQ29kZShpZHQxICsgXCJjYXNlIFwiKSwgY29uZC5jb21waWxlVG9GcmFnbWVudHMobywgTEVWRUxfUEFSRU4pLCBAbWFrZUNvZGUoXCI6XFxuXCIpXG4gICAgICBmcmFnbWVudHMgPSBmcmFnbWVudHMuY29uY2F0IGJvZHksIEBtYWtlQ29kZSgnXFxuJykgaWYgKGJvZHkgPSBibG9jay5jb21waWxlVG9GcmFnbWVudHMgbywgTEVWRUxfVE9QKS5sZW5ndGggPiAwXG4gICAgICBicmVhayBpZiBpIGlzIEBjYXNlcy5sZW5ndGggLSAxIGFuZCBub3QgQG90aGVyd2lzZVxuICAgICAgZXhwciA9IEBsYXN0Tm9kZSBibG9jay5leHByZXNzaW9uc1xuICAgICAgY29udGludWUgaWYgZXhwciBpbnN0YW5jZW9mIFJldHVybiBvciBleHByIGluc3RhbmNlb2YgVGhyb3cgb3IgKGV4cHIgaW5zdGFuY2VvZiBMaXRlcmFsIGFuZCBleHByLmp1bXBzKCkgYW5kIGV4cHIudmFsdWUgaXNudCAnZGVidWdnZXInKVxuICAgICAgZnJhZ21lbnRzLnB1c2ggY29uZC5tYWtlQ29kZShpZHQyICsgJ2JyZWFrO1xcbicpXG4gICAgaWYgQG90aGVyd2lzZSBhbmQgQG90aGVyd2lzZS5leHByZXNzaW9ucy5sZW5ndGhcbiAgICAgIGZyYWdtZW50cy5wdXNoIEBtYWtlQ29kZShpZHQxICsgXCJkZWZhdWx0OlxcblwiKSwgKEBvdGhlcndpc2UuY29tcGlsZVRvRnJhZ21lbnRzIG8sIExFVkVMX1RPUCkuLi4sIEBtYWtlQ29kZShcIlxcblwiKVxuICAgIGZyYWdtZW50cy5wdXNoIEBtYWtlQ29kZSBAdGFiICsgJ30nXG4gICAgZnJhZ21lbnRzXG5cbiAgYXN0VHlwZTogLT4gJ1N3aXRjaFN0YXRlbWVudCdcblxuICBjYXNlc0FzdDogKG8pIC0+XG4gICAgY2FzZXMgPSBbXVxuXG4gICAgZm9yIGthc2UsIGNhc2VJbmRleCBpbiBAY2FzZXNcbiAgICAgIHtjb25kaXRpb25zOiB0ZXN0cywgYmxvY2s6IGNvbnNlcXVlbnR9ID0ga2FzZVxuICAgICAgdGVzdHMgPSBmbGF0dGVuIFt0ZXN0c11cbiAgICAgIGxhc3RUZXN0SW5kZXggPSB0ZXN0cy5sZW5ndGggLSAxXG4gICAgICBmb3IgdGVzdCwgdGVzdEluZGV4IGluIHRlc3RzXG4gICAgICAgIHRlc3RDb25zZXF1ZW50ID1cbiAgICAgICAgICBpZiB0ZXN0SW5kZXggaXMgbGFzdFRlc3RJbmRleFxuICAgICAgICAgICAgY29uc2VxdWVudFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG51bGxcblxuICAgICAgICBjYXNlTG9jYXRpb25EYXRhID0gdGVzdC5sb2NhdGlvbkRhdGFcbiAgICAgICAgY2FzZUxvY2F0aW9uRGF0YSA9IG1lcmdlTG9jYXRpb25EYXRhIGNhc2VMb2NhdGlvbkRhdGEsIHRlc3RDb25zZXF1ZW50LmV4cHJlc3Npb25zW3Rlc3RDb25zZXF1ZW50LmV4cHJlc3Npb25zLmxlbmd0aCAtIDFdLmxvY2F0aW9uRGF0YSBpZiB0ZXN0Q29uc2VxdWVudD8uZXhwcmVzc2lvbnMubGVuZ3RoXG4gICAgICAgIGNhc2VMb2NhdGlvbkRhdGEgPSBtZXJnZUxvY2F0aW9uRGF0YSBjYXNlTG9jYXRpb25EYXRhLCBrYXNlLmxvY2F0aW9uRGF0YSwganVzdExlYWRpbmc6IHllcyBpZiB0ZXN0SW5kZXggaXMgMFxuICAgICAgICBjYXNlTG9jYXRpb25EYXRhID0gbWVyZ2VMb2NhdGlvbkRhdGEgY2FzZUxvY2F0aW9uRGF0YSwga2FzZS5sb2NhdGlvbkRhdGEsIGp1c3RFbmRpbmc6ICB5ZXMgaWYgdGVzdEluZGV4IGlzIGxhc3RUZXN0SW5kZXhcblxuICAgICAgICBjYXNlcy5wdXNoIG5ldyBTd2l0Y2hDYXNlKHRlc3QsIHRlc3RDb25zZXF1ZW50LCB0cmFpbGluZzogdGVzdEluZGV4IGlzIGxhc3RUZXN0SW5kZXgpLndpdGhMb2NhdGlvbkRhdGFGcm9tIGxvY2F0aW9uRGF0YTogY2FzZUxvY2F0aW9uRGF0YVxuXG4gICAgaWYgQG90aGVyd2lzZT8uZXhwcmVzc2lvbnMubGVuZ3RoXG4gICAgICBjYXNlcy5wdXNoIG5ldyBTd2l0Y2hDYXNlKG51bGwsIEBvdGhlcndpc2UpLndpdGhMb2NhdGlvbkRhdGFGcm9tIEBvdGhlcndpc2VcblxuICAgIGthc2UuYXN0KG8pIGZvciBrYXNlIGluIGNhc2VzXG5cbiAgYXN0UHJvcGVydGllczogKG8pIC0+XG4gICAgcmV0dXJuXG4gICAgICBkaXNjcmltaW5hbnQ6IEBzdWJqZWN0Py5hc3QobywgTEVWRUxfUEFSRU4pID8gbnVsbFxuICAgICAgY2FzZXM6IEBjYXNlc0FzdCBvXG5cbmNsYXNzIFN3aXRjaENhc2UgZXh0ZW5kcyBCYXNlXG4gIGNvbnN0cnVjdG9yOiAoQHRlc3QsIEBibG9jaywge0B0cmFpbGluZ30gPSB7fSkgLT5cbiAgICBzdXBlcigpXG5cbiAgY2hpbGRyZW46IFsndGVzdCcsICdibG9jayddXG5cbiAgYXN0UHJvcGVydGllczogKG8pIC0+XG4gICAgcmV0dXJuXG4gICAgICB0ZXN0OiBAdGVzdD8uYXN0KG8sIExFVkVMX1BBUkVOKSA/IG51bGxcbiAgICAgIGNvbnNlcXVlbnQ6IEBibG9jaz8uYXN0KG8sIExFVkVMX1RPUCkuYm9keSA/IFtdXG4gICAgICB0cmFpbGluZzogISFAdHJhaWxpbmdcblxuZXhwb3J0cy5Td2l0Y2hXaGVuID0gY2xhc3MgU3dpdGNoV2hlbiBleHRlbmRzIEJhc2VcbiAgY29uc3RydWN0b3I6IChAY29uZGl0aW9ucywgQGJsb2NrKSAtPlxuICAgIHN1cGVyKClcblxuICBjaGlsZHJlbjogWydjb25kaXRpb25zJywgJ2Jsb2NrJ11cblxuIyMjIyBJZlxuXG4jICpJZi9lbHNlKiBzdGF0ZW1lbnRzLiBBY3RzIGFzIGFuIGV4cHJlc3Npb24gYnkgcHVzaGluZyBkb3duIHJlcXVlc3RlZCByZXR1cm5zXG4jIHRvIHRoZSBsYXN0IGxpbmUgb2YgZWFjaCBjbGF1c2UuXG4jXG4jIFNpbmdsZS1leHByZXNzaW9uICoqSWZzKiogYXJlIGNvbXBpbGVkIGludG8gY29uZGl0aW9uYWwgb3BlcmF0b3JzIGlmIHBvc3NpYmxlLFxuIyBiZWNhdXNlIHRlcm5hcmllcyBhcmUgYWxyZWFkeSBwcm9wZXIgZXhwcmVzc2lvbnMsIGFuZCBkb27igJl0IG5lZWQgY29udmVyc2lvbi5cbmV4cG9ydHMuSWYgPSBjbGFzcyBJZiBleHRlbmRzIEJhc2VcbiAgY29uc3RydWN0b3I6IChAY29uZGl0aW9uLCBAYm9keSwgb3B0aW9ucyA9IHt9KSAtPlxuICAgIHN1cGVyKClcbiAgICBAZWxzZUJvZHkgID0gbnVsbFxuICAgIEBpc0NoYWluICAgPSBmYWxzZVxuICAgIHtAc29haywgQHBvc3RmaXgsIEB0eXBlfSA9IG9wdGlvbnNcbiAgICBtb3ZlQ29tbWVudHMgQGNvbmRpdGlvbiwgQCBpZiBAY29uZGl0aW9uLmNvbW1lbnRzXG5cbiAgY2hpbGRyZW46IFsnY29uZGl0aW9uJywgJ2JvZHknLCAnZWxzZUJvZHknXVxuXG4gIGJvZHlOb2RlOiAgICAgLT4gQGJvZHk/LnVud3JhcCgpXG4gIGVsc2VCb2R5Tm9kZTogLT4gQGVsc2VCb2R5Py51bndyYXAoKVxuXG4gICMgUmV3cml0ZSBhIGNoYWluIG9mICoqSWZzKiogdG8gYWRkIGEgZGVmYXVsdCBjYXNlIGFzIHRoZSBmaW5hbCAqZWxzZSouXG4gIGFkZEVsc2U6IChlbHNlQm9keSkgLT5cbiAgICBpZiBAaXNDaGFpblxuICAgICAgQGVsc2VCb2R5Tm9kZSgpLmFkZEVsc2UgZWxzZUJvZHlcbiAgICAgIEBsb2NhdGlvbkRhdGEgPSBtZXJnZUxvY2F0aW9uRGF0YSBAbG9jYXRpb25EYXRhLCBAZWxzZUJvZHlOb2RlKCkubG9jYXRpb25EYXRhXG4gICAgZWxzZVxuICAgICAgQGlzQ2hhaW4gID0gZWxzZUJvZHkgaW5zdGFuY2VvZiBJZlxuICAgICAgQGVsc2VCb2R5ID0gQGVuc3VyZUJsb2NrIGVsc2VCb2R5XG4gICAgICBAZWxzZUJvZHkudXBkYXRlTG9jYXRpb25EYXRhSWZNaXNzaW5nIGVsc2VCb2R5LmxvY2F0aW9uRGF0YVxuICAgICAgQGxvY2F0aW9uRGF0YSA9IG1lcmdlTG9jYXRpb25EYXRhIEBsb2NhdGlvbkRhdGEsIEBlbHNlQm9keS5sb2NhdGlvbkRhdGEgaWYgQGxvY2F0aW9uRGF0YT8gYW5kIEBlbHNlQm9keS5sb2NhdGlvbkRhdGE/XG4gICAgdGhpc1xuXG4gICMgVGhlICoqSWYqKiBvbmx5IGNvbXBpbGVzIGludG8gYSBzdGF0ZW1lbnQgaWYgZWl0aGVyIG9mIGl0cyBib2RpZXMgbmVlZHNcbiAgIyB0byBiZSBhIHN0YXRlbWVudC4gT3RoZXJ3aXNlIGEgY29uZGl0aW9uYWwgb3BlcmF0b3IgaXMgc2FmZS5cbiAgaXNTdGF0ZW1lbnQ6IChvKSAtPlxuICAgIG8/LmxldmVsIGlzIExFVkVMX1RPUCBvclxuICAgICAgQGJvZHlOb2RlKCkuaXNTdGF0ZW1lbnQobykgb3IgQGVsc2VCb2R5Tm9kZSgpPy5pc1N0YXRlbWVudChvKVxuXG4gIGp1bXBzOiAobykgLT4gQGJvZHkuanVtcHMobykgb3IgQGVsc2VCb2R5Py5qdW1wcyhvKVxuXG4gIGNvbXBpbGVOb2RlOiAobykgLT5cbiAgICBpZiBAaXNTdGF0ZW1lbnQgbyB0aGVuIEBjb21waWxlU3RhdGVtZW50IG8gZWxzZSBAY29tcGlsZUV4cHJlc3Npb24gb1xuXG4gIG1ha2VSZXR1cm46IChyZXN1bHRzLCBtYXJrKSAtPlxuICAgIGlmIG1hcmtcbiAgICAgIEBib2R5Py5tYWtlUmV0dXJuIHJlc3VsdHMsIG1hcmtcbiAgICAgIEBlbHNlQm9keT8ubWFrZVJldHVybiByZXN1bHRzLCBtYXJrXG4gICAgICByZXR1cm5cbiAgICBAZWxzZUJvZHkgIG9yPSBuZXcgQmxvY2sgW25ldyBMaXRlcmFsICd2b2lkIDAnXSBpZiByZXN1bHRzXG4gICAgQGJvZHkgICAgIGFuZD0gbmV3IEJsb2NrIFtAYm9keS5tYWtlUmV0dXJuIHJlc3VsdHNdXG4gICAgQGVsc2VCb2R5IGFuZD0gbmV3IEJsb2NrIFtAZWxzZUJvZHkubWFrZVJldHVybiByZXN1bHRzXVxuICAgIHRoaXNcblxuICBlbnN1cmVCbG9jazogKG5vZGUpIC0+XG4gICAgaWYgbm9kZSBpbnN0YW5jZW9mIEJsb2NrIHRoZW4gbm9kZSBlbHNlIG5ldyBCbG9jayBbbm9kZV1cblxuICAjIENvbXBpbGUgdGhlIGBJZmAgYXMgYSByZWd1bGFyICppZi1lbHNlKiBzdGF0ZW1lbnQuIEZsYXR0ZW5lZCBjaGFpbnNcbiAgIyBmb3JjZSBpbm5lciAqZWxzZSogYm9kaWVzIGludG8gc3RhdGVtZW50IGZvcm0uXG4gIGNvbXBpbGVTdGF0ZW1lbnQ6IChvKSAtPlxuICAgIGNoaWxkICAgID0gZGVsIG8sICdjaGFpbkNoaWxkJ1xuICAgIGV4ZXEgICAgID0gZGVsIG8sICdpc0V4aXN0ZW50aWFsRXF1YWxzJ1xuXG4gICAgaWYgZXhlcVxuICAgICAgcmV0dXJuIG5ldyBJZihAcHJvY2Vzc2VkQ29uZGl0aW9uKCkuaW52ZXJ0KCksIEBlbHNlQm9keU5vZGUoKSwgdHlwZTogJ2lmJykuY29tcGlsZVRvRnJhZ21lbnRzIG9cblxuICAgIGluZGVudCAgID0gby5pbmRlbnQgKyBUQUJcbiAgICBjb25kICAgICA9IEBwcm9jZXNzZWRDb25kaXRpb24oKS5jb21waWxlVG9GcmFnbWVudHMgbywgTEVWRUxfUEFSRU5cbiAgICBib2R5ICAgICA9IEBlbnN1cmVCbG9jayhAYm9keSkuY29tcGlsZVRvRnJhZ21lbnRzIG1lcmdlIG8sIHtpbmRlbnR9XG4gICAgaWZQYXJ0ICAgPSBbXS5jb25jYXQgQG1ha2VDb2RlKFwiaWYgKFwiKSwgY29uZCwgQG1ha2VDb2RlKFwiKSB7XFxuXCIpLCBib2R5LCBAbWFrZUNvZGUoXCJcXG4je0B0YWJ9fVwiKVxuICAgIGlmUGFydC51bnNoaWZ0IEBtYWtlQ29kZSBAdGFiIHVubGVzcyBjaGlsZFxuICAgIHJldHVybiBpZlBhcnQgdW5sZXNzIEBlbHNlQm9keVxuICAgIGFuc3dlciA9IGlmUGFydC5jb25jYXQgQG1ha2VDb2RlKCcgZWxzZSAnKVxuICAgIGlmIEBpc0NoYWluXG4gICAgICBvLmNoYWluQ2hpbGQgPSB5ZXNcbiAgICAgIGFuc3dlciA9IGFuc3dlci5jb25jYXQgQGVsc2VCb2R5LnVud3JhcCgpLmNvbXBpbGVUb0ZyYWdtZW50cyBvLCBMRVZFTF9UT1BcbiAgICBlbHNlXG4gICAgICBhbnN3ZXIgPSBhbnN3ZXIuY29uY2F0IEBtYWtlQ29kZShcIntcXG5cIiksIEBlbHNlQm9keS5jb21waWxlVG9GcmFnbWVudHMobWVyZ2Uobywge2luZGVudH0pLCBMRVZFTF9UT1ApLCBAbWFrZUNvZGUoXCJcXG4je0B0YWJ9fVwiKVxuICAgIGFuc3dlclxuXG4gICMgQ29tcGlsZSB0aGUgYElmYCBhcyBhIGNvbmRpdGlvbmFsIG9wZXJhdG9yLlxuICBjb21waWxlRXhwcmVzc2lvbjogKG8pIC0+XG4gICAgY29uZCA9IEBwcm9jZXNzZWRDb25kaXRpb24oKS5jb21waWxlVG9GcmFnbWVudHMgbywgTEVWRUxfQ09ORFxuICAgIGJvZHkgPSBAYm9keU5vZGUoKS5jb21waWxlVG9GcmFnbWVudHMgbywgTEVWRUxfTElTVFxuICAgIGFsdCAgPSBpZiBAZWxzZUJvZHlOb2RlKCkgdGhlbiBAZWxzZUJvZHlOb2RlKCkuY29tcGlsZVRvRnJhZ21lbnRzKG8sIExFVkVMX0xJU1QpIGVsc2UgW0BtYWtlQ29kZSgndm9pZCAwJyldXG4gICAgZnJhZ21lbnRzID0gY29uZC5jb25jYXQgQG1ha2VDb2RlKFwiID8gXCIpLCBib2R5LCBAbWFrZUNvZGUoXCIgOiBcIiksIGFsdFxuICAgIGlmIG8ubGV2ZWwgPj0gTEVWRUxfQ09ORCB0aGVuIEB3cmFwSW5QYXJlbnRoZXNlcyBmcmFnbWVudHMgZWxzZSBmcmFnbWVudHNcblxuICB1bmZvbGRTb2FrOiAtPlxuICAgIEBzb2FrIGFuZCB0aGlzXG5cbiAgcHJvY2Vzc2VkQ29uZGl0aW9uOiAtPlxuICAgIEBwcm9jZXNzZWRDb25kaXRpb25DYWNoZSA/PSBpZiBAdHlwZSBpcyAndW5sZXNzJyB0aGVuIEBjb25kaXRpb24uaW52ZXJ0KCkgZWxzZSBAY29uZGl0aW9uXG5cbiAgaXNTdGF0ZW1lbnRBc3Q6IChvKSAtPlxuICAgIG8ubGV2ZWwgaXMgTEVWRUxfVE9QXG5cbiAgYXN0VHlwZTogKG8pIC0+XG4gICAgaWYgQGlzU3RhdGVtZW50QXN0IG9cbiAgICAgICdJZlN0YXRlbWVudCdcbiAgICBlbHNlXG4gICAgICAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJ1xuXG4gIGFzdFByb3BlcnRpZXM6IChvKSAtPlxuICAgIGlzU3RhdGVtZW50ID0gQGlzU3RhdGVtZW50QXN0IG9cblxuICAgIHJldHVyblxuICAgICAgdGVzdDogQGNvbmRpdGlvbi5hc3QgbywgaWYgaXNTdGF0ZW1lbnQgdGhlbiBMRVZFTF9QQVJFTiBlbHNlIExFVkVMX0NPTkRcbiAgICAgIGNvbnNlcXVlbnQ6XG4gICAgICAgIGlmIGlzU3RhdGVtZW50XG4gICAgICAgICAgQGJvZHkuYXN0IG8sIExFVkVMX1RPUFxuICAgICAgICBlbHNlXG4gICAgICAgICAgQGJvZHlOb2RlKCkuYXN0IG8sIExFVkVMX1RPUFxuICAgICAgYWx0ZXJuYXRlOlxuICAgICAgICBpZiBAaXNDaGFpblxuICAgICAgICAgIEBlbHNlQm9keS51bndyYXAoKS5hc3QgbywgaWYgaXNTdGF0ZW1lbnQgdGhlbiBMRVZFTF9UT1AgZWxzZSBMRVZFTF9DT05EXG4gICAgICAgIGVsc2UgaWYgbm90IGlzU3RhdGVtZW50IGFuZCBAZWxzZUJvZHk/LmV4cHJlc3Npb25zPy5sZW5ndGggaXMgMVxuICAgICAgICAgIEBlbHNlQm9keS5leHByZXNzaW9uc1swXS5hc3QgbywgTEVWRUxfVE9QXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBAZWxzZUJvZHk/LmFzdChvLCBMRVZFTF9UT1ApID8gbnVsbFxuICAgICAgcG9zdGZpeDogISFAcG9zdGZpeFxuICAgICAgaW52ZXJ0ZWQ6IEB0eXBlIGlzICd1bmxlc3MnXG5cbiMgQSBzZXF1ZW5jZSBleHByZXNzaW9uIGUuZy4gYChhOyBiKWAuXG4jIEN1cnJlbnRseSBvbmx5IHVzZWQgZHVyaW5nIEFTVCBnZW5lcmF0aW9uLlxuZXhwb3J0cy5TZXF1ZW5jZSA9IGNsYXNzIFNlcXVlbmNlIGV4dGVuZHMgQmFzZVxuICBjaGlsZHJlbjogWydleHByZXNzaW9ucyddXG5cbiAgY29uc3RydWN0b3I6IChAZXhwcmVzc2lvbnMpIC0+XG4gICAgc3VwZXIoKVxuXG4gIGFzdE5vZGU6IChvKSAtPlxuICAgIHJldHVybiBAZXhwcmVzc2lvbnNbMF0uYXN0KG8pIGlmIEBleHByZXNzaW9ucy5sZW5ndGggaXMgMVxuICAgIHN1cGVyIG9cblxuICBhc3RUeXBlOiAtPiAnU2VxdWVuY2VFeHByZXNzaW9uJ1xuXG4gIGFzdFByb3BlcnRpZXM6IChvKSAtPlxuICAgIHJldHVyblxuICAgICAgZXhwcmVzc2lvbnM6XG4gICAgICAgIGV4cHJlc3Npb24uYXN0KG8pIGZvciBleHByZXNzaW9uIGluIEBleHByZXNzaW9uc1xuXG4jIENvbnN0YW50c1xuIyAtLS0tLS0tLS1cblxuVVRJTElUSUVTID1cbiAgbW9kdWxvOiAtPiAnZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gKCthICUgKGIgPSArYikgKyBiKSAlIGI7IH0nXG5cbiAgYm91bmRNZXRob2RDaGVjazogLT4gXCJcbiAgICBmdW5jdGlvbihpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQm91bmQgaW5zdGFuY2UgbWV0aG9kIGFjY2Vzc2VkIGJlZm9yZSBiaW5kaW5nJyk7XG4gICAgICB9XG4gICAgfVxuICBcIlxuXG4gICMgU2hvcnRjdXRzIHRvIHNwZWVkIHVwIHRoZSBsb29rdXAgdGltZSBmb3IgbmF0aXZlIGZ1bmN0aW9ucy5cbiAgaGFzUHJvcDogLT4gJ3t9Lmhhc093blByb3BlcnR5J1xuICBpbmRleE9mOiAtPiAnW10uaW5kZXhPZidcbiAgc2xpY2UgIDogLT4gJ1tdLnNsaWNlJ1xuICBzcGxpY2UgOiAtPiAnW10uc3BsaWNlJ1xuXG4jIExldmVscyBpbmRpY2F0ZSBhIG5vZGUncyBwb3NpdGlvbiBpbiB0aGUgQVNULiBVc2VmdWwgZm9yIGtub3dpbmcgaWZcbiMgcGFyZW5zIGFyZSBuZWNlc3Nhcnkgb3Igc3VwZXJmbHVvdXMuXG5MRVZFTF9UT1AgICAgPSAxICAjIC4uLjtcbkxFVkVMX1BBUkVOICA9IDIgICMgKC4uLilcbkxFVkVMX0xJU1QgICA9IDMgICMgWy4uLl1cbkxFVkVMX0NPTkQgICA9IDQgICMgLi4uID8geCA6IHlcbkxFVkVMX09QICAgICA9IDUgICMgIS4uLlxuTEVWRUxfQUNDRVNTID0gNiAgIyAuLi5bMF1cblxuIyBUYWJzIGFyZSB0d28gc3BhY2VzIGZvciBwcmV0dHkgcHJpbnRpbmcuXG5UQUIgPSAnICAnXG5cblNJTVBMRU5VTSA9IC9eWystXT9cXGQrKD86X1xcZCspKiQvXG5TSU1QTEVfU1RSSU5HX09NSVQgPSAvXFxzKlxcblxccyovZ1xuTEVBRElOR19CTEFOS19MSU5FICA9IC9eW15cXG5cXFNdKlxcbi9cblRSQUlMSU5HX0JMQU5LX0xJTkUgPSAvXFxuW15cXG5cXFNdKiQvXG5TVFJJTkdfT01JVCAgICA9IC8vL1xuICAgICgoPzpcXFxcXFxcXCkrKSAgICAgICMgQ29uc3VtZSAoYW5kIHByZXNlcnZlKSBhbiBldmVuIG51bWJlciBvZiBiYWNrc2xhc2hlcy5cbiAgfCBcXFxcW15cXFNcXG5dKlxcblxccyogICMgUmVtb3ZlIGVzY2FwZWQgbmV3bGluZXMuXG4vLy9nXG5IRVJFR0VYX09NSVQgPSAvLy9cbiAgICAoKD86XFxcXFxcXFwpKykgICAgICMgQ29uc3VtZSAoYW5kIHByZXNlcnZlKSBhbiBldmVuIG51bWJlciBvZiBiYWNrc2xhc2hlcy5cbiAgfCBcXFxcKFxccykgICAgICAgICAgIyBQcmVzZXJ2ZSBlc2NhcGVkIHdoaXRlc3BhY2UuXG4gIHwgXFxzKyg/OiMuKik/ICAgICAjIFJlbW92ZSB3aGl0ZXNwYWNlIGFuZCBjb21tZW50cy5cbi8vL2dcblxuIyBIZWxwZXIgRnVuY3Rpb25zXG4jIC0tLS0tLS0tLS0tLS0tLS1cblxuIyBIZWxwZXIgZm9yIGVuc3VyaW5nIHRoYXQgdXRpbGl0eSBmdW5jdGlvbnMgYXJlIGFzc2lnbmVkIGF0IHRoZSB0b3AgbGV2ZWwuXG51dGlsaXR5ID0gKG5hbWUsIG8pIC0+XG4gIHtyb290fSA9IG8uc2NvcGVcbiAgaWYgbmFtZSBvZiByb290LnV0aWxpdGllc1xuICAgIHJvb3QudXRpbGl0aWVzW25hbWVdXG4gIGVsc2VcbiAgICByZWYgPSByb290LmZyZWVWYXJpYWJsZSBuYW1lXG4gICAgcm9vdC5hc3NpZ24gcmVmLCBVVElMSVRJRVNbbmFtZV0gb1xuICAgIHJvb3QudXRpbGl0aWVzW25hbWVdID0gcmVmXG5cbm11bHRpZGVudCA9IChjb2RlLCB0YWIsIGluY2x1ZGluZ0ZpcnN0TGluZSA9IHllcykgLT5cbiAgZW5kc1dpdGhOZXdMaW5lID0gY29kZVtjb2RlLmxlbmd0aCAtIDFdIGlzICdcXG4nXG4gIGNvZGUgPSAoaWYgaW5jbHVkaW5nRmlyc3RMaW5lIHRoZW4gdGFiIGVsc2UgJycpICsgY29kZS5yZXBsYWNlIC9cXG4vZywgXCIkJiN7dGFifVwiXG4gIGNvZGUgPSBjb2RlLnJlcGxhY2UgL1xccyskLywgJydcbiAgY29kZSA9IGNvZGUgKyAnXFxuJyBpZiBlbmRzV2l0aE5ld0xpbmVcbiAgY29kZVxuXG4jIFdoZXJldmVyIGluIENvZmZlZVNjcmlwdCAxIHdlIG1pZ2h04oCZdmUgaW5zZXJ0ZWQgYSBgbWFrZUNvZGUgXCIje0B0YWJ9XCJgIHRvXG4jIGluZGVudCBhIGxpbmUgb2YgY29kZSwgbm93IHdlIG11c3QgYWNjb3VudCBmb3IgdGhlIHBvc3NpYmlsaXR5IG9mIGNvbW1lbnRzXG4jIHByZWNlZGluZyB0aGF0IGxpbmUgb2YgY29kZS4gSWYgdGhlcmUgYXJlIHN1Y2ggY29tbWVudHMsIGluZGVudCBlYWNoIGxpbmUgb2ZcbiMgc3VjaCBjb21tZW50cywgYW5kIF90aGVuXyBpbmRlbnQgdGhlIGZpcnN0IGZvbGxvd2luZyBsaW5lIG9mIGNvZGUuXG5pbmRlbnRJbml0aWFsID0gKGZyYWdtZW50cywgbm9kZSkgLT5cbiAgZm9yIGZyYWdtZW50LCBmcmFnbWVudEluZGV4IGluIGZyYWdtZW50c1xuICAgIGlmIGZyYWdtZW50LmlzSGVyZUNvbW1lbnRcbiAgICAgIGZyYWdtZW50LmNvZGUgPSBtdWx0aWRlbnQgZnJhZ21lbnQuY29kZSwgbm9kZS50YWJcbiAgICBlbHNlXG4gICAgICBmcmFnbWVudHMuc3BsaWNlIGZyYWdtZW50SW5kZXgsIDAsIG5vZGUubWFrZUNvZGUgXCIje25vZGUudGFifVwiXG4gICAgICBicmVha1xuICBmcmFnbWVudHNcblxuaGFzTGluZUNvbW1lbnRzID0gKG5vZGUpIC0+XG4gIHJldHVybiBubyB1bmxlc3Mgbm9kZS5jb21tZW50c1xuICBmb3IgY29tbWVudCBpbiBub2RlLmNvbW1lbnRzXG4gICAgcmV0dXJuIHllcyBpZiBjb21tZW50LmhlcmUgaXMgbm9cbiAgcmV0dXJuIG5vXG5cbiMgTW92ZSB0aGUgYGNvbW1lbnRzYCBwcm9wZXJ0eSBmcm9tIG9uZSBvYmplY3QgdG8gYW5vdGhlciwgZGVsZXRpbmcgaXQgZnJvbVxuIyB0aGUgZmlyc3Qgb2JqZWN0LlxubW92ZUNvbW1lbnRzID0gKGZyb20sIHRvKSAtPlxuICByZXR1cm4gdW5sZXNzIGZyb20/LmNvbW1lbnRzXG4gIGF0dGFjaENvbW1lbnRzVG9Ob2RlIGZyb20uY29tbWVudHMsIHRvXG4gIGRlbGV0ZSBmcm9tLmNvbW1lbnRzXG5cbiMgU29tZXRpbWVzIHdoZW4gY29tcGlsaW5nIGEgbm9kZSwgd2Ugd2FudCB0byBpbnNlcnQgYSBmcmFnbWVudCBhdCB0aGUgc3RhcnRcbiMgb2YgYW4gYXJyYXkgb2YgZnJhZ21lbnRzOyBidXQgaWYgdGhlIHN0YXJ0IGhhcyBvbmUgb3IgbW9yZSBjb21tZW50IGZyYWdtZW50cyxcbiMgd2Ugd2FudCB0byBpbnNlcnQgdGhpcyBmcmFnbWVudCBhZnRlciB0aG9zZSBidXQgYmVmb3JlIGFueSBub24tY29tbWVudHMuXG51bnNoaWZ0QWZ0ZXJDb21tZW50cyA9IChmcmFnbWVudHMsIGZyYWdtZW50VG9JbnNlcnQpIC0+XG4gIGluc2VydGVkID0gbm9cbiAgZm9yIGZyYWdtZW50LCBmcmFnbWVudEluZGV4IGluIGZyYWdtZW50cyB3aGVuIG5vdCBmcmFnbWVudC5pc0NvbW1lbnRcbiAgICBmcmFnbWVudHMuc3BsaWNlIGZyYWdtZW50SW5kZXgsIDAsIGZyYWdtZW50VG9JbnNlcnRcbiAgICBpbnNlcnRlZCA9IHllc1xuICAgIGJyZWFrXG4gIGZyYWdtZW50cy5wdXNoIGZyYWdtZW50VG9JbnNlcnQgdW5sZXNzIGluc2VydGVkXG4gIGZyYWdtZW50c1xuXG5pc0xpdGVyYWxBcmd1bWVudHMgPSAobm9kZSkgLT5cbiAgbm9kZSBpbnN0YW5jZW9mIElkZW50aWZpZXJMaXRlcmFsIGFuZCBub2RlLnZhbHVlIGlzICdhcmd1bWVudHMnXG5cbmlzTGl0ZXJhbFRoaXMgPSAobm9kZSkgLT5cbiAgbm9kZSBpbnN0YW5jZW9mIFRoaXNMaXRlcmFsIG9yIChub2RlIGluc3RhbmNlb2YgQ29kZSBhbmQgbm9kZS5ib3VuZClcblxuc2hvdWxkQ2FjaGVPcklzQXNzaWduYWJsZSA9IChub2RlKSAtPiBub2RlLnNob3VsZENhY2hlKCkgb3Igbm9kZS5pc0Fzc2lnbmFibGU/KClcblxuIyBVbmZvbGQgYSBub2RlJ3MgY2hpbGQgaWYgc29haywgdGhlbiB0dWNrIHRoZSBub2RlIHVuZGVyIGNyZWF0ZWQgYElmYFxudW5mb2xkU29hayA9IChvLCBwYXJlbnQsIG5hbWUpIC0+XG4gIHJldHVybiB1bmxlc3MgaWZuID0gcGFyZW50W25hbWVdLnVuZm9sZFNvYWsgb1xuICBwYXJlbnRbbmFtZV0gPSBpZm4uYm9keVxuICBpZm4uYm9keSA9IG5ldyBWYWx1ZSBwYXJlbnRcbiAgaWZuXG5cbiMgQ29uc3RydWN0cyBhIHN0cmluZyBvciByZWdleCBieSBlc2NhcGluZyBjZXJ0YWluIGNoYXJhY3RlcnMuXG5tYWtlRGVsaW1pdGVkTGl0ZXJhbCA9IChib2R5LCB7ZGVsaW1pdGVyOiBkZWxpbWl0ZXJPcHRpb24sIGVzY2FwZU5ld2xpbmVzLCBkb3VibGUsIGluY2x1ZGVEZWxpbWl0ZXJzID0geWVzLCBlc2NhcGVEZWxpbWl0ZXIgPSB5ZXMsIGNvbnZlcnRUcmFpbGluZ051bGxFc2NhcGVzfSA9IHt9KSAtPlxuICBib2R5ID0gJyg/OiknIGlmIGJvZHkgaXMgJycgYW5kIGRlbGltaXRlck9wdGlvbiBpcyAnLydcbiAgZXNjYXBlVGVtcGxhdGVMaXRlcmFsQ3VybGllcyA9IGRlbGltaXRlck9wdGlvbiBpcyAnYCdcbiAgcmVnZXggPSAvLy9cbiAgICAgIChcXFxcXFxcXCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBFc2NhcGVkIGJhY2tzbGFzaC5cbiAgICB8IChcXFxcMCg/PVxcZCkpICAgICAgICAgICAgICAgICAgICAgICAgICAjIE51bGwgY2hhcmFjdGVyIG1pc3Rha2VuIGFzIG9jdGFsIGVzY2FwZS5cbiAgICAje1xuICAgICAgaWYgY29udmVydFRyYWlsaW5nTnVsbEVzY2FwZXNcbiAgICAgICAgLy8vIHwgKFxcXFwwKSAkIC8vLy5zb3VyY2UgICAgICAgICAgICMgVHJhaWxpbmcgbnVsbCBjaGFyYWN0ZXIgdGhhdCBjb3VsZCBiZSBtaXN0YWtlbiBhcyBvY3RhbCBlc2NhcGUuXG4gICAgICBlbHNlXG4gICAgICAgICcnXG4gICAgfVxuICAgICN7XG4gICAgICBpZiBlc2NhcGVEZWxpbWl0ZXJcbiAgICAgICAgLy8vIHwgXFxcXD8oI3tkZWxpbWl0ZXJPcHRpb259KSAvLy8uc291cmNlICMgKFBvc3NpYmx5IGVzY2FwZWQpIGRlbGltaXRlci5cbiAgICAgIGVsc2VcbiAgICAgICAgJydcbiAgICB9XG4gICAgI3tcbiAgICAgIGlmIGVzY2FwZVRlbXBsYXRlTGl0ZXJhbEN1cmxpZXNcbiAgICAgICAgLy8vIHwgXFxcXD8oXFwkXFx7KSAvLy8uc291cmNlICAgICAgICAgIyBgJHtgIGluc2lkZSB0ZW1wbGF0ZSBsaXRlcmFscyBtdXN0IGJlIGVzY2FwZWQuXG4gICAgICBlbHNlXG4gICAgICAgICcnXG4gICAgfVxuICAgIHwgXFxcXD8oPzpcbiAgICAgICAgI3tpZiBlc2NhcGVOZXdsaW5lcyB0aGVuICcoXFxuKXwnIGVsc2UgJyd9XG4gICAgICAgICAgKFxccilcbiAgICAgICAgfCAoXFx1MjAyOClcbiAgICAgICAgfCAoXFx1MjAyOSlcbiAgICAgICkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIChQb3NzaWJseSBlc2NhcGVkKSBuZXdsaW5lcy5cbiAgICB8IChcXFxcLikgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgT3RoZXIgZXNjYXBlcy5cbiAgLy8vZ1xuICBib2R5ID0gYm9keS5yZXBsYWNlIHJlZ2V4LCAobWF0Y2gsIGJhY2tzbGFzaCwgbnVsLCAuLi5hcmdzKSAtPlxuICAgIHRyYWlsaW5nTnVsbEVzY2FwZSA9XG4gICAgICBhcmdzLnNoaWZ0KCkgaWYgY29udmVydFRyYWlsaW5nTnVsbEVzY2FwZXNcbiAgICBkZWxpbWl0ZXIgPVxuICAgICAgYXJncy5zaGlmdCgpIGlmIGVzY2FwZURlbGltaXRlclxuICAgIHRlbXBsYXRlTGl0ZXJhbEN1cmx5ID1cbiAgICAgIGFyZ3Muc2hpZnQoKSBpZiBlc2NhcGVUZW1wbGF0ZUxpdGVyYWxDdXJsaWVzXG4gICAgbGYgPVxuICAgICAgYXJncy5zaGlmdCgpIGlmIGVzY2FwZU5ld2xpbmVzXG4gICAgW2NyLCBscywgcHMsIG90aGVyXSA9IGFyZ3NcbiAgICBzd2l0Y2hcbiAgICAgICMgSWdub3JlIGVzY2FwZWQgYmFja3NsYXNoZXMuXG4gICAgICB3aGVuIGJhY2tzbGFzaCB0aGVuIChpZiBkb3VibGUgdGhlbiBiYWNrc2xhc2ggKyBiYWNrc2xhc2ggZWxzZSBiYWNrc2xhc2gpXG4gICAgICB3aGVuIG51bCAgICAgICAgICAgICAgICAgIHRoZW4gJ1xcXFx4MDAnXG4gICAgICB3aGVuIHRyYWlsaW5nTnVsbEVzY2FwZSAgIHRoZW4gXCJcXFxceDAwXCJcbiAgICAgIHdoZW4gZGVsaW1pdGVyICAgICAgICAgICAgdGhlbiBcIlxcXFwje2RlbGltaXRlcn1cIlxuICAgICAgd2hlbiB0ZW1wbGF0ZUxpdGVyYWxDdXJseSB0aGVuIFwiXFxcXCR7XCJcbiAgICAgIHdoZW4gbGYgICAgICAgICAgICAgICAgICAgdGhlbiAnXFxcXG4nXG4gICAgICB3aGVuIGNyICAgICAgICAgICAgICAgICAgIHRoZW4gJ1xcXFxyJ1xuICAgICAgd2hlbiBscyAgICAgICAgICAgICAgICAgICB0aGVuICdcXFxcdTIwMjgnXG4gICAgICB3aGVuIHBzICAgICAgICAgICAgICAgICAgIHRoZW4gJ1xcXFx1MjAyOSdcbiAgICAgIHdoZW4gb3RoZXIgICAgICAgICAgICAgICAgdGhlbiAoaWYgZG91YmxlIHRoZW4gXCJcXFxcI3tvdGhlcn1cIiBlbHNlIG90aGVyKVxuICBwcmludGVkRGVsaW1pdGVyID0gaWYgaW5jbHVkZURlbGltaXRlcnMgdGhlbiBkZWxpbWl0ZXJPcHRpb24gZWxzZSAnJ1xuICBcIiN7cHJpbnRlZERlbGltaXRlcn0je2JvZHl9I3twcmludGVkRGVsaW1pdGVyfVwiXG5cbnNuaWZmRGlyZWN0aXZlcyA9IChleHByZXNzaW9ucywge25vdEZpbmFsRXhwcmVzc2lvbn0gPSB7fSkgLT5cbiAgaW5kZXggPSAwXG4gIGxhc3RJbmRleCA9IGV4cHJlc3Npb25zLmxlbmd0aCAtIDFcbiAgd2hpbGUgaW5kZXggPD0gbGFzdEluZGV4XG4gICAgYnJlYWsgaWYgaW5kZXggaXMgbGFzdEluZGV4IGFuZCBub3RGaW5hbEV4cHJlc3Npb25cbiAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbnNbaW5kZXhdXG4gICAgaWYgKHVud3JhcHBlZCA9IGV4cHJlc3Npb24/LnVud3JhcD8oKSkgaW5zdGFuY2VvZiBQYXNzdGhyb3VnaExpdGVyYWwgYW5kIHVud3JhcHBlZC5nZW5lcmF0ZWRcbiAgICAgIGluZGV4KytcbiAgICAgIGNvbnRpbnVlXG4gICAgYnJlYWsgdW5sZXNzIGV4cHJlc3Npb24gaW5zdGFuY2VvZiBWYWx1ZSBhbmQgZXhwcmVzc2lvbi5pc1N0cmluZygpIGFuZCBub3QgZXhwcmVzc2lvbi51bndyYXAoKS5zaG91bGRHZW5lcmF0ZVRlbXBsYXRlTGl0ZXJhbCgpXG4gICAgZXhwcmVzc2lvbnNbaW5kZXhdID1cbiAgICAgIG5ldyBEaXJlY3RpdmUgZXhwcmVzc2lvblxuICAgICAgLndpdGhMb2NhdGlvbkRhdGFGcm9tIGV4cHJlc3Npb25cbiAgICBpbmRleCsrXG5cbmFzdEFzQmxvY2tJZk5lZWRlZCA9IChub2RlLCBvKSAtPlxuICB1bndyYXBwZWQgPSBub2RlLnVud3JhcCgpXG4gIGlmIHVud3JhcHBlZCBpbnN0YW5jZW9mIEJsb2NrIGFuZCB1bndyYXBwZWQuZXhwcmVzc2lvbnMubGVuZ3RoID4gMVxuICAgIHVud3JhcHBlZC5tYWtlUmV0dXJuIG51bGwsIHllc1xuICAgIHVud3JhcHBlZC5hc3QgbywgTEVWRUxfVE9QXG4gIGVsc2VcbiAgICBub2RlLmFzdCBvLCBMRVZFTF9QQVJFTlxuXG4jIEhlbHBlcnMgZm9yIGBtZXJnZUxvY2F0aW9uRGF0YWAgYW5kIGBtZXJnZUFzdExvY2F0aW9uRGF0YWAgYmVsb3cuXG5sZXNzZXIgID0gKGEsIGIpIC0+IGlmIGEgPCBiIHRoZW4gYSBlbHNlIGJcbmdyZWF0ZXIgPSAoYSwgYikgLT4gaWYgYSA+IGIgdGhlbiBhIGVsc2UgYlxuXG5pc0FzdExvY0dyZWF0ZXIgPSAoYSwgYikgLT5cbiAgcmV0dXJuIHllcyBpZiBhLmxpbmUgPiBiLmxpbmVcbiAgcmV0dXJuIG5vIHVubGVzcyBhLmxpbmUgaXMgYi5saW5lXG4gIGEuY29sdW1uID4gYi5jb2x1bW5cblxuaXNMb2NhdGlvbkRhdGFTdGFydEdyZWF0ZXIgPSAoYSwgYikgLT5cbiAgcmV0dXJuIHllcyBpZiBhLmZpcnN0X2xpbmUgPiBiLmZpcnN0X2xpbmVcbiAgcmV0dXJuIG5vIHVubGVzcyBhLmZpcnN0X2xpbmUgaXMgYi5maXJzdF9saW5lXG4gIGEuZmlyc3RfY29sdW1uID4gYi5maXJzdF9jb2x1bW5cblxuaXNMb2NhdGlvbkRhdGFFbmRHcmVhdGVyID0gKGEsIGIpIC0+XG4gIHJldHVybiB5ZXMgaWYgYS5sYXN0X2xpbmUgPiBiLmxhc3RfbGluZVxuICByZXR1cm4gbm8gdW5sZXNzIGEubGFzdF9saW5lIGlzIGIubGFzdF9saW5lXG4gIGEubGFzdF9jb2x1bW4gPiBiLmxhc3RfY29sdW1uXG5cbiMgVGFrZSB0d28gbm9kZXPigJkgbG9jYXRpb24gZGF0YSBhbmQgcmV0dXJuIGEgbmV3IGBsb2NhdGlvbkRhdGFgIG9iamVjdCB0aGF0XG4jIGVuY29tcGFzc2VzIHRoZSBsb2NhdGlvbiBkYXRhIG9mIGJvdGggbm9kZXMuIFNvIHRoZSBuZXcgYGZpcnN0X2xpbmVgIHZhbHVlXG4jIHdpbGwgYmUgdGhlIGVhcmxpZXIgb2YgdGhlIHR3byBub2Rlc+KAmSBgZmlyc3RfbGluZWAgdmFsdWVzLCB0aGUgbmV3XG4jIGBsYXN0X2NvbHVtbmAgdGhlIGxhdGVyIG9mIHRoZSB0d28gbm9kZXPigJkgYGxhc3RfY29sdW1uYCB2YWx1ZXMsIGV0Yy5cbiNcbiMgSWYgeW91IG9ubHkgd2FudCB0byBleHRlbmQgdGhlIGZpcnN0IG5vZGXigJlzIGxvY2F0aW9uIGRhdGEgd2l0aCB0aGUgc3RhcnQgb3JcbiMgZW5kIGxvY2F0aW9uIGRhdGEgb2YgdGhlIHNlY29uZCBub2RlLCBwYXNzIHRoZSBganVzdExlYWRpbmdgIG9yIGBqdXN0RW5kaW5nYFxuIyBvcHRpb25zLiBTbyBlLmcuIGlmIGBmaXJzdGDigJlzIHJhbmdlIGlzIFs0LCA1XSBhbmQgYHNlY29uZGDigJlzIHJhbmdlIGlzIFsxLCAxMF0sXG4jIHlvdeKAmWQgZ2V0OlxuIyBgYGBcbiMgbWVyZ2VMb2NhdGlvbkRhdGEoZmlyc3QsIHNlY29uZCkucmFuZ2UgICAgICAgICAgICAgICAgICAgIyBbMSwgMTBdXG4jIG1lcmdlTG9jYXRpb25EYXRhKGZpcnN0LCBzZWNvbmQsIGp1c3RMZWFkaW5nOiB5ZXMpLnJhbmdlICMgWzEsIDVdXG4jIG1lcmdlTG9jYXRpb25EYXRhKGZpcnN0LCBzZWNvbmQsIGp1c3RFbmRpbmc6ICB5ZXMpLnJhbmdlICMgWzQsIDEwXVxuIyBgYGBcbmV4cG9ydHMubWVyZ2VMb2NhdGlvbkRhdGEgPSBtZXJnZUxvY2F0aW9uRGF0YSA9IChsb2NhdGlvbkRhdGFBLCBsb2NhdGlvbkRhdGFCLCB7anVzdExlYWRpbmcsIGp1c3RFbmRpbmd9ID0ge30pIC0+XG4gIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgIGlmIGp1c3RFbmRpbmdcbiAgICAgIGZpcnN0X2xpbmU6ICAgbG9jYXRpb25EYXRhQS5maXJzdF9saW5lXG4gICAgICBmaXJzdF9jb2x1bW46IGxvY2F0aW9uRGF0YUEuZmlyc3RfY29sdW1uXG4gICAgZWxzZVxuICAgICAgaWYgaXNMb2NhdGlvbkRhdGFTdGFydEdyZWF0ZXIgbG9jYXRpb25EYXRhQSwgbG9jYXRpb25EYXRhQlxuICAgICAgICBmaXJzdF9saW5lOiAgIGxvY2F0aW9uRGF0YUIuZmlyc3RfbGluZVxuICAgICAgICBmaXJzdF9jb2x1bW46IGxvY2F0aW9uRGF0YUIuZmlyc3RfY29sdW1uXG4gICAgICBlbHNlXG4gICAgICAgIGZpcnN0X2xpbmU6ICAgbG9jYXRpb25EYXRhQS5maXJzdF9saW5lXG4gICAgICAgIGZpcnN0X2NvbHVtbjogbG9jYXRpb25EYXRhQS5maXJzdF9jb2x1bW5cbiAgLFxuICAgIGlmIGp1c3RMZWFkaW5nXG4gICAgICBsYXN0X2xpbmU6ICAgICAgICAgICAgIGxvY2F0aW9uRGF0YUEubGFzdF9saW5lXG4gICAgICBsYXN0X2NvbHVtbjogICAgICAgICAgIGxvY2F0aW9uRGF0YUEubGFzdF9jb2x1bW5cbiAgICAgIGxhc3RfbGluZV9leGNsdXNpdmU6ICAgbG9jYXRpb25EYXRhQS5sYXN0X2xpbmVfZXhjbHVzaXZlXG4gICAgICBsYXN0X2NvbHVtbl9leGNsdXNpdmU6IGxvY2F0aW9uRGF0YUEubGFzdF9jb2x1bW5fZXhjbHVzaXZlXG4gICAgZWxzZVxuICAgICAgaWYgaXNMb2NhdGlvbkRhdGFFbmRHcmVhdGVyIGxvY2F0aW9uRGF0YUEsIGxvY2F0aW9uRGF0YUJcbiAgICAgICAgbGFzdF9saW5lOiAgICAgICAgICAgICBsb2NhdGlvbkRhdGFBLmxhc3RfbGluZVxuICAgICAgICBsYXN0X2NvbHVtbjogICAgICAgICAgIGxvY2F0aW9uRGF0YUEubGFzdF9jb2x1bW5cbiAgICAgICAgbGFzdF9saW5lX2V4Y2x1c2l2ZTogICBsb2NhdGlvbkRhdGFBLmxhc3RfbGluZV9leGNsdXNpdmVcbiAgICAgICAgbGFzdF9jb2x1bW5fZXhjbHVzaXZlOiBsb2NhdGlvbkRhdGFBLmxhc3RfY29sdW1uX2V4Y2x1c2l2ZVxuICAgICAgZWxzZVxuICAgICAgICBsYXN0X2xpbmU6ICAgICAgICAgICAgIGxvY2F0aW9uRGF0YUIubGFzdF9saW5lXG4gICAgICAgIGxhc3RfY29sdW1uOiAgICAgICAgICAgbG9jYXRpb25EYXRhQi5sYXN0X2NvbHVtblxuICAgICAgICBsYXN0X2xpbmVfZXhjbHVzaXZlOiAgIGxvY2F0aW9uRGF0YUIubGFzdF9saW5lX2V4Y2x1c2l2ZVxuICAgICAgICBsYXN0X2NvbHVtbl9leGNsdXNpdmU6IGxvY2F0aW9uRGF0YUIubGFzdF9jb2x1bW5fZXhjbHVzaXZlXG4gICxcbiAgICByYW5nZTogW1xuICAgICAgaWYganVzdEVuZGluZ1xuICAgICAgICBsb2NhdGlvbkRhdGFBLnJhbmdlWzBdXG4gICAgICBlbHNlXG4gICAgICAgIGxlc3NlciBsb2NhdGlvbkRhdGFBLnJhbmdlWzBdLCBsb2NhdGlvbkRhdGFCLnJhbmdlWzBdXG4gICAgLFxuICAgICAgaWYganVzdExlYWRpbmdcbiAgICAgICAgbG9jYXRpb25EYXRhQS5yYW5nZVsxXVxuICAgICAgZWxzZVxuICAgICAgICBncmVhdGVyIGxvY2F0aW9uRGF0YUEucmFuZ2VbMV0sIGxvY2F0aW9uRGF0YUIucmFuZ2VbMV1cbiAgICBdXG4gIClcblxuIyBUYWtlIHR3byBBU1Qgbm9kZXMsIG9yIHR3byBBU1Qgbm9kZXPigJkgbG9jYXRpb24gZGF0YSBvYmplY3RzLCBhbmQgcmV0dXJuIGEgbmV3XG4jIGxvY2F0aW9uIGRhdGEgb2JqZWN0IHRoYXQgZW5jb21wYXNzZXMgdGhlIGxvY2F0aW9uIGRhdGEgb2YgYm90aCBub2Rlcy4gU28gdGhlXG4jIG5ldyBgc3RhcnRgIHZhbHVlIHdpbGwgYmUgdGhlIGVhcmxpZXIgb2YgdGhlIHR3byBub2Rlc+KAmSBgc3RhcnRgIHZhbHVlcywgdGhlXG4jIG5ldyBgZW5kYCB2YWx1ZSB3aWxsIGJlIHRoZSBsYXRlciBvZiB0aGUgdHdvIG5vZGVz4oCZIGBlbmRgIHZhbHVlcywgZXRjLlxuI1xuIyBJZiB5b3Ugb25seSB3YW50IHRvIGV4dGVuZCB0aGUgZmlyc3Qgbm9kZeKAmXMgbG9jYXRpb24gZGF0YSB3aXRoIHRoZSBzdGFydCBvclxuIyBlbmQgbG9jYXRpb24gZGF0YSBvZiB0aGUgc2Vjb25kIG5vZGUsIHBhc3MgdGhlIGBqdXN0TGVhZGluZ2Agb3IgYGp1c3RFbmRpbmdgXG4jIG9wdGlvbnMuIFNvIGUuZy4gaWYgYGZpcnN0YOKAmXMgcmFuZ2UgaXMgWzQsIDVdIGFuZCBgc2Vjb25kYOKAmXMgcmFuZ2UgaXMgWzEsIDEwXSxcbiMgeW914oCZZCBnZXQ6XG4jIGBgYFxuIyBtZXJnZUFzdExvY2F0aW9uRGF0YShmaXJzdCwgc2Vjb25kKS5yYW5nZSAgICAgICAgICAgICAgICAgICAjIFsxLCAxMF1cbiMgbWVyZ2VBc3RMb2NhdGlvbkRhdGEoZmlyc3QsIHNlY29uZCwganVzdExlYWRpbmc6IHllcykucmFuZ2UgIyBbMSwgNV1cbiMgbWVyZ2VBc3RMb2NhdGlvbkRhdGEoZmlyc3QsIHNlY29uZCwganVzdEVuZGluZzogIHllcykucmFuZ2UgIyBbNCwgMTBdXG4jIGBgYFxuZXhwb3J0cy5tZXJnZUFzdExvY2F0aW9uRGF0YSA9IG1lcmdlQXN0TG9jYXRpb25EYXRhID0gKG5vZGVBLCBub2RlQiwge2p1c3RMZWFkaW5nLCBqdXN0RW5kaW5nfSA9IHt9KSAtPlxuICByZXR1cm5cbiAgICBsb2M6XG4gICAgICBzdGFydDpcbiAgICAgICAgaWYganVzdEVuZGluZ1xuICAgICAgICAgIG5vZGVBLmxvYy5zdGFydFxuICAgICAgICBlbHNlXG4gICAgICAgICAgaWYgaXNBc3RMb2NHcmVhdGVyIG5vZGVBLmxvYy5zdGFydCwgbm9kZUIubG9jLnN0YXJ0XG4gICAgICAgICAgICBub2RlQi5sb2Muc3RhcnRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBub2RlQS5sb2Muc3RhcnRcbiAgICAgIGVuZDpcbiAgICAgICAgaWYganVzdExlYWRpbmdcbiAgICAgICAgICBub2RlQS5sb2MuZW5kXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBpZiBpc0FzdExvY0dyZWF0ZXIgbm9kZUEubG9jLmVuZCwgbm9kZUIubG9jLmVuZFxuICAgICAgICAgICAgbm9kZUEubG9jLmVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG5vZGVCLmxvYy5lbmRcbiAgICByYW5nZTogW1xuICAgICAgaWYganVzdEVuZGluZ1xuICAgICAgICBub2RlQS5yYW5nZVswXVxuICAgICAgZWxzZVxuICAgICAgICBsZXNzZXIgbm9kZUEucmFuZ2VbMF0sIG5vZGVCLnJhbmdlWzBdXG4gICAgLFxuICAgICAgaWYganVzdExlYWRpbmdcbiAgICAgICAgbm9kZUEucmFuZ2VbMV1cbiAgICAgIGVsc2VcbiAgICAgICAgZ3JlYXRlciBub2RlQS5yYW5nZVsxXSwgbm9kZUIucmFuZ2VbMV1cbiAgICBdXG4gICAgc3RhcnQ6XG4gICAgICBpZiBqdXN0RW5kaW5nXG4gICAgICAgIG5vZGVBLnN0YXJ0XG4gICAgICBlbHNlXG4gICAgICAgIGxlc3NlciBub2RlQS5zdGFydCwgbm9kZUIuc3RhcnRcbiAgICBlbmQ6XG4gICAgICBpZiBqdXN0TGVhZGluZ1xuICAgICAgICBub2RlQS5lbmRcbiAgICAgIGVsc2VcbiAgICAgICAgZ3JlYXRlciBub2RlQS5lbmQsIG5vZGVCLmVuZFxuXG4jIENvbnZlcnQgSmlzb24tc3R5bGUgbm9kZSBjbGFzcyBsb2NhdGlvbiBkYXRhIHRvIEJhYmVsLXN0eWxlIGxvY2F0aW9uIGRhdGFcbmV4cG9ydHMuamlzb25Mb2NhdGlvbkRhdGFUb0FzdExvY2F0aW9uRGF0YSA9IGppc29uTG9jYXRpb25EYXRhVG9Bc3RMb2NhdGlvbkRhdGEgPSAoe2ZpcnN0X2xpbmUsIGZpcnN0X2NvbHVtbiwgbGFzdF9saW5lX2V4Y2x1c2l2ZSwgbGFzdF9jb2x1bW5fZXhjbHVzaXZlLCByYW5nZX0pIC0+XG4gIHJldHVyblxuICAgIGxvYzpcbiAgICAgIHN0YXJ0OlxuICAgICAgICBsaW5lOiAgIGZpcnN0X2xpbmUgKyAxXG4gICAgICAgIGNvbHVtbjogZmlyc3RfY29sdW1uXG4gICAgICBlbmQ6XG4gICAgICAgIGxpbmU6ICAgbGFzdF9saW5lX2V4Y2x1c2l2ZSArIDFcbiAgICAgICAgY29sdW1uOiBsYXN0X2NvbHVtbl9leGNsdXNpdmVcbiAgICByYW5nZTogW1xuICAgICAgcmFuZ2VbMF1cbiAgICAgIHJhbmdlWzFdXG4gICAgXVxuICAgIHN0YXJ0OiByYW5nZVswXVxuICAgIGVuZDogICByYW5nZVsxXVxuXG4jIEdlbmVyYXRlIGEgemVyby13aWR0aCBsb2NhdGlvbiBkYXRhIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGVuZCBvZiBhbm90aGVyIG5vZGXigJlzIGxvY2F0aW9uLlxuemVyb1dpZHRoTG9jYXRpb25EYXRhRnJvbUVuZExvY2F0aW9uID0gKHtyYW5nZTogWywgZW5kUmFuZ2VdLCBsYXN0X2xpbmVfZXhjbHVzaXZlLCBsYXN0X2NvbHVtbl9leGNsdXNpdmV9KSAtPiB7XG4gIGZpcnN0X2xpbmU6IGxhc3RfbGluZV9leGNsdXNpdmVcbiAgZmlyc3RfY29sdW1uOiBsYXN0X2NvbHVtbl9leGNsdXNpdmVcbiAgbGFzdF9saW5lOiBsYXN0X2xpbmVfZXhjbHVzaXZlXG4gIGxhc3RfY29sdW1uOiBsYXN0X2NvbHVtbl9leGNsdXNpdmVcbiAgbGFzdF9saW5lX2V4Y2x1c2l2ZVxuICBsYXN0X2NvbHVtbl9leGNsdXNpdmVcbiAgcmFuZ2U6IFtlbmRSYW5nZSwgZW5kUmFuZ2VdXG59XG5cbmV4dHJhY3RTYW1lTGluZUxvY2F0aW9uRGF0YUZpcnN0ID0gKG51bUNoYXJzKSAtPiAoe3JhbmdlOiBbc3RhcnRSYW5nZV0sIGZpcnN0X2xpbmUsIGZpcnN0X2NvbHVtbn0pIC0+IHtcbiAgZmlyc3RfbGluZVxuICBmaXJzdF9jb2x1bW5cbiAgbGFzdF9saW5lOiBmaXJzdF9saW5lXG4gIGxhc3RfY29sdW1uOiBmaXJzdF9jb2x1bW4gKyBudW1DaGFycyAtIDFcbiAgbGFzdF9saW5lX2V4Y2x1c2l2ZTogZmlyc3RfbGluZVxuICBsYXN0X2NvbHVtbl9leGNsdXNpdmU6IGZpcnN0X2NvbHVtbiArIG51bUNoYXJzXG4gIHJhbmdlOiBbc3RhcnRSYW5nZSwgc3RhcnRSYW5nZSArIG51bUNoYXJzXVxufVxuXG5leHRyYWN0U2FtZUxpbmVMb2NhdGlvbkRhdGFMYXN0ID0gKG51bUNoYXJzKSAtPiAoe3JhbmdlOiBbLCBlbmRSYW5nZV0sIGxhc3RfbGluZSwgbGFzdF9jb2x1bW4sIGxhc3RfbGluZV9leGNsdXNpdmUsIGxhc3RfY29sdW1uX2V4Y2x1c2l2ZX0pIC0+IHtcbiAgZmlyc3RfbGluZTogbGFzdF9saW5lXG4gIGZpcnN0X2NvbHVtbjogbGFzdF9jb2x1bW4gLSAobnVtQ2hhcnMgLSAxKVxuICBsYXN0X2xpbmU6IGxhc3RfbGluZVxuICBsYXN0X2NvbHVtbjogbGFzdF9jb2x1bW5cbiAgbGFzdF9saW5lX2V4Y2x1c2l2ZVxuICBsYXN0X2NvbHVtbl9leGNsdXNpdmVcbiAgcmFuZ2U6IFtlbmRSYW5nZSAtIG51bUNoYXJzLCBlbmRSYW5nZV1cbn1cblxuIyBXZSBkb27igJl0IGN1cnJlbnRseSBoYXZlIGEgdG9rZW4gY29ycmVzcG9uZGluZyB0byB0aGUgZW1wdHkgc3BhY2VcbiMgYmV0d2VlbiBpbnRlcnBvbGF0aW9uL0pTWCBleHByZXNzaW9uIGJyYWNlcywgc28gcGllY2UgdG9nZXRoZXIgdGhlIGxvY2F0aW9uXG4jIGRhdGEgYnkgdHJpbW1pbmcgdGhlIGJyYWNlcyBmcm9tIHRoZSBJbnRlcnBvbGF0aW9u4oCZcyBsb2NhdGlvbiBkYXRhLlxuIyBUZWNobmljYWxseSB0aGUgbGFzdF9saW5lL2xhc3RfY29sdW1uIGNhbGN1bGF0aW9uIGhlcmUgY291bGQgYmVcbiMgaW5jb3JyZWN0IGlmIHRoZSBlbmRpbmcgYnJhY2UgaXMgcHJlY2VkZWQgYnkgYSBuZXdsaW5lLCBidXRcbiMgbGFzdF9saW5lL2xhc3RfY29sdW1uIGFyZW7igJl0IHVzZWQgZm9yIEFTVCBnZW5lcmF0aW9uIGFueXdheS5cbmVtcHR5RXhwcmVzc2lvbkxvY2F0aW9uRGF0YSA9ICh7aW50ZXJwb2xhdGlvbk5vZGU6IGVsZW1lbnQsIG9wZW5pbmdCcmFjZSwgY2xvc2luZ0JyYWNlfSkgLT5cbiAgZmlyc3RfbGluZTogICAgICAgICAgICBlbGVtZW50LmxvY2F0aW9uRGF0YS5maXJzdF9saW5lXG4gIGZpcnN0X2NvbHVtbjogICAgICAgICAgZWxlbWVudC5sb2NhdGlvbkRhdGEuZmlyc3RfY29sdW1uICsgb3BlbmluZ0JyYWNlLmxlbmd0aFxuICBsYXN0X2xpbmU6ICAgICAgICAgICAgIGVsZW1lbnQubG9jYXRpb25EYXRhLmxhc3RfbGluZVxuICBsYXN0X2NvbHVtbjogICAgICAgICAgIGVsZW1lbnQubG9jYXRpb25EYXRhLmxhc3RfY29sdW1uIC0gY2xvc2luZ0JyYWNlLmxlbmd0aFxuICBsYXN0X2xpbmVfZXhjbHVzaXZlOiAgIGVsZW1lbnQubG9jYXRpb25EYXRhLmxhc3RfbGluZVxuICBsYXN0X2NvbHVtbl9leGNsdXNpdmU6IGVsZW1lbnQubG9jYXRpb25EYXRhLmxhc3RfY29sdW1uXG4gIHJhbmdlOiBbXG4gICAgZWxlbWVudC5sb2NhdGlvbkRhdGEucmFuZ2VbMF0gKyBvcGVuaW5nQnJhY2UubGVuZ3RoXG4gICAgZWxlbWVudC5sb2NhdGlvbkRhdGEucmFuZ2VbMV0gLSBjbG9zaW5nQnJhY2UubGVuZ3RoXG4gIF1cbiJdfQ==
//# sourceURL=/home/flow/jzr/coffeescript/src/nodes.coffee