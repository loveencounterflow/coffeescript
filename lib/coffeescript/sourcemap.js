// Generated by CoffeeScript 2.7.0
(function() {
  // Source maps allow JavaScript runtimes to match running JavaScript back to
  // the original source code that corresponds to it. This can be minified
  // JavaScript, but in our case, we're concerned with mapping pretty-printed
  // JavaScript back to CoffeeScript.

  // In order to produce maps, we must keep track of positions (line number, column number)
  // that originated every node in the syntax tree, and be able to generate a
  // [map file](https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit)
  // — which is a compact, VLQ-encoded representation of the JSON serialization
  // of this information — to write out alongside the generated JavaScript.

  // LineMap
  // -------

  // A **LineMap** object keeps track of information about original line and column
  // positions for a single line of output JavaScript code.
  // **SourceMaps** are implemented in terms of **LineMaps**.
  var LineMap, SourceMap;

  LineMap = class LineMap {
    constructor(line1) {
      this.line = line1;
      this.columns = [];
    }

    add(column, [sourceLine, sourceColumn], options = {}) {
      if (this.columns[column] && options.noReplace) {
        return;
      }
      return this.columns[column] = {
        line: this.line,
        column,
        sourceLine,
        sourceColumn
      };
    }

    sourceLocation(column) {
      var mapping;
      while (!((mapping = this.columns[column]) || (column <= 0))) {
        column--;
      }
      return mapping && [mapping.sourceLine, mapping.sourceColumn];
    }

  };

  SourceMap = (function() {
    var BASE64_CHARS, VLQ_CONTINUATION_BIT, VLQ_SHIFT, VLQ_VALUE_MASK;

    // SourceMap
    // ---------

      // Maps locations in a single generated JavaScript file back to locations in
    // the original CoffeeScript source file.

      // This is intentionally agnostic towards how a source map might be represented on
    // disk. Once the compiler is ready to produce a "v3"-style source map, we can walk
    // through the arrays of line and column buffer to produce it.
    class SourceMap {
      constructor() {
        this.lines = [];
      }

      // Adds a mapping to this SourceMap. `sourceLocation` and `generatedLocation`
      // are both `[line, column]` arrays. If `options.noReplace` is true, then if there
      // is already a mapping for the specified `line` and `column`, this will have no
      // effect.
      add(sourceLocation, generatedLocation, options = {}) {
        var base, column, line, lineMap;
        [line, column] = generatedLocation;
        lineMap = ((base = this.lines)[line] || (base[line] = new LineMap(line)));
        return lineMap.add(column, sourceLocation, options);
      }

      // Look up the original position of a given `line` and `column` in the generated
      // code.
      sourceLocation([line, column]) {
        var lineMap;
        while (!((lineMap = this.lines[line]) || (line <= 0))) {
          line--;
        }
        return lineMap && lineMap.sourceLocation(column);
      }

      static registerCompiled(filename, source, sourcemap) {
        if (sourcemap != null) {
          return SourceMap.sourceMaps[filename] = sourcemap;
        }
      }

      static getSourceMap(filename) {
        return SourceMap.sourceMaps[filename];
      }

      // V3 SourceMap Generation
      // -----------------------

        // Builds up a V3 source map, returning the generated JSON as a string.
      // `options.sourceRoot` may be used to specify the sourceRoot written to the source
      // map.  Also, `options.sourceFiles` and `options.generatedFile` may be passed to
      // set "sources" and "file", respectively.
      generate(options = {}, code = null) {
        var buffer, i, j, lastColumn, lastSourceColumn, lastSourceLine, len, len1, lineMap, lineNumber, mapping, needComma, ref, ref1, sources, v3, writingline;
        writingline = 0;
        lastColumn = 0;
        lastSourceLine = 0;
        lastSourceColumn = 0;
        needComma = false;
        buffer = "";
        ref = this.lines;
        for (lineNumber = i = 0, len = ref.length; i < len; lineNumber = ++i) {
          lineMap = ref[lineNumber];
          if (lineMap) {
            ref1 = lineMap.columns;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              mapping = ref1[j];
              if (!(mapping)) {
                continue;
              }
              while (writingline < mapping.line) {
                lastColumn = 0;
                needComma = false;
                buffer += ";";
                writingline++;
              }
              // Write a comma if we've already written a segment on this line.
              if (needComma) {
                buffer += ",";
                needComma = false;
              }
              // Write the next segment. Segments can be 1, 4, or 5 values.  If just one, then it
              // is a generated column which doesn't match anything in the source code.

              // The starting column in the generated source, relative to any previous recorded
              // column for the current line:
              buffer += this.encodeVlq(mapping.column - lastColumn);
              lastColumn = mapping.column;
              // The index into the list of sources:
              buffer += this.encodeVlq(0);
              // The starting line in the original source, relative to the previous source line.
              buffer += this.encodeVlq(mapping.sourceLine - lastSourceLine);
              lastSourceLine = mapping.sourceLine;
              // The starting column in the original source, relative to the previous column.
              buffer += this.encodeVlq(mapping.sourceColumn - lastSourceColumn);
              lastSourceColumn = mapping.sourceColumn;
              needComma = true;
            }
          }
        }
        // Produce the canonical JSON object format for a "v3" source map.
        sources = options.sourceFiles ? options.sourceFiles : options.filename ? [options.filename] : ['<anonymous>'];
        v3 = {
          version: 3,
          file: options.generatedFile || '',
          sourceRoot: options.sourceRoot || '',
          sources: sources,
          names: [],
          mappings: buffer
        };
        if (options.sourceMap || options.inlineMap) {
          v3.sourcesContent = [code];
        }
        return v3;
      }

      encodeVlq(value) {
        var answer, nextChunk, signBit, valueToEncode;
        answer = '';
        // Least significant bit represents the sign.
        signBit = value < 0 ? 1 : 0;
        // The next bits are the actual value.
        valueToEncode = (Math.abs(value) << 1) + signBit;
        // Make sure we encode at least one character, even if valueToEncode is 0.
        while (valueToEncode || !answer) {
          nextChunk = valueToEncode & VLQ_VALUE_MASK;
          valueToEncode = valueToEncode >> VLQ_SHIFT;
          if (valueToEncode) {
            nextChunk |= VLQ_CONTINUATION_BIT;
          }
          answer += this.encodeBase64(nextChunk);
        }
        return answer;
      }

      encodeBase64(value) {
        return BASE64_CHARS[value] || (function() {
          throw new Error(`Cannot Base64 encode value: ${value}`);
        })();
      }

    };

    // Caching
    // -------

    // A static source maps cache `filename`: `map`. These are used for transforming
    // stack traces and are currently set in `CoffeeScript.compile` for all files
    // compiled with the source maps option.
    SourceMap.sourceMaps = Object.create(null);

    // Base64 VLQ Encoding
    // -------------------

    // Note that SourceMap VLQ encoding is "backwards".  MIDI-style VLQ encoding puts
    // the most-significant-bit (MSB) from the original value into the MSB of the VLQ
    // encoded value (see [Wikipedia](https://en.wikipedia.org/wiki/File:Uintvar_coding.svg)).
    // SourceMap VLQ does things the other way around, with the least significat four
    // bits of the original value encoded into the first byte of the VLQ encoded value.
    VLQ_SHIFT = 5;

    VLQ_CONTINUATION_BIT = 1 << VLQ_SHIFT; // 0010 0000

    VLQ_VALUE_MASK = VLQ_CONTINUATION_BIT - 1; // 0001 1111

    // Regular Base64 Encoding
    // -----------------------
    BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

    return SourceMap;

  }).call(this);

  // Our API for source maps is just the `SourceMap` class.
  module.exports = SourceMap;

}).call(this);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic291cmNlbWFwLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uLyIsInNvdXJjZXMiOlsic3JjL3NvdXJjZW1hcC5saXRjb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQWlCMEQ7RUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFBLE9BQUEsRUFBQTs7RUFFaEQsVUFBTixNQUFBLFFBQUE7SUFDRSxXQUFhLE1BQUEsQ0FBQTtNQUFDLElBQUMsQ0FBQTtNQUNiLElBQUMsQ0FBQSxPQUFELEdBQVc7SUFEQTs7SUFHYixHQUFLLENBQUMsTUFBRCxFQUFTLENBQUMsVUFBRCxFQUFhLFlBQWIsQ0FBVCxFQUFxQyxVQUFRLENBQUEsQ0FBN0MsQ0FBQTtNQUNILElBQVUsSUFBQyxDQUFBLE9BQU8sQ0FBQyxNQUFELENBQVIsSUFBcUIsT0FBTyxDQUFDLFNBQXZDO0FBQUEsZUFBQTs7YUFDQSxJQUFDLENBQUEsT0FBTyxDQUFDLE1BQUQsQ0FBUixHQUFtQjtRQUFDLElBQUEsRUFBTSxJQUFDLENBQUEsSUFBUjtRQUFjLE1BQWQ7UUFBc0IsVUFBdEI7UUFBa0M7TUFBbEM7SUFGaEI7O0lBSUwsY0FBZ0IsQ0FBQyxNQUFELENBQUE7QUFDdEIsVUFBQTtBQUFRLGVBQWUsQ0FBQyxPQUFBLEdBQVUsSUFBQyxDQUFBLE9BQU8sQ0FBQyxNQUFELENBQW5CLENBQUEsSUFBZ0MsQ0FBQyxNQUFBLElBQVUsQ0FBWCxFQUEvQztRQUFBLE1BQUE7TUFBQTthQUNBLE9BQUEsSUFBWSxDQUFDLE9BQU8sQ0FBQyxVQUFULEVBQXFCLE9BQU8sQ0FBQyxZQUE3QjtJQUZFOztFQVJsQjs7RUF1Qk07Ozs7Ozs7Ozs7OztJQUFOLE1BQUEsVUFBQTtNQUNFLFdBQWEsQ0FBQSxDQUFBO1FBQ1gsSUFBQyxDQUFBLEtBQUQsR0FBUztNQURFLENBQW5COzs7Ozs7TUFRTSxHQUFLLENBQUMsY0FBRCxFQUFpQixpQkFBakIsRUFBb0MsVUFBVSxDQUFBLENBQTlDLENBQUE7QUFDWCxZQUFBLElBQUEs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LEdBQWlCO0FBdExxQyIsInNvdXJjZXNDb250ZW50IjpbIlNvdXJjZSBtYXBzIGFsbG93IEphdmFTY3JpcHQgcnVudGltZXMgdG8gbWF0Y2ggcnVubmluZyBKYXZhU2NyaXB0IGJhY2sgdG9cbnRoZSBvcmlnaW5hbCBzb3VyY2UgY29kZSB0aGF0IGNvcnJlc3BvbmRzIHRvIGl0LiBUaGlzIGNhbiBiZSBtaW5pZmllZFxuSmF2YVNjcmlwdCwgYnV0IGluIG91ciBjYXNlLCB3ZSdyZSBjb25jZXJuZWQgd2l0aCBtYXBwaW5nIHByZXR0eS1wcmludGVkXG5KYXZhU2NyaXB0IGJhY2sgdG8gQ29mZmVlU2NyaXB0LlxuXG5JbiBvcmRlciB0byBwcm9kdWNlIG1hcHMsIHdlIG11c3Qga2VlcCB0cmFjayBvZiBwb3NpdGlvbnMgKGxpbmUgbnVtYmVyLCBjb2x1bW4gbnVtYmVyKVxudGhhdCBvcmlnaW5hdGVkIGV2ZXJ5IG5vZGUgaW4gdGhlIHN5bnRheCB0cmVlLCBhbmQgYmUgYWJsZSB0byBnZW5lcmF0ZSBhXG5bbWFwIGZpbGVdKGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdClcbuKAlCB3aGljaCBpcyBhIGNvbXBhY3QsIFZMUS1lbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBKU09OIHNlcmlhbGl6YXRpb25cbm9mIHRoaXMgaW5mb3JtYXRpb24g4oCUIHRvIHdyaXRlIG91dCBhbG9uZ3NpZGUgdGhlIGdlbmVyYXRlZCBKYXZhU2NyaXB0LlxuXG5cbkxpbmVNYXBcbi0tLS0tLS1cblxuQSAqKkxpbmVNYXAqKiBvYmplY3Qga2VlcHMgdHJhY2sgb2YgaW5mb3JtYXRpb24gYWJvdXQgb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uXG5wb3NpdGlvbnMgZm9yIGEgc2luZ2xlIGxpbmUgb2Ygb3V0cHV0IEphdmFTY3JpcHQgY29kZS5cbioqU291cmNlTWFwcyoqIGFyZSBpbXBsZW1lbnRlZCBpbiB0ZXJtcyBvZiAqKkxpbmVNYXBzKiouXG5cbiAgICBjbGFzcyBMaW5lTWFwXG4gICAgICBjb25zdHJ1Y3RvcjogKEBsaW5lKSAtPlxuICAgICAgICBAY29sdW1ucyA9IFtdXG5cbiAgICAgIGFkZDogKGNvbHVtbiwgW3NvdXJjZUxpbmUsIHNvdXJjZUNvbHVtbl0sIG9wdGlvbnM9e30pIC0+XG4gICAgICAgIHJldHVybiBpZiBAY29sdW1uc1tjb2x1bW5dIGFuZCBvcHRpb25zLm5vUmVwbGFjZVxuICAgICAgICBAY29sdW1uc1tjb2x1bW5dID0ge2xpbmU6IEBsaW5lLCBjb2x1bW4sIHNvdXJjZUxpbmUsIHNvdXJjZUNvbHVtbn1cblxuICAgICAgc291cmNlTG9jYXRpb246IChjb2x1bW4pIC0+XG4gICAgICAgIGNvbHVtbi0tIHVudGlsIChtYXBwaW5nID0gQGNvbHVtbnNbY29sdW1uXSkgb3IgKGNvbHVtbiA8PSAwKVxuICAgICAgICBtYXBwaW5nIGFuZCBbbWFwcGluZy5zb3VyY2VMaW5lLCBtYXBwaW5nLnNvdXJjZUNvbHVtbl1cblxuXG5Tb3VyY2VNYXBcbi0tLS0tLS0tLVxuXG5NYXBzIGxvY2F0aW9ucyBpbiBhIHNpbmdsZSBnZW5lcmF0ZWQgSmF2YVNjcmlwdCBmaWxlIGJhY2sgdG8gbG9jYXRpb25zIGluXG50aGUgb3JpZ2luYWwgQ29mZmVlU2NyaXB0IHNvdXJjZSBmaWxlLlxuXG5UaGlzIGlzIGludGVudGlvbmFsbHkgYWdub3N0aWMgdG93YXJkcyBob3cgYSBzb3VyY2UgbWFwIG1pZ2h0IGJlIHJlcHJlc2VudGVkIG9uXG5kaXNrLiBPbmNlIHRoZSBjb21waWxlciBpcyByZWFkeSB0byBwcm9kdWNlIGEgXCJ2M1wiLXN0eWxlIHNvdXJjZSBtYXAsIHdlIGNhbiB3YWxrXG50aHJvdWdoIHRoZSBhcnJheXMgb2YgbGluZSBhbmQgY29sdW1uIGJ1ZmZlciB0byBwcm9kdWNlIGl0LlxuXG4gICAgY2xhc3MgU291cmNlTWFwXG4gICAgICBjb25zdHJ1Y3RvcjogLT5cbiAgICAgICAgQGxpbmVzID0gW11cblxuQWRkcyBhIG1hcHBpbmcgdG8gdGhpcyBTb3VyY2VNYXAuIGBzb3VyY2VMb2NhdGlvbmAgYW5kIGBnZW5lcmF0ZWRMb2NhdGlvbmBcbmFyZSBib3RoIGBbbGluZSwgY29sdW1uXWAgYXJyYXlzLiBJZiBgb3B0aW9ucy5ub1JlcGxhY2VgIGlzIHRydWUsIHRoZW4gaWYgdGhlcmVcbmlzIGFscmVhZHkgYSBtYXBwaW5nIGZvciB0aGUgc3BlY2lmaWVkIGBsaW5lYCBhbmQgYGNvbHVtbmAsIHRoaXMgd2lsbCBoYXZlIG5vXG5lZmZlY3QuXG5cbiAgICAgIGFkZDogKHNvdXJjZUxvY2F0aW9uLCBnZW5lcmF0ZWRMb2NhdGlvbiwgb3B0aW9ucyA9IHt9KSAtPlxuICAgICAgICBbbGluZSwgY29sdW1uXSA9IGdlbmVyYXRlZExvY2F0aW9uXG4gICAgICAgIGxpbmVNYXAgPSAoQGxpbmVzW2xpbmVdIG9yPSBuZXcgTGluZU1hcChsaW5lKSlcbiAgICAgICAgbGluZU1hcC5hZGQgY29sdW1uLCBzb3VyY2VMb2NhdGlvbiwgb3B0aW9uc1xuXG5Mb29rIHVwIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBvZiBhIGdpdmVuIGBsaW5lYCBhbmQgYGNvbHVtbmAgaW4gdGhlIGdlbmVyYXRlZFxuY29kZS5cblxuICAgICAgc291cmNlTG9jYXRpb246IChbbGluZSwgY29sdW1uXSkgLT5cbiAgICAgICAgbGluZS0tIHVudGlsIChsaW5lTWFwID0gQGxpbmVzW2xpbmVdKSBvciAobGluZSA8PSAwKVxuICAgICAgICBsaW5lTWFwIGFuZCBsaW5lTWFwLnNvdXJjZUxvY2F0aW9uIGNvbHVtblxuXG5DYWNoaW5nXG4tLS0tLS0tXG5cbkEgc3RhdGljIHNvdXJjZSBtYXBzIGNhY2hlIGBmaWxlbmFtZWA6IGBtYXBgLiBUaGVzZSBhcmUgdXNlZCBmb3IgdHJhbnNmb3JtaW5nXG5zdGFjayB0cmFjZXMgYW5kIGFyZSBjdXJyZW50bHkgc2V0IGluIGBDb2ZmZWVTY3JpcHQuY29tcGlsZWAgZm9yIGFsbCBmaWxlc1xuY29tcGlsZWQgd2l0aCB0aGUgc291cmNlIG1hcHMgb3B0aW9uLlxuXG4gICAgICBAc291cmNlTWFwczogT2JqZWN0LmNyZWF0ZSBudWxsXG5cbiAgICAgIEByZWdpc3RlckNvbXBpbGVkOiAoZmlsZW5hbWUsIHNvdXJjZSwgc291cmNlbWFwKSA9PlxuICAgICAgICBpZiBzb3VyY2VtYXA/XG4gICAgICAgICAgQHNvdXJjZU1hcHNbZmlsZW5hbWVdID0gc291cmNlbWFwXG5cbiAgICAgIEBnZXRTb3VyY2VNYXA6IChmaWxlbmFtZSkgPT5cbiAgICAgICAgQHNvdXJjZU1hcHNbZmlsZW5hbWVdXG5cblxuVjMgU291cmNlTWFwIEdlbmVyYXRpb25cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbkJ1aWxkcyB1cCBhIFYzIHNvdXJjZSBtYXAsIHJldHVybmluZyB0aGUgZ2VuZXJhdGVkIEpTT04gYXMgYSBzdHJpbmcuXG5gb3B0aW9ucy5zb3VyY2VSb290YCBtYXkgYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSBzb3VyY2VSb290IHdyaXR0ZW4gdG8gdGhlIHNvdXJjZVxubWFwLiAgQWxzbywgYG9wdGlvbnMuc291cmNlRmlsZXNgIGFuZCBgb3B0aW9ucy5nZW5lcmF0ZWRGaWxlYCBtYXkgYmUgcGFzc2VkIHRvXG5zZXQgXCJzb3VyY2VzXCIgYW5kIFwiZmlsZVwiLCByZXNwZWN0aXZlbHkuXG5cbiAgICAgIGdlbmVyYXRlOiAob3B0aW9ucyA9IHt9LCBjb2RlID0gbnVsbCkgLT5cbiAgICAgICAgd3JpdGluZ2xpbmUgICAgICAgPSAwXG4gICAgICAgIGxhc3RDb2x1bW4gICAgICAgID0gMFxuICAgICAgICBsYXN0U291cmNlTGluZSAgICA9IDBcbiAgICAgICAgbGFzdFNvdXJjZUNvbHVtbiAgPSAwXG4gICAgICAgIG5lZWRDb21tYSAgICAgICAgID0gbm9cbiAgICAgICAgYnVmZmVyICAgICAgICAgICAgPSBcIlwiXG5cbiAgICAgICAgZm9yIGxpbmVNYXAsIGxpbmVOdW1iZXIgaW4gQGxpbmVzIHdoZW4gbGluZU1hcFxuICAgICAgICAgIGZvciBtYXBwaW5nIGluIGxpbmVNYXAuY29sdW1ucyB3aGVuIG1hcHBpbmdcbiAgICAgICAgICAgIHdoaWxlIHdyaXRpbmdsaW5lIDwgbWFwcGluZy5saW5lXG4gICAgICAgICAgICAgIGxhc3RDb2x1bW4gPSAwXG4gICAgICAgICAgICAgIG5lZWRDb21tYSA9IG5vXG4gICAgICAgICAgICAgIGJ1ZmZlciArPSBcIjtcIlxuICAgICAgICAgICAgICB3cml0aW5nbGluZSsrXG5cbldyaXRlIGEgY29tbWEgaWYgd2UndmUgYWxyZWFkeSB3cml0dGVuIGEgc2VnbWVudCBvbiB0aGlzIGxpbmUuXG5cbiAgICAgICAgICAgIGlmIG5lZWRDb21tYVxuICAgICAgICAgICAgICBidWZmZXIgKz0gXCIsXCJcbiAgICAgICAgICAgICAgbmVlZENvbW1hID0gbm9cblxuV3JpdGUgdGhlIG5leHQgc2VnbWVudC4gU2VnbWVudHMgY2FuIGJlIDEsIDQsIG9yIDUgdmFsdWVzLiAgSWYganVzdCBvbmUsIHRoZW4gaXRcbmlzIGEgZ2VuZXJhdGVkIGNvbHVtbiB3aGljaCBkb2Vzbid0IG1hdGNoIGFueXRoaW5nIGluIHRoZSBzb3VyY2UgY29kZS5cblxuVGhlIHN0YXJ0aW5nIGNvbHVtbiBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgcmVsYXRpdmUgdG8gYW55IHByZXZpb3VzIHJlY29yZGVkXG5jb2x1bW4gZm9yIHRoZSBjdXJyZW50IGxpbmU6XG5cbiAgICAgICAgICAgIGJ1ZmZlciArPSBAZW5jb2RlVmxxIG1hcHBpbmcuY29sdW1uIC0gbGFzdENvbHVtblxuICAgICAgICAgICAgbGFzdENvbHVtbiA9IG1hcHBpbmcuY29sdW1uXG5cblRoZSBpbmRleCBpbnRvIHRoZSBsaXN0IG9mIHNvdXJjZXM6XG5cbiAgICAgICAgICAgIGJ1ZmZlciArPSBAZW5jb2RlVmxxIDBcblxuVGhlIHN0YXJ0aW5nIGxpbmUgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgcmVsYXRpdmUgdG8gdGhlIHByZXZpb3VzIHNvdXJjZSBsaW5lLlxuXG4gICAgICAgICAgICBidWZmZXIgKz0gQGVuY29kZVZscSBtYXBwaW5nLnNvdXJjZUxpbmUgLSBsYXN0U291cmNlTGluZVxuICAgICAgICAgICAgbGFzdFNvdXJjZUxpbmUgPSBtYXBwaW5nLnNvdXJjZUxpbmVcblxuVGhlIHN0YXJ0aW5nIGNvbHVtbiBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgY29sdW1uLlxuXG4gICAgICAgICAgICBidWZmZXIgKz0gQGVuY29kZVZscSBtYXBwaW5nLnNvdXJjZUNvbHVtbiAtIGxhc3RTb3VyY2VDb2x1bW5cbiAgICAgICAgICAgIGxhc3RTb3VyY2VDb2x1bW4gPSBtYXBwaW5nLnNvdXJjZUNvbHVtblxuICAgICAgICAgICAgbmVlZENvbW1hID0geWVzXG5cblByb2R1Y2UgdGhlIGNhbm9uaWNhbCBKU09OIG9iamVjdCBmb3JtYXQgZm9yIGEgXCJ2M1wiIHNvdXJjZSBtYXAuXG5cbiAgICAgICAgc291cmNlcyA9IGlmIG9wdGlvbnMuc291cmNlRmlsZXNcbiAgICAgICAgICBvcHRpb25zLnNvdXJjZUZpbGVzXG4gICAgICAgIGVsc2UgaWYgb3B0aW9ucy5maWxlbmFtZVxuICAgICAgICAgIFtvcHRpb25zLmZpbGVuYW1lXVxuICAgICAgICBlbHNlXG4gICAgICAgICAgWyc8YW5vbnltb3VzPiddXG5cbiAgICAgICAgdjMgPVxuICAgICAgICAgIHZlcnNpb246ICAgIDNcbiAgICAgICAgICBmaWxlOiAgICAgICBvcHRpb25zLmdlbmVyYXRlZEZpbGUgb3IgJydcbiAgICAgICAgICBzb3VyY2VSb290OiBvcHRpb25zLnNvdXJjZVJvb3Qgb3IgJydcbiAgICAgICAgICBzb3VyY2VzOiAgICBzb3VyY2VzXG4gICAgICAgICAgbmFtZXM6ICAgICAgW11cbiAgICAgICAgICBtYXBwaW5nczogICBidWZmZXJcblxuICAgICAgICB2My5zb3VyY2VzQ29udGVudCA9IFtjb2RlXSBpZiBvcHRpb25zLnNvdXJjZU1hcCBvciBvcHRpb25zLmlubGluZU1hcFxuXG4gICAgICAgIHYzXG5cblxuQmFzZTY0IFZMUSBFbmNvZGluZ1xuLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5Ob3RlIHRoYXQgU291cmNlTWFwIFZMUSBlbmNvZGluZyBpcyBcImJhY2t3YXJkc1wiLiAgTUlESS1zdHlsZSBWTFEgZW5jb2RpbmcgcHV0c1xudGhlIG1vc3Qtc2lnbmlmaWNhbnQtYml0IChNU0IpIGZyb20gdGhlIG9yaWdpbmFsIHZhbHVlIGludG8gdGhlIE1TQiBvZiB0aGUgVkxRXG5lbmNvZGVkIHZhbHVlIChzZWUgW1dpa2lwZWRpYV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlsZTpVaW50dmFyX2NvZGluZy5zdmcpKS5cblNvdXJjZU1hcCBWTFEgZG9lcyB0aGluZ3MgdGhlIG90aGVyIHdheSBhcm91bmQsIHdpdGggdGhlIGxlYXN0IHNpZ25pZmljYXQgZm91clxuYml0cyBvZiB0aGUgb3JpZ2luYWwgdmFsdWUgZW5jb2RlZCBpbnRvIHRoZSBmaXJzdCBieXRlIG9mIHRoZSBWTFEgZW5jb2RlZCB2YWx1ZS5cblxuICAgICAgVkxRX1NISUZUICAgICAgICAgICAgPSA1XG4gICAgICBWTFFfQ09OVElOVUFUSU9OX0JJVCA9IDEgPDwgVkxRX1NISUZUICAgICAgICAgICAgICMgMDAxMCAwMDAwXG4gICAgICBWTFFfVkFMVUVfTUFTSyAgICAgICA9IFZMUV9DT05USU5VQVRJT05fQklUIC0gMSAgICMgMDAwMSAxMTExXG5cbiAgICAgIGVuY29kZVZscTogKHZhbHVlKSAtPlxuICAgICAgICBhbnN3ZXIgPSAnJ1xuXG4gICAgICAgICMgTGVhc3Qgc2lnbmlmaWNhbnQgYml0IHJlcHJlc2VudHMgdGhlIHNpZ24uXG4gICAgICAgIHNpZ25CaXQgPSBpZiB2YWx1ZSA8IDAgdGhlbiAxIGVsc2UgMFxuXG4gICAgICAgICMgVGhlIG5leHQgYml0cyBhcmUgdGhlIGFjdHVhbCB2YWx1ZS5cbiAgICAgICAgdmFsdWVUb0VuY29kZSA9IChNYXRoLmFicyh2YWx1ZSkgPDwgMSkgKyBzaWduQml0XG5cbiAgICAgICAgIyBNYWtlIHN1cmUgd2UgZW5jb2RlIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIsIGV2ZW4gaWYgdmFsdWVUb0VuY29kZSBpcyAwLlxuICAgICAgICB3aGlsZSB2YWx1ZVRvRW5jb2RlIG9yIG5vdCBhbnN3ZXJcbiAgICAgICAgICBuZXh0Q2h1bmsgPSB2YWx1ZVRvRW5jb2RlICYgVkxRX1ZBTFVFX01BU0tcbiAgICAgICAgICB2YWx1ZVRvRW5jb2RlID0gdmFsdWVUb0VuY29kZSA+PiBWTFFfU0hJRlRcbiAgICAgICAgICBuZXh0Q2h1bmsgfD0gVkxRX0NPTlRJTlVBVElPTl9CSVQgaWYgdmFsdWVUb0VuY29kZVxuICAgICAgICAgIGFuc3dlciArPSBAZW5jb2RlQmFzZTY0IG5leHRDaHVua1xuXG4gICAgICAgIGFuc3dlclxuXG5cblJlZ3VsYXIgQmFzZTY0IEVuY29kaW5nXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICBCQVNFNjRfQ0hBUlMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcblxuICAgICAgZW5jb2RlQmFzZTY0OiAodmFsdWUpIC0+XG4gICAgICAgIEJBU0U2NF9DSEFSU1t2YWx1ZV0gb3IgdGhyb3cgbmV3IEVycm9yIFwiQ2Fubm90IEJhc2U2NCBlbmNvZGUgdmFsdWU6ICN7dmFsdWV9XCJcblxuXG5PdXIgQVBJIGZvciBzb3VyY2UgbWFwcyBpcyBqdXN0IHRoZSBgU291cmNlTWFwYCBjbGFzcy5cblxuICAgIG1vZHVsZS5leHBvcnRzID0gU291cmNlTWFwXG4iXX0=
//# sourceURL=/home/flow/jzr/coffeescript/src/sourcemap.litcoffee