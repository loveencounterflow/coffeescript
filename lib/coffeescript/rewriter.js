// Generated by CoffeeScript 2.7.0
(function() {
  // The CoffeeScript language has a good deal of optional syntax, implicit syntax,
  // and shorthand syntax. This can greatly complicate a grammar and bloat
  // the resulting parse table. Instead of making the parser handle it all, we take
  // a series of passes over the token stream, using this **Rewriter** to convert
  // shorthand into the unambiguous long form, add implicit indentation and
  // parentheses, and generally clean things up.
  var BALANCED_PAIRS, CALL_CLOSERS, CONTROL_IN_IMPLICIT, DISCARDED, EXPRESSION_CLOSE, EXPRESSION_END, EXPRESSION_START, IMPLICIT_CALL, IMPLICIT_END, IMPLICIT_FUNC, IMPLICIT_UNSPACED_CALL, INVERSES, LINEBREAKS, Rewriter, SINGLE_CLOSERS, SINGLE_LINERS, UNFINISHED, extractAllCommentTokens, generate, k, left, len, moveComments, right, throwSyntaxError,
    indexOf = [].indexOf,
    hasProp = {}.hasOwnProperty;

  ({throwSyntaxError, extractAllCommentTokens} = require('./helpers'));

  // Move attached comments from one token to another.
  moveComments = function(fromToken, toToken) {
    var comment, k, len, ref, unshiftedComments;
    if (!fromToken.comments) {
      return;
    }
    if (toToken.comments && toToken.comments.length !== 0) {
      unshiftedComments = [];
      ref = fromToken.comments;
      for (k = 0, len = ref.length; k < len; k++) {
        comment = ref[k];
        if (comment.unshift) {
          unshiftedComments.push(comment);
        } else {
          toToken.comments.push(comment);
        }
      }
      toToken.comments = unshiftedComments.concat(toToken.comments);
    } else {
      toToken.comments = fromToken.comments;
    }
    return delete fromToken.comments;
  };

  // Create a generated token: one that exists due to a use of implicit syntax.
  // Optionally have this new token take the attached comments from another token.
  generate = function(tag, value, origin, commentsToken) {
    var token;
    token = [tag, value];
    token.generated = true;
    if (origin) {
      token.origin = origin;
    }
    if (commentsToken) {
      moveComments(commentsToken, token);
    }
    return token;
  };

  // The **Rewriter** class is used by the [Lexer](lexer.html), directly against
  // its internal array of tokens.
  exports.Rewriter = Rewriter = (function() {
    class Rewriter {
      // Rewrite the token stream in multiple passes, one logical filter at
      // a time. This could certainly be changed into a single pass through the
      // stream, with a big ol’ efficient switch, but it’s much nicer to work with
      // like this. The order of these passes matters—indentation must be
      // corrected before implicit parentheses can be wrapped around blocks of code.
      rewrite(tokens1) {
        var ref, ref1, t;
        this.tokens = tokens1;
        // Set environment variable `DEBUG_TOKEN_STREAM` to `true` to output token
        // debugging info. Also set `DEBUG_REWRITTEN_TOKEN_STREAM` to `true` to
        // output the token stream after it has been rewritten by this file.
        if (typeof process !== "undefined" && process !== null ? (ref = process.env) != null ? ref.DEBUG_TOKEN_STREAM : void 0 : void 0) {
          if (process.env.DEBUG_REWRITTEN_TOKEN_STREAM) {
            console.log('Initial token stream:');
          }
          console.log(((function() {
            var k, len, ref1, results;
            ref1 = this.tokens;
            results = [];
            for (k = 0, len = ref1.length; k < len; k++) {
              t = ref1[k];
              results.push(t[0] + '/' + t[1] + (t.comments ? '*' : ''));
            }
            return results;
          }).call(this)).join(' '));
        }
        this.removeLeadingNewlines();
        this.closeOpenCalls();
        this.closeOpenIndexes();
        this.normalizeLines();
        this.tagPostfixConditionals();
        this.addImplicitBracesAndParens();
        this.rescueStowawayComments();
        this.addLocationDataToGeneratedTokens();
        this.enforceValidJSXAttributes();
        this.fixIndentationLocationData();
        this.exposeTokenDataToGrammar();
        if (typeof process !== "undefined" && process !== null ? (ref1 = process.env) != null ? ref1.DEBUG_REWRITTEN_TOKEN_STREAM : void 0 : void 0) {
          if (process.env.DEBUG_TOKEN_STREAM) {
            console.log('Rewritten token stream:');
          }
          console.log(((function() {
            var k, len, ref2, results;
            ref2 = this.tokens;
            results = [];
            for (k = 0, len = ref2.length; k < len; k++) {
              t = ref2[k];
              results.push(t[0] + '/' + t[1] + (t.comments ? '*' : ''));
            }
            return results;
          }).call(this)).join(' '));
        }
        return this.tokens;
      }

      // Rewrite the token stream, looking one token ahead and behind.
      // Allow the return value of the block to tell us how many tokens to move
      // forwards (or backwards) in the stream, to make sure we don’t miss anything
      // as tokens are inserted and removed, and the stream changes length under
      // our feet.
      scanTokens(block) {
        var i, token, tokens;
        ({tokens} = this);
        i = 0;
        while (token = tokens[i]) {
          i += block.call(this, token, i, tokens);
        }
        return true;
      }

      detectEnd(i, condition, action, opts = {}) {
        var levels, ref, ref1, token, tokens;
        ({tokens} = this);
        levels = 0;
        while (token = tokens[i]) {
          if (levels === 0 && condition.call(this, token, i)) {
            return action.call(this, token, i);
          }
          if (ref = token[0], indexOf.call(EXPRESSION_START, ref) >= 0) {
            levels += 1;
          } else if (ref1 = token[0], indexOf.call(EXPRESSION_END, ref1) >= 0) {
            levels -= 1;
          }
          if (levels < 0) {
            if (opts.returnOnNegativeLevel) {
              return;
            }
            return action.call(this, token, i);
          }
          i += 1;
        }
        return i - 1;
      }

      // Leading newlines would introduce an ambiguity in the grammar, so we
      // dispatch them here.
      removeLeadingNewlines() {
        var i, k, l, leadingNewlineToken, len, len1, ref, ref1, tag;
        ref = this.tokens;
        for (i = k = 0, len = ref.length; k < len; i = ++k) {
          [tag] = ref[i];
          if (tag !== 'TERMINATOR') {
            // Find the index of the first non-`TERMINATOR` token.
            break;
          }
        }
        if (i === 0) {
          return;
        }
        ref1 = this.tokens.slice(0, i);
        // If there are any comments attached to the tokens we’re about to discard,
        // shift them forward to what will become the new first token.
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          leadingNewlineToken = ref1[l];
          moveComments(leadingNewlineToken, this.tokens[i]);
        }
        // Discard all the leading newline tokens.
        return this.tokens.splice(0, i);
      }

      // The lexer has tagged the opening parenthesis of a method call. Match it with
      // its paired close.
      closeOpenCalls() {
        var action, condition;
        condition = function(token, i) {
          var ref;
          return (ref = token[0]) === ')' || ref === 'CALL_END';
        };
        action = function(token, i) {
          return token[0] = 'CALL_END';
        };
        return this.scanTokens(function(token, i) {
          if (token[0] === 'CALL_START') {
            this.detectEnd(i + 1, condition, action);
          }
          return 1;
        });
      }

      // The lexer has tagged the opening bracket of an indexing operation call.
      // Match it with its paired close.
      closeOpenIndexes() {
        var action, condition, startToken;
        startToken = null;
        condition = function(token, i) {
          var ref;
          return (ref = token[0]) === ']' || ref === 'INDEX_END';
        };
        action = function(token, i) {
          if (this.tokens.length >= i && this.tokens[i + 1][0] === ':') {
            startToken[0] = '[';
            return token[0] = ']';
          } else {
            return token[0] = 'INDEX_END';
          }
        };
        return this.scanTokens(function(token, i) {
          if (token[0] === 'INDEX_START') {
            startToken = token;
            this.detectEnd(i + 1, condition, action);
          }
          return 1;
        });
      }

      // Match tags in token stream starting at `i` with `pattern`.
      // `pattern` may consist of strings (equality), an array of strings (one of)
      // or null (wildcard). Returns the index of the match or -1 if no match.
      indexOfTag(i, ...pattern) {
        var fuzz, j, k, ref, ref1;
        fuzz = 0;
        for (j = k = 0, ref = pattern.length; (0 <= ref ? k < ref : k > ref); j = 0 <= ref ? ++k : --k) {
          if (pattern[j] == null) {
            continue;
          }
          if (typeof pattern[j] === 'string') {
            pattern[j] = [pattern[j]];
          }
          if (ref1 = this.tag(i + j + fuzz), indexOf.call(pattern[j], ref1) < 0) {
            return -1;
          }
        }
        return i + j + fuzz - 1;
      }

      // Returns `yes` if standing in front of something looking like
      // `@<x>:`, `<x>:` or `<EXPRESSION_START><x>...<EXPRESSION_END>:`.
      looksObjectish(j) {
        var end, index;
        if (this.indexOfTag(j, '@', null, ':') !== -1 || this.indexOfTag(j, null, ':') !== -1) {
          return true;
        }
        index = this.indexOfTag(j, EXPRESSION_START);
        if (index !== -1) {
          end = null;
          this.detectEnd(index + 1, (function(token) {
            var ref;
            return ref = token[0], indexOf.call(EXPRESSION_END, ref) >= 0;
          }), (function(token, i) {
            return end = i;
          }));
          if (this.tag(end + 1) === ':') {
            return true;
          }
        }
        return false;
      }

      // Returns `yes` if current line of tokens contain an element of tags on same
      // expression level. Stop searching at `LINEBREAKS` or explicit start of
      // containing balanced expression.
      findTagsBackwards(i, tags) {
        var backStack, ref, ref1, ref2, ref3, ref4, ref5;
        backStack = [];
        while (i >= 0 && (backStack.length || (ref2 = this.tag(i), indexOf.call(tags, ref2) < 0) && ((ref3 = this.tag(i), indexOf.call(EXPRESSION_START, ref3) < 0) || this.tokens[i].generated) && (ref4 = this.tag(i), indexOf.call(LINEBREAKS, ref4) < 0))) {
          if (ref = this.tag(i), indexOf.call(EXPRESSION_END, ref) >= 0) {
            backStack.push(this.tag(i));
          }
          if ((ref1 = this.tag(i), indexOf.call(EXPRESSION_START, ref1) >= 0) && backStack.length) {
            backStack.pop();
          }
          i -= 1;
        }
        return ref5 = this.tag(i), indexOf.call(tags, ref5) >= 0;
      }

      // Look for signs of implicit calls and objects in the token stream and
      // add them.
      addImplicitBracesAndParens() {
        var stack, start;
        // Track current balancing depth (both implicit and explicit) on stack.
        stack = [];
        start = null;
        return this.scanTokens(function(token, i, tokens) {
          var endImplicitCall, endImplicitObject, forward, implicitObjectContinues, implicitObjectIndent, inControlFlow, inImplicit, inImplicitCall, inImplicitControl, inImplicitObject, isImplicit, isImplicitCall, isImplicitObject, k, newLine, nextTag, nextToken, offset, preContinuationLineIndent, preObjectToken, prevTag, prevToken, ref, ref1, ref2, ref3, ref4, ref5, s, sameLine, stackIdx, stackItem, stackNext, stackTag, stackTop, startIdx, startImplicitCall, startImplicitObject, startIndex, startTag, startsLine, tag;
          [tag] = token;
          [prevTag] = prevToken = i > 0 ? tokens[i - 1] : [];
          [nextTag] = nextToken = i < tokens.length - 1 ? tokens[i + 1] : [];
          stackTop = function() {
            return stack[stack.length - 1];
          };
          startIdx = i;
          // Helper function, used for keeping track of the number of tokens consumed
          // and spliced, when returning for getting a new token.
          forward = function(n) {
            return i - startIdx + n;
          };
          // Helper functions
          isImplicit = function(stackItem) {
            var ref;
            return stackItem != null ? (ref = stackItem[2]) != null ? ref.ours : void 0 : void 0;
          };
          isImplicitObject = function(stackItem) {
            return isImplicit(stackItem) && (stackItem != null ? stackItem[0] : void 0) === '{';
          };
          isImplicitCall = function(stackItem) {
            return isImplicit(stackItem) && (stackItem != null ? stackItem[0] : void 0) === '(';
          };
          inImplicit = function() {
            return isImplicit(stackTop());
          };
          inImplicitCall = function() {
            return isImplicitCall(stackTop());
          };
          inImplicitObject = function() {
            return isImplicitObject(stackTop());
          };
          // Unclosed control statement inside implicit parens (like
          // class declaration or if-conditionals).
          inImplicitControl = function() {
            var ref;
            return inImplicit() && ((ref = stackTop()) != null ? ref[0] : void 0) === 'CONTROL';
          };
          startImplicitCall = function(idx) {
            stack.push([
              '(',
              idx,
              {
                ours: true
              }
            ]);
            return tokens.splice(idx, 0, generate('CALL_START', '(', ['', 'implicit function call', token[2]], prevToken));
          };
          endImplicitCall = function() {
            stack.pop();
            tokens.splice(i, 0, generate('CALL_END', ')', ['', 'end of input', token[2]], prevToken));
            return i += 1;
          };
          startImplicitObject = function(idx, {startsLine = true, continuationLineIndent} = {}) {
            var val;
            stack.push([
              '{',
              idx,
              {
                sameLine: true,
                startsLine: startsLine,
                ours: true,
                continuationLineIndent: continuationLineIndent
              }
            ]);
            val = new String('{');
            val.generated = true;
            return tokens.splice(idx, 0, generate('{', val, token, prevToken));
          };
          endImplicitObject = function(j) {
            j = j != null ? j : i;
            stack.pop();
            tokens.splice(j, 0, generate('}', '}', token, prevToken));
            return i += 1;
          };
          implicitObjectContinues = (j) => {
            var nextTerminatorIdx;
            nextTerminatorIdx = null;
            this.detectEnd(j, function(token) {
              return token[0] === 'TERMINATOR';
            }, function(token, i) {
              return nextTerminatorIdx = i;
            }, {
              returnOnNegativeLevel: true
            });
            if (nextTerminatorIdx == null) {
              return false;
            }
            return this.looksObjectish(nextTerminatorIdx + 1);
          };
          // Don’t end an implicit call/object on next indent if any of these are in an argument/value.
          if ((inImplicitCall() || inImplicitObject()) && indexOf.call(CONTROL_IN_IMPLICIT, tag) >= 0 || inImplicitObject() && prevTag === ':' && tag === 'FOR') {
            stack.push([
              'CONTROL',
              i,
              {
                ours: true
              }
            ]);
            return forward(1);
          }
          if (tag === 'INDENT' && inImplicit()) {
            // An `INDENT` closes an implicit call unless

            //  1. We have seen a `CONTROL` argument on the line.
            //  2. The last token before the indent is part of the list below.
            if (prevTag !== '=>' && prevTag !== '->' && prevTag !== '[' && prevTag !== '(' && prevTag !== ',' && prevTag !== '{' && prevTag !== 'ELSE' && prevTag !== '=') {
              while (inImplicitCall() || inImplicitObject() && prevTag !== ':') {
                if (inImplicitCall()) {
                  endImplicitCall();
                } else {
                  endImplicitObject();
                }
              }
            }
            if (inImplicitControl()) {
              stack.pop();
            }
            stack.push([tag, i]);
            return forward(1);
          }
          // Straightforward start of explicit expression.
          if (indexOf.call(EXPRESSION_START, tag) >= 0) {
            stack.push([tag, i]);
            return forward(1);
          }
          // Close all implicit expressions inside of explicitly closed expressions.
          if (indexOf.call(EXPRESSION_END, tag) >= 0) {
            while (inImplicit()) {
              if (inImplicitCall()) {
                endImplicitCall();
              } else if (inImplicitObject()) {
                endImplicitObject();
              } else {
                stack.pop();
              }
            }
            start = stack.pop();
          }
          inControlFlow = () => {
            var controlFlow, isFunc, seenFor, tagCurrentLine;
            seenFor = this.findTagsBackwards(i, ['FOR']) && this.findTagsBackwards(i, ['FORIN', 'FOROF', 'FORFROM']);
            controlFlow = seenFor || this.findTagsBackwards(i, ['WHILE', 'UNTIL', 'LOOP', 'LEADING_WHEN']);
            if (!controlFlow) {
              return false;
            }
            isFunc = false;
            tagCurrentLine = token[2].first_line;
            this.detectEnd(i, function(token, i) {
              var ref;
              return ref = token[0], indexOf.call(LINEBREAKS, ref) >= 0;
            }, function(token, i) {
              var first_line;
              [prevTag, , {first_line}] = tokens[i - 1] || [];
              return isFunc = tagCurrentLine === first_line && (prevTag === '->' || prevTag === '=>');
            }, {
              returnOnNegativeLevel: true
            });
            return isFunc;
          };
          // Recognize standard implicit calls like
          // f a, f() b, f? c, h[0] d etc.
          // Added support for spread dots on the left side: f ...a
          if ((indexOf.call(IMPLICIT_FUNC, tag) >= 0 && token.spaced || tag === '?' && i > 0 && !tokens[i - 1].spaced) && (indexOf.call(IMPLICIT_CALL, nextTag) >= 0 || (nextTag === '...' && (ref = this.tag(i + 2), indexOf.call(IMPLICIT_CALL, ref) >= 0) && !this.findTagsBackwards(i, ['INDEX_START', '['])) || indexOf.call(IMPLICIT_UNSPACED_CALL, nextTag) >= 0 && !nextToken.spaced && !nextToken.newLine) && !inControlFlow()) {
            if (tag === '?') {
              tag = token[0] = 'FUNC_EXIST';
            }
            startImplicitCall(i + 1);
            return forward(2);
          }
          // Implicit call taking an implicit indented object as first argument.

          //     f
          //       a: b
          //       c: d

          // Don’t accept implicit calls of this type, when on the same line
          // as the control structures below as that may misinterpret constructs like:

          //     if f
          //        a: 1
          // as

          //     if f(a: 1)

          // which is probably always unintended.
          // Furthermore don’t allow this in the first line of a literal array
          // or explicit object, as that creates grammatical ambiguities (#5368).
          if (indexOf.call(IMPLICIT_FUNC, tag) >= 0 && this.indexOfTag(i + 1, 'INDENT') > -1 && this.looksObjectish(i + 2) && !this.findTagsBackwards(i, ['CLASS', 'EXTENDS', 'IF', 'CATCH', 'SWITCH', 'LEADING_WHEN', 'FOR', 'WHILE', 'UNTIL']) && !(((ref1 = (s = (ref2 = stackTop()) != null ? ref2[0] : void 0)) === '{' || ref1 === '[') && !isImplicit(stackTop()) && this.findTagsBackwards(i, s))) {
            startImplicitCall(i + 1);
            stack.push(['INDENT', i + 2]);
            return forward(3);
          }
          // Implicit objects start here.
          if (tag === ':') {
            // Go back to the (implicit) start of the object.
            s = (function() {
              var ref3;
              switch (false) {
                case ref3 = this.tag(i - 1), indexOf.call(EXPRESSION_END, ref3) < 0:
                  [startTag, startIndex] = start;
                  if (startTag === '[' && startIndex > 0 && this.tag(startIndex - 1) === '@' && !tokens[startIndex - 1].spaced) {
                    return startIndex - 1;
                  } else {
                    return startIndex;
                  }
                  break;
                case this.tag(i - 2) !== '@':
                  return i - 2;
                default:
                  return i - 1;
              }
            }).call(this);
            startsLine = s <= 0 || (ref3 = this.tag(s - 1), indexOf.call(LINEBREAKS, ref3) >= 0) || tokens[s - 1].newLine;
            // Are we just continuing an already declared object?
            // Including the case where we indent on the line after an explicit '{'.
            if (stackTop()) {
              [stackTag, stackIdx] = stackTop();
              stackNext = stack[stack.length - 2];
              if ((stackTag === '{' || stackTag === 'INDENT' && (stackNext != null ? stackNext[0] : void 0) === '{' && !isImplicit(stackNext) && this.findTagsBackwards(stackIdx - 1, ['{'])) && (startsLine || this.tag(s - 1) === ',' || this.tag(s - 1) === '{') && (ref4 = this.tag(s - 1), indexOf.call(UNFINISHED, ref4) < 0)) {
                return forward(1);
              }
            }
            preObjectToken = i > 1 ? tokens[i - 2] : [];
            startImplicitObject(s, {
              startsLine: !!startsLine,
              continuationLineIndent: preObjectToken.continuationLineIndent
            });
            return forward(2);
          }
          // End implicit calls when chaining method calls
          // like e.g.:

          //     f ->
          //       a
          //     .g b, ->
          //       c
          //     .h a

          // and also

          //     f a
          //     .g b
          //     .h a

          // Mark all enclosing objects as not sameLine
          if (indexOf.call(LINEBREAKS, tag) >= 0) {
            for (k = stack.length - 1; k >= 0; k += -1) {
              stackItem = stack[k];
              if (!isImplicit(stackItem)) {
                break;
              }
              if (isImplicitObject(stackItem)) {
                stackItem[2].sameLine = false;
              }
            }
          }
          // End indented-continuation-line implicit objects once that indentation is over.
          if (tag === 'TERMINATOR' && token.endsContinuationLineIndentation) {
            ({preContinuationLineIndent} = token.endsContinuationLineIndentation);
            while (inImplicitObject() && ((implicitObjectIndent = stackTop()[2].continuationLineIndent) != null) && implicitObjectIndent > preContinuationLineIndent) {
              endImplicitObject();
            }
          }
          newLine = prevTag === 'OUTDENT' || prevToken.newLine;
          if (indexOf.call(IMPLICIT_END, tag) >= 0 || (indexOf.call(CALL_CLOSERS, tag) >= 0 && newLine) || ((tag === '..' || tag === '...') && this.findTagsBackwards(i, ["INDEX_START"]))) {
            while (inImplicit()) {
              [stackTag, stackIdx, {sameLine, startsLine}] = stackTop();
              // Close implicit calls when reached end of argument list
              if (inImplicitCall() && prevTag !== ',' || (prevTag === ',' && tag === 'TERMINATOR' && (nextTag == null))) {
                endImplicitCall();
              // Close implicit objects such as:
              // return a: 1, b: 2 unless true
              } else if (inImplicitObject() && sameLine && tag !== 'TERMINATOR' && prevTag !== ':' && !((tag === 'POST_IF' || tag === 'FOR' || tag === 'WHILE' || tag === 'UNTIL') && startsLine && implicitObjectContinues(i + 1))) {
                endImplicitObject();
              // Close implicit objects when at end of line, line didn't end with a comma
              // and the implicit object didn't start the line or the next line doesn’t look like
              // the continuation of an object.
              } else if (inImplicitObject() && tag === 'TERMINATOR' && prevTag !== ',' && !(startsLine && this.looksObjectish(i + 1))) {
                endImplicitObject();
              } else if (inImplicitControl() && tokens[stackTop()[1]][0] === 'CLASS' && tag === 'TERMINATOR') {
                stack.pop();
              } else {
                break;
              }
            }
          }
          // Close implicit object if comma is the last character
          // and what comes after doesn’t look like it belongs.
          // This is used for trailing commas and calls, like:

          //     x =
          //         a: b,
          //         c: d,
          //     e = 2

          // and

          //     f a, b: c, d: e, f, g: h: i, j

          if (tag === ',' && !this.looksObjectish(i + 1) && inImplicitObject() && !((ref5 = this.tag(i + 2)) === 'FOROF' || ref5 === 'FORIN') && (nextTag !== 'TERMINATOR' || !this.looksObjectish(i + 2))) {
            // When nextTag is OUTDENT the comma is insignificant and
            // should just be ignored so embed it in the implicit object.

            // When it isn’t the comma go on to play a role in a call or
            // array further up the stack, so give it a chance.
            offset = nextTag === 'OUTDENT' ? 1 : 0;
            while (inImplicitObject()) {
              endImplicitObject(i + offset);
            }
          }
          return forward(1);
        });
      }

      // Make sure only strings and wrapped expressions are used in JSX attributes.
      enforceValidJSXAttributes() {
        return this.scanTokens(function(token, i, tokens) {
          var next, ref;
          if (token.jsxColon) {
            next = tokens[i + 1];
            if ((ref = next[0]) !== 'STRING_START' && ref !== 'STRING' && ref !== '(') {
              throwSyntaxError('expected wrapped or quoted JSX attribute', next[2]);
            }
          }
          return 1;
        });
      }

      // Not all tokens survive processing by the parser. To avoid comments getting
      // lost into the ether, find comments attached to doomed tokens and move them
      // to a token that will make it to the other side.
      rescueStowawayComments() {
        var dontShiftForward, insertPlaceholder, shiftCommentsBackward, shiftCommentsForward;
        insertPlaceholder = function(token, j, tokens, method) {
          if (tokens[j][0] !== 'TERMINATOR') {
            tokens[method](generate('TERMINATOR', '\n', tokens[j]));
          }
          return tokens[method](generate('JS', '', tokens[j], token));
        };
        dontShiftForward = function(i, tokens) {
          var j, ref;
          j = i + 1;
          while (j !== tokens.length && (ref = tokens[j][0], indexOf.call(DISCARDED, ref) >= 0)) {
            if (tokens[j][0] === 'INTERPOLATION_END') {
              return true;
            }
            j++;
          }
          return false;
        };
        shiftCommentsForward = function(token, i, tokens) {
          var comment, j, k, len, ref, ref1, ref2;
          // Find the next surviving token and attach this token’s comments to it,
          // with a flag that we know to output such comments *before* that
          // token’s own compilation. (Otherwise comments are output following
          // the token they’re attached to.)
          j = i;
          while (j !== tokens.length && (ref = tokens[j][0], indexOf.call(DISCARDED, ref) >= 0)) {
            j++;
          }
          if (!(j === tokens.length || (ref1 = tokens[j][0], indexOf.call(DISCARDED, ref1) >= 0))) {
            ref2 = token.comments;
            for (k = 0, len = ref2.length; k < len; k++) {
              comment = ref2[k];
              comment.unshift = true;
            }
            moveComments(token, tokens[j]);
            return 1; // All following tokens are doomed!
          } else {
            j = tokens.length - 1;
            insertPlaceholder(token, j, tokens, 'push');
            // The generated tokens were added to the end, not inline, so we don’t skip.
            return 1;
          }
        };
        shiftCommentsBackward = function(token, i, tokens) {
          var j, ref, ref1;
          // Find the last surviving token and attach this token’s comments to it.
          j = i;
          while (j !== -1 && (ref = tokens[j][0], indexOf.call(DISCARDED, ref) >= 0)) {
            j--;
          }
          if (!(j === -1 || (ref1 = tokens[j][0], indexOf.call(DISCARDED, ref1) >= 0))) {
            moveComments(token, tokens[j]);
            return 1; // All previous tokens are doomed!
          } else {
            insertPlaceholder(token, 0, tokens, 'unshift');
            // We added two tokens, so shift forward to account for the insertion.
            return 3;
          }
        };
        return this.scanTokens(function(token, i, tokens) {
          var dummyToken, j, ref, ref1, ret;
          if (!token.comments) {
            return 1;
          }
          ret = 1;
          if (ref = token[0], indexOf.call(DISCARDED, ref) >= 0) {
            // This token won’t survive passage through the parser, so we need to
            // rescue its attached tokens and redistribute them to nearby tokens.
            // Comments that don’t start a new line can shift backwards to the last
            // safe token, while other tokens should shift forward.
            dummyToken = {
              comments: []
            };
            j = token.comments.length - 1;
            while (j !== -1) {
              if (token.comments[j].newLine === false && token.comments[j].here === false) {
                dummyToken.comments.unshift(token.comments[j]);
                token.comments.splice(j, 1);
              }
              j--;
            }
            if (dummyToken.comments.length !== 0) {
              ret = shiftCommentsBackward(dummyToken, i - 1, tokens);
            }
            if (token.comments.length !== 0) {
              shiftCommentsForward(token, i, tokens);
            }
          } else if (!dontShiftForward(i, tokens)) {
            // If any of this token’s comments start a line—there’s only
            // whitespace between the preceding newline and the start of the
            // comment—and this isn’t one of the special `JS` tokens, then
            // shift this comment forward to precede the next valid token.
            // `Block.compileComments` also has logic to make sure that
            // “starting new line” comments follow or precede the nearest
            // newline relative to the token that the comment is attached to,
            // but that newline might be inside a `}` or `)` or other generated
            // token that we really want this comment to output after. Therefore
            // we need to shift the comments here, avoiding such generated and
            // discarded tokens.
            dummyToken = {
              comments: []
            };
            j = token.comments.length - 1;
            while (j !== -1) {
              if (token.comments[j].newLine && !token.comments[j].unshift && !(token[0] === 'JS' && token.generated)) {
                dummyToken.comments.unshift(token.comments[j]);
                token.comments.splice(j, 1);
              }
              j--;
            }
            if (dummyToken.comments.length !== 0) {
              ret = shiftCommentsForward(dummyToken, i + 1, tokens);
            }
          }
          if (((ref1 = token.comments) != null ? ref1.length : void 0) === 0) {
            delete token.comments;
          }
          return ret;
        });
      }

      // Add location data to all tokens generated by the rewriter.
      addLocationDataToGeneratedTokens() {
        return this.scanTokens(function(token, i, tokens) {
          var column, line, nextLocation, prevLocation, rangeIndex, ref, ref1;
          if (token[2]) {
            return 1;
          }
          if (!(token.generated || token.explicit)) {
            return 1;
          }
          if (token.fromThen && token[0] === 'INDENT') {
            token[2] = token.origin[2];
            return 1;
          }
          if (token[0] === '{' && (nextLocation = (ref = tokens[i + 1]) != null ? ref[2] : void 0)) {
            ({
              first_line: line,
              first_column: column,
              range: [rangeIndex]
            } = nextLocation);
          } else if (prevLocation = (ref1 = tokens[i - 1]) != null ? ref1[2] : void 0) {
            ({
              last_line: line,
              last_column: column,
              range: [, rangeIndex]
            } = prevLocation);
            column += 1;
          } else {
            line = column = 0;
            rangeIndex = 0;
          }
          token[2] = {
            first_line: line,
            first_column: column,
            last_line: line,
            last_column: column,
            last_line_exclusive: line,
            last_column_exclusive: column,
            range: [rangeIndex, rangeIndex]
          };
          return 1;
        });
      }

      // `OUTDENT` tokens should always be positioned at the last character of the
      // previous token, so that AST nodes ending in an `OUTDENT` token end up with a
      // location corresponding to the last “real” token under the node.
      fixIndentationLocationData() {
        var findPrecedingComment;
        if (this.allComments == null) {
          this.allComments = extractAllCommentTokens(this.tokens);
        }
        findPrecedingComment = (token, {afterPosition, indentSize, first, indented}) => {
          var comment, k, l, lastMatching, matches, ref, ref1, tokenStart;
          tokenStart = token[2].range[0];
          matches = function(comment) {
            if (comment.outdented) {
              if (!((indentSize != null) && comment.indentSize > indentSize)) {
                return false;
              }
            }
            if (indented && !comment.indented) {
              return false;
            }
            if (!(comment.locationData.range[0] < tokenStart)) {
              return false;
            }
            if (!(comment.locationData.range[0] > afterPosition)) {
              return false;
            }
            return true;
          };
          if (first) {
            lastMatching = null;
            ref = this.allComments;
            for (k = ref.length - 1; k >= 0; k += -1) {
              comment = ref[k];
              if (matches(comment)) {
                lastMatching = comment;
              } else if (lastMatching) {
                return lastMatching;
              }
            }
            return lastMatching;
          }
          ref1 = this.allComments;
          for (l = ref1.length - 1; l >= 0; l += -1) {
            comment = ref1[l];
            if (matches(comment)) {
              return comment;
            }
          }
          return null;
        };
        return this.scanTokens(function(token, i, tokens) {
          var isIndent, nextToken, nextTokenIndex, precedingComment, prevLocationData, prevToken, ref, ref1, ref2, useNextToken;
          if (!(((ref = token[0]) === 'INDENT' || ref === 'OUTDENT') || (token.generated && token[0] === 'CALL_END' && !((ref1 = token.data) != null ? ref1.closingTagNameToken : void 0)) || (token.generated && token[0] === '}'))) {
            return 1;
          }
          isIndent = token[0] === 'INDENT';
          prevToken = (ref2 = token.prevToken) != null ? ref2 : tokens[i - 1];
          prevLocationData = prevToken[2];
          // addLocationDataToGeneratedTokens() set the outdent’s location data
          // to the preceding token’s, but in order to detect comments inside an
          // empty "block" we want to look for comments preceding the next token.
          useNextToken = token.explicit || token.generated;
          if (useNextToken) {
            nextToken = token;
            nextTokenIndex = i;
            while ((nextToken.explicit || nextToken.generated) && nextTokenIndex !== tokens.length - 1) {
              nextToken = tokens[nextTokenIndex++];
            }
          }
          precedingComment = findPrecedingComment(useNextToken ? nextToken : token, {
            afterPosition: prevLocationData.range[0],
            indentSize: token.indentSize,
            first: isIndent,
            indented: useNextToken
          });
          if (isIndent) {
            if (!(precedingComment != null ? precedingComment.newLine : void 0)) {
              return 1;
            }
          }
          if (token.generated && token[0] === 'CALL_END' && (precedingComment != null ? precedingComment.indented : void 0)) {
            // We don’t want e.g. an implicit call at the end of an `if` condition to
            // include a following indented comment.
            return 1;
          }
          if (precedingComment != null) {
            prevLocationData = precedingComment.locationData;
          }
          token[2] = {
            first_line: precedingComment != null ? prevLocationData.first_line : prevLocationData.last_line,
            first_column: precedingComment != null ? isIndent ? 0 : prevLocationData.first_column : prevLocationData.last_column,
            last_line: prevLocationData.last_line,
            last_column: prevLocationData.last_column,
            last_line_exclusive: prevLocationData.last_line_exclusive,
            last_column_exclusive: prevLocationData.last_column_exclusive,
            range: isIndent && (precedingComment != null) ? [prevLocationData.range[0] - precedingComment.indentSize, prevLocationData.range[1]] : prevLocationData.range
          };
          return 1;
        });
      }

      // Because our grammar is LALR(1), it can’t handle some single-line
      // expressions that lack ending delimiters. The **Rewriter** adds the implicit
      // blocks, so it doesn’t need to. To keep the grammar clean and tidy, trailing
      // newlines within expressions are removed and the indentation tokens of empty
      // blocks are added.
      normalizeLines() {
        var action, closeElseTag, condition, ifThens, indent, leading_if_then, leading_switch_when, outdent, starter;
        starter = indent = outdent = null;
        leading_switch_when = null;
        leading_if_then = null;
        // Count `THEN` tags
        ifThens = [];
        condition = function(token, i) {
          var ref, ref1, ref2, ref3;
          return token[1] !== ';' && (ref = token[0], indexOf.call(SINGLE_CLOSERS, ref) >= 0) && !(token[0] === 'TERMINATOR' && (ref1 = this.tag(i + 1), indexOf.call(EXPRESSION_CLOSE, ref1) >= 0)) && !(token[0] === 'ELSE' && (starter !== 'THEN' || (leading_if_then || leading_switch_when))) && !(((ref2 = token[0]) === 'CATCH' || ref2 === 'FINALLY') && (starter === '->' || starter === '=>')) || (ref3 = token[0], indexOf.call(CALL_CLOSERS, ref3) >= 0) && (this.tokens[i - 1].newLine || this.tokens[i - 1][0] === 'OUTDENT');
        };
        action = function(token, i) {
          if (token[0] === 'ELSE' && starter === 'THEN') {
            ifThens.pop();
          }
          return this.tokens.splice((this.tag(i - 1) === ',' ? i - 1 : i), 0, outdent);
        };
        closeElseTag = (tokens, i) => {
          var lastThen, outdentElse, tlen;
          tlen = ifThens.length;
          if (!(tlen > 0)) {
            return i;
          }
          lastThen = ifThens.pop();
          [, outdentElse] = this.indentation(tokens[lastThen]);
          // Insert `OUTDENT` to close inner `IF`.
          outdentElse[1] = tlen * 2;
          tokens.splice(i, 0, outdentElse);
          // Insert `OUTDENT` to close outer `IF`.
          outdentElse[1] = 2;
          tokens.splice(i + 1, 0, outdentElse);
          // Remove outdents from the end.
          this.detectEnd(i + 2, function(token, i) {
            var ref;
            return (ref = token[0]) === 'OUTDENT' || ref === 'TERMINATOR';
          }, function(token, i) {
            if (this.tag(i) === 'OUTDENT' && this.tag(i + 1) === 'OUTDENT') {
              return tokens.splice(i, 2);
            }
          });
          return i + 2;
        };
        return this.scanTokens(function(token, i, tokens) {
          var conditionTag, j, k, ref, ref1, ref2, tag;
          [tag] = token;
          conditionTag = (tag === '->' || tag === '=>') && this.findTagsBackwards(i, ['IF', 'WHILE', 'FOR', 'UNTIL', 'SWITCH', 'WHEN', 'LEADING_WHEN', '[', 'INDEX_START']) && !(this.findTagsBackwards(i, ['THEN', '..', '...']));
          if (tag === 'TERMINATOR') {
            if (this.tag(i + 1) === 'ELSE' && this.tag(i - 1) !== 'OUTDENT') {
              tokens.splice(i, 1, ...this.indentation());
              return 1;
            }
            if (ref = this.tag(i + 1), indexOf.call(EXPRESSION_CLOSE, ref) >= 0) {
              if (token[1] === ';' && this.tag(i + 1) === 'OUTDENT') {
                tokens[i + 1].prevToken = token;
                moveComments(token, tokens[i + 1]);
              }
              tokens.splice(i, 1);
              return 0;
            }
          }
          if (tag === 'CATCH') {
            for (j = k = 1; k <= 2; j = ++k) {
              if (!((ref1 = this.tag(i + j)) === 'OUTDENT' || ref1 === 'TERMINATOR' || ref1 === 'FINALLY')) {
                continue;
              }
              tokens.splice(i + j, 0, ...this.indentation());
              return 2 + j;
            }
          }
          if ((tag === '->' || tag === '=>') && (((ref2 = this.tag(i + 1)) === ',' || ref2 === ']') || this.tag(i + 1) === '.' && token.newLine)) {
            [indent, outdent] = this.indentation(tokens[i]);
            tokens.splice(i + 1, 0, indent, outdent);
            return 1;
          }
          if (indexOf.call(SINGLE_LINERS, tag) >= 0 && this.tag(i + 1) !== 'INDENT' && !(tag === 'ELSE' && this.tag(i + 1) === 'IF') && !conditionTag) {
            starter = tag;
            [indent, outdent] = this.indentation(tokens[i]);
            if (starter === 'THEN') {
              indent.fromThen = true;
            }
            if (tag === 'THEN') {
              leading_switch_when = this.findTagsBackwards(i, ['LEADING_WHEN']) && this.tag(i + 1) === 'IF';
              leading_if_then = this.findTagsBackwards(i, ['IF']) && this.tag(i + 1) === 'IF';
            }
            if (tag === 'THEN' && this.findTagsBackwards(i, ['IF'])) {
              ifThens.push(i);
            }
            // `ELSE` tag is not closed.
            if (tag === 'ELSE' && this.tag(i - 1) !== 'OUTDENT') {
              i = closeElseTag(tokens, i);
            }
            tokens.splice(i + 1, 0, indent);
            this.detectEnd(i + 2, condition, action);
            if (tag === 'THEN') {
              tokens.splice(i, 1);
            }
            return 1;
          }
          return 1;
        });
      }

      // Tag postfix conditionals as such, so that we can parse them with a
      // different precedence.
      tagPostfixConditionals() {
        var action, condition, original;
        original = null;
        condition = function(token, i) {
          var prevTag, tag;
          [tag] = token;
          [prevTag] = this.tokens[i - 1];
          return tag === 'TERMINATOR' || (tag === 'INDENT' && indexOf.call(SINGLE_LINERS, prevTag) < 0);
        };
        action = function(token, i) {
          if (token[0] !== 'INDENT' || (token.generated && !token.fromThen)) {
            return original[0] = 'POST_' + original[0];
          }
        };
        return this.scanTokens(function(token, i) {
          if (token[0] !== 'IF') {
            return 1;
          }
          original = token;
          this.detectEnd(i + 1, condition, action);
          return 1;
        });
      }

      // For tokens with extra data, we want to make that data visible to the grammar
      // by wrapping the token value as a String() object and setting the data as
      // properties of that object. The grammar should then be responsible for
      // cleaning this up for the node constructor: unwrapping the token value to a
      // primitive string and separately passing any expected token data properties
      exposeTokenDataToGrammar() {
        return this.scanTokens(function(token, i) {
          var key, ref, ref1, val;
          if (token.generated || (token.data && Object.keys(token.data).length !== 0)) {
            token[1] = new String(token[1]);
            ref1 = (ref = token.data) != null ? ref : {};
            for (key in ref1) {
              if (!hasProp.call(ref1, key)) continue;
              val = ref1[key];
              token[1][key] = val;
            }
            if (token.generated) {
              token[1].generated = true;
            }
          }
          return 1;
        });
      }

      // Generate the indentation tokens, based on another token on the same line.
      indentation(origin) {
        var indent, outdent;
        indent = ['INDENT', 2];
        outdent = ['OUTDENT', 2];
        if (origin) {
          indent.generated = outdent.generated = true;
          indent.origin = outdent.origin = origin;
        } else {
          indent.explicit = outdent.explicit = true;
        }
        return [indent, outdent];
      }

      // Look up a tag by token index.
      tag(i) {
        var ref;
        return (ref = this.tokens[i]) != null ? ref[0] : void 0;
      }

    };

    Rewriter.prototype.generate = generate;

    return Rewriter;

  }).call(this);

  // Constants
  // ---------

  // List of the token pairs that must be balanced.
  BALANCED_PAIRS = [['(', ')'], ['[', ']'], ['{', '}'], ['INDENT', 'OUTDENT'], ['CALL_START', 'CALL_END'], ['PARAM_START', 'PARAM_END'], ['INDEX_START', 'INDEX_END'], ['STRING_START', 'STRING_END'], ['INTERPOLATION_START', 'INTERPOLATION_END'], ['REGEX_START', 'REGEX_END']];

  // The inverse mappings of `BALANCED_PAIRS` we’re trying to fix up, so we can
  // look things up from either end.
  exports.INVERSES = INVERSES = {};

  // The tokens that signal the start/end of a balanced pair.
  EXPRESSION_START = [];

  EXPRESSION_END = [];

  for (k = 0, len = BALANCED_PAIRS.length; k < len; k++) {
    [left, right] = BALANCED_PAIRS[k];
    EXPRESSION_START.push(INVERSES[right] = left);
    EXPRESSION_END.push(INVERSES[left] = right);
  }

  // Tokens that indicate the close of a clause of an expression.
  EXPRESSION_CLOSE = ['CATCH', 'THEN', 'ELSE', 'FINALLY'].concat(EXPRESSION_END);

  // Tokens that, if followed by an `IMPLICIT_CALL`, indicate a function invocation.
  IMPLICIT_FUNC = ['IDENTIFIER', 'PROPERTY', 'SUPER', ')', 'CALL_END', ']', 'INDEX_END', '@', 'THIS'];

  // If preceded by an `IMPLICIT_FUNC`, indicates a function invocation.
  IMPLICIT_CALL = ['IDENTIFIER', 'JSX_TAG', 'PROPERTY', 'NUMBER', 'INFINITY', 'NAN', 'STRING', 'STRING_START', 'REGEX', 'REGEX_START', 'JS', 'NEW', 'PARAM_START', 'CLASS', 'IF', 'TRY', 'SWITCH', 'THIS', 'DYNAMIC_IMPORT', 'IMPORT_META', 'NEW_TARGET', 'UNDEFINED', 'NULL', 'BOOL', 'UNARY', 'DO', 'DO_IIFE', 'YIELD', 'AWAIT', 'UNARY_MATH', 'SUPER', 'THROW', '@', '->', '=>', '[', '(', '{', '--', '++'];

  IMPLICIT_UNSPACED_CALL = ['+', '-'];

  // Tokens that always mark the end of an implicit call for single-liners.
  IMPLICIT_END = ['POST_IF', 'FOR', 'WHILE', 'UNTIL', 'WHEN', 'BY', 'LOOP', 'TERMINATOR'];

  // Single-line flavors of block expressions that have unclosed endings.
  // The grammar can’t disambiguate them, so we insert the implicit indentation.
  SINGLE_LINERS = ['ELSE', '->', '=>', 'TRY', 'FINALLY', 'THEN'];

  SINGLE_CLOSERS = ['TERMINATOR', 'CATCH', 'FINALLY', 'ELSE', 'OUTDENT', 'LEADING_WHEN'];

  // Tokens that end a line.
  LINEBREAKS = ['TERMINATOR', 'INDENT', 'OUTDENT'];

  // Tokens that close open calls when they follow a newline.
  CALL_CLOSERS = ['.', '?.', '::', '?::'];

  // Tokens that prevent a subsequent indent from ending implicit calls/objects
  CONTROL_IN_IMPLICIT = ['IF', 'TRY', 'FINALLY', 'CATCH', 'CLASS', 'SWITCH'];

  // Tokens that are swallowed up by the parser, never leading to code generation.
  // You can spot these in `grammar.coffee` because the `o` function second
  // argument doesn’t contain a `new` call for these tokens.
  // `STRING_START` isn’t on this list because its `locationData` matches that of
  // the node that becomes `StringWithInterpolations`, and therefore
  // `addDataToNode` attaches `STRING_START`’s tokens to that node.
  DISCARDED = ['(', ')', '[', ']', '{', '}', ':', '.', '..', '...', ',', '=', '++', '--', '?', 'AS', 'AWAIT', 'CALL_START', 'CALL_END', 'DEFAULT', 'DO', 'DO_IIFE', 'ELSE', 'EXTENDS', 'EXPORT', 'FORIN', 'FOROF', 'FORFROM', 'IMPORT', 'INDENT', 'INDEX_SOAK', 'INTERPOLATION_START', 'INTERPOLATION_END', 'LEADING_WHEN', 'OUTDENT', 'PARAM_END', 'REGEX_START', 'REGEX_END', 'RETURN', 'STRING_END', 'THROW', 'UNARY', 'YIELD'].concat(IMPLICIT_UNSPACED_CALL.concat(IMPLICIT_END.concat(CALL_CLOSERS.concat(CONTROL_IN_IMPLICIT))));

  // Tokens that, when appearing at the end of a line, suppress a following TERMINATOR/INDENT token
  exports.UNFINISHED = UNFINISHED = ['\\', '.', '?.', '?::', 'UNARY', 'DO', 'DO_IIFE', 'MATH', 'UNARY_MATH', '+', '-', '**', 'SHIFT', 'RELATION', 'COMPARE', '&', '^', '|', '&&', '||', 'BIN?', 'EXTENDS'];

}).call(this);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmV3cml0ZXIuanMiLCJzb3VyY2VSb290IjoiLi4vLi4vIiwic291cmNlcyI6WyJzcmMvcmV3cml0ZXIuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFLNkM7RUFBQTs7Ozs7O0FBQUEsTUFBQSxjQUFBLEVBQUEsWUFBQSxFQUFBLG1CQUFBLEVBQUEsU0FBQSxFQUFBLGdCQUFBLEVBQUEsY0FBQSxFQUFBLGdCQUFBLEVBQUEsYUFBQSxFQUFBLFlBQUEsRUFBQSxhQUFBLEVBQUEsc0JBQUEsRUFBQSxRQUFBLEVBQUEsVUFBQSxFQUFBLFFBQUEsRUFBQSxjQUFBLEVBQUEsYUFBQSxFQUFBLFVBQUEsRUFBQSx1QkFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBLEVBQUEsSUFBQSxFQUFBLEdBQUEsRUFBQSxZQUFBLEVBQUEsS0FBQSxFQUFBLGdCQUFBO0lBQUE7OztFQUU3QyxDQUFBLENBQUMsZ0JBQUQsRUFBbUIsdUJBQW5CLENBQUEsR0FBOEMsT0FBQSxDQUFRLFdBQVIsQ0FBOUMsRUFGNkM7OztFQUs3QyxZQUFBLEdBQWUsUUFBQSxDQUFDLFNBQUQsRUFBWSxPQUFaLENBQUE7QUFDZixRQUFBLE9BQUEsRUFBQSxDQUFBLEVBQUEsR0FBQSxFQUFBLEdBQUEsRUFBQTtJQUFFLEtBQWMsU0FBUyxDQUFDLFFBQXhCO0FBQUEsYUFBQTs7SUFDQSxJQUFHLE9BQU8sQ0FBQyxRQUFSLElBQXFCLE9BQU8sQ0FBQyxRQUFRLENBQUMsTUFBakIsS0FBNkIsQ0FBckQ7TUFDRSxpQkFBQSxHQUFvQjtBQUNwQjtNQUFBLEtBQUEscUNBQUE7O1FBQ0UsSUFBRyxPQUFPLENBQUMsT0FBWDtVQUNFLGlCQUFpQixDQUFDLElBQWxCLENBQXVCLE9BQXZCLEVBREY7U0FBQSxNQUFBO1VBR0UsT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFqQixDQUFzQixPQUF0QixFQUhGOztNQURGO01BS0EsT0FBTyxDQUFDLFFBQVIsR0FBbUIsaUJBQWlCLENBQUMsTUFBbEIsQ0FBeUIsT0FBTyxD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ZVNjcmlwdCBsYW5ndWFnZSBoYXMgYSBnb29kIGRlYWwgb2Ygb3B0aW9uYWwgc3ludGF4LCBpbXBsaWNpdCBzeW50YXgsXG4jIGFuZCBzaG9ydGhhbmQgc3ludGF4LiBUaGlzIGNhbiBncmVhdGx5IGNvbXBsaWNhdGUgYSBncmFtbWFyIGFuZCBibG9hdFxuIyB0aGUgcmVzdWx0aW5nIHBhcnNlIHRhYmxlLiBJbnN0ZWFkIG9mIG1ha2luZyB0aGUgcGFyc2VyIGhhbmRsZSBpdCBhbGwsIHdlIHRha2VcbiMgYSBzZXJpZXMgb2YgcGFzc2VzIG92ZXIgdGhlIHRva2VuIHN0cmVhbSwgdXNpbmcgdGhpcyAqKlJld3JpdGVyKiogdG8gY29udmVydFxuIyBzaG9ydGhhbmQgaW50byB0aGUgdW5hbWJpZ3VvdXMgbG9uZyBmb3JtLCBhZGQgaW1wbGljaXQgaW5kZW50YXRpb24gYW5kXG4jIHBhcmVudGhlc2VzLCBhbmQgZ2VuZXJhbGx5IGNsZWFuIHRoaW5ncyB1cC5cblxue3Rocm93U3ludGF4RXJyb3IsIGV4dHJhY3RBbGxDb21tZW50VG9rZW5zfSA9IHJlcXVpcmUgJy4vaGVscGVycydcblxuIyBNb3ZlIGF0dGFjaGVkIGNvbW1lbnRzIGZyb20gb25lIHRva2VuIHRvIGFub3RoZXIuXG5tb3ZlQ29tbWVudHMgPSAoZnJvbVRva2VuLCB0b1Rva2VuKSAtPlxuICByZXR1cm4gdW5sZXNzIGZyb21Ub2tlbi5jb21tZW50c1xuICBpZiB0b1Rva2VuLmNvbW1lbnRzIGFuZCB0b1Rva2VuLmNvbW1lbnRzLmxlbmd0aCBpc250IDBcbiAgICB1bnNoaWZ0ZWRDb21tZW50cyA9IFtdXG4gICAgZm9yIGNvbW1lbnQgaW4gZnJvbVRva2VuLmNvbW1lbnRzXG4gICAgICBpZiBjb21tZW50LnVuc2hpZnRcbiAgICAgICAgdW5zaGlmdGVkQ29tbWVudHMucHVzaCBjb21tZW50XG4gICAgICBlbHNlXG4gICAgICAgIHRvVG9rZW4uY29tbWVudHMucHVzaCBjb21tZW50XG4gICAgdG9Ub2tlbi5jb21tZW50cyA9IHVuc2hpZnRlZENvbW1lbnRzLmNvbmNhdCB0b1Rva2VuLmNvbW1lbnRzXG4gIGVsc2VcbiAgICB0b1Rva2VuLmNvbW1lbnRzID0gZnJvbVRva2VuLmNvbW1lbnRzXG4gIGRlbGV0ZSBmcm9tVG9rZW4uY29tbWVudHNcblxuIyBDcmVhdGUgYSBnZW5lcmF0ZWQgdG9rZW46IG9uZSB0aGF0IGV4aXN0cyBkdWUgdG8gYSB1c2Ugb2YgaW1wbGljaXQgc3ludGF4LlxuIyBPcHRpb25hbGx5IGhhdmUgdGhpcyBuZXcgdG9rZW4gdGFrZSB0aGUgYXR0YWNoZWQgY29tbWVudHMgZnJvbSBhbm90aGVyIHRva2VuLlxuZ2VuZXJhdGUgPSAodGFnLCB2YWx1ZSwgb3JpZ2luLCBjb21tZW50c1Rva2VuKSAtPlxuICB0b2tlbiA9IFt0YWcsIHZhbHVlXVxuICB0b2tlbi5nZW5lcmF0ZWQgPSB5ZXNcbiAgdG9rZW4ub3JpZ2luID0gb3JpZ2luIGlmIG9yaWdpblxuICBtb3ZlQ29tbWVudHMgY29tbWVudHNUb2tlbiwgdG9rZW4gaWYgY29tbWVudHNUb2tlblxuICB0b2tlblxuXG4jIFRoZSAqKlJld3JpdGVyKiogY2xhc3MgaXMgdXNlZCBieSB0aGUgW0xleGVyXShsZXhlci5odG1sKSwgZGlyZWN0bHkgYWdhaW5zdFxuIyBpdHMgaW50ZXJuYWwgYXJyYXkgb2YgdG9rZW5zLlxuZXhwb3J0cy5SZXdyaXRlciA9IGNsYXNzIFJld3JpdGVyXG5cbiAgIyBSZXdyaXRlIHRoZSB0b2tlbiBzdHJlYW0gaW4gbXVsdGlwbGUgcGFzc2VzLCBvbmUgbG9naWNhbCBmaWx0ZXIgYXRcbiAgIyBhIHRpbWUuIFRoaXMgY291bGQgY2VydGFpbmx5IGJlIGNoYW5nZWQgaW50byBhIHNpbmdsZSBwYXNzIHRocm91Z2ggdGhlXG4gICMgc3RyZWFtLCB3aXRoIGEgYmlnIG9s4oCZIGVmZmljaWVudCBzd2l0Y2gsIGJ1dCBpdOKAmXMgbXVjaCBuaWNlciB0byB3b3JrIHdpdGhcbiAgIyBsaWtlIHRoaXMuIFRoZSBvcmRlciBvZiB0aGVzZSBwYXNzZXMgbWF0dGVyc+KAlGluZGVudGF0aW9uIG11c3QgYmVcbiAgIyBjb3JyZWN0ZWQgYmVmb3JlIGltcGxpY2l0IHBhcmVudGhlc2VzIGNhbiBiZSB3cmFwcGVkIGFyb3VuZCBibG9ja3Mgb2YgY29kZS5cbiAgcmV3cml0ZTogKEB0b2tlbnMpIC0+XG4gICAgIyBTZXQgZW52aXJvbm1lbnQgdmFyaWFibGUgYERFQlVHX1RPS0VOX1NUUkVBTWAgdG8gYHRydWVgIHRvIG91dHB1dCB0b2tlblxuICAgICMgZGVidWdnaW5nIGluZm8uIEFsc28gc2V0IGBERUJVR19SRVdSSVRURU5fVE9LRU5fU1RSRUFNYCB0byBgdHJ1ZWAgdG9cbiAgICAjIG91dHB1dCB0aGUgdG9rZW4gc3RyZWFtIGFmdGVyIGl0IGhhcyBiZWVuIHJld3JpdHRlbiBieSB0aGlzIGZpbGUuXG4gICAgaWYgcHJvY2Vzcz8uZW52Py5ERUJVR19UT0tFTl9TVFJFQU1cbiAgICAgIGNvbnNvbGUubG9nICdJbml0aWFsIHRva2VuIHN0cmVhbTonIGlmIHByb2Nlc3MuZW52LkRFQlVHX1JFV1JJVFRFTl9UT0tFTl9TVFJFQU1cbiAgICAgIGNvbnNvbGUubG9nICh0WzBdICsgJy8nICsgdFsxXSArIChpZiB0LmNvbW1lbnRzIHRoZW4gJyonIGVsc2UgJycpIGZvciB0IGluIEB0b2tlbnMpLmpvaW4gJyAnXG4gICAgQHJlbW92ZUxlYWRpbmdOZXdsaW5lcygpXG4gICAgQGNsb3NlT3BlbkNhbGxzKClcbiAgICBAY2xvc2VPcGVuSW5kZXhlcygpXG4gICAgQG5vcm1hbGl6ZUxpbmVzKClcbiAgICBAdGFnUG9zdGZpeENvbmRpdGlvbmFscygpXG4gICAgQGFkZEltcGxpY2l0QnJhY2VzQW5kUGFyZW5zKClcbiAgICBAcmVzY3VlU3Rvd2F3YXlDb21tZW50cygpXG4gICAgQGFkZExvY2F0aW9uRGF0YVRvR2VuZXJhdGVkVG9rZW5zKClcbiAgICBAZW5mb3JjZVZhbGlkSlNYQXR0cmlidXRlcygpXG4gICAgQGZpeEluZGVudGF0aW9uTG9jYXRpb25EYXRhKClcbiAgICBAZXhwb3NlVG9rZW5EYXRhVG9HcmFtbWFyKClcbiAgICBpZiBwcm9jZXNzPy5lbnY/LkRFQlVHX1JFV1JJVFRFTl9UT0tFTl9TVFJFQU1cbiAgICAgIGNvbnNvbGUubG9nICdSZXdyaXR0ZW4gdG9rZW4gc3RyZWFtOicgaWYgcHJvY2Vzcy5lbnYuREVCVUdfVE9LRU5fU1RSRUFNXG4gICAgICBjb25zb2xlLmxvZyAodFswXSArICcvJyArIHRbMV0gKyAoaWYgdC5jb21tZW50cyB0aGVuICcqJyBlbHNlICcnKSBmb3IgdCBpbiBAdG9rZW5zKS5qb2luICcgJ1xuICAgIEB0b2tlbnNcblxuICAjIFJld3JpdGUgdGhlIHRva2VuIHN0cmVhbSwgbG9va2luZyBvbmUgdG9rZW4gYWhlYWQgYW5kIGJlaGluZC5cbiAgIyBBbGxvdyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBibG9jayB0byB0ZWxsIHVzIGhvdyBtYW55IHRva2VucyB0byBtb3ZlXG4gICMgZm9yd2FyZHMgKG9yIGJhY2t3YXJkcykgaW4gdGhlIHN0cmVhbSwgdG8gbWFrZSBzdXJlIHdlIGRvbuKAmXQgbWlzcyBhbnl0aGluZ1xuICAjIGFzIHRva2VucyBhcmUgaW5zZXJ0ZWQgYW5kIHJlbW92ZWQsIGFuZCB0aGUgc3RyZWFtIGNoYW5nZXMgbGVuZ3RoIHVuZGVyXG4gICMgb3VyIGZlZXQuXG4gIHNjYW5Ub2tlbnM6IChibG9jaykgLT5cbiAgICB7dG9rZW5zfSA9IHRoaXNcbiAgICBpID0gMFxuICAgIGkgKz0gYmxvY2suY2FsbCB0aGlzLCB0b2tlbiwgaSwgdG9rZW5zIHdoaWxlIHRva2VuID0gdG9rZW5zW2ldXG4gICAgdHJ1ZVxuXG4gIGRldGVjdEVuZDogKGksIGNvbmRpdGlvbiwgYWN0aW9uLCBvcHRzID0ge30pIC0+XG4gICAge3Rva2Vuc30gPSB0aGlzXG4gICAgbGV2ZWxzID0gMFxuICAgIHdoaWxlIHRva2VuID0gdG9rZW5zW2ldXG4gICAgICByZXR1cm4gYWN0aW9uLmNhbGwgdGhpcywgdG9rZW4sIGkgaWYgbGV2ZWxzIGlzIDAgYW5kIGNvbmRpdGlvbi5jYWxsIHRoaXMsIHRva2VuLCBpXG4gICAgICBpZiB0b2tlblswXSBpbiBFWFBSRVNTSU9OX1NUQVJUXG4gICAgICAgIGxldmVscyArPSAxXG4gICAgICBlbHNlIGlmIHRva2VuWzBdIGluIEVYUFJFU1NJT05fRU5EXG4gICAgICAgIGxldmVscyAtPSAxXG4gICAgICBpZiBsZXZlbHMgPCAwXG4gICAgICAgIHJldHVybiBpZiBvcHRzLnJldHVybk9uTmVnYXRpdmVMZXZlbFxuICAgICAgICByZXR1cm4gYWN0aW9uLmNhbGwgdGhpcywgdG9rZW4sIGlcbiAgICAgIGkgKz0gMVxuICAgIGkgLSAxXG5cbiAgIyBMZWFkaW5nIG5ld2xpbmVzIHdvdWxkIGludHJvZHVjZSBhbiBhbWJpZ3VpdHkgaW4gdGhlIGdyYW1tYXIsIHNvIHdlXG4gICMgZGlzcGF0Y2ggdGhlbSBoZXJlLlxuICByZW1vdmVMZWFkaW5nTmV3bGluZXM6IC0+XG4gICAgIyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgbm9uLWBURVJNSU5BVE9SYCB0b2tlbi5cbiAgICBicmVhayBmb3IgW3RhZ10sIGkgaW4gQHRva2VucyB3aGVuIHRhZyBpc250ICdURVJNSU5BVE9SJ1xuICAgIHJldHVybiBpZiBpIGlzIDBcbiAgICAjIElmIHRoZXJlIGFyZSBhbnkgY29tbWVudHMgYXR0YWNoZWQgdG8gdGhlIHRva2VucyB3ZeKAmXJlIGFib3V0IHRvIGRpc2NhcmQsXG4gICAgIyBzaGlmdCB0aGVtIGZvcndhcmQgdG8gd2hhdCB3aWxsIGJlY29tZSB0aGUgbmV3IGZpcnN0IHRva2VuLlxuICAgIGZvciBsZWFkaW5nTmV3bGluZVRva2VuIGluIEB0b2tlbnNbMC4uLmldXG4gICAgICBtb3ZlQ29tbWVudHMgbGVhZGluZ05ld2xpbmVUb2tlbiwgQHRva2Vuc1tpXVxuICAgICMgRGlzY2FyZCBhbGwgdGhlIGxlYWRpbmcgbmV3bGluZSB0b2tlbnMuXG4gICAgQHRva2Vucy5zcGxpY2UgMCwgaVxuXG4gICMgVGhlIGxleGVyIGhhcyB0YWdnZWQgdGhlIG9wZW5pbmcgcGFyZW50aGVzaXMgb2YgYSBtZXRob2QgY2FsbC4gTWF0Y2ggaXQgd2l0aFxuICAjIGl0cyBwYWlyZWQgY2xvc2UuXG4gIGNsb3NlT3BlbkNhbGxzOiAtPlxuICAgIGNvbmRpdGlvbiA9ICh0b2tlbiwgaSkgLT5cbiAgICAgIHRva2VuWzBdIGluIFsnKScsICdDQUxMX0VORCddXG5cbiAgICBhY3Rpb24gPSAodG9rZW4sIGkpIC0+XG4gICAgICB0b2tlblswXSA9ICdDQUxMX0VORCdcblxuICAgIEBzY2FuVG9rZW5zICh0b2tlbiwgaSkgLT5cbiAgICAgIEBkZXRlY3RFbmQgaSArIDEsIGNvbmRpdGlvbiwgYWN0aW9uIGlmIHRva2VuWzBdIGlzICdDQUxMX1NUQVJUJ1xuICAgICAgMVxuXG4gICMgVGhlIGxleGVyIGhhcyB0YWdnZWQgdGhlIG9wZW5pbmcgYnJhY2tldCBvZiBhbiBpbmRleGluZyBvcGVyYXRpb24gY2FsbC5cbiAgIyBNYXRjaCBpdCB3aXRoIGl0cyBwYWlyZWQgY2xvc2UuXG4gIGNsb3NlT3BlbkluZGV4ZXM6IC0+XG4gICAgc3RhcnRUb2tlbiA9IG51bGxcbiAgICBjb25kaXRpb24gPSAodG9rZW4sIGkpIC0+XG4gICAgICB0b2tlblswXSBpbiBbJ10nLCAnSU5ERVhfRU5EJ11cblxuICAgIGFjdGlvbiA9ICh0b2tlbiwgaSkgLT5cbiAgICAgIGlmIEB0b2tlbnMubGVuZ3RoID49IGkgYW5kIEB0b2tlbnNbaSArIDFdWzBdIGlzICc6J1xuICAgICAgICBzdGFydFRva2VuWzBdID0gJ1snXG4gICAgICAgIHRva2VuWzBdID0gJ10nXG4gICAgICBlbHNlXG4gICAgICAgIHRva2VuWzBdID0gJ0lOREVYX0VORCdcblxuICAgIEBzY2FuVG9rZW5zICh0b2tlbiwgaSkgLT5cbiAgICAgIGlmIHRva2VuWzBdIGlzICdJTkRFWF9TVEFSVCdcbiAgICAgICAgc3RhcnRUb2tlbiA9IHRva2VuXG4gICAgICAgIEBkZXRlY3RFbmQgaSArIDEsIGNvbmRpdGlvbiwgYWN0aW9uXG4gICAgICAxXG5cbiAgIyBNYXRjaCB0YWdzIGluIHRva2VuIHN0cmVhbSBzdGFydGluZyBhdCBgaWAgd2l0aCBgcGF0dGVybmAuXG4gICMgYHBhdHRlcm5gIG1heSBjb25zaXN0IG9mIHN0cmluZ3MgKGVxdWFsaXR5KSwgYW4gYXJyYXkgb2Ygc3RyaW5ncyAob25lIG9mKVxuICAjIG9yIG51bGwgKHdpbGRjYXJkKS4gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoIG9yIC0xIGlmIG5vIG1hdGNoLlxuICBpbmRleE9mVGFnOiAoaSwgcGF0dGVybi4uLikgLT5cbiAgICBmdXp6ID0gMFxuICAgIGZvciBqIGluIFswIC4uLiBwYXR0ZXJuLmxlbmd0aF1cbiAgICAgIGNvbnRpbnVlIGlmIG5vdCBwYXR0ZXJuW2pdP1xuICAgICAgcGF0dGVybltqXSA9IFtwYXR0ZXJuW2pdXSBpZiB0eXBlb2YgcGF0dGVybltqXSBpcyAnc3RyaW5nJ1xuICAgICAgcmV0dXJuIC0xIGlmIEB0YWcoaSArIGogKyBmdXp6KSBub3QgaW4gcGF0dGVybltqXVxuICAgIGkgKyBqICsgZnV6eiAtIDFcblxuICAjIFJldHVybnMgYHllc2AgaWYgc3RhbmRpbmcgaW4gZnJvbnQgb2Ygc29tZXRoaW5nIGxvb2tpbmcgbGlrZVxuICAjIGBAPHg+OmAsIGA8eD46YCBvciBgPEVYUFJFU1NJT05fU1RBUlQ+PHg+Li4uPEVYUFJFU1NJT05fRU5EPjpgLlxuICBsb29rc09iamVjdGlzaDogKGopIC0+XG4gICAgcmV0dXJuIHllcyBpZiBAaW5kZXhPZlRhZyhqLCAnQCcsIG51bGwsICc6JykgaXNudCAtMSBvciBAaW5kZXhPZlRhZyhqLCBudWxsLCAnOicpIGlzbnQgLTFcbiAgICBpbmRleCA9IEBpbmRleE9mVGFnIGosIEVYUFJFU1NJT05fU1RBUlRcbiAgICBpZiBpbmRleCBpc250IC0xXG4gICAgICBlbmQgPSBudWxsXG4gICAgICBAZGV0ZWN0RW5kIGluZGV4ICsgMSwgKCh0b2tlbikgLT4gdG9rZW5bMF0gaW4gRVhQUkVTU0lPTl9FTkQpLCAoKHRva2VuLCBpKSAtPiBlbmQgPSBpKVxuICAgICAgcmV0dXJuIHllcyBpZiBAdGFnKGVuZCArIDEpIGlzICc6J1xuICAgIG5vXG5cbiAgIyBSZXR1cm5zIGB5ZXNgIGlmIGN1cnJlbnQgbGluZSBvZiB0b2tlbnMgY29udGFpbiBhbiBlbGVtZW50IG9mIHRhZ3Mgb24gc2FtZVxuICAjIGV4cHJlc3Npb24gbGV2ZWwuIFN0b3Agc2VhcmNoaW5nIGF0IGBMSU5FQlJFQUtTYCBvciBleHBsaWNpdCBzdGFydCBvZlxuICAjIGNvbnRhaW5pbmcgYmFsYW5jZWQgZXhwcmVzc2lvbi5cbiAgZmluZFRhZ3NCYWNrd2FyZHM6IChpLCB0YWdzKSAtPlxuICAgIGJhY2tTdGFjayA9IFtdXG4gICAgd2hpbGUgaSA+PSAwIGFuZCAoYmFja1N0YWNrLmxlbmd0aCBvclxuICAgICAgICAgIEB0YWcoaSkgbm90IGluIHRhZ3MgYW5kXG4gICAgICAgICAgKEB0YWcoaSkgbm90IGluIEVYUFJFU1NJT05fU1RBUlQgb3IgQHRva2Vuc1tpXS5nZW5lcmF0ZWQpIGFuZFxuICAgICAgICAgIEB0YWcoaSkgbm90IGluIExJTkVCUkVBS1MpXG4gICAgICBiYWNrU3RhY2sucHVzaCBAdGFnKGkpIGlmIEB0YWcoaSkgaW4gRVhQUkVTU0lPTl9FTkRcbiAgICAgIGJhY2tTdGFjay5wb3AoKSBpZiBAdGFnKGkpIGluIEVYUFJFU1NJT05fU1RBUlQgYW5kIGJhY2tTdGFjay5sZW5ndGhcbiAgICAgIGkgLT0gMVxuICAgIEB0YWcoaSkgaW4gdGFnc1xuXG4gICMgTG9vayBmb3Igc2lnbnMgb2YgaW1wbGljaXQgY2FsbHMgYW5kIG9iamVjdHMgaW4gdGhlIHRva2VuIHN0cmVhbSBhbmRcbiAgIyBhZGQgdGhlbS5cbiAgYWRkSW1wbGljaXRCcmFjZXNBbmRQYXJlbnM6IC0+XG4gICAgIyBUcmFjayBjdXJyZW50IGJhbGFuY2luZyBkZXB0aCAoYm90aCBpbXBsaWNpdCBhbmQgZXhwbGljaXQpIG9uIHN0YWNrLlxuICAgIHN0YWNrID0gW11cbiAgICBzdGFydCA9IG51bGxcblxuICAgIEBzY2FuVG9rZW5zICh0b2tlbiwgaSwgdG9rZW5zKSAtPlxuICAgICAgW3RhZ10gICAgID0gdG9rZW5cbiAgICAgIFtwcmV2VGFnXSA9IHByZXZUb2tlbiA9IGlmIGkgPiAwIHRoZW4gdG9rZW5zW2kgLSAxXSBlbHNlIFtdXG4gICAgICBbbmV4dFRhZ10gPSBuZXh0VG9rZW4gPSBpZiBpIDwgdG9rZW5zLmxlbmd0aCAtIDEgdGhlbiB0b2tlbnNbaSArIDFdIGVsc2UgW11cbiAgICAgIHN0YWNrVG9wICA9IC0+IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXG4gICAgICBzdGFydElkeCAgPSBpXG5cbiAgICAgICMgSGVscGVyIGZ1bmN0aW9uLCB1c2VkIGZvciBrZWVwaW5nIHRyYWNrIG9mIHRoZSBudW1iZXIgb2YgdG9rZW5zIGNvbnN1bWVkXG4gICAgICAjIGFuZCBzcGxpY2VkLCB3aGVuIHJldHVybmluZyBmb3IgZ2V0dGluZyBhIG5ldyB0b2tlbi5cbiAgICAgIGZvcndhcmQgICA9IChuKSAtPiBpIC0gc3RhcnRJZHggKyBuXG5cbiAgICAgICMgSGVscGVyIGZ1bmN0aW9uc1xuICAgICAgaXNJbXBsaWNpdCAgICAgICAgPSAoc3RhY2tJdGVtKSAtPiBzdGFja0l0ZW0/WzJdPy5vdXJzXG4gICAgICBpc0ltcGxpY2l0T2JqZWN0ICA9IChzdGFja0l0ZW0pIC0+IGlzSW1wbGljaXQoc3RhY2tJdGVtKSBhbmQgc3RhY2tJdGVtP1swXSBpcyAneydcbiAgICAgIGlzSW1wbGljaXRDYWxsICAgID0gKHN0YWNrSXRlbSkgLT4gaXNJbXBsaWNpdChzdGFja0l0ZW0pIGFuZCBzdGFja0l0ZW0/WzBdIGlzICcoJ1xuICAgICAgaW5JbXBsaWNpdCAgICAgICAgPSAtPiBpc0ltcGxpY2l0IHN0YWNrVG9wKClcbiAgICAgIGluSW1wbGljaXRDYWxsICAgID0gLT4gaXNJbXBsaWNpdENhbGwgc3RhY2tUb3AoKVxuICAgICAgaW5JbXBsaWNpdE9iamVjdCAgPSAtPiBpc0ltcGxpY2l0T2JqZWN0IHN0YWNrVG9wKClcbiAgICAgICMgVW5jbG9zZWQgY29udHJvbCBzdGF0ZW1lbnQgaW5zaWRlIGltcGxpY2l0IHBhcmVucyAobGlrZVxuICAgICAgIyBjbGFzcyBkZWNsYXJhdGlvbiBvciBpZi1jb25kaXRpb25hbHMpLlxuICAgICAgaW5JbXBsaWNpdENvbnRyb2wgPSAtPiBpbkltcGxpY2l0KCkgYW5kIHN0YWNrVG9wKCk/WzBdIGlzICdDT05UUk9MJ1xuXG4gICAgICBzdGFydEltcGxpY2l0Q2FsbCA9IChpZHgpIC0+XG4gICAgICAgIHN0YWNrLnB1c2ggWycoJywgaWR4LCBvdXJzOiB5ZXNdXG4gICAgICAgIHRva2Vucy5zcGxpY2UgaWR4LCAwLCBnZW5lcmF0ZSAnQ0FMTF9TVEFSVCcsICcoJywgWycnLCAnaW1wbGljaXQgZnVuY3Rpb24gY2FsbCcsIHRva2VuWzJdXSwgcHJldlRva2VuXG5cbiAgICAgIGVuZEltcGxpY2l0Q2FsbCA9IC0+XG4gICAgICAgIHN0YWNrLnBvcCgpXG4gICAgICAgIHRva2Vucy5zcGxpY2UgaSwgMCwgZ2VuZXJhdGUgJ0NBTExfRU5EJywgJyknLCBbJycsICdlbmQgb2YgaW5wdXQnLCB0b2tlblsyXV0sIHByZXZUb2tlblxuICAgICAgICBpICs9IDFcblxuICAgICAgc3RhcnRJbXBsaWNpdE9iamVjdCA9IChpZHgsIHtzdGFydHNMaW5lID0geWVzLCBjb250aW51YXRpb25MaW5lSW5kZW50fSA9IHt9KSAtPlxuICAgICAgICBzdGFjay5wdXNoIFsneycsIGlkeCwgc2FtZUxpbmU6IHllcywgc3RhcnRzTGluZTogc3RhcnRzTGluZSwgb3VyczogeWVzLCBjb250aW51YXRpb25MaW5lSW5kZW50OiBjb250aW51YXRpb25MaW5lSW5kZW50XVxuICAgICAgICB2YWwgPSBuZXcgU3RyaW5nICd7J1xuICAgICAgICB2YWwuZ2VuZXJhdGVkID0geWVzXG4gICAgICAgIHRva2Vucy5zcGxpY2UgaWR4LCAwLCBnZW5lcmF0ZSAneycsIHZhbCwgdG9rZW4sIHByZXZUb2tlblxuXG4gICAgICBlbmRJbXBsaWNpdE9iamVjdCA9IChqKSAtPlxuICAgICAgICBqID0gaiA/IGlcbiAgICAgICAgc3RhY2sucG9wKClcbiAgICAgICAgdG9rZW5zLnNwbGljZSBqLCAwLCBnZW5lcmF0ZSAnfScsICd9JywgdG9rZW4sIHByZXZUb2tlblxuICAgICAgICBpICs9IDFcblxuICAgICAgaW1wbGljaXRPYmplY3RDb250aW51ZXMgPSAoaikgPT5cbiAgICAgICAgbmV4dFRlcm1pbmF0b3JJZHggPSBudWxsXG4gICAgICAgIEBkZXRlY3RFbmQgaixcbiAgICAgICAgICAodG9rZW4pIC0+IHRva2VuWzBdIGlzICdURVJNSU5BVE9SJ1xuICAgICAgICAgICh0b2tlbiwgaSkgLT4gbmV4dFRlcm1pbmF0b3JJZHggPSBpXG4gICAgICAgICAgcmV0dXJuT25OZWdhdGl2ZUxldmVsOiB5ZXNcbiAgICAgICAgcmV0dXJuIG5vIHVubGVzcyBuZXh0VGVybWluYXRvcklkeD9cbiAgICAgICAgQGxvb2tzT2JqZWN0aXNoIG5leHRUZXJtaW5hdG9ySWR4ICsgMVxuXG4gICAgICAjIERvbuKAmXQgZW5kIGFuIGltcGxpY2l0IGNhbGwvb2JqZWN0IG9uIG5leHQgaW5kZW50IGlmIGFueSBvZiB0aGVzZSBhcmUgaW4gYW4gYXJndW1lbnQvdmFsdWUuXG4gICAgICBpZiAoXG4gICAgICAgIChpbkltcGxpY2l0Q2FsbCgpIG9yIGluSW1wbGljaXRPYmplY3QoKSkgYW5kIHRhZyBpbiBDT05UUk9MX0lOX0lNUExJQ0lUIG9yXG4gICAgICAgIGluSW1wbGljaXRPYmplY3QoKSBhbmQgcHJldlRhZyBpcyAnOicgYW5kIHRhZyBpcyAnRk9SJ1xuICAgICAgKVxuICAgICAgICBzdGFjay5wdXNoIFsnQ09OVFJPTCcsIGksIG91cnM6IHllc11cbiAgICAgICAgcmV0dXJuIGZvcndhcmQoMSlcblxuICAgICAgaWYgdGFnIGlzICdJTkRFTlQnIGFuZCBpbkltcGxpY2l0KClcblxuICAgICAgICAjIEFuIGBJTkRFTlRgIGNsb3NlcyBhbiBpbXBsaWNpdCBjYWxsIHVubGVzc1xuICAgICAgICAjXG4gICAgICAgICMgIDEuIFdlIGhhdmUgc2VlbiBhIGBDT05UUk9MYCBhcmd1bWVudCBvbiB0aGUgbGluZS5cbiAgICAgICAgIyAgMi4gVGhlIGxhc3QgdG9rZW4gYmVmb3JlIHRoZSBpbmRlbnQgaXMgcGFydCBvZiB0aGUgbGlzdCBiZWxvdy5cbiAgICAgICAgaWYgcHJldlRhZyBub3QgaW4gWyc9PicsICctPicsICdbJywgJygnLCAnLCcsICd7JywgJ0VMU0UnLCAnPSddXG4gICAgICAgICAgd2hpbGUgaW5JbXBsaWNpdENhbGwoKSBvciBpbkltcGxpY2l0T2JqZWN0KCkgYW5kIHByZXZUYWcgaXNudCAnOidcbiAgICAgICAgICAgIGlmIGluSW1wbGljaXRDYWxsKClcbiAgICAgICAgICAgICAgZW5kSW1wbGljaXRDYWxsKClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgZW5kSW1wbGljaXRPYmplY3QoKVxuICAgICAgICBzdGFjay5wb3AoKSBpZiBpbkltcGxpY2l0Q29udHJvbCgpXG4gICAgICAgIHN0YWNrLnB1c2ggW3RhZywgaV1cbiAgICAgICAgcmV0dXJuIGZvcndhcmQoMSlcblxuICAgICAgIyBTdHJhaWdodGZvcndhcmQgc3RhcnQgb2YgZXhwbGljaXQgZXhwcmVzc2lvbi5cbiAgICAgIGlmIHRhZyBpbiBFWFBSRVNTSU9OX1NUQVJUXG4gICAgICAgIHN0YWNrLnB1c2ggW3RhZywgaV1cbiAgICAgICAgcmV0dXJuIGZvcndhcmQoMSlcblxuICAgICAgIyBDbG9zZSBhbGwgaW1wbGljaXQgZXhwcmVzc2lvbnMgaW5zaWRlIG9mIGV4cGxpY2l0bHkgY2xvc2VkIGV4cHJlc3Npb25zLlxuICAgICAgaWYgdGFnIGluIEVYUFJFU1NJT05fRU5EXG4gICAgICAgIHdoaWxlIGluSW1wbGljaXQoKVxuICAgICAgICAgIGlmIGluSW1wbGljaXRDYWxsKClcbiAgICAgICAgICAgIGVuZEltcGxpY2l0Q2FsbCgpXG4gICAgICAgICAgZWxzZSBpZiBpbkltcGxpY2l0T2JqZWN0KClcbiAgICAgICAgICAgIGVuZEltcGxpY2l0T2JqZWN0KClcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBzdGFjay5wb3AoKVxuICAgICAgICBzdGFydCA9IHN0YWNrLnBvcCgpXG5cbiAgICAgIGluQ29udHJvbEZsb3cgPSA9PlxuICAgICAgICBzZWVuRm9yID0gQGZpbmRUYWdzQmFja3dhcmRzKGksIFsnRk9SJ10pIGFuZCBAZmluZFRhZ3NCYWNrd2FyZHMoaSwgWydGT1JJTicsICdGT1JPRicsICdGT1JGUk9NJ10pXG4gICAgICAgIGNvbnRyb2xGbG93ID0gc2VlbkZvciBvciBAZmluZFRhZ3NCYWNrd2FyZHMgaSwgWydXSElMRScsICdVTlRJTCcsICdMT09QJywgJ0xFQURJTkdfV0hFTiddXG4gICAgICAgIHJldHVybiBubyB1bmxlc3MgY29udHJvbEZsb3dcbiAgICAgICAgaXNGdW5jID0gbm9cbiAgICAgICAgdGFnQ3VycmVudExpbmUgPSB0b2tlblsyXS5maXJzdF9saW5lXG4gICAgICAgIEBkZXRlY3RFbmQgaSxcbiAgICAgICAgICAodG9rZW4sIGkpIC0+IHRva2VuWzBdIGluIExJTkVCUkVBS1NcbiAgICAgICAgICAodG9rZW4sIGkpIC0+XG4gICAgICAgICAgICBbcHJldlRhZywgLHtmaXJzdF9saW5lfV0gPSB0b2tlbnNbaSAtIDFdIHx8IFtdXG4gICAgICAgICAgICBpc0Z1bmMgPSB0YWdDdXJyZW50TGluZSBpcyBmaXJzdF9saW5lIGFuZCBwcmV2VGFnIGluIFsnLT4nLCAnPT4nXVxuICAgICAgICAgIHJldHVybk9uTmVnYXRpdmVMZXZlbDogeWVzXG4gICAgICAgIGlzRnVuY1xuXG4gICAgICAjIFJlY29nbml6ZSBzdGFuZGFyZCBpbXBsaWNpdCBjYWxscyBsaWtlXG4gICAgICAjIGYgYSwgZigpIGIsIGY/IGMsIGhbMF0gZCBldGMuXG4gICAgICAjIEFkZGVkIHN1cHBvcnQgZm9yIHNwcmVhZCBkb3RzIG9uIHRoZSBsZWZ0IHNpZGU6IGYgLi4uYVxuICAgICAgaWYgKHRhZyBpbiBJTVBMSUNJVF9GVU5DIGFuZCB0b2tlbi5zcGFjZWQgb3JcbiAgICAgICAgICB0YWcgaXMgJz8nIGFuZCBpID4gMCBhbmQgbm90IHRva2Vuc1tpIC0gMV0uc3BhY2VkKSBhbmRcbiAgICAgICAgIChuZXh0VGFnIGluIElNUExJQ0lUX0NBTEwgb3JcbiAgICAgICAgIChuZXh0VGFnIGlzICcuLi4nIGFuZCBAdGFnKGkgKyAyKSBpbiBJTVBMSUNJVF9DQUxMIGFuZCBub3QgQGZpbmRUYWdzQmFja3dhcmRzKGksIFsnSU5ERVhfU1RBUlQnLCAnWyddKSkgb3JcbiAgICAgICAgICBuZXh0VGFnIGluIElNUExJQ0lUX1VOU1BBQ0VEX0NBTEwgYW5kXG4gICAgICAgICAgbm90IG5leHRUb2tlbi5zcGFjZWQgYW5kIG5vdCBuZXh0VG9rZW4ubmV3TGluZSkgYW5kXG4gICAgICAgICAgbm90IGluQ29udHJvbEZsb3coKVxuICAgICAgICB0YWcgPSB0b2tlblswXSA9ICdGVU5DX0VYSVNUJyBpZiB0YWcgaXMgJz8nXG4gICAgICAgIHN0YXJ0SW1wbGljaXRDYWxsIGkgKyAxXG4gICAgICAgIHJldHVybiBmb3J3YXJkKDIpXG5cbiAgICAgICMgSW1wbGljaXQgY2FsbCB0YWtpbmcgYW4gaW1wbGljaXQgaW5kZW50ZWQgb2JqZWN0IGFzIGZpcnN0IGFyZ3VtZW50LlxuICAgICAgI1xuICAgICAgIyAgICAgZlxuICAgICAgIyAgICAgICBhOiBiXG4gICAgICAjICAgICAgIGM6IGRcbiAgICAgICNcbiAgICAgICMgRG9u4oCZdCBhY2NlcHQgaW1wbGljaXQgY2FsbHMgb2YgdGhpcyB0eXBlLCB3aGVuIG9uIHRoZSBzYW1lIGxpbmVcbiAgICAgICMgYXMgdGhlIGNvbnRyb2wgc3RydWN0dXJlcyBiZWxvdyBhcyB0aGF0IG1heSBtaXNpbnRlcnByZXQgY29uc3RydWN0cyBsaWtlOlxuICAgICAgI1xuICAgICAgIyAgICAgaWYgZlxuICAgICAgIyAgICAgICAgYTogMVxuICAgICAgIyBhc1xuICAgICAgI1xuICAgICAgIyAgICAgaWYgZihhOiAxKVxuICAgICAgI1xuICAgICAgIyB3aGljaCBpcyBwcm9iYWJseSBhbHdheXMgdW5pbnRlbmRlZC5cbiAgICAgICMgRnVydGhlcm1vcmUgZG9u4oCZdCBhbGxvdyB0aGlzIGluIHRoZSBmaXJzdCBsaW5lIG9mIGEgbGl0ZXJhbCBhcnJheVxuICAgICAgIyBvciBleHBsaWNpdCBvYmplY3QsIGFzIHRoYXQgY3JlYXRlcyBncmFtbWF0aWNhbCBhbWJpZ3VpdGllcyAoIzUzNjgpLlxuICAgICAgaWYgdGFnIGluIElNUExJQ0lUX0ZVTkMgYW5kXG4gICAgICAgICBAaW5kZXhPZlRhZyhpICsgMSwgJ0lOREVOVCcpID4gLTEgYW5kIEBsb29rc09iamVjdGlzaChpICsgMikgYW5kXG4gICAgICAgICBub3QgQGZpbmRUYWdzQmFja3dhcmRzKGksIFsnQ0xBU1MnLCAnRVhURU5EUycsICdJRicsICdDQVRDSCcsXG4gICAgICAgICAgJ1NXSVRDSCcsICdMRUFESU5HX1dIRU4nLCAnRk9SJywgJ1dISUxFJywgJ1VOVElMJ10pIGFuZFxuICAgICAgICAgbm90ICgocyA9IHN0YWNrVG9wKCk/WzBdKSBpbiBbJ3snLCAnWyddIGFuZFxuICAgICAgICAgICAgICBub3QgaXNJbXBsaWNpdChzdGFja1RvcCgpKSBhbmRcbiAgICAgICAgICAgICAgQGZpbmRUYWdzQmFja3dhcmRzKGksIHMpKVxuICAgICAgICBzdGFydEltcGxpY2l0Q2FsbCBpICsgMVxuICAgICAgICBzdGFjay5wdXNoIFsnSU5ERU5UJywgaSArIDJdXG4gICAgICAgIHJldHVybiBmb3J3YXJkKDMpXG5cbiAgICAgICMgSW1wbGljaXQgb2JqZWN0cyBzdGFydCBoZXJlLlxuICAgICAgaWYgdGFnIGlzICc6J1xuICAgICAgICAjIEdvIGJhY2sgdG8gdGhlIChpbXBsaWNpdCkgc3RhcnQgb2YgdGhlIG9iamVjdC5cbiAgICAgICAgcyA9IHN3aXRjaFxuICAgICAgICAgIHdoZW4gQHRhZyhpIC0gMSkgaW4gRVhQUkVTU0lPTl9FTkRcbiAgICAgICAgICAgIFtzdGFydFRhZywgc3RhcnRJbmRleF0gPSBzdGFydFxuICAgICAgICAgICAgaWYgc3RhcnRUYWcgaXMgJ1snIGFuZCBzdGFydEluZGV4ID4gMCBhbmQgQHRhZyhzdGFydEluZGV4IC0gMSkgaXMgJ0AnIGFuZCBub3QgdG9rZW5zW3N0YXJ0SW5kZXggLSAxXS5zcGFjZWRcbiAgICAgICAgICAgICAgc3RhcnRJbmRleCAtIDFcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgc3RhcnRJbmRleFxuICAgICAgICAgIHdoZW4gQHRhZyhpIC0gMikgaXMgJ0AnIHRoZW4gaSAtIDJcbiAgICAgICAgICBlbHNlIGkgLSAxXG5cbiAgICAgICAgc3RhcnRzTGluZSA9IHMgPD0gMCBvciBAdGFnKHMgLSAxKSBpbiBMSU5FQlJFQUtTIG9yIHRva2Vuc1tzIC0gMV0ubmV3TGluZVxuICAgICAgICAjIEFyZSB3ZSBqdXN0IGNvbnRpbnVpbmcgYW4gYWxyZWFkeSBkZWNsYXJlZCBvYmplY3Q/XG4gICAgICAgICMgSW5jbHVkaW5nIHRoZSBjYXNlIHdoZXJlIHdlIGluZGVudCBvbiB0aGUgbGluZSBhZnRlciBhbiBleHBsaWNpdCAneycuXG4gICAgICAgIGlmIHN0YWNrVG9wKClcbiAgICAgICAgICBbc3RhY2tUYWcsIHN0YWNrSWR4XSA9IHN0YWNrVG9wKClcbiAgICAgICAgICBzdGFja05leHQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAyXVxuICAgICAgICAgIGlmIChzdGFja1RhZyBpcyAneycgb3JcbiAgICAgICAgICAgICAgc3RhY2tUYWcgaXMgJ0lOREVOVCcgYW5kIHN0YWNrTmV4dD9bMF0gaXMgJ3snIGFuZFxuICAgICAgICAgICAgICBub3QgaXNJbXBsaWNpdChzdGFja05leHQpIGFuZFxuICAgICAgICAgICAgICBAZmluZFRhZ3NCYWNrd2FyZHMoc3RhY2tJZHgtMSwgWyd7J10pKSBhbmRcbiAgICAgICAgICAgICAoc3RhcnRzTGluZSBvciBAdGFnKHMgLSAxKSBpcyAnLCcgb3IgQHRhZyhzIC0gMSkgaXMgJ3snKSBhbmRcbiAgICAgICAgICAgICBAdGFnKHMgLSAxKSBub3QgaW4gVU5GSU5JU0hFRFxuICAgICAgICAgICAgcmV0dXJuIGZvcndhcmQoMSlcblxuICAgICAgICBwcmVPYmplY3RUb2tlbiA9IGlmIGkgPiAxIHRoZW4gdG9rZW5zW2kgLSAyXSBlbHNlIFtdXG4gICAgICAgIHN0YXJ0SW1wbGljaXRPYmplY3Qocywge3N0YXJ0c0xpbmU6ICEhc3RhcnRzTGluZSwgY29udGludWF0aW9uTGluZUluZGVudDogcHJlT2JqZWN0VG9rZW4uY29udGludWF0aW9uTGluZUluZGVudH0pXG4gICAgICAgIHJldHVybiBmb3J3YXJkKDIpXG5cbiAgICAgICMgRW5kIGltcGxpY2l0IGNhbGxzIHdoZW4gY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICAjIGxpa2UgZS5nLjpcbiAgICAgICNcbiAgICAgICMgICAgIGYgLT5cbiAgICAgICMgICAgICAgYVxuICAgICAgIyAgICAgLmcgYiwgLT5cbiAgICAgICMgICAgICAgY1xuICAgICAgIyAgICAgLmggYVxuICAgICAgI1xuICAgICAgIyBhbmQgYWxzb1xuICAgICAgI1xuICAgICAgIyAgICAgZiBhXG4gICAgICAjICAgICAuZyBiXG4gICAgICAjICAgICAuaCBhXG5cbiAgICAgICMgTWFyayBhbGwgZW5jbG9zaW5nIG9iamVjdHMgYXMgbm90IHNhbWVMaW5lXG4gICAgICBpZiB0YWcgaW4gTElORUJSRUFLU1xuICAgICAgICBmb3Igc3RhY2tJdGVtIGluIHN0YWNrIGJ5IC0xXG4gICAgICAgICAgYnJlYWsgdW5sZXNzIGlzSW1wbGljaXQgc3RhY2tJdGVtXG4gICAgICAgICAgc3RhY2tJdGVtWzJdLnNhbWVMaW5lID0gbm8gaWYgaXNJbXBsaWNpdE9iamVjdCBzdGFja0l0ZW1cblxuICAgICAgIyBFbmQgaW5kZW50ZWQtY29udGludWF0aW9uLWxpbmUgaW1wbGljaXQgb2JqZWN0cyBvbmNlIHRoYXQgaW5kZW50YXRpb24gaXMgb3Zlci5cbiAgICAgIGlmIHRhZyBpcyAnVEVSTUlOQVRPUicgYW5kIHRva2VuLmVuZHNDb250aW51YXRpb25MaW5lSW5kZW50YXRpb25cbiAgICAgICAge3ByZUNvbnRpbnVhdGlvbkxpbmVJbmRlbnR9ID0gdG9rZW4uZW5kc0NvbnRpbnVhdGlvbkxpbmVJbmRlbnRhdGlvblxuICAgICAgICB3aGlsZSBpbkltcGxpY2l0T2JqZWN0KCkgYW5kIChpbXBsaWNpdE9iamVjdEluZGVudCA9IHN0YWNrVG9wKClbMl0uY29udGludWF0aW9uTGluZUluZGVudCk/IGFuZCBpbXBsaWNpdE9iamVjdEluZGVudCA+IHByZUNvbnRpbnVhdGlvbkxpbmVJbmRlbnRcbiAgICAgICAgICBlbmRJbXBsaWNpdE9iamVjdCgpXG5cbiAgICAgIG5ld0xpbmUgPSBwcmV2VGFnIGlzICdPVVRERU5UJyBvciBwcmV2VG9rZW4ubmV3TGluZVxuICAgICAgaWYgdGFnIGluIElNUExJQ0lUX0VORCBvclxuICAgICAgICAgICh0YWcgaW4gQ0FMTF9DTE9TRVJTIGFuZCBuZXdMaW5lKSBvclxuICAgICAgICAgICh0YWcgaW4gWycuLicsICcuLi4nXSBhbmQgQGZpbmRUYWdzQmFja3dhcmRzKGksIFtcIklOREVYX1NUQVJUXCJdKSlcbiAgICAgICAgd2hpbGUgaW5JbXBsaWNpdCgpXG4gICAgICAgICAgW3N0YWNrVGFnLCBzdGFja0lkeCwge3NhbWVMaW5lLCBzdGFydHNMaW5lfV0gPSBzdGFja1RvcCgpXG4gICAgICAgICAgIyBDbG9zZSBpbXBsaWNpdCBjYWxscyB3aGVuIHJlYWNoZWQgZW5kIG9mIGFyZ3VtZW50IGxpc3RcbiAgICAgICAgICBpZiBpbkltcGxpY2l0Q2FsbCgpIGFuZCBwcmV2VGFnIGlzbnQgJywnIG9yXG4gICAgICAgICAgICAgIChwcmV2VGFnIGlzICcsJyBhbmQgdGFnIGlzICdURVJNSU5BVE9SJyBhbmQgbm90IG5leHRUYWc/KVxuICAgICAgICAgICAgZW5kSW1wbGljaXRDYWxsKClcbiAgICAgICAgICAjIENsb3NlIGltcGxpY2l0IG9iamVjdHMgc3VjaCBhczpcbiAgICAgICAgICAjIHJldHVybiBhOiAxLCBiOiAyIHVubGVzcyB0cnVlXG4gICAgICAgICAgZWxzZSBpZiBpbkltcGxpY2l0T2JqZWN0KCkgYW5kIHNhbWVMaW5lIGFuZFxuICAgICAgICAgICAgICAgICAgdGFnIGlzbnQgJ1RFUk1JTkFUT1InIGFuZCBwcmV2VGFnIGlzbnQgJzonIGFuZFxuICAgICAgICAgICAgICAgICAgbm90ICh0YWcgaW4gWydQT1NUX0lGJywgJ0ZPUicsICdXSElMRScsICdVTlRJTCddIGFuZCBzdGFydHNMaW5lIGFuZCBpbXBsaWNpdE9iamVjdENvbnRpbnVlcyhpICsgMSkpXG4gICAgICAgICAgICBlbmRJbXBsaWNpdE9iamVjdCgpXG4gICAgICAgICAgIyBDbG9zZSBpbXBsaWNpdCBvYmplY3RzIHdoZW4gYXQgZW5kIG9mIGxpbmUsIGxpbmUgZGlkbid0IGVuZCB3aXRoIGEgY29tbWFcbiAgICAgICAgICAjIGFuZCB0aGUgaW1wbGljaXQgb2JqZWN0IGRpZG4ndCBzdGFydCB0aGUgbGluZSBvciB0aGUgbmV4dCBsaW5lIGRvZXNu4oCZdCBsb29rIGxpa2VcbiAgICAgICAgICAjIHRoZSBjb250aW51YXRpb24gb2YgYW4gb2JqZWN0LlxuICAgICAgICAgIGVsc2UgaWYgaW5JbXBsaWNpdE9iamVjdCgpIGFuZCB0YWcgaXMgJ1RFUk1JTkFUT1InIGFuZCBwcmV2VGFnIGlzbnQgJywnIGFuZFxuICAgICAgICAgICAgICAgICAgbm90IChzdGFydHNMaW5lIGFuZCBAbG9va3NPYmplY3Rpc2goaSArIDEpKVxuICAgICAgICAgICAgZW5kSW1wbGljaXRPYmplY3QoKVxuICAgICAgICAgIGVsc2UgaWYgaW5JbXBsaWNpdENvbnRyb2woKSBhbmQgdG9rZW5zW3N0YWNrVG9wKClbMV1dWzBdIGlzICdDTEFTUycgYW5kIHRhZyBpcyAnVEVSTUlOQVRPUidcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWtcblxuICAgICAgIyBDbG9zZSBpbXBsaWNpdCBvYmplY3QgaWYgY29tbWEgaXMgdGhlIGxhc3QgY2hhcmFjdGVyXG4gICAgICAjIGFuZCB3aGF0IGNvbWVzIGFmdGVyIGRvZXNu4oCZdCBsb29rIGxpa2UgaXQgYmVsb25ncy5cbiAgICAgICMgVGhpcyBpcyB1c2VkIGZvciB0cmFpbGluZyBjb21tYXMgYW5kIGNhbGxzLCBsaWtlOlxuICAgICAgI1xuICAgICAgIyAgICAgeCA9XG4gICAgICAjICAgICAgICAgYTogYixcbiAgICAgICMgICAgICAgICBjOiBkLFxuICAgICAgIyAgICAgZSA9IDJcbiAgICAgICNcbiAgICAgICMgYW5kXG4gICAgICAjXG4gICAgICAjICAgICBmIGEsIGI6IGMsIGQ6IGUsIGYsIGc6IGg6IGksIGpcbiAgICAgICNcbiAgICAgIGlmIHRhZyBpcyAnLCcgYW5kIG5vdCBAbG9va3NPYmplY3Rpc2goaSArIDEpIGFuZCBpbkltcGxpY2l0T2JqZWN0KCkgYW5kIG5vdCAoQHRhZyhpICsgMikgaW4gWydGT1JPRicsICdGT1JJTiddKSBhbmRcbiAgICAgICAgIChuZXh0VGFnIGlzbnQgJ1RFUk1JTkFUT1InIG9yIG5vdCBAbG9va3NPYmplY3Rpc2goaSArIDIpKVxuICAgICAgICAjIFdoZW4gbmV4dFRhZyBpcyBPVVRERU5UIHRoZSBjb21tYSBpcyBpbnNpZ25pZmljYW50IGFuZFxuICAgICAgICAjIHNob3VsZCBqdXN0IGJlIGlnbm9yZWQgc28gZW1iZWQgaXQgaW4gdGhlIGltcGxpY2l0IG9iamVjdC5cbiAgICAgICAgI1xuICAgICAgICAjIFdoZW4gaXQgaXNu4oCZdCB0aGUgY29tbWEgZ28gb24gdG8gcGxheSBhIHJvbGUgaW4gYSBjYWxsIG9yXG4gICAgICAgICMgYXJyYXkgZnVydGhlciB1cCB0aGUgc3RhY2ssIHNvIGdpdmUgaXQgYSBjaGFuY2UuXG4gICAgICAgIG9mZnNldCA9IGlmIG5leHRUYWcgaXMgJ09VVERFTlQnIHRoZW4gMSBlbHNlIDBcbiAgICAgICAgd2hpbGUgaW5JbXBsaWNpdE9iamVjdCgpXG4gICAgICAgICAgZW5kSW1wbGljaXRPYmplY3QgaSArIG9mZnNldFxuICAgICAgcmV0dXJuIGZvcndhcmQoMSlcblxuICAjIE1ha2Ugc3VyZSBvbmx5IHN0cmluZ3MgYW5kIHdyYXBwZWQgZXhwcmVzc2lvbnMgYXJlIHVzZWQgaW4gSlNYIGF0dHJpYnV0ZXMuXG4gIGVuZm9yY2VWYWxpZEpTWEF0dHJpYnV0ZXM6IC0+XG4gICAgQHNjYW5Ub2tlbnMgKHRva2VuLCBpLCB0b2tlbnMpIC0+XG4gICAgICBpZiB0b2tlbi5qc3hDb2xvblxuICAgICAgICBuZXh0ID0gdG9rZW5zW2kgKyAxXVxuICAgICAgICBpZiBuZXh0WzBdIG5vdCBpbiBbJ1NUUklOR19TVEFSVCcsICdTVFJJTkcnLCAnKCddXG4gICAgICAgICAgdGhyb3dTeW50YXhFcnJvciAnZXhwZWN0ZWQgd3JhcHBlZCBvciBxdW90ZWQgSlNYIGF0dHJpYnV0ZScsIG5leHRbMl1cbiAgICAgIHJldHVybiAxXG5cbiAgIyBOb3QgYWxsIHRva2VucyBzdXJ2aXZlIHByb2Nlc3NpbmcgYnkgdGhlIHBhcnNlci4gVG8gYXZvaWQgY29tbWVudHMgZ2V0dGluZ1xuICAjIGxvc3QgaW50byB0aGUgZXRoZXIsIGZpbmQgY29tbWVudHMgYXR0YWNoZWQgdG8gZG9vbWVkIHRva2VucyBhbmQgbW92ZSB0aGVtXG4gICMgdG8gYSB0b2tlbiB0aGF0IHdpbGwgbWFrZSBpdCB0byB0aGUgb3RoZXIgc2lkZS5cbiAgcmVzY3VlU3Rvd2F3YXlDb21tZW50czogLT5cbiAgICBpbnNlcnRQbGFjZWhvbGRlciA9ICh0b2tlbiwgaiwgdG9rZW5zLCBtZXRob2QpIC0+XG4gICAgICB0b2tlbnNbbWV0aG9kXSBnZW5lcmF0ZSAnVEVSTUlOQVRPUicsICdcXG4nLCB0b2tlbnNbal0gdW5sZXNzIHRva2Vuc1tqXVswXSBpcyAnVEVSTUlOQVRPUidcbiAgICAgIHRva2Vuc1ttZXRob2RdIGdlbmVyYXRlICdKUycsICcnLCB0b2tlbnNbal0sIHRva2VuXG5cbiAgICBkb250U2hpZnRGb3J3YXJkID0gKGksIHRva2VucykgLT5cbiAgICAgIGogPSBpICsgMVxuICAgICAgd2hpbGUgaiBpc250IHRva2Vucy5sZW5ndGggYW5kIHRva2Vuc1tqXVswXSBpbiBESVNDQVJERURcbiAgICAgICAgcmV0dXJuIHllcyBpZiB0b2tlbnNbal1bMF0gaXMgJ0lOVEVSUE9MQVRJT05fRU5EJ1xuICAgICAgICBqKytcbiAgICAgIG5vXG5cbiAgICBzaGlmdENvbW1lbnRzRm9yd2FyZCA9ICh0b2tlbiwgaSwgdG9rZW5zKSAtPlxuICAgICAgIyBGaW5kIHRoZSBuZXh0IHN1cnZpdmluZyB0b2tlbiBhbmQgYXR0YWNoIHRoaXMgdG9rZW7igJlzIGNvbW1lbnRzIHRvIGl0LFxuICAgICAgIyB3aXRoIGEgZmxhZyB0aGF0IHdlIGtub3cgdG8gb3V0cHV0IHN1Y2ggY29tbWVudHMgKmJlZm9yZSogdGhhdFxuICAgICAgIyB0b2tlbuKAmXMgb3duIGNvbXBpbGF0aW9uLiAoT3RoZXJ3aXNlIGNvbW1lbnRzIGFyZSBvdXRwdXQgZm9sbG93aW5nXG4gICAgICAjIHRoZSB0b2tlbiB0aGV54oCZcmUgYXR0YWNoZWQgdG8uKVxuICAgICAgaiA9IGlcbiAgICAgIGorKyB3aGlsZSBqIGlzbnQgdG9rZW5zLmxlbmd0aCBhbmQgdG9rZW5zW2pdWzBdIGluIERJU0NBUkRFRFxuICAgICAgdW5sZXNzIGogaXMgdG9rZW5zLmxlbmd0aCBvciB0b2tlbnNbal1bMF0gaW4gRElTQ0FSREVEXG4gICAgICAgIGNvbW1lbnQudW5zaGlmdCA9IHllcyBmb3IgY29tbWVudCBpbiB0b2tlbi5jb21tZW50c1xuICAgICAgICBtb3ZlQ29tbWVudHMgdG9rZW4sIHRva2Vuc1tqXVxuICAgICAgICByZXR1cm4gMVxuICAgICAgZWxzZSAjIEFsbCBmb2xsb3dpbmcgdG9rZW5zIGFyZSBkb29tZWQhXG4gICAgICAgIGogPSB0b2tlbnMubGVuZ3RoIC0gMVxuICAgICAgICBpbnNlcnRQbGFjZWhvbGRlciB0b2tlbiwgaiwgdG9rZW5zLCAncHVzaCdcbiAgICAgICAgIyBUaGUgZ2VuZXJhdGVkIHRva2VucyB3ZXJlIGFkZGVkIHRvIHRoZSBlbmQsIG5vdCBpbmxpbmUsIHNvIHdlIGRvbuKAmXQgc2tpcC5cbiAgICAgICAgcmV0dXJuIDFcblxuICAgIHNoaWZ0Q29tbWVudHNCYWNrd2FyZCA9ICh0b2tlbiwgaSwgdG9rZW5zKSAtPlxuICAgICAgIyBGaW5kIHRoZSBsYXN0IHN1cnZpdmluZyB0b2tlbiBhbmQgYXR0YWNoIHRoaXMgdG9rZW7igJlzIGNvbW1lbnRzIHRvIGl0LlxuICAgICAgaiA9IGlcbiAgICAgIGotLSB3aGlsZSBqIGlzbnQgLTEgYW5kIHRva2Vuc1tqXVswXSBpbiBESVNDQVJERURcbiAgICAgIHVubGVzcyBqIGlzIC0xIG9yIHRva2Vuc1tqXVswXSBpbiBESVNDQVJERURcbiAgICAgICAgbW92ZUNvbW1lbnRzIHRva2VuLCB0b2tlbnNbal1cbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIGVsc2UgIyBBbGwgcHJldmlvdXMgdG9rZW5zIGFyZSBkb29tZWQhXG4gICAgICAgIGluc2VydFBsYWNlaG9sZGVyIHRva2VuLCAwLCB0b2tlbnMsICd1bnNoaWZ0J1xuICAgICAgICAjIFdlIGFkZGVkIHR3byB0b2tlbnMsIHNvIHNoaWZ0IGZvcndhcmQgdG8gYWNjb3VudCBmb3IgdGhlIGluc2VydGlvbi5cbiAgICAgICAgcmV0dXJuIDNcblxuICAgIEBzY2FuVG9rZW5zICh0b2tlbiwgaSwgdG9rZW5zKSAtPlxuICAgICAgcmV0dXJuIDEgdW5sZXNzIHRva2VuLmNvbW1lbnRzXG4gICAgICByZXQgPSAxXG4gICAgICBpZiB0b2tlblswXSBpbiBESVNDQVJERURcbiAgICAgICAgIyBUaGlzIHRva2VuIHdvbuKAmXQgc3Vydml2ZSBwYXNzYWdlIHRocm91Z2ggdGhlIHBhcnNlciwgc28gd2UgbmVlZCB0b1xuICAgICAgICAjIHJlc2N1ZSBpdHMgYXR0YWNoZWQgdG9rZW5zIGFuZCByZWRpc3RyaWJ1dGUgdGhlbSB0byBuZWFyYnkgdG9rZW5zLlxuICAgICAgICAjIENvbW1lbnRzIHRoYXQgZG9u4oCZdCBzdGFydCBhIG5ldyBsaW5lIGNhbiBzaGlmdCBiYWNrd2FyZHMgdG8gdGhlIGxhc3RcbiAgICAgICAgIyBzYWZlIHRva2VuLCB3aGlsZSBvdGhlciB0b2tlbnMgc2hvdWxkIHNoaWZ0IGZvcndhcmQuXG4gICAgICAgIGR1bW15VG9rZW4gPSBjb21tZW50czogW11cbiAgICAgICAgaiA9IHRva2VuLmNvbW1lbnRzLmxlbmd0aCAtIDFcbiAgICAgICAgdW50aWwgaiBpcyAtMVxuICAgICAgICAgIGlmIHRva2VuLmNvbW1lbnRzW2pdLm5ld0xpbmUgaXMgbm8gYW5kIHRva2VuLmNvbW1lbnRzW2pdLmhlcmUgaXMgbm9cbiAgICAgICAgICAgIGR1bW15VG9rZW4uY29tbWVudHMudW5zaGlmdCB0b2tlbi5jb21tZW50c1tqXVxuICAgICAgICAgICAgdG9rZW4uY29tbWVudHMuc3BsaWNlIGosIDFcbiAgICAgICAgICBqLS1cbiAgICAgICAgaWYgZHVtbXlUb2tlbi5jb21tZW50cy5sZW5ndGggaXNudCAwXG4gICAgICAgICAgcmV0ID0gc2hpZnRDb21tZW50c0JhY2t3YXJkIGR1bW15VG9rZW4sIGkgLSAxLCB0b2tlbnNcbiAgICAgICAgaWYgdG9rZW4uY29tbWVudHMubGVuZ3RoIGlzbnQgMFxuICAgICAgICAgIHNoaWZ0Q29tbWVudHNGb3J3YXJkIHRva2VuLCBpLCB0b2tlbnNcbiAgICAgIGVsc2UgdW5sZXNzIGRvbnRTaGlmdEZvcndhcmQgaSwgdG9rZW5zXG4gICAgICAgICMgSWYgYW55IG9mIHRoaXMgdG9rZW7igJlzIGNvbW1lbnRzIHN0YXJ0IGEgbGluZeKAlHRoZXJl4oCZcyBvbmx5XG4gICAgICAgICMgd2hpdGVzcGFjZSBiZXR3ZWVuIHRoZSBwcmVjZWRpbmcgbmV3bGluZSBhbmQgdGhlIHN0YXJ0IG9mIHRoZVxuICAgICAgICAjIGNvbW1lbnTigJRhbmQgdGhpcyBpc27igJl0IG9uZSBvZiB0aGUgc3BlY2lhbCBgSlNgIHRva2VucywgdGhlblxuICAgICAgICAjIHNoaWZ0IHRoaXMgY29tbWVudCBmb3J3YXJkIHRvIHByZWNlZGUgdGhlIG5leHQgdmFsaWQgdG9rZW4uXG4gICAgICAgICMgYEJsb2NrLmNvbXBpbGVDb21tZW50c2AgYWxzbyBoYXMgbG9naWMgdG8gbWFrZSBzdXJlIHRoYXRcbiAgICAgICAgIyDigJxzdGFydGluZyBuZXcgbGluZeKAnSBjb21tZW50cyBmb2xsb3cgb3IgcHJlY2VkZSB0aGUgbmVhcmVzdFxuICAgICAgICAjIG5ld2xpbmUgcmVsYXRpdmUgdG8gdGhlIHRva2VuIHRoYXQgdGhlIGNvbW1lbnQgaXMgYXR0YWNoZWQgdG8sXG4gICAgICAgICMgYnV0IHRoYXQgbmV3bGluZSBtaWdodCBiZSBpbnNpZGUgYSBgfWAgb3IgYClgIG9yIG90aGVyIGdlbmVyYXRlZFxuICAgICAgICAjIHRva2VuIHRoYXQgd2UgcmVhbGx5IHdhbnQgdGhpcyBjb21tZW50IHRvIG91dHB1dCBhZnRlci4gVGhlcmVmb3JlXG4gICAgICAgICMgd2UgbmVlZCB0byBzaGlmdCB0aGUgY29tbWVudHMgaGVyZSwgYXZvaWRpbmcgc3VjaCBnZW5lcmF0ZWQgYW5kXG4gICAgICAgICMgZGlzY2FyZGVkIHRva2Vucy5cbiAgICAgICAgZHVtbXlUb2tlbiA9IGNvbW1lbnRzOiBbXVxuICAgICAgICBqID0gdG9rZW4uY29tbWVudHMubGVuZ3RoIC0gMVxuICAgICAgICB1bnRpbCBqIGlzIC0xXG4gICAgICAgICAgaWYgdG9rZW4uY29tbWVudHNbal0ubmV3TGluZSBhbmQgbm90IHRva2VuLmNvbW1lbnRzW2pdLnVuc2hpZnQgYW5kXG4gICAgICAgICAgICAgbm90ICh0b2tlblswXSBpcyAnSlMnIGFuZCB0b2tlbi5nZW5lcmF0ZWQpXG4gICAgICAgICAgICBkdW1teVRva2VuLmNvbW1lbnRzLnVuc2hpZnQgdG9rZW4uY29tbWVudHNbal1cbiAgICAgICAgICAgIHRva2VuLmNvbW1lbnRzLnNwbGljZSBqLCAxXG4gICAgICAgICAgai0tXG4gICAgICAgIGlmIGR1bW15VG9rZW4uY29tbWVudHMubGVuZ3RoIGlzbnQgMFxuICAgICAgICAgIHJldCA9IHNoaWZ0Q29tbWVudHNGb3J3YXJkIGR1bW15VG9rZW4sIGkgKyAxLCB0b2tlbnNcbiAgICAgIGRlbGV0ZSB0b2tlbi5jb21tZW50cyBpZiB0b2tlbi5jb21tZW50cz8ubGVuZ3RoIGlzIDBcbiAgICAgIHJldFxuXG4gICMgQWRkIGxvY2F0aW9uIGRhdGEgdG8gYWxsIHRva2VucyBnZW5lcmF0ZWQgYnkgdGhlIHJld3JpdGVyLlxuICBhZGRMb2NhdGlvbkRhdGFUb0dlbmVyYXRlZFRva2VuczogLT5cbiAgICBAc2NhblRva2VucyAodG9rZW4sIGksIHRva2VucykgLT5cbiAgICAgIHJldHVybiAxIGlmICAgICB0b2tlblsyXVxuICAgICAgcmV0dXJuIDEgdW5sZXNzIHRva2VuLmdlbmVyYXRlZCBvciB0b2tlbi5leHBsaWNpdFxuICAgICAgaWYgdG9rZW4uZnJvbVRoZW4gYW5kIHRva2VuWzBdIGlzICdJTkRFTlQnXG4gICAgICAgIHRva2VuWzJdID0gdG9rZW4ub3JpZ2luWzJdXG4gICAgICAgIHJldHVybiAxXG4gICAgICBpZiB0b2tlblswXSBpcyAneycgYW5kIG5leHRMb2NhdGlvbj10b2tlbnNbaSArIDFdP1syXVxuICAgICAgICB7Zmlyc3RfbGluZTogbGluZSwgZmlyc3RfY29sdW1uOiBjb2x1bW4sIHJhbmdlOiBbcmFuZ2VJbmRleF19ID0gbmV4dExvY2F0aW9uXG4gICAgICBlbHNlIGlmIHByZXZMb2NhdGlvbiA9IHRva2Vuc1tpIC0gMV0/WzJdXG4gICAgICAgIHtsYXN0X2xpbmU6IGxpbmUsIGxhc3RfY29sdW1uOiBjb2x1bW4sIHJhbmdlOiBbLCByYW5nZUluZGV4XX0gPSBwcmV2TG9jYXRpb25cbiAgICAgICAgY29sdW1uICs9IDFcbiAgICAgIGVsc2VcbiAgICAgICAgbGluZSA9IGNvbHVtbiA9IDBcbiAgICAgICAgcmFuZ2VJbmRleCA9IDBcbiAgICAgIHRva2VuWzJdID0ge1xuICAgICAgICBmaXJzdF9saW5lOiAgICAgICAgICAgIGxpbmVcbiAgICAgICAgZmlyc3RfY29sdW1uOiAgICAgICAgICBjb2x1bW5cbiAgICAgICAgbGFzdF9saW5lOiAgICAgICAgICAgICBsaW5lXG4gICAgICAgIGxhc3RfY29sdW1uOiAgICAgICAgICAgY29sdW1uXG4gICAgICAgIGxhc3RfbGluZV9leGNsdXNpdmU6ICAgbGluZVxuICAgICAgICBsYXN0X2NvbHVtbl9leGNsdXNpdmU6IGNvbHVtblxuICAgICAgICByYW5nZTogW3JhbmdlSW5kZXgsIHJhbmdlSW5kZXhdXG4gICAgICB9XG4gICAgICByZXR1cm4gMVxuXG4gICMgYE9VVERFTlRgIHRva2VucyBzaG91bGQgYWx3YXlzIGJlIHBvc2l0aW9uZWQgYXQgdGhlIGxhc3QgY2hhcmFjdGVyIG9mIHRoZVxuICAjIHByZXZpb3VzIHRva2VuLCBzbyB0aGF0IEFTVCBub2RlcyBlbmRpbmcgaW4gYW4gYE9VVERFTlRgIHRva2VuIGVuZCB1cCB3aXRoIGFcbiAgIyBsb2NhdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBsYXN0IOKAnHJlYWzigJ0gdG9rZW4gdW5kZXIgdGhlIG5vZGUuXG4gIGZpeEluZGVudGF0aW9uTG9jYXRpb25EYXRhOiAtPlxuICAgIEBhbGxDb21tZW50cyA/PSBleHRyYWN0QWxsQ29tbWVudFRva2VucyBAdG9rZW5zXG4gICAgZmluZFByZWNlZGluZ0NvbW1lbnQgPSAodG9rZW4sIHthZnRlclBvc2l0aW9uLCBpbmRlbnRTaXplLCBmaXJzdCwgaW5kZW50ZWR9KSA9PlxuICAgICAgdG9rZW5TdGFydCA9IHRva2VuWzJdLnJhbmdlWzBdXG4gICAgICBtYXRjaGVzID0gKGNvbW1lbnQpIC0+XG4gICAgICAgIGlmIGNvbW1lbnQub3V0ZGVudGVkXG4gICAgICAgICAgcmV0dXJuIG5vIHVubGVzcyBpbmRlbnRTaXplPyBhbmQgY29tbWVudC5pbmRlbnRTaXplID4gaW5kZW50U2l6ZVxuICAgICAgICByZXR1cm4gbm8gaWYgaW5kZW50ZWQgYW5kIG5vdCBjb21tZW50LmluZGVudGVkXG4gICAgICAgIHJldHVybiBubyB1bmxlc3MgY29tbWVudC5sb2NhdGlvbkRhdGEucmFuZ2VbMF0gPCB0b2tlblN0YXJ0XG4gICAgICAgIHJldHVybiBubyB1bmxlc3MgY29tbWVudC5sb2NhdGlvbkRhdGEucmFuZ2VbMF0gPiBhZnRlclBvc2l0aW9uXG4gICAgICAgIHllc1xuICAgICAgaWYgZmlyc3RcbiAgICAgICAgbGFzdE1hdGNoaW5nID0gbnVsbFxuICAgICAgICBmb3IgY29tbWVudCBpbiBAYWxsQ29tbWVudHMgYnkgLTFcbiAgICAgICAgICBpZiBtYXRjaGVzIGNvbW1lbnRcbiAgICAgICAgICAgIGxhc3RNYXRjaGluZyA9IGNvbW1lbnRcbiAgICAgICAgICBlbHNlIGlmIGxhc3RNYXRjaGluZ1xuICAgICAgICAgICAgcmV0dXJuIGxhc3RNYXRjaGluZ1xuICAgICAgICByZXR1cm4gbGFzdE1hdGNoaW5nXG4gICAgICBmb3IgY29tbWVudCBpbiBAYWxsQ29tbWVudHMgd2hlbiBtYXRjaGVzIGNvbW1lbnQgYnkgLTFcbiAgICAgICAgcmV0dXJuIGNvbW1lbnRcbiAgICAgIG51bGxcblxuICAgIEBzY2FuVG9rZW5zICh0b2tlbiwgaSwgdG9rZW5zKSAtPlxuICAgICAgcmV0dXJuIDEgdW5sZXNzIHRva2VuWzBdIGluIFsnSU5ERU5UJywgJ09VVERFTlQnXSBvclxuICAgICAgICAodG9rZW4uZ2VuZXJhdGVkIGFuZCB0b2tlblswXSBpcyAnQ0FMTF9FTkQnIGFuZCBub3QgdG9rZW4uZGF0YT8uY2xvc2luZ1RhZ05hbWVUb2tlbikgb3JcbiAgICAgICAgKHRva2VuLmdlbmVyYXRlZCBhbmQgdG9rZW5bMF0gaXMgJ30nKVxuICAgICAgaXNJbmRlbnQgPSB0b2tlblswXSBpcyAnSU5ERU5UJ1xuICAgICAgcHJldlRva2VuID0gdG9rZW4ucHJldlRva2VuID8gdG9rZW5zW2kgLSAxXVxuICAgICAgcHJldkxvY2F0aW9uRGF0YSA9IHByZXZUb2tlblsyXVxuICAgICAgIyBhZGRMb2NhdGlvbkRhdGFUb0dlbmVyYXRlZFRva2VucygpIHNldCB0aGUgb3V0ZGVudOKAmXMgbG9jYXRpb24gZGF0YVxuICAgICAgIyB0byB0aGUgcHJlY2VkaW5nIHRva2Vu4oCZcywgYnV0IGluIG9yZGVyIHRvIGRldGVjdCBjb21tZW50cyBpbnNpZGUgYW5cbiAgICAgICMgZW1wdHkgXCJibG9ja1wiIHdlIHdhbnQgdG8gbG9vayBmb3IgY29tbWVudHMgcHJlY2VkaW5nIHRoZSBuZXh0IHRva2VuLlxuICAgICAgdXNlTmV4dFRva2VuID0gdG9rZW4uZXhwbGljaXQgb3IgdG9rZW4uZ2VuZXJhdGVkXG4gICAgICBpZiB1c2VOZXh0VG9rZW5cbiAgICAgICAgbmV4dFRva2VuID0gdG9rZW5cbiAgICAgICAgbmV4dFRva2VuSW5kZXggPSBpXG4gICAgICAgIG5leHRUb2tlbiA9IHRva2Vuc1tuZXh0VG9rZW5JbmRleCsrXSB3aGlsZSAobmV4dFRva2VuLmV4cGxpY2l0IG9yIG5leHRUb2tlbi5nZW5lcmF0ZWQpIGFuZCBuZXh0VG9rZW5JbmRleCBpc250IHRva2Vucy5sZW5ndGggLSAxXG4gICAgICBwcmVjZWRpbmdDb21tZW50ID0gZmluZFByZWNlZGluZ0NvbW1lbnQoXG4gICAgICAgIGlmIHVzZU5leHRUb2tlblxuICAgICAgICAgIG5leHRUb2tlblxuICAgICAgICBlbHNlXG4gICAgICAgICAgdG9rZW5cbiAgICAgICAgYWZ0ZXJQb3NpdGlvbjogcHJldkxvY2F0aW9uRGF0YS5yYW5nZVswXVxuICAgICAgICBpbmRlbnRTaXplOiB0b2tlbi5pbmRlbnRTaXplXG4gICAgICAgIGZpcnN0OiBpc0luZGVudFxuICAgICAgICBpbmRlbnRlZDogdXNlTmV4dFRva2VuXG4gICAgICApXG4gICAgICBpZiBpc0luZGVudFxuICAgICAgICByZXR1cm4gMSB1bmxlc3MgcHJlY2VkaW5nQ29tbWVudD8ubmV3TGluZVxuICAgICAgIyBXZSBkb27igJl0IHdhbnQgZS5nLiBhbiBpbXBsaWNpdCBjYWxsIGF0IHRoZSBlbmQgb2YgYW4gYGlmYCBjb25kaXRpb24gdG9cbiAgICAgICMgaW5jbHVkZSBhIGZvbGxvd2luZyBpbmRlbnRlZCBjb21tZW50LlxuICAgICAgcmV0dXJuIDEgaWYgdG9rZW4uZ2VuZXJhdGVkIGFuZCB0b2tlblswXSBpcyAnQ0FMTF9FTkQnIGFuZCBwcmVjZWRpbmdDb21tZW50Py5pbmRlbnRlZFxuICAgICAgcHJldkxvY2F0aW9uRGF0YSA9IHByZWNlZGluZ0NvbW1lbnQubG9jYXRpb25EYXRhIGlmIHByZWNlZGluZ0NvbW1lbnQ/XG4gICAgICB0b2tlblsyXSA9XG4gICAgICAgIGZpcnN0X2xpbmU6XG4gICAgICAgICAgaWYgcHJlY2VkaW5nQ29tbWVudD9cbiAgICAgICAgICAgIHByZXZMb2NhdGlvbkRhdGEuZmlyc3RfbGluZVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHByZXZMb2NhdGlvbkRhdGEubGFzdF9saW5lXG4gICAgICAgIGZpcnN0X2NvbHVtbjpcbiAgICAgICAgICBpZiBwcmVjZWRpbmdDb21tZW50P1xuICAgICAgICAgICAgaWYgaXNJbmRlbnRcbiAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBwcmV2TG9jYXRpb25EYXRhLmZpcnN0X2NvbHVtblxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHByZXZMb2NhdGlvbkRhdGEubGFzdF9jb2x1bW5cbiAgICAgICAgbGFzdF9saW5lOiAgICAgICAgICAgICAgcHJldkxvY2F0aW9uRGF0YS5sYXN0X2xpbmVcbiAgICAgICAgbGFzdF9jb2x1bW46ICAgICAgICAgICAgcHJldkxvY2F0aW9uRGF0YS5sYXN0X2NvbHVtblxuICAgICAgICBsYXN0X2xpbmVfZXhjbHVzaXZlOiAgICBwcmV2TG9jYXRpb25EYXRhLmxhc3RfbGluZV9leGNsdXNpdmVcbiAgICAgICAgbGFzdF9jb2x1bW5fZXhjbHVzaXZlOiAgcHJldkxvY2F0aW9uRGF0YS5sYXN0X2NvbHVtbl9leGNsdXNpdmVcbiAgICAgICAgcmFuZ2U6XG4gICAgICAgICAgaWYgaXNJbmRlbnQgYW5kIHByZWNlZGluZ0NvbW1lbnQ/XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIHByZXZMb2NhdGlvbkRhdGEucmFuZ2VbMF0gLSBwcmVjZWRpbmdDb21tZW50LmluZGVudFNpemVcbiAgICAgICAgICAgICAgcHJldkxvY2F0aW9uRGF0YS5yYW5nZVsxXVxuICAgICAgICAgICAgXVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHByZXZMb2NhdGlvbkRhdGEucmFuZ2VcbiAgICAgIHJldHVybiAxXG5cbiAgIyBCZWNhdXNlIG91ciBncmFtbWFyIGlzIExBTFIoMSksIGl0IGNhbuKAmXQgaGFuZGxlIHNvbWUgc2luZ2xlLWxpbmVcbiAgIyBleHByZXNzaW9ucyB0aGF0IGxhY2sgZW5kaW5nIGRlbGltaXRlcnMuIFRoZSAqKlJld3JpdGVyKiogYWRkcyB0aGUgaW1wbGljaXRcbiAgIyBibG9ja3MsIHNvIGl0IGRvZXNu4oCZdCBuZWVkIHRvLiBUbyBrZWVwIHRoZSBncmFtbWFyIGNsZWFuIGFuZCB0aWR5LCB0cmFpbGluZ1xuICAjIG5ld2xpbmVzIHdpdGhpbiBleHByZXNzaW9ucyBhcmUgcmVtb3ZlZCBhbmQgdGhlIGluZGVudGF0aW9uIHRva2VucyBvZiBlbXB0eVxuICAjIGJsb2NrcyBhcmUgYWRkZWQuXG4gIG5vcm1hbGl6ZUxpbmVzOiAtPlxuICAgIHN0YXJ0ZXIgPSBpbmRlbnQgPSBvdXRkZW50ID0gbnVsbFxuICAgIGxlYWRpbmdfc3dpdGNoX3doZW4gPSBudWxsXG4gICAgbGVhZGluZ19pZl90aGVuID0gbnVsbFxuICAgICMgQ291bnQgYFRIRU5gIHRhZ3NcbiAgICBpZlRoZW5zID0gW11cblxuICAgIGNvbmRpdGlvbiA9ICh0b2tlbiwgaSkgLT5cbiAgICAgIHRva2VuWzFdIGlzbnQgJzsnIGFuZCB0b2tlblswXSBpbiBTSU5HTEVfQ0xPU0VSUyBhbmRcbiAgICAgIG5vdCAodG9rZW5bMF0gaXMgJ1RFUk1JTkFUT1InIGFuZCBAdGFnKGkgKyAxKSBpbiBFWFBSRVNTSU9OX0NMT1NFKSBhbmRcbiAgICAgIG5vdCAodG9rZW5bMF0gaXMgJ0VMU0UnIGFuZFxuICAgICAgICAgICAoc3RhcnRlciBpc250ICdUSEVOJyBvciAobGVhZGluZ19pZl90aGVuIG9yIGxlYWRpbmdfc3dpdGNoX3doZW4pKSkgYW5kXG4gICAgICBub3QgKHRva2VuWzBdIGluIFsnQ0FUQ0gnLCAnRklOQUxMWSddIGFuZCBzdGFydGVyIGluIFsnLT4nLCAnPT4nXSkgb3JcbiAgICAgIHRva2VuWzBdIGluIENBTExfQ0xPU0VSUyBhbmRcbiAgICAgIChAdG9rZW5zW2kgLSAxXS5uZXdMaW5lIG9yIEB0b2tlbnNbaSAtIDFdWzBdIGlzICdPVVRERU5UJylcblxuICAgIGFjdGlvbiA9ICh0b2tlbiwgaSkgLT5cbiAgICAgIGlmVGhlbnMucG9wKCkgaWYgdG9rZW5bMF0gaXMgJ0VMU0UnIGFuZCBzdGFydGVyIGlzICdUSEVOJ1xuICAgICAgQHRva2Vucy5zcGxpY2UgKGlmIEB0YWcoaSAtIDEpIGlzICcsJyB0aGVuIGkgLSAxIGVsc2UgaSksIDAsIG91dGRlbnRcblxuICAgIGNsb3NlRWxzZVRhZyA9ICh0b2tlbnMsIGkpID0+XG4gICAgICB0bGVuID0gaWZUaGVucy5sZW5ndGhcbiAgICAgIHJldHVybiBpIHVubGVzcyB0bGVuID4gMFxuICAgICAgbGFzdFRoZW4gPSBpZlRoZW5zLnBvcCgpXG4gICAgICBbLCBvdXRkZW50RWxzZV0gPSBAaW5kZW50YXRpb24gdG9rZW5zW2xhc3RUaGVuXVxuICAgICAgIyBJbnNlcnQgYE9VVERFTlRgIHRvIGNsb3NlIGlubmVyIGBJRmAuXG4gICAgICBvdXRkZW50RWxzZVsxXSA9IHRsZW4qMlxuICAgICAgdG9rZW5zLnNwbGljZShpLCAwLCBvdXRkZW50RWxzZSlcbiAgICAgICMgSW5zZXJ0IGBPVVRERU5UYCB0byBjbG9zZSBvdXRlciBgSUZgLlxuICAgICAgb3V0ZGVudEVsc2VbMV0gPSAyXG4gICAgICB0b2tlbnMuc3BsaWNlKGkgKyAxLCAwLCBvdXRkZW50RWxzZSlcbiAgICAgICMgUmVtb3ZlIG91dGRlbnRzIGZyb20gdGhlIGVuZC5cbiAgICAgIEBkZXRlY3RFbmQgaSArIDIsXG4gICAgICAgICh0b2tlbiwgaSkgLT4gdG9rZW5bMF0gaW4gWydPVVRERU5UJywgJ1RFUk1JTkFUT1InXVxuICAgICAgICAodG9rZW4sIGkpIC0+XG4gICAgICAgICAgICBpZiBAdGFnKGkpIGlzICdPVVRERU5UJyBhbmQgQHRhZyhpICsgMSkgaXMgJ09VVERFTlQnXG4gICAgICAgICAgICAgIHRva2Vucy5zcGxpY2UgaSwgMlxuICAgICAgaSArIDJcblxuICAgIEBzY2FuVG9rZW5zICh0b2tlbiwgaSwgdG9rZW5zKSAtPlxuICAgICAgW3RhZ10gPSB0b2tlblxuICAgICAgY29uZGl0aW9uVGFnID0gdGFnIGluIFsnLT4nLCAnPT4nXSBhbmRcbiAgICAgICAgQGZpbmRUYWdzQmFja3dhcmRzKGksIFsnSUYnLCAnV0hJTEUnLCAnRk9SJywgJ1VOVElMJywgJ1NXSVRDSCcsICdXSEVOJywgJ0xFQURJTkdfV0hFTicsICdbJywgJ0lOREVYX1NUQVJUJ10pIGFuZFxuICAgICAgICBub3QgKEBmaW5kVGFnc0JhY2t3YXJkcyBpLCBbJ1RIRU4nLCAnLi4nLCAnLi4uJ10pXG5cbiAgICAgIGlmIHRhZyBpcyAnVEVSTUlOQVRPUidcbiAgICAgICAgaWYgQHRhZyhpICsgMSkgaXMgJ0VMU0UnIGFuZCBAdGFnKGkgLSAxKSBpc250ICdPVVRERU5UJ1xuICAgICAgICAgIHRva2Vucy5zcGxpY2UgaSwgMSwgQGluZGVudGF0aW9uKCkuLi5cbiAgICAgICAgICByZXR1cm4gMVxuICAgICAgICBpZiBAdGFnKGkgKyAxKSBpbiBFWFBSRVNTSU9OX0NMT1NFXG4gICAgICAgICAgaWYgdG9rZW5bMV0gaXMgJzsnIGFuZCBAdGFnKGkgKyAxKSBpcyAnT1VUREVOVCdcbiAgICAgICAgICAgIHRva2Vuc1tpICsgMV0ucHJldlRva2VuID0gdG9rZW5cbiAgICAgICAgICAgIG1vdmVDb21tZW50cyB0b2tlbiwgdG9rZW5zW2kgKyAxXVxuICAgICAgICAgIHRva2Vucy5zcGxpY2UgaSwgMVxuICAgICAgICAgIHJldHVybiAwXG4gICAgICBpZiB0YWcgaXMgJ0NBVENIJ1xuICAgICAgICBmb3IgaiBpbiBbMS4uMl0gd2hlbiBAdGFnKGkgKyBqKSBpbiBbJ09VVERFTlQnLCAnVEVSTUlOQVRPUicsICdGSU5BTExZJ11cbiAgICAgICAgICB0b2tlbnMuc3BsaWNlIGkgKyBqLCAwLCBAaW5kZW50YXRpb24oKS4uLlxuICAgICAgICAgIHJldHVybiAyICsgalxuICAgICAgaWYgdGFnIGluIFsnLT4nLCAnPT4nXSBhbmQgKEB0YWcoaSArIDEpIGluIFsnLCcsICddJ10gb3IgQHRhZyhpICsgMSkgaXMgJy4nIGFuZCB0b2tlbi5uZXdMaW5lKVxuICAgICAgICBbaW5kZW50LCBvdXRkZW50XSA9IEBpbmRlbnRhdGlvbiB0b2tlbnNbaV1cbiAgICAgICAgdG9rZW5zLnNwbGljZSBpICsgMSwgMCwgaW5kZW50LCBvdXRkZW50XG4gICAgICAgIHJldHVybiAxXG4gICAgICBpZiB0YWcgaW4gU0lOR0xFX0xJTkVSUyBhbmQgQHRhZyhpICsgMSkgaXNudCAnSU5ERU5UJyBhbmRcbiAgICAgICAgIG5vdCAodGFnIGlzICdFTFNFJyBhbmQgQHRhZyhpICsgMSkgaXMgJ0lGJykgYW5kXG4gICAgICAgICBub3QgY29uZGl0aW9uVGFnXG4gICAgICAgIHN0YXJ0ZXIgPSB0YWdcbiAgICAgICAgW2luZGVudCwgb3V0ZGVudF0gPSBAaW5kZW50YXRpb24gdG9rZW5zW2ldXG4gICAgICAgIGluZGVudC5mcm9tVGhlbiAgID0gdHJ1ZSBpZiBzdGFydGVyIGlzICdUSEVOJ1xuICAgICAgICBpZiB0YWcgaXMgJ1RIRU4nXG4gICAgICAgICAgbGVhZGluZ19zd2l0Y2hfd2hlbiA9IEBmaW5kVGFnc0JhY2t3YXJkcyhpLCBbJ0xFQURJTkdfV0hFTiddKSBhbmQgQHRhZyhpICsgMSkgaXMgJ0lGJ1xuICAgICAgICAgIGxlYWRpbmdfaWZfdGhlbiA9IEBmaW5kVGFnc0JhY2t3YXJkcyhpLCBbJ0lGJ10pIGFuZCBAdGFnKGkgKyAxKSBpcyAnSUYnXG4gICAgICAgIGlmVGhlbnMucHVzaCBpIGlmIHRhZyBpcyAnVEhFTicgYW5kIEBmaW5kVGFnc0JhY2t3YXJkcyhpLCBbJ0lGJ10pXG4gICAgICAgICMgYEVMU0VgIHRhZyBpcyBub3QgY2xvc2VkLlxuICAgICAgICBpZiB0YWcgaXMgJ0VMU0UnIGFuZCBAdGFnKGkgLSAxKSBpc250ICdPVVRERU5UJ1xuICAgICAgICAgIGkgPSBjbG9zZUVsc2VUYWcgdG9rZW5zLCBpXG4gICAgICAgIHRva2Vucy5zcGxpY2UgaSArIDEsIDAsIGluZGVudFxuICAgICAgICBAZGV0ZWN0RW5kIGkgKyAyLCBjb25kaXRpb24sIGFjdGlvblxuICAgICAgICB0b2tlbnMuc3BsaWNlIGksIDEgaWYgdGFnIGlzICdUSEVOJ1xuICAgICAgICByZXR1cm4gMVxuICAgICAgcmV0dXJuIDFcblxuICAjIFRhZyBwb3N0Zml4IGNvbmRpdGlvbmFscyBhcyBzdWNoLCBzbyB0aGF0IHdlIGNhbiBwYXJzZSB0aGVtIHdpdGggYVxuICAjIGRpZmZlcmVudCBwcmVjZWRlbmNlLlxuICB0YWdQb3N0Zml4Q29uZGl0aW9uYWxzOiAtPlxuICAgIG9yaWdpbmFsID0gbnVsbFxuXG4gICAgY29uZGl0aW9uID0gKHRva2VuLCBpKSAtPlxuICAgICAgW3RhZ10gPSB0b2tlblxuICAgICAgW3ByZXZUYWddID0gQHRva2Vuc1tpIC0gMV1cbiAgICAgIHRhZyBpcyAnVEVSTUlOQVRPUicgb3IgKHRhZyBpcyAnSU5ERU5UJyBhbmQgcHJldlRhZyBub3QgaW4gU0lOR0xFX0xJTkVSUylcblxuICAgIGFjdGlvbiA9ICh0b2tlbiwgaSkgLT5cbiAgICAgIGlmIHRva2VuWzBdIGlzbnQgJ0lOREVOVCcgb3IgKHRva2VuLmdlbmVyYXRlZCBhbmQgbm90IHRva2VuLmZyb21UaGVuKVxuICAgICAgICBvcmlnaW5hbFswXSA9ICdQT1NUXycgKyBvcmlnaW5hbFswXVxuXG4gICAgQHNjYW5Ub2tlbnMgKHRva2VuLCBpKSAtPlxuICAgICAgcmV0dXJuIDEgdW5sZXNzIHRva2VuWzBdIGlzICdJRidcbiAgICAgIG9yaWdpbmFsID0gdG9rZW5cbiAgICAgIEBkZXRlY3RFbmQgaSArIDEsIGNvbmRpdGlvbiwgYWN0aW9uXG4gICAgICByZXR1cm4gMVxuXG4gICMgRm9yIHRva2VucyB3aXRoIGV4dHJhIGRhdGEsIHdlIHdhbnQgdG8gbWFrZSB0aGF0IGRhdGEgdmlzaWJsZSB0byB0aGUgZ3JhbW1hclxuICAjIGJ5IHdyYXBwaW5nIHRoZSB0b2tlbiB2YWx1ZSBhcyBhIFN0cmluZygpIG9iamVjdCBhbmQgc2V0dGluZyB0aGUgZGF0YSBhc1xuICAjIHByb3BlcnRpZXMgb2YgdGhhdCBvYmplY3QuIFRoZSBncmFtbWFyIHNob3VsZCB0aGVuIGJlIHJlc3BvbnNpYmxlIGZvclxuICAjIGNsZWFuaW5nIHRoaXMgdXAgZm9yIHRoZSBub2RlIGNvbnN0cnVjdG9yOiB1bndyYXBwaW5nIHRoZSB0b2tlbiB2YWx1ZSB0byBhXG4gICMgcHJpbWl0aXZlIHN0cmluZyBhbmQgc2VwYXJhdGVseSBwYXNzaW5nIGFueSBleHBlY3RlZCB0b2tlbiBkYXRhIHByb3BlcnRpZXNcbiAgZXhwb3NlVG9rZW5EYXRhVG9HcmFtbWFyOiAtPlxuICAgIEBzY2FuVG9rZW5zICh0b2tlbiwgaSkgLT5cbiAgICAgIGlmIHRva2VuLmdlbmVyYXRlZCBvciAodG9rZW4uZGF0YSBhbmQgT2JqZWN0LmtleXModG9rZW4uZGF0YSkubGVuZ3RoIGlzbnQgMClcbiAgICAgICAgdG9rZW5bMV0gPSBuZXcgU3RyaW5nIHRva2VuWzFdXG4gICAgICAgIHRva2VuWzFdW2tleV0gPSB2YWwgZm9yIG93biBrZXksIHZhbCBvZiAodG9rZW4uZGF0YSA/IHt9KVxuICAgICAgICB0b2tlblsxXS5nZW5lcmF0ZWQgPSB5ZXMgaWYgdG9rZW4uZ2VuZXJhdGVkXG4gICAgICAxXG5cbiAgIyBHZW5lcmF0ZSB0aGUgaW5kZW50YXRpb24gdG9rZW5zLCBiYXNlZCBvbiBhbm90aGVyIHRva2VuIG9uIHRoZSBzYW1lIGxpbmUuXG4gIGluZGVudGF0aW9uOiAob3JpZ2luKSAtPlxuICAgIGluZGVudCAgPSBbJ0lOREVOVCcsIDJdXG4gICAgb3V0ZGVudCA9IFsnT1VUREVOVCcsIDJdXG4gICAgaWYgb3JpZ2luXG4gICAgICBpbmRlbnQuZ2VuZXJhdGVkID0gb3V0ZGVudC5nZW5lcmF0ZWQgPSB5ZXNcbiAgICAgIGluZGVudC5vcmlnaW4gPSBvdXRkZW50Lm9yaWdpbiA9IG9yaWdpblxuICAgIGVsc2VcbiAgICAgIGluZGVudC5leHBsaWNpdCA9IG91dGRlbnQuZXhwbGljaXQgPSB5ZXNcbiAgICBbaW5kZW50LCBvdXRkZW50XVxuXG4gIGdlbmVyYXRlOiBnZW5lcmF0ZVxuXG4gICMgTG9vayB1cCBhIHRhZyBieSB0b2tlbiBpbmRleC5cbiAgdGFnOiAoaSkgLT4gQHRva2Vuc1tpXT9bMF1cblxuIyBDb25zdGFudHNcbiMgLS0tLS0tLS0tXG5cbiMgTGlzdCBvZiB0aGUgdG9rZW4gcGFpcnMgdGhhdCBtdXN0IGJlIGJhbGFuY2VkLlxuQkFMQU5DRURfUEFJUlMgPSBbXG4gIFsnKCcsICcpJ11cbiAgWydbJywgJ10nXVxuICBbJ3snLCAnfSddXG4gIFsnSU5ERU5UJywgJ09VVERFTlQnXSxcbiAgWydDQUxMX1NUQVJUJywgJ0NBTExfRU5EJ11cbiAgWydQQVJBTV9TVEFSVCcsICdQQVJBTV9FTkQnXVxuICBbJ0lOREVYX1NUQVJUJywgJ0lOREVYX0VORCddXG4gIFsnU1RSSU5HX1NUQVJUJywgJ1NUUklOR19FTkQnXVxuICBbJ0lOVEVSUE9MQVRJT05fU1RBUlQnLCAnSU5URVJQT0xBVElPTl9FTkQnXVxuICBbJ1JFR0VYX1NUQVJUJywgJ1JFR0VYX0VORCddXG5dXG5cbiMgVGhlIGludmVyc2UgbWFwcGluZ3Mgb2YgYEJBTEFOQ0VEX1BBSVJTYCB3ZeKAmXJlIHRyeWluZyB0byBmaXggdXAsIHNvIHdlIGNhblxuIyBsb29rIHRoaW5ncyB1cCBmcm9tIGVpdGhlciBlbmQuXG5leHBvcnRzLklOVkVSU0VTID0gSU5WRVJTRVMgPSB7fVxuXG4jIFRoZSB0b2tlbnMgdGhhdCBzaWduYWwgdGhlIHN0YXJ0L2VuZCBvZiBhIGJhbGFuY2VkIHBhaXIuXG5FWFBSRVNTSU9OX1NUQVJUID0gW11cbkVYUFJFU1NJT05fRU5EICAgPSBbXVxuXG5mb3IgW2xlZnQsIHJpZ2h0XSBpbiBCQUxBTkNFRF9QQUlSU1xuICBFWFBSRVNTSU9OX1NUQVJULnB1c2ggSU5WRVJTRVNbcmlnaHRdID0gbGVmdFxuICBFWFBSRVNTSU9OX0VORCAgLnB1c2ggSU5WRVJTRVNbbGVmdF0gPSByaWdodFxuXG4jIFRva2VucyB0aGF0IGluZGljYXRlIHRoZSBjbG9zZSBvZiBhIGNsYXVzZSBvZiBhbiBleHByZXNzaW9uLlxuRVhQUkVTU0lPTl9DTE9TRSA9IFsnQ0FUQ0gnLCAnVEhFTicsICdFTFNFJywgJ0ZJTkFMTFknXS5jb25jYXQgRVhQUkVTU0lPTl9FTkRcblxuIyBUb2tlbnMgdGhhdCwgaWYgZm9sbG93ZWQgYnkgYW4gYElNUExJQ0lUX0NBTExgLCBpbmRpY2F0ZSBhIGZ1bmN0aW9uIGludm9jYXRpb24uXG5JTVBMSUNJVF9GVU5DICAgID0gWydJREVOVElGSUVSJywgJ1BST1BFUlRZJywgJ1NVUEVSJywgJyknLCAnQ0FMTF9FTkQnLCAnXScsICdJTkRFWF9FTkQnLCAnQCcsICdUSElTJ11cblxuIyBJZiBwcmVjZWRlZCBieSBhbiBgSU1QTElDSVRfRlVOQ2AsIGluZGljYXRlcyBhIGZ1bmN0aW9uIGludm9jYXRpb24uXG5JTVBMSUNJVF9DQUxMICAgID0gW1xuICAnSURFTlRJRklFUicsICdKU1hfVEFHJywgJ1BST1BFUlRZJywgJ05VTUJFUicsICdJTkZJTklUWScsICdOQU4nXG4gICdTVFJJTkcnLCAnU1RSSU5HX1NUQVJUJywgJ1JFR0VYJywgJ1JFR0VYX1NUQVJUJywgJ0pTJ1xuICAnTkVXJywgJ1BBUkFNX1NUQVJUJywgJ0NMQVNTJywgJ0lGJywgJ1RSWScsICdTV0lUQ0gnLCAnVEhJUydcbiAgJ0RZTkFNSUNfSU1QT1JUJywgJ0lNUE9SVF9NRVRBJywgJ05FV19UQVJHRVQnXG4gICdVTkRFRklORUQnLCAnTlVMTCcsICdCT09MJ1xuICAnVU5BUlknLCAnRE8nLCAnRE9fSUlGRScsICdZSUVMRCcsICdBV0FJVCcsICdVTkFSWV9NQVRIJywgJ1NVUEVSJywgJ1RIUk9XJ1xuICAnQCcsICctPicsICc9PicsICdbJywgJygnLCAneycsICctLScsICcrKydcbl1cblxuSU1QTElDSVRfVU5TUEFDRURfQ0FMTCA9IFsnKycsICctJ11cblxuIyBUb2tlbnMgdGhhdCBhbHdheXMgbWFyayB0aGUgZW5kIG9mIGFuIGltcGxpY2l0IGNhbGwgZm9yIHNpbmdsZS1saW5lcnMuXG5JTVBMSUNJVF9FTkQgICAgID0gWydQT1NUX0lGJywgJ0ZPUicsICdXSElMRScsICdVTlRJTCcsICdXSEVOJywgJ0JZJyxcbiAgJ0xPT1AnLCAnVEVSTUlOQVRPUiddXG5cbiMgU2luZ2xlLWxpbmUgZmxhdm9ycyBvZiBibG9jayBleHByZXNzaW9ucyB0aGF0IGhhdmUgdW5jbG9zZWQgZW5kaW5ncy5cbiMgVGhlIGdyYW1tYXIgY2Fu4oCZdCBkaXNhbWJpZ3VhdGUgdGhlbSwgc28gd2UgaW5zZXJ0IHRoZSBpbXBsaWNpdCBpbmRlbnRhdGlvbi5cblNJTkdMRV9MSU5FUlMgICAgPSBbJ0VMU0UnLCAnLT4nLCAnPT4nLCAnVFJZJywgJ0ZJTkFMTFknLCAnVEhFTiddXG5TSU5HTEVfQ0xPU0VSUyAgID0gWydURVJNSU5BVE9SJywgJ0NBVENIJywgJ0ZJTkFMTFknLCAnRUxTRScsICdPVVRERU5UJywgJ0xFQURJTkdfV0hFTiddXG5cbiMgVG9rZW5zIHRoYXQgZW5kIGEgbGluZS5cbkxJTkVCUkVBS1MgICAgICAgPSBbJ1RFUk1JTkFUT1InLCAnSU5ERU5UJywgJ09VVERFTlQnXVxuXG4jIFRva2VucyB0aGF0IGNsb3NlIG9wZW4gY2FsbHMgd2hlbiB0aGV5IGZvbGxvdyBhIG5ld2xpbmUuXG5DQUxMX0NMT1NFUlMgICAgID0gWycuJywgJz8uJywgJzo6JywgJz86OiddXG5cbiMgVG9rZW5zIHRoYXQgcHJldmVudCBhIHN1YnNlcXVlbnQgaW5kZW50IGZyb20gZW5kaW5nIGltcGxpY2l0IGNhbGxzL29iamVjdHNcbkNPTlRST0xfSU5fSU1QTElDSVQgPSBbJ0lGJywgJ1RSWScsICdGSU5BTExZJywgJ0NBVENIJywgJ0NMQVNTJywgJ1NXSVRDSCddXG5cbiMgVG9rZW5zIHRoYXQgYXJlIHN3YWxsb3dlZCB1cCBieSB0aGUgcGFyc2VyLCBuZXZlciBsZWFkaW5nIHRvIGNvZGUgZ2VuZXJhdGlvbi5cbiMgWW91IGNhbiBzcG90IHRoZXNlIGluIGBncmFtbWFyLmNvZmZlZWAgYmVjYXVzZSB0aGUgYG9gIGZ1bmN0aW9uIHNlY29uZFxuIyBhcmd1bWVudCBkb2VzbuKAmXQgY29udGFpbiBhIGBuZXdgIGNhbGwgZm9yIHRoZXNlIHRva2Vucy5cbiMgYFNUUklOR19TVEFSVGAgaXNu4oCZdCBvbiB0aGlzIGxpc3QgYmVjYXVzZSBpdHMgYGxvY2F0aW9uRGF0YWAgbWF0Y2hlcyB0aGF0IG9mXG4jIHRoZSBub2RlIHRoYXQgYmVjb21lcyBgU3RyaW5nV2l0aEludGVycG9sYXRpb25zYCwgYW5kIHRoZXJlZm9yZVxuIyBgYWRkRGF0YVRvTm9kZWAgYXR0YWNoZXMgYFNUUklOR19TVEFSVGDigJlzIHRva2VucyB0byB0aGF0IG5vZGUuXG5ESVNDQVJERUQgPSBbJygnLCAnKScsICdbJywgJ10nLCAneycsICd9JywgJzonLCAnLicsICcuLicsICcuLi4nLCAnLCcsICc9JywgJysrJywgJy0tJywgJz8nLFxuICAnQVMnLCAnQVdBSVQnLCAnQ0FMTF9TVEFSVCcsICdDQUxMX0VORCcsICdERUZBVUxUJywgJ0RPJywgJ0RPX0lJRkUnLCAnRUxTRScsXG4gICdFWFRFTkRTJywgJ0VYUE9SVCcsICdGT1JJTicsICdGT1JPRicsICdGT1JGUk9NJywgJ0lNUE9SVCcsICdJTkRFTlQnLCAnSU5ERVhfU09BSycsXG4gICdJTlRFUlBPTEFUSU9OX1NUQVJUJywgJ0lOVEVSUE9MQVRJT05fRU5EJywgJ0xFQURJTkdfV0hFTicsICdPVVRERU5UJywgJ1BBUkFNX0VORCcsXG4gICdSRUdFWF9TVEFSVCcsICdSRUdFWF9FTkQnLCAnUkVUVVJOJywgJ1NUUklOR19FTkQnLCAnVEhST1cnLCAnVU5BUlknLCAnWUlFTEQnXG5dLmNvbmNhdCBJTVBMSUNJVF9VTlNQQUNFRF9DQUxMLmNvbmNhdCBJTVBMSUNJVF9FTkQuY29uY2F0IENBTExfQ0xPU0VSUy5jb25jYXQgQ09OVFJPTF9JTl9JTVBMSUNJVFxuXG4jIFRva2VucyB0aGF0LCB3aGVuIGFwcGVhcmluZyBhdCB0aGUgZW5kIG9mIGEgbGluZSwgc3VwcHJlc3MgYSBmb2xsb3dpbmcgVEVSTUlOQVRPUi9JTkRFTlQgdG9rZW5cbmV4cG9ydHMuVU5GSU5JU0hFRCA9IFVORklOSVNIRUQgPSBbJ1xcXFwnLCAnLicsICc/LicsICc/OjonLCAnVU5BUlknLCAnRE8nLCAnRE9fSUlGRScsICdNQVRIJywgJ1VOQVJZX01BVEgnLCAnKycsICctJyxcbiAgICAgICAgICAgJyoqJywgJ1NISUZUJywgJ1JFTEFUSU9OJywgJ0NPTVBBUkUnLCAnJicsICdeJywgJ3wnLCAnJiYnLCAnfHwnLFxuICAgICAgICAgICAnQklOPycsICdFWFRFTkRTJ11cbiJdfQ==
//# sourceURL=/home/flow/jzr/coffeescript/src/rewriter.coffee