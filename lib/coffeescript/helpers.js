// Generated by CoffeeScript 2.7.0
(function() {
  // This file contains the common helper functions that we'd like to share among
  // the **Lexer**, **Rewriter**, and the **Nodes**. Merge objects, flatten
  // arrays, count characters, that sort of thing.

  // Peek at the beginning of a given string to see if it matches a sequence.
  var UNICODE_CODE_POINT_ESCAPE, attachCommentsToNode, buildLocationData, buildLocationHash, buildTokenDataDictionary, extend, flatten, isBoolean, isNumber, isString, ref, repeat, syntaxErrorToString, unicodeCodePointToUnicodeEscapes,
    indexOf = [].indexOf;

  exports.starts = function(string, literal, start) {
    return literal === string.substr(start, literal.length);
  };

  // Peek at the end of a given string to see if it matches a sequence.
  exports.ends = function(string, literal, back) {
    var len;
    len = literal.length;
    return literal === string.substr(string.length - len - (back || 0), len);
  };

  // Repeat a string `n` times.
  exports.repeat = repeat = function(str, n) {
    var res;
    // Use clever algorithm to have O(log(n)) string concatenation operations.
    res = '';
    while (n > 0) {
      if (n & 1) {
        res += str;
      }
      n >>>= 1;
      str += str;
    }
    return res;
  };

  // Trim out all falsy values from an array.
  exports.compact = function(array) {
    var i, item, len1, results;
    results = [];
    for (i = 0, len1 = array.length; i < len1; i++) {
      item = array[i];
      if (item) {
        results.push(item);
      }
    }
    return results;
  };

  // Count the number of occurrences of a string in a string.
  exports.count = function(string, substr) {
    var num, pos;
    num = pos = 0;
    if (!substr.length) {
      return 1 / 0;
    }
    while (pos = 1 + string.indexOf(substr, pos)) {
      num++;
    }
    return num;
  };

  // Merge objects, returning a fresh copy with attributes from both sides.
  // Used every time `Base#compile` is called, to allow properties in the
  // options hash to propagate down the tree without polluting other branches.
  exports.merge = function(options, overrides) {
    return extend(extend({}, options), overrides);
  };

  // Extend a source object with the properties of another object (shallow copy).
  extend = exports.extend = function(object, properties) {
    var key, val;
    for (key in properties) {
      val = properties[key];
      object[key] = val;
    }
    return object;
  };

  // Return a flattened version of an array.
  // Handy for getting a list of `children` from the nodes.
  exports.flatten = flatten = function(array) {
    return array.flat(2e308);
  };

  // Delete a key from an object, returning the value. Useful when a node is
  // looking for a particular method in an options hash.
  exports.del = function(obj, key) {
    var val;
    val = obj[key];
    delete obj[key];
    return val;
  };

  // Typical Array::some
  exports.some = (ref = Array.prototype.some) != null ? ref : function(fn) {
    var e, i, len1, ref1;
    ref1 = this;
    for (i = 0, len1 = ref1.length; i < len1; i++) {
      e = ref1[i];
      if (fn(e)) {
        return true;
      }
    }
    return false;
  };

  // Helper function for extracting code from Literate CoffeeScript by stripping
  // out all non-code blocks, producing a string of CoffeeScript code that can
  // be compiled “normally.”
  exports.invertLiterate = function(code) {
    var blankLine, i, indented, insideComment, len1, line, listItemStart, out, ref1;
    out = [];
    blankLine = /^\s*$/;
    indented = /^[\t ]/;
    listItemStart = /^(?:\t?| {0,3})(?:[\*\-\+]|[0-9]{1,9}\.)[ \t]/; // Up to one tab, or up to three spaces, or neither;
    // followed by `*`, `-` or `+`;
    // or by an integer up to 9 digits long, followed by a period;
    // followed by a space or a tab.
    insideComment = false;
    ref1 = code.split('\n');
    for (i = 0, len1 = ref1.length; i < len1; i++) {
      line = ref1[i];
      if (blankLine.test(line)) {
        insideComment = false;
        out.push(line);
      } else if (insideComment || listItemStart.test(line)) {
        insideComment = true;
        out.push(`# ${line}`);
      } else if (!insideComment && indented.test(line)) {
        out.push(line);
      } else {
        insideComment = true;
        out.push(`# ${line}`);
      }
    }
    return out.join('\n');
  };

  // Merge two jison-style location data objects together.
  // If `last` is not provided, this will simply return `first`.
  buildLocationData = function(first, last) {
    if (!last) {
      return first;
    } else {
      return {
        first_line: first.first_line,
        first_column: first.first_column,
        last_line: last.last_line,
        last_column: last.last_column,
        last_line_exclusive: last.last_line_exclusive,
        last_column_exclusive: last.last_column_exclusive,
        range: [first.range[0], last.range[1]]
      };
    }
  };

  // Build a list of all comments attached to tokens.
  exports.extractAllCommentTokens = function(tokens) {
    var allCommentsObj, comment, commentKey, i, j, k, key, len1, len2, len3, ref1, results, sortedKeys, token;
    allCommentsObj = {};
    for (i = 0, len1 = tokens.length; i < len1; i++) {
      token = tokens[i];
      if (token.comments) {
        ref1 = token.comments;
        for (j = 0, len2 = ref1.length; j < len2; j++) {
          comment = ref1[j];
          commentKey = comment.locationData.range[0];
          allCommentsObj[commentKey] = comment;
        }
      }
    }
    sortedKeys = Object.keys(allCommentsObj).sort(function(a, b) {
      return a - b;
    });
    results = [];
    for (k = 0, len3 = sortedKeys.length; k < len3; k++) {
      key = sortedKeys[k];
      results.push(allCommentsObj[key]);
    }
    return results;
  };

  // Get a lookup hash for a token based on its location data.
  // Multiple tokens might have the same location hash, but using exclusive
  // location data distinguishes e.g. zero-length generated tokens from
  // actual source tokens.
  buildLocationHash = function(loc) {
    return `${loc.range[0]}-${loc.range[1]}`;
  };

  // Build a dictionary of extra token properties organized by tokens’ locations
  // used as lookup hashes.
  exports.buildTokenDataDictionary = buildTokenDataDictionary = function(tokens) {
    var base1, i, len1, token, tokenData, tokenHash;
    tokenData = {};
    for (i = 0, len1 = tokens.length; i < len1; i++) {
      token = tokens[i];
      if (!token.comments) {
        continue;
      }
      tokenHash = buildLocationHash(token[2]);
      // Multiple tokens might have the same location hash, such as the generated
      // `JS` tokens added at the start or end of the token stream to hold
      // comments that start or end a file.
      if (tokenData[tokenHash] == null) {
        tokenData[tokenHash] = {};
      }
      if (token.comments) { // `comments` is always an array.
        // For “overlapping” tokens, that is tokens with the same location data
        // and therefore matching `tokenHash`es, merge the comments from both/all
        // tokens together into one array, even if there are duplicate comments;
        // they will get sorted out later.
        ((base1 = tokenData[tokenHash]).comments != null ? base1.comments : base1.comments = []).push(...token.comments);
      }
    }
    return tokenData;
  };

  // This returns a function which takes an object as a parameter, and if that
  // object is an AST node, updates that object's locationData.
  // The object is returned either way.
  exports.addDataToNode = function(parserState, firstLocationData, firstValue, lastLocationData, lastValue, forceUpdateLocation = true) {
    return function(obj) {
      var locationData, objHash, ref1, ref2, ref3;
      // Add location data.
      locationData = buildLocationData((ref1 = firstValue != null ? firstValue.locationData : void 0) != null ? ref1 : firstLocationData, (ref2 = lastValue != null ? lastValue.locationData : void 0) != null ? ref2 : lastLocationData);
      if (((obj != null ? obj.updateLocationDataIfMissing : void 0) != null) && (firstLocationData != null)) {
        obj.updateLocationDataIfMissing(locationData, forceUpdateLocation);
      } else {
        obj.locationData = locationData;
      }
      // Add comments, building the dictionary of token data if it hasn’t been
      // built yet.
      if (parserState.tokenData == null) {
        parserState.tokenData = buildTokenDataDictionary(parserState.parser.tokens);
      }
      if (obj.locationData != null) {
        objHash = buildLocationHash(obj.locationData);
        if (((ref3 = parserState.tokenData[objHash]) != null ? ref3.comments : void 0) != null) {
          attachCommentsToNode(parserState.tokenData[objHash].comments, obj);
        }
      }
      return obj;
    };
  };

  exports.attachCommentsToNode = attachCommentsToNode = function(comments, node) {
    if ((comments == null) || comments.length === 0) {
      return;
    }
    if (node.comments == null) {
      node.comments = [];
    }
    return node.comments.push(...comments);
  };

  // Convert jison location data to a string.
  // `obj` can be a token, or a locationData.
  exports.locationDataToString = function(obj) {
    var locationData;
    if (("2" in obj) && ("first_line" in obj[2])) {
      locationData = obj[2];
    } else if ("first_line" in obj) {
      locationData = obj;
    }
    if (locationData) {
      return `${locationData.first_line + 1}:${locationData.first_column + 1}-` + `${locationData.last_line + 1}:${locationData.last_column + 1}`;
    } else {
      return "No location data";
    }
  };

  // Generate a unique anonymous file name so we can distinguish source map cache
  // entries for any number of anonymous scripts.
  exports.anonymousFileName = (function() {
    var n;
    n = 0;
    return function() {
      return `<anonymous-${n++}>`;
    };
  })();

  // A `.coffee.md` compatible version of `basename`, that returns the file sans-extension.
  exports.baseFileName = function(file, stripExt = false, useWinPathSep = false) {
    var parts, pathSep;
    pathSep = useWinPathSep ? /\\|\// : /\//;
    parts = file.split(pathSep);
    file = parts[parts.length - 1];
    if (!(stripExt && file.indexOf('.') >= 0)) {
      return file;
    }
    parts = file.split('.');
    parts.pop();
    if (parts[parts.length - 1] === 'coffee' && parts.length > 1) {
      parts.pop();
    }
    return parts.join('.');
  };

  // Determine if a filename represents a CoffeeScript file.
  exports.isCoffee = function(file) {
    return /\.((lit)?coffee|coffee\.md)$/.test(file);
  };

  // Determine if a filename represents a Literate CoffeeScript file.
  exports.isLiterate = function(file) {
    return /\.(litcoffee|coffee\.md)$/.test(file);
  };

  // Throws a SyntaxError from a given location.
  // The error's `toString` will return an error message following the "standard"
  // format `<filename>:<line>:<col>: <message>` plus the line with the error and a
  // marker showing where the error is.
  exports.throwSyntaxError = function(message, location) {
    var error;
    error = new SyntaxError(message);
    error.location = location;
    error.toString = syntaxErrorToString;
    // Instead of showing the compiler's stacktrace, show our custom error message
    // (this is useful when the error bubbles up in Node.js applications that
    // compile CoffeeScript for example).
    error.stack = error.toString();
    throw error;
  };

  // Update a compiler SyntaxError with source code information if it didn't have
  // it already.
  exports.updateSyntaxError = function(error, code, filename) {
    // Avoid screwing up the `stack` property of other errors (i.e. possible bugs).
    if (error.toString === syntaxErrorToString) {
      error.code || (error.code = code);
      error.filename || (error.filename = filename);
      error.stack = error.toString();
    }
    return error;
  };

  syntaxErrorToString = function() {
    var codeLine, colorize, colorsEnabled, end, filename, first_column, first_line, last_column, last_line, marker, ref1, ref2, ref3, ref4, start;
    if (!(this.code && this.location)) {
      return Error.prototype.toString.call(this);
    }
    ({first_line, first_column, last_line, last_column} = this.location);
    if (last_line == null) {
      last_line = first_line;
    }
    if (last_column == null) {
      last_column = first_column;
    }
    if ((ref1 = this.filename) != null ? ref1.startsWith('<anonymous') : void 0) {
      filename = '[stdin]';
    } else {
      filename = this.filename || '[stdin]';
    }
    codeLine = this.code.split('\n')[first_line];
    start = first_column;
    // Show only the first line on multi-line errors.
    end = first_line === last_line ? last_column + 1 : codeLine.length;
    marker = codeLine.slice(0, start).replace(/[^\s]/g, ' ') + repeat('^', end - start);
    // Check to see if we're running on a color-enabled TTY.
    if (typeof process !== "undefined" && process !== null) {
      colorsEnabled = ((ref2 = process.stdout) != null ? ref2.isTTY : void 0) && !((ref3 = process.env) != null ? ref3.NODE_DISABLE_COLORS : void 0);
    }
    if ((ref4 = this.colorful) != null ? ref4 : colorsEnabled) {
      colorize = function(str) {
        return `\x1B[1;31m${str}\x1B[0m`;
      };
      codeLine = codeLine.slice(0, start) + colorize(codeLine.slice(start, end)) + codeLine.slice(end);
      marker = colorize(marker);
    }
    return `${filename}:${first_line + 1}:${first_column + 1}: error: ${this.message}
${codeLine}
${marker}`;
  };

  exports.nameWhitespaceCharacter = function(string) {
    switch (string) {
      case ' ':
        return 'space';
      case '\n':
        return 'newline';
      case '\r':
        return 'carriage return';
      case '\t':
        return 'tab';
      default:
        return string;
    }
  };

  exports.parseNumber = function(string) {
    var base;
    if (string == null) {
      return 0/0;
    }
    base = (function() {
      switch (string.charAt(1)) {
        case 'b':
          return 2;
        case 'o':
          return 8;
        case 'x':
          return 16;
        default:
          return null;
      }
    })();
    if (base != null) {
      return parseInt(string.slice(2).replace(/_/g, ''), base);
    } else {
      return parseFloat(string.replace(/_/g, ''));
    }
  };

  exports.isFunction = function(obj) {
    return Object.prototype.toString.call(obj) === '[object Function]';
  };

  exports.isNumber = isNumber = function(obj) {
    return Object.prototype.toString.call(obj) === '[object Number]';
  };

  exports.isString = isString = function(obj) {
    return Object.prototype.toString.call(obj) === '[object String]';
  };

  exports.isBoolean = isBoolean = function(obj) {
    return obj === true || obj === false || Object.prototype.toString.call(obj) === '[object Boolean]';
  };

  exports.isPlainObject = function(obj) {
    return typeof obj === 'object' && !!obj && !Array.isArray(obj) && !isNumber(obj) && !isString(obj) && !isBoolean(obj);
  };

  unicodeCodePointToUnicodeEscapes = function(codePoint) {
    var high, low, toUnicodeEscape;
    toUnicodeEscape = function(val) {
      var str;
      str = val.toString(16);
      return `\\u${repeat('0', 4 - str.length)}${str}`;
    };
    if (codePoint < 0x10000) {
      return toUnicodeEscape(codePoint);
    }
    // surrogate pair
    high = Math.floor((codePoint - 0x10000) / 0x400) + 0xD800;
    low = (codePoint - 0x10000) % 0x400 + 0xDC00;
    return `${toUnicodeEscape(high)}${toUnicodeEscape(low)}`;
  };

  // Replace `\u{...}` with `\uxxxx[\uxxxx]` in regexes without `u` flag
  exports.replaceUnicodeCodePointEscapes = function(str, {flags, error, delimiter = ''} = {}) {
    var shouldReplace;
    shouldReplace = (flags != null) && indexOf.call(flags, 'u') < 0;
    return str.replace(UNICODE_CODE_POINT_ESCAPE, function(match, escapedBackslash, codePointHex, offset) {
      var codePointDecimal;
      if (escapedBackslash) {
        return escapedBackslash;
      }
      codePointDecimal = parseInt(codePointHex, 16);
      if (codePointDecimal > 0x10ffff) {
        error("unicode code point escapes greater than \\u{10ffff} are not allowed", {
          offset: offset + delimiter.length,
          length: codePointHex.length + 4
        });
      }
      if (!shouldReplace) {
        return match;
      }
      return unicodeCodePointToUnicodeEscapes(codePointDecimal);
    });
  };

  UNICODE_CODE_POINT_ESCAPE = /(\\\\)|\\u\{([\da-fA-F]+)\}/g; // Make sure the escape isn’t escaped.

}).call(this);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8iLCJzb3VyY2VzIjpbInNyYy9oZWxwZXJzLmNvZmZlZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBSTBFO0VBQUE7Ozs7O0FBQUEsTUFBQSx5QkFBQSxFQUFBLG9CQUFBLEVBQUEsaUJBQUEsRUFBQSxpQkFBQSxFQUFBLHdCQUFBLEVBQUEsTUFBQSxFQUFBLE9BQUEsRUFBQSxTQUFBLEVBQUEsUUFBQSxFQUFBLFFBQUEsRUFBQSxHQUFBLEVBQUEsTUFBQSxFQUFBLG1CQUFBLEVBQUEsZ0NBQUE7SUFBQTs7RUFDMUUsT0FBTyxDQUFDLE1BQVIsR0FBaUIsUUFBQSxDQUFDLE1BQUQsRUFBUyxPQUFULEVBQWtCLEtBQWxCLENBQUE7V0FDZixPQUFBLEtBQVcsTUFBTSxDQUFDLE1BQVAsQ0FBYyxLQUFkLEVBQXFCLE9BQU8sQ0FBQyxNQUE3QjtFQURJLEVBRHlEOzs7RUFLMUUsT0FBTyxDQUFDLElBQVIsR0FBZSxRQUFBLENBQUMsTUFBRCxFQUFTLE9BQVQsRUFBa0IsSUFBbEIsQ0FBQTtBQUNmLFFBQUE7SUFBRSxHQUFBLEdBQU0sT0FBTyxDQUFDO1dBQ2QsT0FBQSxLQUFXLE1BQU0sQ0FBQyxNQUFQLENBQWMsTUFBTSxDQUFDLE1BQVAsR0FBZ0IsR0FBaEIsR0FBc0IsQ0FBQyxJQUFBLElBQVEsQ0FBVCxDQUFwQyxFQUFpRCxHQUFqRDtFQUZFLEVBTDJEOzs7RUFVMUUsT0FBTyxDQUFDLE1BQVIsR0FBaUIsTUFBQSxHQUFTLFFBQUEsQ0FBQyxHQUFELEVBQU0sQ0FBTixDQUFBO0FBQzFCLFFBQUEsR0FBQTs7SUFDRSxHQUFBLEdBQU07QUFDTixXQUFNLENBQUEsR0FBSSxDQUFWO01BQ0UsSUFBYyxDQUFBLEdBQUksQ0FBbEI7UUFBQSxHQUFBLElBQU8sSUFBUDs7TUFDQSxDQUFBLE1BQU87TUFDUCxHQUFBLElBQU87SUFIVDtXQUlBO0VBUHdCLEVBVmdEOzs7RUFvQjFFLE9BQU8sQ0FBQyxPQUFSLEdB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IGNvbW1vbiBoZWxwZXIgZnVuY3Rpb25zIHRoYXQgd2UnZCBsaWtlIHRvIHNoYXJlIGFtb25nXG4jIHRoZSAqKkxleGVyKiosICoqUmV3cml0ZXIqKiwgYW5kIHRoZSAqKk5vZGVzKiouIE1lcmdlIG9iamVjdHMsIGZsYXR0ZW5cbiMgYXJyYXlzLCBjb3VudCBjaGFyYWN0ZXJzLCB0aGF0IHNvcnQgb2YgdGhpbmcuXG5cbiMgUGVlayBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgZ2l2ZW4gc3RyaW5nIHRvIHNlZSBpZiBpdCBtYXRjaGVzIGEgc2VxdWVuY2UuXG5leHBvcnRzLnN0YXJ0cyA9IChzdHJpbmcsIGxpdGVyYWwsIHN0YXJ0KSAtPlxuICBsaXRlcmFsIGlzIHN0cmluZy5zdWJzdHIgc3RhcnQsIGxpdGVyYWwubGVuZ3RoXG5cbiMgUGVlayBhdCB0aGUgZW5kIG9mIGEgZ2l2ZW4gc3RyaW5nIHRvIHNlZSBpZiBpdCBtYXRjaGVzIGEgc2VxdWVuY2UuXG5leHBvcnRzLmVuZHMgPSAoc3RyaW5nLCBsaXRlcmFsLCBiYWNrKSAtPlxuICBsZW4gPSBsaXRlcmFsLmxlbmd0aFxuICBsaXRlcmFsIGlzIHN0cmluZy5zdWJzdHIgc3RyaW5nLmxlbmd0aCAtIGxlbiAtIChiYWNrIG9yIDApLCBsZW5cblxuIyBSZXBlYXQgYSBzdHJpbmcgYG5gIHRpbWVzLlxuZXhwb3J0cy5yZXBlYXQgPSByZXBlYXQgPSAoc3RyLCBuKSAtPlxuICAjIFVzZSBjbGV2ZXIgYWxnb3JpdGhtIHRvIGhhdmUgTyhsb2cobikpIHN0cmluZyBjb25jYXRlbmF0aW9uIG9wZXJhdGlvbnMuXG4gIHJlcyA9ICcnXG4gIHdoaWxlIG4gPiAwXG4gICAgcmVzICs9IHN0ciBpZiBuICYgMVxuICAgIG4gPj4+PSAxXG4gICAgc3RyICs9IHN0clxuICByZXNcblxuIyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG5leHBvcnRzLmNvbXBhY3QgPSAoYXJyYXkpIC0+XG4gIGl0ZW0gZm9yIGl0ZW0gaW4gYXJyYXkgd2hlbiBpdGVtXG5cbiMgQ291bnQgdGhlIG51bWJlciBvZiBvY2N1cnJlbmNlcyBvZiBhIHN0cmluZyBpbiBhIHN0cmluZy5cbmV4cG9ydHMuY291bnQgPSAoc3RyaW5nLCBzdWJzdHIpIC0+XG4gIG51bSA9IHBvcyA9IDBcbiAgcmV0dXJuIDEvMCB1bmxlc3Mgc3Vic3RyLmxlbmd0aFxuICBudW0rKyB3aGlsZSBwb3MgPSAxICsgc3RyaW5nLmluZGV4T2Ygc3Vic3RyLCBwb3NcbiAgbnVtXG5cbiMgTWVyZ2Ugb2JqZWN0cywgcmV0dXJuaW5nIGEgZnJlc2ggY29weSB3aXRoIGF0dHJpYnV0ZXMgZnJvbSBib3RoIHNpZGVzLlxuIyBVc2VkIGV2ZXJ5IHRpbWUgYEJhc2UjY29tcGlsZWAgaXMgY2FsbGVkLCB0byBhbGxvdyBwcm9wZXJ0aWVzIGluIHRoZVxuIyBvcHRpb25zIGhhc2ggdG8gcHJvcGFnYXRlIGRvd24gdGhlIHRyZWUgd2l0aG91dCBwb2xsdXRpbmcgb3RoZXIgYnJhbmNoZXMuXG5leHBvcnRzLm1lcmdlID0gKG9wdGlvbnMsIG92ZXJyaWRlcykgLT5cbiAgZXh0ZW5kIChleHRlbmQge30sIG9wdGlvbnMpLCBvdmVycmlkZXNcblxuIyBFeHRlbmQgYSBzb3VyY2Ugb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgb2YgYW5vdGhlciBvYmplY3QgKHNoYWxsb3cgY29weSkuXG5leHRlbmQgPSBleHBvcnRzLmV4dGVuZCA9IChvYmplY3QsIHByb3BlcnRpZXMpIC0+XG4gIGZvciBrZXksIHZhbCBvZiBwcm9wZXJ0aWVzXG4gICAgb2JqZWN0W2tleV0gPSB2YWxcbiAgb2JqZWN0XG5cbiMgUmV0dXJuIGEgZmxhdHRlbmVkIHZlcnNpb24gb2YgYW4gYXJyYXkuXG4jIEhhbmR5IGZvciBnZXR0aW5nIGEgbGlzdCBvZiBgY2hpbGRyZW5gIGZyb20gdGhlIG5vZGVzLlxuZXhwb3J0cy5mbGF0dGVuID0gZmxhdHRlbiA9IChhcnJheSkgLT5cbiAgYXJyYXkuZmxhdChJbmZpbml0eSlcblxuIyBEZWxldGUgYSBrZXkgZnJvbSBhbiBvYmplY3QsIHJldHVybmluZyB0aGUgdmFsdWUuIFVzZWZ1bCB3aGVuIGEgbm9kZSBpc1xuIyBsb29raW5nIGZvciBhIHBhcnRpY3VsYXIgbWV0aG9kIGluIGFuIG9wdGlvbnMgaGFzaC5cbmV4cG9ydHMuZGVsID0gKG9iaiwga2V5KSAtPlxuICB2YWwgPSAgb2JqW2tleV1cbiAgZGVsZXRlIG9ialtrZXldXG4gIHZhbFxuXG4jIFR5cGljYWwgQXJyYXk6OnNvbWVcbmV4cG9ydHMuc29tZSA9IEFycmF5Ojpzb21lID8gKGZuKSAtPlxuICByZXR1cm4gdHJ1ZSBmb3IgZSBpbiB0aGlzIHdoZW4gZm4gZVxuICBmYWxzZVxuXG4jIEhlbHBlciBmdW5jdGlvbiBmb3IgZXh0cmFjdGluZyBjb2RlIGZyb20gTGl0ZXJhdGUgQ29mZmVlU2NyaXB0IGJ5IHN0cmlwcGluZ1xuIyBvdXQgYWxsIG5vbi1jb2RlIGJsb2NrcywgcHJvZHVjaW5nIGEgc3RyaW5nIG9mIENvZmZlZVNjcmlwdCBjb2RlIHRoYXQgY2FuXG4jIGJlIGNvbXBpbGVkIOKAnG5vcm1hbGx5LuKAnVxuZXhwb3J0cy5pbnZlcnRMaXRlcmF0ZSA9IChjb2RlKSAtPlxuICBvdXQgPSBbXVxuICBibGFua0xpbmUgPSAvXlxccyokL1xuICBpbmRlbnRlZCA9IC9eW1xcdCBdL1xuICBsaXN0SXRlbVN0YXJ0ID0gLy8vIF5cbiAgICAoPzpcXHQ/fFxcIHswLDN9KSAgICMgVXAgdG8gb25lIHRhYiwgb3IgdXAgdG8gdGhyZWUgc3BhY2VzLCBvciBuZWl0aGVyO1xuICAgICg/OlxuICAgICAgW1xcKlxcLVxcK10gfCAgICAgICMgZm9sbG93ZWQgYnkgYCpgLCBgLWAgb3IgYCtgO1xuICAgICAgWzAtOV17MSw5fVxcLiAgICAjIG9yIGJ5IGFuIGludGVnZXIgdXAgdG8gOSBkaWdpdHMgbG9uZywgZm9sbG93ZWQgYnkgYSBwZXJpb2Q7XG4gICAgKVxuICAgIFtcXCBcXHRdICAgICAgICAgICAgIyBmb2xsb3dlZCBieSBhIHNwYWNlIG9yIGEgdGFiLlxuICAvLy9cbiAgaW5zaWRlQ29tbWVudCA9IG5vXG4gIGZvciBsaW5lIGluIGNvZGUuc3BsaXQoJ1xcbicpXG4gICAgaWYgYmxhbmtMaW5lLnRlc3QobGluZSlcbiAgICAgIGluc2lkZUNvbW1lbnQgPSBub1xuICAgICAgb3V0LnB1c2ggbGluZVxuICAgIGVsc2UgaWYgaW5zaWRlQ29tbWVudCBvciBsaXN0SXRlbVN0YXJ0LnRlc3QobGluZSlcbiAgICAgIGluc2lkZUNvbW1lbnQgPSB5ZXNcbiAgICAgIG91dC5wdXNoIFwiIyAje2xpbmV9XCJcbiAgICBlbHNlIGlmIG5vdCBpbnNpZGVDb21tZW50IGFuZCBpbmRlbnRlZC50ZXN0KGxpbmUpXG4gICAgICBvdXQucHVzaCBsaW5lXG4gICAgZWxzZVxuICAgICAgaW5zaWRlQ29tbWVudCA9IHllc1xuICAgICAgb3V0LnB1c2ggXCIjICN7bGluZX1cIlxuICBvdXQuam9pbiAnXFxuJ1xuXG4jIE1lcmdlIHR3byBqaXNvbi1zdHlsZSBsb2NhdGlvbiBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4jIElmIGBsYXN0YCBpcyBub3QgcHJvdmlkZWQsIHRoaXMgd2lsbCBzaW1wbHkgcmV0dXJuIGBmaXJzdGAuXG5idWlsZExvY2F0aW9uRGF0YSA9IChmaXJzdCwgbGFzdCkgLT5cbiAgaWYgbm90IGxhc3RcbiAgICBmaXJzdFxuICBlbHNlXG4gICAgZmlyc3RfbGluZTogZmlyc3QuZmlyc3RfbGluZVxuICAgIGZpcnN0X2NvbHVtbjogZmlyc3QuZmlyc3RfY29sdW1uXG4gICAgbGFzdF9saW5lOiBsYXN0Lmxhc3RfbGluZVxuICAgIGxhc3RfY29sdW1uOiBsYXN0Lmxhc3RfY29sdW1uXG4gICAgbGFzdF9saW5lX2V4Y2x1c2l2ZTogbGFzdC5sYXN0X2xpbmVfZXhjbHVzaXZlXG4gICAgbGFzdF9jb2x1bW5fZXhjbHVzaXZlOiBsYXN0Lmxhc3RfY29sdW1uX2V4Y2x1c2l2ZVxuICAgIHJhbmdlOiBbXG4gICAgICBmaXJzdC5yYW5nZVswXVxuICAgICAgbGFzdC5yYW5nZVsxXVxuICAgIF1cblxuIyBCdWlsZCBhIGxpc3Qgb2YgYWxsIGNvbW1lbnRzIGF0dGFjaGVkIHRvIHRva2Vucy5cbmV4cG9ydHMuZXh0cmFjdEFsbENvbW1lbnRUb2tlbnMgPSAodG9rZW5zKSAtPlxuICBhbGxDb21tZW50c09iaiA9IHt9XG4gIGZvciB0b2tlbiBpbiB0b2tlbnMgd2hlbiB0b2tlbi5jb21tZW50c1xuICAgIGZvciBjb21tZW50IGluIHRva2VuLmNvbW1lbnRzXG4gICAgICBjb21tZW50S2V5ID0gY29tbWVudC5sb2NhdGlvbkRhdGEucmFuZ2VbMF1cbiAgICAgIGFsbENvbW1lbnRzT2JqW2NvbW1lbnRLZXldID0gY29tbWVudFxuICBzb3J0ZWRLZXlzID0gT2JqZWN0LmtleXMoYWxsQ29tbWVudHNPYmopLnNvcnQgKGEsIGIpIC0+IGEgLSBiXG4gIGZvciBrZXkgaW4gc29ydGVkS2V5c1xuICAgIGFsbENvbW1lbnRzT2JqW2tleV1cblxuIyBHZXQgYSBsb29rdXAgaGFzaCBmb3IgYSB0b2tlbiBiYXNlZCBvbiBpdHMgbG9jYXRpb24gZGF0YS5cbiMgTXVsdGlwbGUgdG9rZW5zIG1pZ2h0IGhhdmUgdGhlIHNhbWUgbG9jYXRpb24gaGFzaCwgYnV0IHVzaW5nIGV4Y2x1c2l2ZVxuIyBsb2NhdGlvbiBkYXRhIGRpc3Rpbmd1aXNoZXMgZS5nLiB6ZXJvLWxlbmd0aCBnZW5lcmF0ZWQgdG9rZW5zIGZyb21cbiMgYWN0dWFsIHNvdXJjZSB0b2tlbnMuXG5idWlsZExvY2F0aW9uSGFzaCA9IChsb2MpIC0+XG4gIFwiI3tsb2MucmFuZ2VbMF19LSN7bG9jLnJhbmdlWzFdfVwiXG5cbiMgQnVpbGQgYSBkaWN0aW9uYXJ5IG9mIGV4dHJhIHRva2VuIHByb3BlcnRpZXMgb3JnYW5pemVkIGJ5IHRva2Vuc+KAmSBsb2NhdGlvbnNcbiMgdXNlZCBhcyBsb29rdXAgaGFzaGVzLlxuZXhwb3J0cy5idWlsZFRva2VuRGF0YURpY3Rpb25hcnkgPSBidWlsZFRva2VuRGF0YURpY3Rpb25hcnkgPSAodG9rZW5zKSAtPlxuICB0b2tlbkRhdGEgPSB7fVxuICBmb3IgdG9rZW4gaW4gdG9rZW5zIHdoZW4gdG9rZW4uY29tbWVudHNcbiAgICB0b2tlbkhhc2ggPSBidWlsZExvY2F0aW9uSGFzaCB0b2tlblsyXVxuICAgICMgTXVsdGlwbGUgdG9rZW5zIG1pZ2h0IGhhdmUgdGhlIHNhbWUgbG9jYXRpb24gaGFzaCwgc3VjaCBhcyB0aGUgZ2VuZXJhdGVkXG4gICAgIyBgSlNgIHRva2VucyBhZGRlZCBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSB0b2tlbiBzdHJlYW0gdG8gaG9sZFxuICAgICMgY29tbWVudHMgdGhhdCBzdGFydCBvciBlbmQgYSBmaWxlLlxuICAgIHRva2VuRGF0YVt0b2tlbkhhc2hdID89IHt9XG4gICAgaWYgdG9rZW4uY29tbWVudHMgIyBgY29tbWVudHNgIGlzIGFsd2F5cyBhbiBhcnJheS5cbiAgICAgICMgRm9yIOKAnG92ZXJsYXBwaW5n4oCdIHRva2VucywgdGhhdCBpcyB0b2tlbnMgd2l0aCB0aGUgc2FtZSBsb2NhdGlvbiBkYXRhXG4gICAgICAjIGFuZCB0aGVyZWZvcmUgbWF0Y2hpbmcgYHRva2VuSGFzaGBlcywgbWVyZ2UgdGhlIGNvbW1lbnRzIGZyb20gYm90aC9hbGxcbiAgICAgICMgdG9rZW5zIHRvZ2V0aGVyIGludG8gb25lIGFycmF5LCBldmVuIGlmIHRoZXJlIGFyZSBkdXBsaWNhdGUgY29tbWVudHM7XG4gICAgICAjIHRoZXkgd2lsbCBnZXQgc29ydGVkIG91dCBsYXRlci5cbiAgICAgICh0b2tlbkRhdGFbdG9rZW5IYXNoXS5jb21tZW50cyA/PSBbXSkucHVzaCB0b2tlbi5jb21tZW50cy4uLlxuICB0b2tlbkRhdGFcblxuIyBUaGlzIHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCB0YWtlcyBhbiBvYmplY3QgYXMgYSBwYXJhbWV0ZXIsIGFuZCBpZiB0aGF0XG4jIG9iamVjdCBpcyBhbiBBU1Qgbm9kZSwgdXBkYXRlcyB0aGF0IG9iamVjdCdzIGxvY2F0aW9uRGF0YS5cbiMgVGhlIG9iamVjdCBpcyByZXR1cm5lZCBlaXRoZXIgd2F5LlxuZXhwb3J0cy5hZGREYXRhVG9Ob2RlID0gKHBhcnNlclN0YXRlLCBmaXJzdExvY2F0aW9uRGF0YSwgZmlyc3RWYWx1ZSwgbGFzdExvY2F0aW9uRGF0YSwgbGFzdFZhbHVlLCBmb3JjZVVwZGF0ZUxvY2F0aW9uID0geWVzKSAtPlxuICAob2JqKSAtPlxuICAgICMgQWRkIGxvY2F0aW9uIGRhdGEuXG4gICAgbG9jYXRpb25EYXRhID0gYnVpbGRMb2NhdGlvbkRhdGEoZmlyc3RWYWx1ZT8ubG9jYXRpb25EYXRhID8gZmlyc3RMb2NhdGlvbkRhdGEsIGxhc3RWYWx1ZT8ubG9jYXRpb25EYXRhID8gbGFzdExvY2F0aW9uRGF0YSlcbiAgICBpZiBvYmo/LnVwZGF0ZUxvY2F0aW9uRGF0YUlmTWlzc2luZz8gYW5kIGZpcnN0TG9jYXRpb25EYXRhP1xuICAgICAgb2JqLnVwZGF0ZUxvY2F0aW9uRGF0YUlmTWlzc2luZyBsb2NhdGlvbkRhdGEsIGZvcmNlVXBkYXRlTG9jYXRpb25cbiAgICBlbHNlXG4gICAgICBvYmoubG9jYXRpb25EYXRhID0gbG9jYXRpb25EYXRhXG5cbiAgICAjIEFkZCBjb21tZW50cywgYnVpbGRpbmcgdGhlIGRpY3Rpb25hcnkgb2YgdG9rZW4gZGF0YSBpZiBpdCBoYXNu4oCZdCBiZWVuXG4gICAgIyBidWlsdCB5ZXQuXG4gICAgcGFyc2VyU3RhdGUudG9rZW5EYXRhID89IGJ1aWxkVG9rZW5EYXRhRGljdGlvbmFyeSBwYXJzZXJTdGF0ZS5wYXJzZXIudG9rZW5zXG4gICAgaWYgb2JqLmxvY2F0aW9uRGF0YT9cbiAgICAgIG9iakhhc2ggPSBidWlsZExvY2F0aW9uSGFzaCBvYmoubG9jYXRpb25EYXRhXG4gICAgICBpZiBwYXJzZXJTdGF0ZS50b2tlbkRhdGFbb2JqSGFzaF0/LmNvbW1lbnRzP1xuICAgICAgICBhdHRhY2hDb21tZW50c1RvTm9kZSBwYXJzZXJTdGF0ZS50b2tlbkRhdGFbb2JqSGFzaF0uY29tbWVudHMsIG9ialxuICAgIG9ialxuXG5leHBvcnRzLmF0dGFjaENvbW1lbnRzVG9Ob2RlID0gYXR0YWNoQ29tbWVudHNUb05vZGUgPSAoY29tbWVudHMsIG5vZGUpIC0+XG4gIHJldHVybiBpZiBub3QgY29tbWVudHM/IG9yIGNvbW1lbnRzLmxlbmd0aCBpcyAwXG4gIG5vZGUuY29tbWVudHMgPz0gW11cbiAgbm9kZS5jb21tZW50cy5wdXNoIGNvbW1lbnRzLi4uXG5cbiMgQ29udmVydCBqaXNvbiBsb2NhdGlvbiBkYXRhIHRvIGEgc3RyaW5nLlxuIyBgb2JqYCBjYW4gYmUgYSB0b2tlbiwgb3IgYSBsb2NhdGlvbkRhdGEuXG5leHBvcnRzLmxvY2F0aW9uRGF0YVRvU3RyaW5nID0gKG9iaikgLT5cbiAgaWYgKFwiMlwiIG9mIG9iaikgYW5kIChcImZpcnN0X2xpbmVcIiBvZiBvYmpbMl0pIHRoZW4gbG9jYXRpb25EYXRhID0gb2JqWzJdXG4gIGVsc2UgaWYgXCJmaXJzdF9saW5lXCIgb2Ygb2JqIHRoZW4gbG9jYXRpb25EYXRhID0gb2JqXG5cbiAgaWYgbG9jYXRpb25EYXRhXG4gICAgXCIje2xvY2F0aW9uRGF0YS5maXJzdF9saW5lICsgMX06I3tsb2NhdGlvbkRhdGEuZmlyc3RfY29sdW1uICsgMX0tXCIgK1xuICAgIFwiI3tsb2NhdGlvbkRhdGEubGFzdF9saW5lICsgMX06I3tsb2NhdGlvbkRhdGEubGFzdF9jb2x1bW4gKyAxfVwiXG4gIGVsc2VcbiAgICBcIk5vIGxvY2F0aW9uIGRhdGFcIlxuXG4jIEdlbmVyYXRlIGEgdW5pcXVlIGFub255bW91cyBmaWxlIG5hbWUgc28gd2UgY2FuIGRpc3Rpbmd1aXNoIHNvdXJjZSBtYXAgY2FjaGVcbiMgZW50cmllcyBmb3IgYW55IG51bWJlciBvZiBhbm9ueW1vdXMgc2NyaXB0cy5cbmV4cG9ydHMuYW5vbnltb3VzRmlsZU5hbWUgPSBkbyAtPlxuICBuID0gMFxuICAtPlxuICAgIFwiPGFub255bW91cy0je24rK30+XCJcblxuIyBBIGAuY29mZmVlLm1kYCBjb21wYXRpYmxlIHZlcnNpb24gb2YgYGJhc2VuYW1lYCwgdGhhdCByZXR1cm5zIHRoZSBmaWxlIHNhbnMtZXh0ZW5zaW9uLlxuZXhwb3J0cy5iYXNlRmlsZU5hbWUgPSAoZmlsZSwgc3RyaXBFeHQgPSBubywgdXNlV2luUGF0aFNlcCA9IG5vKSAtPlxuICBwYXRoU2VwID0gaWYgdXNlV2luUGF0aFNlcCB0aGVuIC9cXFxcfFxcLy8gZWxzZSAvXFwvL1xuICBwYXJ0cyA9IGZpbGUuc3BsaXQocGF0aFNlcClcbiAgZmlsZSA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdXG4gIHJldHVybiBmaWxlIHVubGVzcyBzdHJpcEV4dCBhbmQgZmlsZS5pbmRleE9mKCcuJykgPj0gMFxuICBwYXJ0cyA9IGZpbGUuc3BsaXQoJy4nKVxuICBwYXJ0cy5wb3AoKVxuICBwYXJ0cy5wb3AoKSBpZiBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSBpcyAnY29mZmVlJyBhbmQgcGFydHMubGVuZ3RoID4gMVxuICBwYXJ0cy5qb2luKCcuJylcblxuIyBEZXRlcm1pbmUgaWYgYSBmaWxlbmFtZSByZXByZXNlbnRzIGEgQ29mZmVlU2NyaXB0IGZpbGUuXG5leHBvcnRzLmlzQ29mZmVlID0gKGZpbGUpIC0+IC9cXC4oKGxpdCk/Y29mZmVlfGNvZmZlZVxcLm1kKSQvLnRlc3QgZmlsZVxuXG4jIERldGVybWluZSBpZiBhIGZpbGVuYW1lIHJlcHJlc2VudHMgYSBMaXRlcmF0ZSBDb2ZmZWVTY3JpcHQgZmlsZS5cbmV4cG9ydHMuaXNMaXRlcmF0ZSA9IChmaWxlKSAtPiAvXFwuKGxpdGNvZmZlZXxjb2ZmZWVcXC5tZCkkLy50ZXN0IGZpbGVcblxuIyBUaHJvd3MgYSBTeW50YXhFcnJvciBmcm9tIGEgZ2l2ZW4gbG9jYXRpb24uXG4jIFRoZSBlcnJvcidzIGB0b1N0cmluZ2Agd2lsbCByZXR1cm4gYW4gZXJyb3IgbWVzc2FnZSBmb2xsb3dpbmcgdGhlIFwic3RhbmRhcmRcIlxuIyBmb3JtYXQgYDxmaWxlbmFtZT46PGxpbmU+Ojxjb2w+OiA8bWVzc2FnZT5gIHBsdXMgdGhlIGxpbmUgd2l0aCB0aGUgZXJyb3IgYW5kIGFcbiMgbWFya2VyIHNob3dpbmcgd2hlcmUgdGhlIGVycm9yIGlzLlxuZXhwb3J0cy50aHJvd1N5bnRheEVycm9yID0gKG1lc3NhZ2UsIGxvY2F0aW9uKSAtPlxuICBlcnJvciA9IG5ldyBTeW50YXhFcnJvciBtZXNzYWdlXG4gIGVycm9yLmxvY2F0aW9uID0gbG9jYXRpb25cbiAgZXJyb3IudG9TdHJpbmcgPSBzeW50YXhFcnJvclRvU3RyaW5nXG5cbiAgIyBJbnN0ZWFkIG9mIHNob3dpbmcgdGhlIGNvbXBpbGVyJ3Mgc3RhY2t0cmFjZSwgc2hvdyBvdXIgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAgIyAodGhpcyBpcyB1c2VmdWwgd2hlbiB0aGUgZXJyb3IgYnViYmxlcyB1cCBpbiBOb2RlLmpzIGFwcGxpY2F0aW9ucyB0aGF0XG4gICMgY29tcGlsZSBDb2ZmZWVTY3JpcHQgZm9yIGV4YW1wbGUpLlxuICBlcnJvci5zdGFjayA9IGVycm9yLnRvU3RyaW5nKClcblxuICB0aHJvdyBlcnJvclxuXG4jIFVwZGF0ZSBhIGNvbXBpbGVyIFN5bnRheEVycm9yIHdpdGggc291cmNlIGNvZGUgaW5mb3JtYXRpb24gaWYgaXQgZGlkbid0IGhhdmVcbiMgaXQgYWxyZWFkeS5cbmV4cG9ydHMudXBkYXRlU3ludGF4RXJyb3IgPSAoZXJyb3IsIGNvZGUsIGZpbGVuYW1lKSAtPlxuICAjIEF2b2lkIHNjcmV3aW5nIHVwIHRoZSBgc3RhY2tgIHByb3BlcnR5IG9mIG90aGVyIGVycm9ycyAoaS5lLiBwb3NzaWJsZSBidWdzKS5cbiAgaWYgZXJyb3IudG9TdHJpbmcgaXMgc3ludGF4RXJyb3JUb1N0cmluZ1xuICAgIGVycm9yLmNvZGUgb3I9IGNvZGVcbiAgICBlcnJvci5maWxlbmFtZSBvcj0gZmlsZW5hbWVcbiAgICBlcnJvci5zdGFjayA9IGVycm9yLnRvU3RyaW5nKClcbiAgZXJyb3Jcblxuc3ludGF4RXJyb3JUb1N0cmluZyA9IC0+XG4gIHJldHVybiBFcnJvcjo6dG9TdHJpbmcuY2FsbCBAIHVubGVzcyBAY29kZSBhbmQgQGxvY2F0aW9uXG5cbiAge2ZpcnN0X2xpbmUsIGZpcnN0X2NvbHVtbiwgbGFzdF9saW5lLCBsYXN0X2NvbHVtbn0gPSBAbG9jYXRpb25cbiAgbGFzdF9saW5lID89IGZpcnN0X2xpbmVcbiAgbGFzdF9jb2x1bW4gPz0gZmlyc3RfY29sdW1uXG5cbiAgaWYgQGZpbGVuYW1lPy5zdGFydHNXaXRoICc8YW5vbnltb3VzJ1xuICAgIGZpbGVuYW1lID0gJ1tzdGRpbl0nXG4gIGVsc2VcbiAgICBmaWxlbmFtZSA9IEBmaWxlbmFtZSBvciAnW3N0ZGluXSdcblxuICBjb2RlTGluZSA9IEBjb2RlLnNwbGl0KCdcXG4nKVtmaXJzdF9saW5lXVxuICBzdGFydCAgICA9IGZpcnN0X2NvbHVtblxuICAjIFNob3cgb25seSB0aGUgZmlyc3QgbGluZSBvbiBtdWx0aS1saW5lIGVycm9ycy5cbiAgZW5kICAgICAgPSBpZiBmaXJzdF9saW5lIGlzIGxhc3RfbGluZSB0aGVuIGxhc3RfY29sdW1uICsgMSBlbHNlIGNvZGVMaW5lLmxlbmd0aFxuICBtYXJrZXIgICA9IGNvZGVMaW5lWy4uLnN0YXJ0XS5yZXBsYWNlKC9bXlxcc10vZywgJyAnKSArIHJlcGVhdCgnXicsIGVuZCAtIHN0YXJ0KVxuXG4gICMgQ2hlY2sgdG8gc2VlIGlmIHdlJ3JlIHJ1bm5pbmcgb24gYSBjb2xvci1lbmFibGVkIFRUWS5cbiAgaWYgcHJvY2Vzcz9cbiAgICBjb2xvcnNFbmFibGVkID0gcHJvY2Vzcy5zdGRvdXQ/LmlzVFRZIGFuZCBub3QgcHJvY2Vzcy5lbnY/Lk5PREVfRElTQUJMRV9DT0xPUlNcblxuICBpZiBAY29sb3JmdWwgPyBjb2xvcnNFbmFibGVkXG4gICAgY29sb3JpemUgPSAoc3RyKSAtPiBcIlxceDFCWzE7MzFtI3tzdHJ9XFx4MUJbMG1cIlxuICAgIGNvZGVMaW5lID0gY29kZUxpbmVbLi4uc3RhcnRdICsgY29sb3JpemUoY29kZUxpbmVbc3RhcnQuLi5lbmRdKSArIGNvZGVMaW5lW2VuZC4uXVxuICAgIG1hcmtlciAgID0gY29sb3JpemUgbWFya2VyXG5cbiAgXCJcIlwiXG4gICAgI3tmaWxlbmFtZX06I3tmaXJzdF9saW5lICsgMX06I3tmaXJzdF9jb2x1bW4gKyAxfTogZXJyb3I6ICN7QG1lc3NhZ2V9XG4gICAgI3tjb2RlTGluZX1cbiAgICAje21hcmtlcn1cbiAgXCJcIlwiXG5cbmV4cG9ydHMubmFtZVdoaXRlc3BhY2VDaGFyYWN0ZXIgPSAoc3RyaW5nKSAtPlxuICBzd2l0Y2ggc3RyaW5nXG4gICAgd2hlbiAnICcgdGhlbiAnc3BhY2UnXG4gICAgd2hlbiAnXFxuJyB0aGVuICduZXdsaW5lJ1xuICAgIHdoZW4gJ1xccicgdGhlbiAnY2FycmlhZ2UgcmV0dXJuJ1xuICAgIHdoZW4gJ1xcdCcgdGhlbiAndGFiJ1xuICAgIGVsc2Ugc3RyaW5nXG5cbmV4cG9ydHMucGFyc2VOdW1iZXIgPSAoc3RyaW5nKSAtPlxuICByZXR1cm4gTmFOIHVubGVzcyBzdHJpbmc/XG5cbiAgYmFzZSA9IHN3aXRjaCBzdHJpbmcuY2hhckF0IDFcbiAgICB3aGVuICdiJyB0aGVuIDJcbiAgICB3aGVuICdvJyB0aGVuIDhcbiAgICB3aGVuICd4JyB0aGVuIDE2XG4gICAgZWxzZSBudWxsXG5cbiAgaWYgYmFzZT9cbiAgICBwYXJzZUludCBzdHJpbmdbMi4uXS5yZXBsYWNlKC9fL2csICcnKSwgYmFzZVxuICBlbHNlXG4gICAgcGFyc2VGbG9hdCBzdHJpbmcucmVwbGFjZSgvXy9nLCAnJylcblxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gKG9iaikgLT4gT2JqZWN0Ojp0b1N0cmluZy5jYWxsKG9iaikgaXMgJ1tvYmplY3QgRnVuY3Rpb25dJ1xuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyID0gKG9iaikgLT4gT2JqZWN0Ojp0b1N0cmluZy5jYWxsKG9iaikgaXMgJ1tvYmplY3QgTnVtYmVyXSdcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZyA9IChvYmopIC0+IE9iamVjdDo6dG9TdHJpbmcuY2FsbChvYmopIGlzICdbb2JqZWN0IFN0cmluZ10nXG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbiA9IChvYmopIC0+IG9iaiBpcyB5ZXMgb3Igb2JqIGlzIG5vIG9yIE9iamVjdDo6dG9TdHJpbmcuY2FsbChvYmopIGlzICdbb2JqZWN0IEJvb2xlYW5dJ1xuZXhwb3J0cy5pc1BsYWluT2JqZWN0ID0gKG9iaikgLT4gdHlwZW9mIG9iaiBpcyAnb2JqZWN0JyBhbmQgISFvYmogYW5kIG5vdCBBcnJheS5pc0FycmF5KG9iaikgYW5kIG5vdCBpc051bWJlcihvYmopIGFuZCBub3QgaXNTdHJpbmcob2JqKSBhbmQgbm90IGlzQm9vbGVhbihvYmopXG5cbnVuaWNvZGVDb2RlUG9pbnRUb1VuaWNvZGVFc2NhcGVzID0gKGNvZGVQb2ludCkgLT5cbiAgdG9Vbmljb2RlRXNjYXBlID0gKHZhbCkgLT5cbiAgICBzdHIgPSB2YWwudG9TdHJpbmcgMTZcbiAgICBcIlxcXFx1I3tyZXBlYXQgJzAnLCA0IC0gc3RyLmxlbmd0aH0je3N0cn1cIlxuICByZXR1cm4gdG9Vbmljb2RlRXNjYXBlKGNvZGVQb2ludCkgaWYgY29kZVBvaW50IDwgMHgxMDAwMFxuICAjIHN1cnJvZ2F0ZSBwYWlyXG4gIGhpZ2ggPSBNYXRoLmZsb29yKChjb2RlUG9pbnQgLSAweDEwMDAwKSAvIDB4NDAwKSArIDB4RDgwMFxuICBsb3cgPSAoY29kZVBvaW50IC0gMHgxMDAwMCkgJSAweDQwMCArIDB4REMwMFxuICBcIiN7dG9Vbmljb2RlRXNjYXBlKGhpZ2gpfSN7dG9Vbmljb2RlRXNjYXBlKGxvdyl9XCJcblxuIyBSZXBsYWNlIGBcXHV7Li4ufWAgd2l0aCBgXFx1eHh4eFtcXHV4eHh4XWAgaW4gcmVnZXhlcyB3aXRob3V0IGB1YCBmbGFnXG5leHBvcnRzLnJlcGxhY2VVbmljb2RlQ29kZVBvaW50RXNjYXBlcyA9IChzdHIsIHtmbGFncywgZXJyb3IsIGRlbGltaXRlciA9ICcnfSA9IHt9KSAtPlxuICBzaG91bGRSZXBsYWNlID0gZmxhZ3M/IGFuZCAndScgbm90IGluIGZsYWdzXG4gIHN0ci5yZXBsYWNlIFVOSUNPREVfQ09ERV9QT0lOVF9FU0NBUEUsIChtYXRjaCwgZXNjYXBlZEJhY2tzbGFzaCwgY29kZVBvaW50SGV4LCBvZmZzZXQpIC0+XG4gICAgcmV0dXJuIGVzY2FwZWRCYWNrc2xhc2ggaWYgZXNjYXBlZEJhY2tzbGFzaFxuXG4gICAgY29kZVBvaW50RGVjaW1hbCA9IHBhcnNlSW50IGNvZGVQb2ludEhleCwgMTZcbiAgICBpZiBjb2RlUG9pbnREZWNpbWFsID4gMHgxMGZmZmZcbiAgICAgIGVycm9yIFwidW5pY29kZSBjb2RlIHBvaW50IGVzY2FwZXMgZ3JlYXRlciB0aGFuIFxcXFx1ezEwZmZmZn0gYXJlIG5vdCBhbGxvd2VkXCIsXG4gICAgICAgIG9mZnNldDogb2Zmc2V0ICsgZGVsaW1pdGVyLmxlbmd0aFxuICAgICAgICBsZW5ndGg6IGNvZGVQb2ludEhleC5sZW5ndGggKyA0XG4gICAgcmV0dXJuIG1hdGNoIHVubGVzcyBzaG91bGRSZXBsYWNlXG5cbiAgICB1bmljb2RlQ29kZVBvaW50VG9Vbmljb2RlRXNjYXBlcyBjb2RlUG9pbnREZWNpbWFsXG5cblVOSUNPREVfQ09ERV9QT0lOVF9FU0NBUEUgPSAvLy9cbiAgKCBcXFxcXFxcXCApICAgICAgICAjIE1ha2Ugc3VyZSB0aGUgZXNjYXBlIGlzbuKAmXQgZXNjYXBlZC5cbiAgfFxuICBcXFxcdVxceyAoIFtcXGRhLWZBLUZdKyApIFxcfVxuLy8vZ1xuIl19
//# sourceURL=/home/flow/jzr/coffeescript/src/helpers.coffee