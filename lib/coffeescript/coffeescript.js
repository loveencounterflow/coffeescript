// Generated by CoffeeScript 2.7.0
(function() {
  // CoffeeScript can be used both on the server, as a command-line compiler based
  // on Node.js/V8, or to run CoffeeScript directly in the browser. This module
  // contains the main entry functions for tokenizing, parsing, and compiling
  // source CoffeeScript into JavaScript.
  var FILE_EXTENSIONS, Lexer, SourceMap, base64encode, checkShebangLine, compile, getSourceMap, helpers, lexer, packageJson, parser, registerCompiled, withPrettyErrors;

  ({Lexer} = require('./lexer'));

  ({parser} = require('./parser'));

  helpers = require('./helpers');

  SourceMap = require('./sourcemap');

  // Require `package.json`, which is two levels above this file, as this file is
  // evaluated from `lib/coffeescript`.
  packageJson = require('../../package.json');

  // The current CoffeeScript version number.
  exports.VERSION = packageJson.version;

  exports.FILE_EXTENSIONS = FILE_EXTENSIONS = ['.coffee', '.litcoffee', '.coffee.md'];

  // Expose helpers for testing.
  exports.helpers = helpers;

  ({getSourceMap, registerCompiled} = SourceMap);

  // This is exported to enable an external module to implement caching of
  // sourcemaps. This is used only when `patchStackTrace` has been called to adjust
  // stack traces for files with cached source maps.
  exports.registerCompiled = registerCompiled;

  // Function that allows for btoa in both nodejs and the browser.
  base64encode = function(src) {
    switch (false) {
      case typeof Buffer !== 'function':
        return Buffer.from(src).toString('base64');
      case typeof btoa !== 'function':
        // The contents of a `<script>` block are encoded via UTF-16, so if any extended
        // characters are used in the block, btoa will fail as it maxes out at UTF-8.
        // See https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_Unicode_Problem
        // for the gory details, and for the solution implemented here.
        return btoa(encodeURIComponent(src).replace(/%([0-9A-F]{2})/g, function(match, p1) {
          return String.fromCharCode('0x' + p1);
        }));
      default:
        throw new Error('Unable to base64 encode inline sourcemap.');
    }
  };

  // Function wrapper to add source file information to SyntaxErrors thrown by the
  // lexer/parser/compiler.
  withPrettyErrors = function(fn) {
    return function(code, options = {}, handler = null) {
      var err;
      try {
        return fn.call(this, code, options, handler);
      } catch (error) {
        err = error;
        if (typeof code !== 'string') { // Support `CoffeeScript.nodes(tokens)`.
          throw err;
        }
        throw helpers.updateSyntaxError(err, code, options.filename);
      }
    };
  };

  // Compile CoffeeScript code to JavaScript, using the Coffee/Jison compiler.

  // If `options.sourceMap` is specified, then `options.filename` must also be
  // specified. All options that can be passed to `SourceMap#generate` may also
  // be passed here.

  // This returns a javascript string, unless `options.sourceMap` is passed,
  // in which case this returns a `{js, v3SourceMap, sourceMap}`
  // object, where sourceMap is a sourcemap.coffee#SourceMap object, handy for
  // doing programmatic lookups.
  exports.compile = compile = withPrettyErrors(function(code, options = {}, handler = null) { // !!!!!!!!!!
    var ast, currentColumn, currentLine, encoded, filename, fragment, fragments, generateSourceMap, header, i, j, js, len, len1, map, newLines, nodes, range, ref, sourceCodeLastLine, sourceCodeNumberOfLines, sourceMapDataURI, sourceURL, token, tokens, transpiler, transpilerOptions, transpilerOutput, v3SourceMap;
    // exports.compile = compile = withPrettyErrors (code, options = {}) ->
    // console.log 'ΩCS___1', "compile()", handler # !!!!!!!!!!!!!!!!!!
    // Clone `options`, to avoid mutating the `options` object passed in.
    options = Object.assign({}, options);
    generateSourceMap = options.sourceMap || options.inlineMap || (options.filename == null);
    filename = options.filename || helpers.anonymousFileName();
    checkShebangLine(filename, code);
    if (generateSourceMap) {
      map = new SourceMap();
    }
    tokens = lexer.tokenize(code, options);
    if (handler != null) {
      handler({tokens});
    }
    // Pass a list of referenced variables, so that generated variables won’t get
    // the same name.
    options.referencedVars = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = tokens.length; i < len; i++) {
        token = tokens[i];
        if (token[0] === 'IDENTIFIER') {
          results.push(token[1]);
        }
      }
      return results;
    })();
    // Check for import or export; if found, force bare mode.
    if (!((options.bare != null) && options.bare === true)) {
      for (i = 0, len = tokens.length; i < len; i++) {
        token = tokens[i];
        if ((ref = token[0]) === 'IMPORT' || ref === 'EXPORT') {
          options.bare = true;
          break;
        }
      }
    }
    nodes = parser.parse(tokens);
    if (handler != null) {
      handler({nodes});
    }
    // If all that was requested was a POJO representation of the nodes, e.g.
    // the abstract syntax tree (AST), we can stop now and just return that
    // (after fixing the location data for the root/`File`»`Program` node,
    // which might’ve gotten misaligned from the original source due to the
    // `clean` function in the lexer).
    if (options.ast) {
      nodes.allCommentTokens = helpers.extractAllCommentTokens(tokens);
      sourceCodeNumberOfLines = (code.match(/\r?\n/g) || '').length + 1;
      sourceCodeLastLine = /.*$/.exec(code)[0];
      ast = nodes.ast(options);
      range = [0, code.length];
      ast.start = ast.program.start = range[0];
      ast.end = ast.program.end = range[1];
      ast.range = ast.program.range = range;
      ast.loc.start = ast.program.loc.start = {
        line: 1,
        column: 0
      };
      ast.loc.end.line = ast.program.loc.end.line = sourceCodeNumberOfLines;
      ast.loc.end.column = ast.program.loc.end.column = sourceCodeLastLine.length;
      ast.tokens = tokens;
      return ast;
    }
    fragments = nodes.compileToFragments(options);
    currentLine = 0;
    if (options.header) {
      currentLine += 1;
    }
    if (options.shiftLine) {
      currentLine += 1;
    }
    currentColumn = 0;
    js = "";
    for (j = 0, len1 = fragments.length; j < len1; j++) {
      fragment = fragments[j];
      // Update the sourcemap with data from each fragment.
      if (generateSourceMap) {
        // Do not include empty, whitespace, or semicolon-only fragments.
        if (fragment.locationData && !/^[;\s]*$/.test(fragment.code)) {
          map.add([fragment.locationData.first_line, fragment.locationData.first_column], [currentLine, currentColumn], {
            noReplace: true
          });
        }
        newLines = helpers.count(fragment.code, "\n");
        currentLine += newLines;
        if (newLines) {
          currentColumn = fragment.code.length - (fragment.code.lastIndexOf("\n") + 1);
        } else {
          currentColumn += fragment.code.length;
        }
      }
      // Copy the code from each fragment into the final JavaScript.
      js += fragment.code;
    }
    if (options.header) {
      header = `Generated by CoffeeScript ${this.VERSION}`;
      js = `// ${header}\n${js}`;
    }
    if (generateSourceMap) {
      v3SourceMap = map.generate(options, code);
    }
    if (options.transpile) {
      if (typeof options.transpile !== 'object') {
        // This only happens if run via the Node API and `transpile` is set to
        // something other than an object.
        throw new Error('The transpile option must be given an object with options to pass to Babel');
      }
      // Get the reference to Babel that we have been passed if this compiler
      // is run via the CLI or Node API.
      transpiler = options.transpile.transpile;
      delete options.transpile.transpile;
      transpilerOptions = Object.assign({}, options.transpile);
      // See https://github.com/babel/babel/issues/827#issuecomment-77573107:
      // Babel can take a v3 source map object as input in `inputSourceMap`
      // and it will return an *updated* v3 source map object in its output.
      if (v3SourceMap && (transpilerOptions.inputSourceMap == null)) {
        transpilerOptions.inputSourceMap = v3SourceMap;
      }
      transpilerOutput = transpiler(js, transpilerOptions);
      js = transpilerOutput.code;
      if (v3SourceMap && transpilerOutput.map) {
        v3SourceMap = transpilerOutput.map;
      }
    }
    if (options.inlineMap) {
      encoded = base64encode(JSON.stringify(v3SourceMap));
      sourceMapDataURI = `//# sourceMappingURL=data:application/json;base64,${encoded}`;
      sourceURL = `//# sourceURL=${filename}`;
      js = `${js}\n${sourceMapDataURI}\n${sourceURL}`;
    }
    registerCompiled(filename, code, map);
    if (options.sourceMap) {
      return {
        js,
        sourceMap: map,
        v3SourceMap: JSON.stringify(v3SourceMap, null, 2)
      };
    } else {
      return js;
    }
  });

  // Tokenize a string of CoffeeScript code, and return the array of tokens.
  exports.tokens = withPrettyErrors(function(code, options) {
    return lexer.tokenize(code, options);
  });

  // Parse a string of CoffeeScript code or an array of lexed tokens, and
  // return the AST. You can then compile it by calling `.compile()` on the root,
  // or traverse it by using `.traverseChildren()` with a callback.
  exports.nodes = withPrettyErrors(function(source, options) {
    if (typeof source === 'string') {
      source = lexer.tokenize(source, options);
    }
    return parser.parse(source);
  });

  // This file used to export these methods; leave stubs that throw warnings
  // instead. These methods have been moved into `index.coffee` to provide
  // separate entrypoints for Node and non-Node environments, so that static
  // analysis tools don’t choke on Node packages when compiling for a non-Node
  // environment.
  exports.run = exports.eval = exports.register = function() {
    throw new Error('require index.coffee, not this file');
  };

  // Instantiate a Lexer for our use here.
  lexer = new Lexer();

  // The real Lexer produces a generic stream of tokens. This object provides a
  // thin wrapper around it, compatible with the Jison API. We can then pass it
  // directly as a “Jison lexer.”
  parser.lexer = {
    yylloc: {
      range: []
    },
    options: {
      ranges: true
    },
    lex: function() {
      var tag, token;
      token = parser.tokens[this.pos++];
      if (token) {
        [tag, this.yytext, this.yylloc] = token;
        parser.errorToken = token.origin || token;
        this.yylineno = this.yylloc.first_line;
      } else {
        tag = '';
      }
      return tag;
    },
    setInput: function(tokens) {
      parser.tokens = tokens;
      return this.pos = 0;
    },
    upcomingInput: function() {
      return '';
    }
  };

  // Make all the AST nodes visible to the parser.
  parser.yy = require('./nodes');

  // Override Jison's default error handling function.
  parser.yy.parseError = function(message, {token}) {
    var errorLoc, errorTag, errorText, errorToken, tokens;
    // Disregard Jison's message, it contains redundant line number information.
    // Disregard the token, we take its value directly from the lexer in case
    // the error is caused by a generated token which might refer to its origin.
    ({errorToken, tokens} = parser);
    [errorTag, errorText, errorLoc] = errorToken;
    errorText = (function() {
      switch (false) {
        case errorToken !== tokens[tokens.length - 1]:
          return 'end of input';
        case errorTag !== 'INDENT' && errorTag !== 'OUTDENT':
          return 'indentation';
        case errorTag !== 'IDENTIFIER' && errorTag !== 'NUMBER' && errorTag !== 'INFINITY' && errorTag !== 'STRING' && errorTag !== 'STRING_START' && errorTag !== 'REGEX' && errorTag !== 'REGEX_START':
          return errorTag.replace(/_START$/, '').toLowerCase();
        default:
          return helpers.nameWhitespaceCharacter(errorText);
      }
    })();
    // The second argument has a `loc` property, which should have the location
    // data for this token. Unfortunately, Jison seems to send an outdated `loc`
    // (from the previous token), so we take the location information directly
    // from the lexer.
    return helpers.throwSyntaxError(`unexpected ${errorText}`, errorLoc);
  };

  exports.patchStackTrace = function() {
    var formatSourcePosition, getSourceMapping;
    // Based on http://v8.googlecode.com/svn/branches/bleeding_edge/src/messages.js
    // Modified to handle sourceMap
    formatSourcePosition = function(frame, getSourceMapping) {
      var as, column, fileLocation, filename, functionName, isConstructor, isMethodCall, line, methodName, source, tp, typeName;
      filename = void 0;
      fileLocation = '';
      if (frame.isNative()) {
        fileLocation = "native";
      } else {
        if (frame.isEval()) {
          filename = frame.getScriptNameOrSourceURL();
          if (!filename) {
            fileLocation = `${frame.getEvalOrigin()}, `;
          }
        } else {
          filename = frame.getFileName();
        }
        filename || (filename = "<anonymous>");
        line = frame.getLineNumber();
        column = frame.getColumnNumber();
        // Check for a sourceMap position
        source = getSourceMapping(filename, line, column);
        fileLocation = source ? `${filename}:${source[0]}:${source[1]}` : `${filename}:${line}:${column}`;
      }
      functionName = frame.getFunctionName();
      isConstructor = frame.isConstructor();
      isMethodCall = !(frame.isToplevel() || isConstructor);
      if (isMethodCall) {
        methodName = frame.getMethodName();
        typeName = frame.getTypeName();
        if (functionName) {
          tp = as = '';
          if (typeName && functionName.indexOf(typeName)) {
            tp = `${typeName}.`;
          }
          if (methodName && functionName.indexOf(`.${methodName}`) !== functionName.length - methodName.length - 1) {
            as = ` [as ${methodName}]`;
          }
          return `${tp}${functionName}${as} (${fileLocation})`;
        } else {
          return `${typeName}.${methodName || '<anonymous>'} (${fileLocation})`;
        }
      } else if (isConstructor) {
        return `new ${functionName || '<anonymous>'} (${fileLocation})`;
      } else if (functionName) {
        return `${functionName} (${fileLocation})`;
      } else {
        return fileLocation;
      }
    };
    getSourceMapping = function(filename, line, column) {
      var answer, sourceMap;
      sourceMap = getSourceMap(filename, line, column);
      if (sourceMap != null) {
        answer = sourceMap.sourceLocation([line - 1, column - 1]);
      }
      if (answer != null) {
        return [answer[0] + 1, answer[1] + 1];
      } else {
        return null;
      }
    };
    // Based on [michaelficarra/CoffeeScriptRedux](http://goo.gl/ZTx1p)
    // NodeJS / V8 have no support for transforming positions in stack traces using
    // sourceMap, so we must monkey-patch Error to display CoffeeScript source
    // positions.
    return Error.prepareStackTrace = function(err, stack) {
      var frame, frames;
      frames = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = stack.length; i < len; i++) {
          frame = stack[i];
          if (frame.getFunction() === exports.run) {
            // Don’t display stack frames deeper than `CoffeeScript.run`.
            break;
          }
          results.push(`    at ${formatSourcePosition(frame, getSourceMapping)}`);
        }
        return results;
      })();
      return `${err.toString()}\n${frames.join('\n')}\n`;
    };
  };

  checkShebangLine = function(file, input) {
    var args, firstLine, ref, rest;
    firstLine = input.split(/$/m, 1)[0];
    rest = firstLine != null ? firstLine.match(/^#!\s*([^\s]+\s*)(.*)/) : void 0;
    args = rest != null ? (ref = rest[2]) != null ? ref.split(/\s/).filter(function(s) {
      return s !== '';
    }) : void 0 : void 0;
    if ((args != null ? args.length : void 0) > 1) {
      console.error(`The script to be run begins with a shebang line with more than one
argument. This script will fail on platforms such as Linux which only
allow a single argument.`);
      console.error(`The shebang line was: '${firstLine}' in file '${file}'`);
      return console.error(`The arguments were: ${JSON.stringify(args)}`);
    }
  };

}).call(this);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29mZmVlc2NyaXB0LmpzIiwic291cmNlUm9vdCI6Ii4uLy4uLyIsInNvdXJjZXMiOlsic3JjL2NvZmZlZXNjcmlwdC5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUdzQztFQUFBOzs7O0FBQUEsTUFBQSxlQUFBLEVBQUEsS0FBQSxFQUFBLFNBQUEsRUFBQSxZQUFBLEVBQUEsZ0JBQUEsRUFBQSxPQUFBLEVBQUEsWUFBQSxFQUFBLE9BQUEsRUFBQSxLQUFBLEVBQUEsV0FBQSxFQUFBLE1BQUEsRUFBQSxnQkFBQSxFQUFBOztFQUV0QyxDQUFBLENBQUMsS0FBRCxDQUFBLEdBQWdCLE9BQUEsQ0FBUSxTQUFSLENBQWhCOztFQUNBLENBQUEsQ0FBQyxNQUFELENBQUEsR0FBZ0IsT0FBQSxDQUFRLFVBQVIsQ0FBaEI7O0VBQ0EsT0FBQSxHQUFnQixPQUFBLENBQVEsV0FBUjs7RUFDaEIsU0FBQSxHQUFnQixPQUFBLENBQVEsYUFBUixFQUxzQjs7OztFQVF0QyxXQUFBLEdBQWdCLE9BQUEsQ0FBUSxvQkFBUixFQVJzQjs7O0VBV3RDLE9BQU8sQ0FBQyxPQUFSLEdBQWtCLFdBQVcsQ0FBQzs7RUFFOUIsT0FBTyxDQUFDLGVBQVIsR0FBMEIsZUFBQSxHQUFrQixDQUFDLFNBQUQsRUFBWSxZQUFaLEVBQTBCLFlBQTFCLEVBYk47OztFQWdCdEMsT0FBTyxDQUFDLE9BQVIsR0FBa0I7O0VBRWxCLENBQUEsQ0FBQyxZQUFELEVBQWUsZ0JBQWYsQ0FBQSxHQUFtQyxTQUFuQyxFQWxCc0M7Ozs7O0VBc0J0QyxPQUFPLENBQUMsZ0JBQVIsR0FBMkIsaUJBdEJXOzs7RUF5QnRDLFlBQUEsR0FBZSxRQUFBLENBQUMsR0FBRCxDQUFBO0FBQVMsWUFBQSxLQUFBO0FBQUEsV0FDakIsT0FBTyxNQUFQLEtBQWlCLFVBREE7ZUFFcEIsTUFBTSxDQUFDLElBQVAsQ0FBWSxHQUFaLENBQWdCLENBQUMsUUFBakIsQ0FBMEIsUUFBMUI7QUFGb0IsV0FHakIsT0FBTyxJQUFQLEtB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LGdCQUE1QixDQUFWLENBQUE7UUFITyxDQUFBOzs7YUFLVCxDQUFBLENBQUEsQ0FBRyxHQUFHLENBQUMsUUFBSixDQUFBLENBQUgsQ0FBQSxFQUFBLENBQUEsQ0FBc0IsTUFBTSxDQUFDLElBQVAsQ0FBWSxJQUFaLENBQXRCLENBQUEsRUFBQTtJQU53QjtFQWhFRjs7RUF3RTFCLGdCQUFBLEdBQW1CLFFBQUEsQ0FBQyxJQUFELEVBQU8sS0FBUCxDQUFBO0FBQ25CLFFBQUEsSUFBQSxFQUFBLFNBQUEsRUFBQSxHQUFBLEVBQUE7SUFBRSxTQUFBLEdBQVksS0FBSyxDQUFDLEtBQU4sQ0FBWSxJQUFaLEVBQWtCLENBQWxCLENBQW9CLENBQUMsQ0FBRDtJQUNoQyxJQUFBLHVCQUFPLFNBQVMsQ0FBRSxLQUFYLENBQWlCLHVCQUFqQjtJQUNQLElBQUEsK0NBQWUsQ0FBRSxLQUFWLENBQWdCLElBQWhCLENBQXFCLENBQUMsTUFBdEIsQ0FBNkIsUUFBQSxDQUFDLENBQUQsQ0FBQTthQUFPLENBQUEsS0FBTztJQUFkLENBQTdCO0lBQ1Asb0JBQUcsSUFBSSxDQUFFLGdCQUFOLEdBQWUsQ0FBbEI7TUFDRSxPQUFPLENBQUMsS0FBUixDQUFjLENBQUE7O3dCQUFBLENBQWQ7TUFLQSxPQUFPLENBQUMsS0FBUixDQUFjLENBQUEsdUJBQUEsQ0FBQSxDQUEwQixTQUExQixDQUFBLFdBQUEsQ0FBQSxDQUFpRCxJQUFqRCxDQUFBLENBQUEsQ0FBZDthQUNBLE9BQU8sQ0FBQyxLQUFSLENBQWMsQ0FBQSxvQkFBQSxDQUFBLENBQXVCLElBQUksQ0FBQyxTQUFMLENBQWUsSUFBZixDQUF2QixDQUFBLENBQWQsRUFQRjs7RUFKaUI7QUFyVW1CIiwic291cmNlc0NvbnRlbnQiOlsiIyBDb2ZmZWVTY3JpcHQgY2FuIGJlIHVzZWQgYm90aCBvbiB0aGUgc2VydmVyLCBhcyBhIGNvbW1hbmQtbGluZSBjb21waWxlciBiYXNlZFxuIyBvbiBOb2RlLmpzL1Y4LCBvciB0byBydW4gQ29mZmVlU2NyaXB0IGRpcmVjdGx5IGluIHRoZSBicm93c2VyLiBUaGlzIG1vZHVsZVxuIyBjb250YWlucyB0aGUgbWFpbiBlbnRyeSBmdW5jdGlvbnMgZm9yIHRva2VuaXppbmcsIHBhcnNpbmcsIGFuZCBjb21waWxpbmdcbiMgc291cmNlIENvZmZlZVNjcmlwdCBpbnRvIEphdmFTY3JpcHQuXG5cbntMZXhlcn0gICAgICAgPSByZXF1aXJlICcuL2xleGVyJ1xue3BhcnNlcn0gICAgICA9IHJlcXVpcmUgJy4vcGFyc2VyJ1xuaGVscGVycyAgICAgICA9IHJlcXVpcmUgJy4vaGVscGVycydcblNvdXJjZU1hcCAgICAgPSByZXF1aXJlICcuL3NvdXJjZW1hcCdcbiMgUmVxdWlyZSBgcGFja2FnZS5qc29uYCwgd2hpY2ggaXMgdHdvIGxldmVscyBhYm92ZSB0aGlzIGZpbGUsIGFzIHRoaXMgZmlsZSBpc1xuIyBldmFsdWF0ZWQgZnJvbSBgbGliL2NvZmZlZXNjcmlwdGAuXG5wYWNrYWdlSnNvbiAgID0gcmVxdWlyZSAnLi4vLi4vcGFja2FnZS5qc29uJ1xuXG4jIFRoZSBjdXJyZW50IENvZmZlZVNjcmlwdCB2ZXJzaW9uIG51bWJlci5cbmV4cG9ydHMuVkVSU0lPTiA9IHBhY2thZ2VKc29uLnZlcnNpb25cblxuZXhwb3J0cy5GSUxFX0VYVEVOU0lPTlMgPSBGSUxFX0VYVEVOU0lPTlMgPSBbJy5jb2ZmZWUnLCAnLmxpdGNvZmZlZScsICcuY29mZmVlLm1kJ11cblxuIyBFeHBvc2UgaGVscGVycyBmb3IgdGVzdGluZy5cbmV4cG9ydHMuaGVscGVycyA9IGhlbHBlcnNcblxue2dldFNvdXJjZU1hcCwgcmVnaXN0ZXJDb21waWxlZH0gPSBTb3VyY2VNYXBcbiMgVGhpcyBpcyBleHBvcnRlZCB0byBlbmFibGUgYW4gZXh0ZXJuYWwgbW9kdWxlIHRvIGltcGxlbWVudCBjYWNoaW5nIG9mXG4jIHNvdXJjZW1hcHMuIFRoaXMgaXMgdXNlZCBvbmx5IHdoZW4gYHBhdGNoU3RhY2tUcmFjZWAgaGFzIGJlZW4gY2FsbGVkIHRvIGFkanVzdFxuIyBzdGFjayB0cmFjZXMgZm9yIGZpbGVzIHdpdGggY2FjaGVkIHNvdXJjZSBtYXBzLlxuZXhwb3J0cy5yZWdpc3RlckNvbXBpbGVkID0gcmVnaXN0ZXJDb21waWxlZFxuXG4jIEZ1bmN0aW9uIHRoYXQgYWxsb3dzIGZvciBidG9hIGluIGJvdGggbm9kZWpzIGFuZCB0aGUgYnJvd3Nlci5cbmJhc2U2NGVuY29kZSA9IChzcmMpIC0+IHN3aXRjaFxuICB3aGVuIHR5cGVvZiBCdWZmZXIgaXMgJ2Z1bmN0aW9uJ1xuICAgIEJ1ZmZlci5mcm9tKHNyYykudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gIHdoZW4gdHlwZW9mIGJ0b2EgaXMgJ2Z1bmN0aW9uJ1xuICAgICMgVGhlIGNvbnRlbnRzIG9mIGEgYDxzY3JpcHQ+YCBibG9jayBhcmUgZW5jb2RlZCB2aWEgVVRGLTE2LCBzbyBpZiBhbnkgZXh0ZW5kZWRcbiAgICAjIGNoYXJhY3RlcnMgYXJlIHVzZWQgaW4gdGhlIGJsb2NrLCBidG9hIHdpbGwgZmFpbCBhcyBpdCBtYXhlcyBvdXQgYXQgVVRGLTguXG4gICAgIyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvd0Jhc2U2NC9CYXNlNjRfZW5jb2RpbmdfYW5kX2RlY29kaW5nI1RoZV9Vbmljb2RlX1Byb2JsZW1cbiAgICAjIGZvciB0aGUgZ29yeSBkZXRhaWxzLCBhbmQgZm9yIHRoZSBzb2x1dGlvbiBpbXBsZW1lbnRlZCBoZXJlLlxuICAgIGJ0b2EgZW5jb2RlVVJJQ29tcG9uZW50KHNyYykucmVwbGFjZSAvJShbMC05QS1GXXsyfSkvZywgKG1hdGNoLCBwMSkgLT5cbiAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUgJzB4JyArIHAxXG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBiYXNlNjQgZW5jb2RlIGlubGluZSBzb3VyY2VtYXAuJylcblxuIyBGdW5jdGlvbiB3cmFwcGVyIHRvIGFkZCBzb3VyY2UgZmlsZSBpbmZvcm1hdGlvbiB0byBTeW50YXhFcnJvcnMgdGhyb3duIGJ5IHRoZVxuIyBsZXhlci9wYXJzZXIvY29tcGlsZXIuXG53aXRoUHJldHR5RXJyb3JzID0gKGZuKSAtPlxuICAoY29kZSwgb3B0aW9ucyA9IHt9LCBoYW5kbGVyID0gbnVsbCApIC0+XG4gICAgdHJ5XG4gICAgICBmbi5jYWxsIEAsIGNvZGUsIG9wdGlvbnMsIGhhbmRsZXJcbiAgICBjYXRjaCBlcnJcbiAgICAgIHRocm93IGVyciBpZiB0eXBlb2YgY29kZSBpc250ICdzdHJpbmcnICMgU3VwcG9ydCBgQ29mZmVlU2NyaXB0Lm5vZGVzKHRva2VucylgLlxuICAgICAgdGhyb3cgaGVscGVycy51cGRhdGVTeW50YXhFcnJvciBlcnIsIGNvZGUsIG9wdGlvbnMuZmlsZW5hbWVcblxuIyBDb21waWxlIENvZmZlZVNjcmlwdCBjb2RlIHRvIEphdmFTY3JpcHQsIHVzaW5nIHRoZSBDb2ZmZWUvSmlzb24gY29tcGlsZXIuXG4jXG4jIElmIGBvcHRpb25zLnNvdXJjZU1hcGAgaXMgc3BlY2lmaWVkLCB0aGVuIGBvcHRpb25zLmZpbGVuYW1lYCBtdXN0IGFsc28gYmVcbiMgc3BlY2lmaWVkLiBBbGwgb3B0aW9ucyB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gYFNvdXJjZU1hcCNnZW5lcmF0ZWAgbWF5IGFsc29cbiMgYmUgcGFzc2VkIGhlcmUuXG4jXG4jIFRoaXMgcmV0dXJucyBhIGphdmFzY3JpcHQgc3RyaW5nLCB1bmxlc3MgYG9wdGlvbnMuc291cmNlTWFwYCBpcyBwYXNzZWQsXG4jIGluIHdoaWNoIGNhc2UgdGhpcyByZXR1cm5zIGEgYHtqcywgdjNTb3VyY2VNYXAsIHNvdXJjZU1hcH1gXG4jIG9iamVjdCwgd2hlcmUgc291cmNlTWFwIGlzIGEgc291cmNlbWFwLmNvZmZlZSNTb3VyY2VNYXAgb2JqZWN0LCBoYW5keSBmb3JcbiMgZG9pbmcgcHJvZ3JhbW1hdGljIGxvb2t1cHMuXG5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlID0gd2l0aFByZXR0eUVycm9ycyAoY29kZSwgb3B0aW9ucyA9IHt9LCBoYW5kbGVyID0gbnVsbCkgLT4gIyAhISEhISEhISEhXG4jIGV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGUgPSB3aXRoUHJldHR5RXJyb3JzIChjb2RlLCBvcHRpb25zID0ge30pIC0+XG4gICMgY29uc29sZS5sb2cgJ86pQ1NfX18xJywgXCJjb21waWxlKClcIiwgaGFuZGxlciAjICEhISEhISEhISEhISEhISEhIVxuICAjIENsb25lIGBvcHRpb25zYCwgdG8gYXZvaWQgbXV0YXRpbmcgdGhlIGBvcHRpb25zYCBvYmplY3QgcGFzc2VkIGluLlxuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbiB7fSwgb3B0aW9uc1xuXG4gIGdlbmVyYXRlU291cmNlTWFwID0gb3B0aW9ucy5zb3VyY2VNYXAgb3Igb3B0aW9ucy5pbmxpbmVNYXAgb3Igbm90IG9wdGlvbnMuZmlsZW5hbWU/XG4gIGZpbGVuYW1lID0gb3B0aW9ucy5maWxlbmFtZSBvciBoZWxwZXJzLmFub255bW91c0ZpbGVOYW1lKClcblxuICBjaGVja1NoZWJhbmdMaW5lIGZpbGVuYW1lLCBjb2RlXG5cbiAgbWFwID0gbmV3IFNvdXJjZU1hcCBpZiBnZW5lcmF0ZVNvdXJjZU1hcFxuXG4gIHRva2VucyA9IGxleGVyLnRva2VuaXplIGNvZGUsIG9wdGlvbnNcbiAgaGFuZGxlciB7IHRva2VucywgfSBpZiBoYW5kbGVyP1xuXG4gICMgUGFzcyBhIGxpc3Qgb2YgcmVmZXJlbmNlZCB2YXJpYWJsZXMsIHNvIHRoYXQgZ2VuZXJhdGVkIHZhcmlhYmxlcyB3b27igJl0IGdldFxuICAjIHRoZSBzYW1lIG5hbWUuXG4gIG9wdGlvbnMucmVmZXJlbmNlZFZhcnMgPSAoXG4gICAgdG9rZW5bMV0gZm9yIHRva2VuIGluIHRva2VucyB3aGVuIHRva2VuWzBdIGlzICdJREVOVElGSUVSJ1xuICApXG5cbiAgIyBDaGVjayBmb3IgaW1wb3J0IG9yIGV4cG9ydDsgaWYgZm91bmQsIGZvcmNlIGJhcmUgbW9kZS5cbiAgdW5sZXNzIG9wdGlvbnMuYmFyZT8gYW5kIG9wdGlvbnMuYmFyZSBpcyB5ZXNcbiAgICBmb3IgdG9rZW4gaW4gdG9rZW5zXG4gICAgICBpZiB0b2tlblswXSBpbiBbJ0lNUE9SVCcsICdFWFBPUlQnXVxuICAgICAgICBvcHRpb25zLmJhcmUgPSB5ZXNcbiAgICAgICAgYnJlYWtcblxuICBub2RlcyA9IHBhcnNlci5wYXJzZSB0b2tlbnNcbiAgaGFuZGxlciB7IG5vZGVzLCB9IGlmIGhhbmRsZXI/XG4gICMgSWYgYWxsIHRoYXQgd2FzIHJlcXVlc3RlZCB3YXMgYSBQT0pPIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBub2RlcywgZS5nLlxuICAjIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSAoQVNUKSwgd2UgY2FuIHN0b3Agbm93IGFuZCBqdXN0IHJldHVybiB0aGF0XG4gICMgKGFmdGVyIGZpeGluZyB0aGUgbG9jYXRpb24gZGF0YSBmb3IgdGhlIHJvb3QvYEZpbGVgwrtgUHJvZ3JhbWAgbm9kZSxcbiAgIyB3aGljaCBtaWdodOKAmXZlIGdvdHRlbiBtaXNhbGlnbmVkIGZyb20gdGhlIG9yaWdpbmFsIHNvdXJjZSBkdWUgdG8gdGhlXG4gICMgYGNsZWFuYCBmdW5jdGlvbiBpbiB0aGUgbGV4ZXIpLlxuICBpZiBvcHRpb25zLmFzdFxuICAgIG5vZGVzLmFsbENvbW1lbnRUb2tlbnMgPSBoZWxwZXJzLmV4dHJhY3RBbGxDb21tZW50VG9rZW5zIHRva2Vuc1xuICAgIHNvdXJjZUNvZGVOdW1iZXJPZkxpbmVzID0gKGNvZGUubWF0Y2goL1xccj9cXG4vZykgb3IgJycpLmxlbmd0aCArIDFcbiAgICBzb3VyY2VDb2RlTGFzdExpbmUgPSAvLiokLy5leGVjKGNvZGUpWzBdICMgYC4qYCBtYXRjaGVzIGFsbCBidXQgbGluZSBicmVhayBjaGFyYWN0ZXJzLlxuICAgIGFzdCA9IG5vZGVzLmFzdCBvcHRpb25zXG4gICAgcmFuZ2UgPSBbMCwgY29kZS5sZW5ndGhdXG4gICAgYXN0LnN0YXJ0ID0gYXN0LnByb2dyYW0uc3RhcnQgPSByYW5nZVswXVxuICAgIGFzdC5lbmQgPSBhc3QucHJvZ3JhbS5lbmQgPSByYW5nZVsxXVxuICAgIGFzdC5yYW5nZSA9IGFzdC5wcm9ncmFtLnJhbmdlID0gcmFuZ2VcbiAgICBhc3QubG9jLnN0YXJ0ID0gYXN0LnByb2dyYW0ubG9jLnN0YXJ0ID0ge2xpbmU6IDEsIGNvbHVtbjogMH1cbiAgICBhc3QubG9jLmVuZC5saW5lID0gYXN0LnByb2dyYW0ubG9jLmVuZC5saW5lID0gc291cmNlQ29kZU51bWJlck9mTGluZXNcbiAgICBhc3QubG9jLmVuZC5jb2x1bW4gPSBhc3QucHJvZ3JhbS5sb2MuZW5kLmNvbHVtbiA9IHNvdXJjZUNvZGVMYXN0TGluZS5sZW5ndGhcbiAgICBhc3QudG9rZW5zID0gdG9rZW5zXG4gICAgcmV0dXJuIGFzdFxuXG4gIGZyYWdtZW50cyA9IG5vZGVzLmNvbXBpbGVUb0ZyYWdtZW50cyBvcHRpb25zXG5cbiAgY3VycmVudExpbmUgPSAwXG4gIGN1cnJlbnRMaW5lICs9IDEgaWYgb3B0aW9ucy5oZWFkZXJcbiAgY3VycmVudExpbmUgKz0gMSBpZiBvcHRpb25zLnNoaWZ0TGluZVxuICBjdXJyZW50Q29sdW1uID0gMFxuICBqcyA9IFwiXCJcbiAgZm9yIGZyYWdtZW50IGluIGZyYWdtZW50c1xuICAgICMgVXBkYXRlIHRoZSBzb3VyY2VtYXAgd2l0aCBkYXRhIGZyb20gZWFjaCBmcmFnbWVudC5cbiAgICBpZiBnZW5lcmF0ZVNvdXJjZU1hcFxuICAgICAgIyBEbyBub3QgaW5jbHVkZSBlbXB0eSwgd2hpdGVzcGFjZSwgb3Igc2VtaWNvbG9uLW9ubHkgZnJhZ21lbnRzLlxuICAgICAgaWYgZnJhZ21lbnQubG9jYXRpb25EYXRhIGFuZCBub3QgL15bO1xcc10qJC8udGVzdCBmcmFnbWVudC5jb2RlXG4gICAgICAgIG1hcC5hZGQoXG4gICAgICAgICAgW2ZyYWdtZW50LmxvY2F0aW9uRGF0YS5maXJzdF9saW5lLCBmcmFnbWVudC5sb2NhdGlvbkRhdGEuZmlyc3RfY29sdW1uXVxuICAgICAgICAgIFtjdXJyZW50TGluZSwgY3VycmVudENvbHVtbl1cbiAgICAgICAgICB7bm9SZXBsYWNlOiB0cnVlfSlcbiAgICAgIG5ld0xpbmVzID0gaGVscGVycy5jb3VudCBmcmFnbWVudC5jb2RlLCBcIlxcblwiXG4gICAgICBjdXJyZW50TGluZSArPSBuZXdMaW5lc1xuICAgICAgaWYgbmV3TGluZXNcbiAgICAgICAgY3VycmVudENvbHVtbiA9IGZyYWdtZW50LmNvZGUubGVuZ3RoIC0gKGZyYWdtZW50LmNvZGUubGFzdEluZGV4T2YoXCJcXG5cIikgKyAxKVxuICAgICAgZWxzZVxuICAgICAgICBjdXJyZW50Q29sdW1uICs9IGZyYWdtZW50LmNvZGUubGVuZ3RoXG5cbiAgICAjIENvcHkgdGhlIGNvZGUgZnJvbSBlYWNoIGZyYWdtZW50IGludG8gdGhlIGZpbmFsIEphdmFTY3JpcHQuXG4gICAganMgKz0gZnJhZ21lbnQuY29kZVxuXG4gIGlmIG9wdGlvbnMuaGVhZGVyXG4gICAgaGVhZGVyID0gXCJHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0ICN7QFZFUlNJT059XCJcbiAgICBqcyA9IFwiLy8gI3toZWFkZXJ9XFxuI3tqc31cIlxuXG4gIGlmIGdlbmVyYXRlU291cmNlTWFwXG4gICAgdjNTb3VyY2VNYXAgPSBtYXAuZ2VuZXJhdGUgb3B0aW9ucywgY29kZVxuXG4gIGlmIG9wdGlvbnMudHJhbnNwaWxlXG4gICAgaWYgdHlwZW9mIG9wdGlvbnMudHJhbnNwaWxlIGlzbnQgJ29iamVjdCdcbiAgICAgICMgVGhpcyBvbmx5IGhhcHBlbnMgaWYgcnVuIHZpYSB0aGUgTm9kZSBBUEkgYW5kIGB0cmFuc3BpbGVgIGlzIHNldCB0b1xuICAgICAgIyBzb21ldGhpbmcgb3RoZXIgdGhhbiBhbiBvYmplY3QuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IgJ1RoZSB0cmFuc3BpbGUgb3B0aW9uIG11c3QgYmUgZ2l2ZW4gYW4gb2JqZWN0IHdpdGggb3B0aW9ucyB0byBwYXNzIHRvIEJhYmVsJ1xuXG4gICAgIyBHZXQgdGhlIHJlZmVyZW5jZSB0byBCYWJlbCB0aGF0IHdlIGhhdmUgYmVlbiBwYXNzZWQgaWYgdGhpcyBjb21waWxlclxuICAgICMgaXMgcnVuIHZpYSB0aGUgQ0xJIG9yIE5vZGUgQVBJLlxuICAgIHRyYW5zcGlsZXIgPSBvcHRpb25zLnRyYW5zcGlsZS50cmFuc3BpbGVcbiAgICBkZWxldGUgb3B0aW9ucy50cmFuc3BpbGUudHJhbnNwaWxlXG5cbiAgICB0cmFuc3BpbGVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24ge30sIG9wdGlvbnMudHJhbnNwaWxlXG5cbiAgICAjIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYmFiZWwvYmFiZWwvaXNzdWVzLzgyNyNpc3N1ZWNvbW1lbnQtNzc1NzMxMDc6XG4gICAgIyBCYWJlbCBjYW4gdGFrZSBhIHYzIHNvdXJjZSBtYXAgb2JqZWN0IGFzIGlucHV0IGluIGBpbnB1dFNvdXJjZU1hcGBcbiAgICAjIGFuZCBpdCB3aWxsIHJldHVybiBhbiAqdXBkYXRlZCogdjMgc291cmNlIG1hcCBvYmplY3QgaW4gaXRzIG91dHB1dC5cbiAgICBpZiB2M1NvdXJjZU1hcCBhbmQgbm90IHRyYW5zcGlsZXJPcHRpb25zLmlucHV0U291cmNlTWFwP1xuICAgICAgdHJhbnNwaWxlck9wdGlvbnMuaW5wdXRTb3VyY2VNYXAgPSB2M1NvdXJjZU1hcFxuICAgIHRyYW5zcGlsZXJPdXRwdXQgPSB0cmFuc3BpbGVyIGpzLCB0cmFuc3BpbGVyT3B0aW9uc1xuICAgIGpzID0gdHJhbnNwaWxlck91dHB1dC5jb2RlXG4gICAgaWYgdjNTb3VyY2VNYXAgYW5kIHRyYW5zcGlsZXJPdXRwdXQubWFwXG4gICAgICB2M1NvdXJjZU1hcCA9IHRyYW5zcGlsZXJPdXRwdXQubWFwXG5cbiAgaWYgb3B0aW9ucy5pbmxpbmVNYXBcbiAgICBlbmNvZGVkID0gYmFzZTY0ZW5jb2RlIEpTT04uc3RyaW5naWZ5IHYzU291cmNlTWFwXG4gICAgc291cmNlTWFwRGF0YVVSSSA9IFwiLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwje2VuY29kZWR9XCJcbiAgICBzb3VyY2VVUkwgPSBcIi8vIyBzb3VyY2VVUkw9I3tmaWxlbmFtZX1cIlxuICAgIGpzID0gXCIje2pzfVxcbiN7c291cmNlTWFwRGF0YVVSSX1cXG4je3NvdXJjZVVSTH1cIlxuXG4gIHJlZ2lzdGVyQ29tcGlsZWQgZmlsZW5hbWUsIGNvZGUsIG1hcFxuXG4gIGlmIG9wdGlvbnMuc291cmNlTWFwXG4gICAge1xuICAgICAganNcbiAgICAgIHNvdXJjZU1hcDogbWFwXG4gICAgICB2M1NvdXJjZU1hcDogSlNPTi5zdHJpbmdpZnkgdjNTb3VyY2VNYXAsIG51bGwsIDJcbiAgICB9XG4gIGVsc2VcbiAgICBqc1xuXG4jIFRva2VuaXplIGEgc3RyaW5nIG9mIENvZmZlZVNjcmlwdCBjb2RlLCBhbmQgcmV0dXJuIHRoZSBhcnJheSBvZiB0b2tlbnMuXG5leHBvcnRzLnRva2VucyA9IHdpdGhQcmV0dHlFcnJvcnMgKGNvZGUsIG9wdGlvbnMpIC0+XG4gIGxleGVyLnRva2VuaXplIGNvZGUsIG9wdGlvbnNcblxuIyBQYXJzZSBhIHN0cmluZyBvZiBDb2ZmZWVTY3JpcHQgY29kZSBvciBhbiBhcnJheSBvZiBsZXhlZCB0b2tlbnMsIGFuZFxuIyByZXR1cm4gdGhlIEFTVC4gWW91IGNhbiB0aGVuIGNvbXBpbGUgaXQgYnkgY2FsbGluZyBgLmNvbXBpbGUoKWAgb24gdGhlIHJvb3QsXG4jIG9yIHRyYXZlcnNlIGl0IGJ5IHVzaW5nIGAudHJhdmVyc2VDaGlsZHJlbigpYCB3aXRoIGEgY2FsbGJhY2suXG5leHBvcnRzLm5vZGVzID0gd2l0aFByZXR0eUVycm9ycyAoc291cmNlLCBvcHRpb25zKSAtPlxuICBzb3VyY2UgPSBsZXhlci50b2tlbml6ZSBzb3VyY2UsIG9wdGlvbnMgaWYgdHlwZW9mIHNvdXJjZSBpcyAnc3RyaW5nJ1xuICBwYXJzZXIucGFyc2Ugc291cmNlXG5cbiMgVGhpcyBmaWxlIHVzZWQgdG8gZXhwb3J0IHRoZXNlIG1ldGhvZHM7IGxlYXZlIHN0dWJzIHRoYXQgdGhyb3cgd2FybmluZ3NcbiMgaW5zdGVhZC4gVGhlc2UgbWV0aG9kcyBoYXZlIGJlZW4gbW92ZWQgaW50byBgaW5kZXguY29mZmVlYCB0byBwcm92aWRlXG4jIHNlcGFyYXRlIGVudHJ5cG9pbnRzIGZvciBOb2RlIGFuZCBub24tTm9kZSBlbnZpcm9ubWVudHMsIHNvIHRoYXQgc3RhdGljXG4jIGFuYWx5c2lzIHRvb2xzIGRvbuKAmXQgY2hva2Ugb24gTm9kZSBwYWNrYWdlcyB3aGVuIGNvbXBpbGluZyBmb3IgYSBub24tTm9kZVxuIyBlbnZpcm9ubWVudC5cbmV4cG9ydHMucnVuID0gZXhwb3J0cy5ldmFsID0gZXhwb3J0cy5yZWdpc3RlciA9IC0+XG4gIHRocm93IG5ldyBFcnJvciAncmVxdWlyZSBpbmRleC5jb2ZmZWUsIG5vdCB0aGlzIGZpbGUnXG5cbiMgSW5zdGFudGlhdGUgYSBMZXhlciBmb3Igb3VyIHVzZSBoZXJlLlxubGV4ZXIgPSBuZXcgTGV4ZXJcblxuIyBUaGUgcmVhbCBMZXhlciBwcm9kdWNlcyBhIGdlbmVyaWMgc3RyZWFtIG9mIHRva2Vucy4gVGhpcyBvYmplY3QgcHJvdmlkZXMgYVxuIyB0aGluIHdyYXBwZXIgYXJvdW5kIGl0LCBjb21wYXRpYmxlIHdpdGggdGhlIEppc29uIEFQSS4gV2UgY2FuIHRoZW4gcGFzcyBpdFxuIyBkaXJlY3RseSBhcyBhIOKAnEppc29uIGxleGVyLuKAnVxucGFyc2VyLmxleGVyID1cbiAgeXlsbG9jOlxuICAgIHJhbmdlOiBbXVxuICBvcHRpb25zOlxuICAgIHJhbmdlczogeWVzXG4gIGxleDogLT5cbiAgICB0b2tlbiA9IHBhcnNlci50b2tlbnNbQHBvcysrXVxuICAgIGlmIHRva2VuXG4gICAgICBbdGFnLCBAeXl0ZXh0LCBAeXlsbG9jXSA9IHRva2VuXG4gICAgICBwYXJzZXIuZXJyb3JUb2tlbiA9IHRva2VuLm9yaWdpbiBvciB0b2tlblxuICAgICAgQHl5bGluZW5vID0gQHl5bGxvYy5maXJzdF9saW5lXG4gICAgZWxzZVxuICAgICAgdGFnID0gJydcbiAgICB0YWdcbiAgc2V0SW5wdXQ6ICh0b2tlbnMpIC0+XG4gICAgcGFyc2VyLnRva2VucyA9IHRva2Vuc1xuICAgIEBwb3MgPSAwXG4gIHVwY29taW5nSW5wdXQ6IC0+ICcnXG5cbiMgTWFrZSBhbGwgdGhlIEFTVCBub2RlcyB2aXNpYmxlIHRvIHRoZSBwYXJzZXIuXG5wYXJzZXIueXkgPSByZXF1aXJlICcuL25vZGVzJ1xuXG4jIE92ZXJyaWRlIEppc29uJ3MgZGVmYXVsdCBlcnJvciBoYW5kbGluZyBmdW5jdGlvbi5cbnBhcnNlci55eS5wYXJzZUVycm9yID0gKG1lc3NhZ2UsIHt0b2tlbn0pIC0+XG4gICMgRGlzcmVnYXJkIEppc29uJ3MgbWVzc2FnZSwgaXQgY29udGFpbnMgcmVkdW5kYW50IGxpbmUgbnVtYmVyIGluZm9ybWF0aW9uLlxuICAjIERpc3JlZ2FyZCB0aGUgdG9rZW4sIHdlIHRha2UgaXRzIHZhbHVlIGRpcmVjdGx5IGZyb20gdGhlIGxleGVyIGluIGNhc2VcbiAgIyB0aGUgZXJyb3IgaXMgY2F1c2VkIGJ5IGEgZ2VuZXJhdGVkIHRva2VuIHdoaWNoIG1pZ2h0IHJlZmVyIHRvIGl0cyBvcmlnaW4uXG4gIHtlcnJvclRva2VuLCB0b2tlbnN9ID0gcGFyc2VyXG4gIFtlcnJvclRhZywgZXJyb3JUZXh0LCBlcnJvckxvY10gPSBlcnJvclRva2VuXG5cbiAgZXJyb3JUZXh0ID0gc3dpdGNoXG4gICAgd2hlbiBlcnJvclRva2VuIGlzIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV1cbiAgICAgICdlbmQgb2YgaW5wdXQnXG4gICAgd2hlbiBlcnJvclRhZyBpbiBbJ0lOREVOVCcsICdPVVRERU5UJ11cbiAgICAgICdpbmRlbnRhdGlvbidcbiAgICB3aGVuIGVycm9yVGFnIGluIFsnSURFTlRJRklFUicsICdOVU1CRVInLCAnSU5GSU5JVFknLCAnU1RSSU5HJywgJ1NUUklOR19TVEFSVCcsICdSRUdFWCcsICdSRUdFWF9TVEFSVCddXG4gICAgICBlcnJvclRhZy5yZXBsYWNlKC9fU1RBUlQkLywgJycpLnRvTG93ZXJDYXNlKClcbiAgICBlbHNlXG4gICAgICBoZWxwZXJzLm5hbWVXaGl0ZXNwYWNlQ2hhcmFjdGVyIGVycm9yVGV4dFxuXG4gICMgVGhlIHNlY29uZCBhcmd1bWVudCBoYXMgYSBgbG9jYCBwcm9wZXJ0eSwgd2hpY2ggc2hvdWxkIGhhdmUgdGhlIGxvY2F0aW9uXG4gICMgZGF0YSBmb3IgdGhpcyB0b2tlbi4gVW5mb3J0dW5hdGVseSwgSmlzb24gc2VlbXMgdG8gc2VuZCBhbiBvdXRkYXRlZCBgbG9jYFxuICAjIChmcm9tIHRoZSBwcmV2aW91cyB0b2tlbiksIHNvIHdlIHRha2UgdGhlIGxvY2F0aW9uIGluZm9ybWF0aW9uIGRpcmVjdGx5XG4gICMgZnJvbSB0aGUgbGV4ZXIuXG4gIGhlbHBlcnMudGhyb3dTeW50YXhFcnJvciBcInVuZXhwZWN0ZWQgI3tlcnJvclRleHR9XCIsIGVycm9yTG9jXG5cbmV4cG9ydHMucGF0Y2hTdGFja1RyYWNlID0gLT5cbiAgIyBCYXNlZCBvbiBodHRwOi8vdjguZ29vZ2xlY29kZS5jb20vc3ZuL2JyYW5jaGVzL2JsZWVkaW5nX2VkZ2Uvc3JjL21lc3NhZ2VzLmpzXG4gICMgTW9kaWZpZWQgdG8gaGFuZGxlIHNvdXJjZU1hcFxuICBmb3JtYXRTb3VyY2VQb3NpdGlvbiA9IChmcmFtZSwgZ2V0U291cmNlTWFwcGluZykgLT5cbiAgICBmaWxlbmFtZSA9IHVuZGVmaW5lZFxuICAgIGZpbGVMb2NhdGlvbiA9ICcnXG5cbiAgICBpZiBmcmFtZS5pc05hdGl2ZSgpXG4gICAgICBmaWxlTG9jYXRpb24gPSBcIm5hdGl2ZVwiXG4gICAgZWxzZVxuICAgICAgaWYgZnJhbWUuaXNFdmFsKClcbiAgICAgICAgZmlsZW5hbWUgPSBmcmFtZS5nZXRTY3JpcHROYW1lT3JTb3VyY2VVUkwoKVxuICAgICAgICBmaWxlTG9jYXRpb24gPSBcIiN7ZnJhbWUuZ2V0RXZhbE9yaWdpbigpfSwgXCIgdW5sZXNzIGZpbGVuYW1lXG4gICAgICBlbHNlXG4gICAgICAgIGZpbGVuYW1lID0gZnJhbWUuZ2V0RmlsZU5hbWUoKVxuXG4gICAgICBmaWxlbmFtZSBvcj0gXCI8YW5vbnltb3VzPlwiXG5cbiAgICAgIGxpbmUgPSBmcmFtZS5nZXRMaW5lTnVtYmVyKClcbiAgICAgIGNvbHVtbiA9IGZyYW1lLmdldENvbHVtbk51bWJlcigpXG5cbiAgICAgICMgQ2hlY2sgZm9yIGEgc291cmNlTWFwIHBvc2l0aW9uXG4gICAgICBzb3VyY2UgPSBnZXRTb3VyY2VNYXBwaW5nIGZpbGVuYW1lLCBsaW5lLCBjb2x1bW5cbiAgICAgIGZpbGVMb2NhdGlvbiA9XG4gICAgICAgIGlmIHNvdXJjZVxuICAgICAgICAgIFwiI3tmaWxlbmFtZX06I3tzb3VyY2VbMF19OiN7c291cmNlWzFdfVwiXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBcIiN7ZmlsZW5hbWV9OiN7bGluZX06I3tjb2x1bW59XCJcblxuICAgIGZ1bmN0aW9uTmFtZSA9IGZyYW1lLmdldEZ1bmN0aW9uTmFtZSgpXG4gICAgaXNDb25zdHJ1Y3RvciA9IGZyYW1lLmlzQ29uc3RydWN0b3IoKVxuICAgIGlzTWV0aG9kQ2FsbCA9IG5vdCAoZnJhbWUuaXNUb3BsZXZlbCgpIG9yIGlzQ29uc3RydWN0b3IpXG5cbiAgICBpZiBpc01ldGhvZENhbGxcbiAgICAgIG1ldGhvZE5hbWUgPSBmcmFtZS5nZXRNZXRob2ROYW1lKClcbiAgICAgIHR5cGVOYW1lID0gZnJhbWUuZ2V0VHlwZU5hbWUoKVxuXG4gICAgICBpZiBmdW5jdGlvbk5hbWVcbiAgICAgICAgdHAgPSBhcyA9ICcnXG4gICAgICAgIGlmIHR5cGVOYW1lIGFuZCBmdW5jdGlvbk5hbWUuaW5kZXhPZiB0eXBlTmFtZVxuICAgICAgICAgIHRwID0gXCIje3R5cGVOYW1lfS5cIlxuICAgICAgICBpZiBtZXRob2ROYW1lIGFuZCBmdW5jdGlvbk5hbWUuaW5kZXhPZihcIi4je21ldGhvZE5hbWV9XCIpIGlzbnQgZnVuY3Rpb25OYW1lLmxlbmd0aCAtIG1ldGhvZE5hbWUubGVuZ3RoIC0gMVxuICAgICAgICAgIGFzID0gXCIgW2FzICN7bWV0aG9kTmFtZX1dXCJcblxuICAgICAgICBcIiN7dHB9I3tmdW5jdGlvbk5hbWV9I3thc30gKCN7ZmlsZUxvY2F0aW9ufSlcIlxuICAgICAgZWxzZVxuICAgICAgICBcIiN7dHlwZU5hbWV9LiN7bWV0aG9kTmFtZSBvciAnPGFub255bW91cz4nfSAoI3tmaWxlTG9jYXRpb259KVwiXG4gICAgZWxzZSBpZiBpc0NvbnN0cnVjdG9yXG4gICAgICBcIm5ldyAje2Z1bmN0aW9uTmFtZSBvciAnPGFub255bW91cz4nfSAoI3tmaWxlTG9jYXRpb259KVwiXG4gICAgZWxzZSBpZiBmdW5jdGlvbk5hbWVcbiAgICAgIFwiI3tmdW5jdGlvbk5hbWV9ICgje2ZpbGVMb2NhdGlvbn0pXCJcbiAgICBlbHNlXG4gICAgICBmaWxlTG9jYXRpb25cblxuICBnZXRTb3VyY2VNYXBwaW5nID0gKGZpbGVuYW1lLCBsaW5lLCBjb2x1bW4pIC0+XG4gICAgc291cmNlTWFwID0gZ2V0U291cmNlTWFwIGZpbGVuYW1lLCBsaW5lLCBjb2x1bW5cblxuICAgIGFuc3dlciA9IHNvdXJjZU1hcC5zb3VyY2VMb2NhdGlvbiBbbGluZSAtIDEsIGNvbHVtbiAtIDFdIGlmIHNvdXJjZU1hcD9cbiAgICBpZiBhbnN3ZXI/IHRoZW4gW2Fuc3dlclswXSArIDEsIGFuc3dlclsxXSArIDFdIGVsc2UgbnVsbFxuXG4gICMgQmFzZWQgb24gW21pY2hhZWxmaWNhcnJhL0NvZmZlZVNjcmlwdFJlZHV4XShodHRwOi8vZ29vLmdsL1pUeDFwKVxuICAjIE5vZGVKUyAvIFY4IGhhdmUgbm8gc3VwcG9ydCBmb3IgdHJhbnNmb3JtaW5nIHBvc2l0aW9ucyBpbiBzdGFjayB0cmFjZXMgdXNpbmdcbiAgIyBzb3VyY2VNYXAsIHNvIHdlIG11c3QgbW9ua2V5LXBhdGNoIEVycm9yIHRvIGRpc3BsYXkgQ29mZmVlU2NyaXB0IHNvdXJjZVxuICAjIHBvc2l0aW9ucy5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSAoZXJyLCBzdGFjaykgLT5cbiAgICBmcmFtZXMgPSBmb3IgZnJhbWUgaW4gc3RhY2tcbiAgICAgICMgRG9u4oCZdCBkaXNwbGF5IHN0YWNrIGZyYW1lcyBkZWVwZXIgdGhhbiBgQ29mZmVlU2NyaXB0LnJ1bmAuXG4gICAgICBicmVhayBpZiBmcmFtZS5nZXRGdW5jdGlvbigpIGlzIGV4cG9ydHMucnVuXG4gICAgICBcIiAgICBhdCAje2Zvcm1hdFNvdXJjZVBvc2l0aW9uIGZyYW1lLCBnZXRTb3VyY2VNYXBwaW5nfVwiXG5cbiAgICBcIiN7ZXJyLnRvU3RyaW5nKCl9XFxuI3tmcmFtZXMuam9pbiAnXFxuJ31cXG5cIlxuXG5jaGVja1NoZWJhbmdMaW5lID0gKGZpbGUsIGlucHV0KSAtPlxuICBmaXJzdExpbmUgPSBpbnB1dC5zcGxpdCgvJC9tLCAxKVswXVxuICByZXN0ID0gZmlyc3RMaW5lPy5tYXRjaCgvXiMhXFxzKihbXlxcc10rXFxzKikoLiopLylcbiAgYXJncyA9IHJlc3Q/WzJdPy5zcGxpdCgvXFxzLykuZmlsdGVyIChzKSAtPiBzIGlzbnQgJydcbiAgaWYgYXJncz8ubGVuZ3RoID4gMVxuICAgIGNvbnNvbGUuZXJyb3IgJycnXG4gICAgICBUaGUgc2NyaXB0IHRvIGJlIHJ1biBiZWdpbnMgd2l0aCBhIHNoZWJhbmcgbGluZSB3aXRoIG1vcmUgdGhhbiBvbmVcbiAgICAgIGFyZ3VtZW50LiBUaGlzIHNjcmlwdCB3aWxsIGZhaWwgb24gcGxhdGZvcm1zIHN1Y2ggYXMgTGludXggd2hpY2ggb25seVxuICAgICAgYWxsb3cgYSBzaW5nbGUgYXJndW1lbnQuXG4gICAgJycnXG4gICAgY29uc29sZS5lcnJvciBcIlRoZSBzaGViYW5nIGxpbmUgd2FzOiAnI3tmaXJzdExpbmV9JyBpbiBmaWxlICcje2ZpbGV9J1wiXG4gICAgY29uc29sZS5lcnJvciBcIlRoZSBhcmd1bWVudHMgd2VyZTogI3tKU09OLnN0cmluZ2lmeSBhcmdzfVwiXG4iXX0=
//# sourceURL=/home/flow/jzr/coffeescript/src/coffeescript.coffee